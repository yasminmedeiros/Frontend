{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\nvar constants = require('./constants');\nvar axisIds = require('./axis_ids');\nfunction fromLog(v) {\n  return Math.pow(10, v);\n}\nfunction isValidCategory(v) {\n  return v !== null && v !== undefined;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v2.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n  fullLayout = fullLayout || {};\n  var axLetter = (ax._id || 'x').charAt(0);\n  function toLog(v, clip) {\n    if (v > 0) return Math.log(v) / Math.LN10;else if (v <= 0 && clip && ax.range && ax.range.length === 2) {\n      // clip NaN (ie past negative infinity) to LOG_CLIP axis\n      // length past the negative edge\n      var r0 = ax.range[0];\n      var r1 = ax.range[1];\n      return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n    } else return BADNUM;\n  }\n\n  /*\n   * wrapped dateTime2ms that:\n   * - accepts ms numbers for backward compatibility\n   * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n   * - defaults to ax.calendar\n   */\n  function dt2ms(v, _, calendar) {\n    // NOTE: Changed this behavior: previously we took any numeric value\n    // to be a ms, even if it was a string that could be a bare year.\n    // Now we convert it as a date if at all possible, and only try\n    // as (local) ms if that fails.\n    var ms = dateTime2ms(v, calendar || ax.calendar);\n    if (ms === BADNUM) {\n      if (isNumeric(v)) {\n        v = +v;\n        // keep track of tenths of ms, that `new Date` will drop\n        // same logic as in Lib.ms2DateTime\n        var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n        var msRounded = Math.round(v - msecTenths / 10);\n        ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n      } else return BADNUM;\n    }\n    return ms;\n  }\n\n  // wrapped ms2DateTime to insert default ax.calendar\n  function ms2dt(v, r, calendar) {\n    return ms2DateTime(v, r, calendar || ax.calendar);\n  }\n  function getCategoryName(v) {\n    return ax._categories[Math.round(v)];\n  }\n\n  /*\n   * setCategoryIndex: return the index of category v,\n   * inserting it in the list if it's not already there\n   *\n   * this will enter the categories in the order it\n   * encounters them, ie all the categories from the\n   * first data set, then all the ones from the second\n   * that aren't in the first etc.\n   *\n   * it is assumed that this function is being invoked in the\n   * already sorted category order; otherwise there would be\n   * a disconnect between the array and the index returned\n   */\n  function setCategoryIndex(v) {\n    if (isValidCategory(v)) {\n      if (ax._categoriesMap === undefined) {\n        ax._categoriesMap = {};\n      }\n      if (ax._categoriesMap[v] !== undefined) {\n        return ax._categoriesMap[v];\n      } else {\n        ax._categories.push(v);\n        var curLength = ax._categories.length - 1;\n        ax._categoriesMap[v] = curLength;\n        return curLength;\n      }\n    }\n    return BADNUM;\n  }\n  function setMultiCategoryIndex(arrayIn, len) {\n    var arrayOut = new Array(len);\n    for (var i = 0; i < len; i++) {\n      var v0 = (arrayIn[0] || [])[i];\n      var v1 = (arrayIn[1] || [])[i];\n      arrayOut[i] = getCategoryIndex([v0, v1]);\n    }\n    return arrayOut;\n  }\n  function getCategoryIndex(v) {\n    if (ax._categoriesMap) {\n      return ax._categoriesMap[v];\n    }\n  }\n  function getCategoryPosition(v) {\n    // d2l/d2c variant that that won't add categories but will also\n    // allow numbers to be mapped to the linearized axis positions\n    var index = getCategoryIndex(v);\n    if (index !== undefined) return index;\n    if (isNumeric(v)) return +v;\n  }\n  function l2p(v) {\n    if (!isNumeric(v)) return BADNUM;\n\n    // include 2 fractional digits on pixel, for PDF zooming etc\n    return d3.round(ax._b + ax._m * v, 2);\n  }\n  function p2l(px) {\n    return (px - ax._b) / ax._m;\n  }\n\n  // conversions among c/l/p are fairly simple - do them together for all axis types\n  ax.c2l = ax.type === 'log' ? toLog : ensureNumber;\n  ax.l2c = ax.type === 'log' ? fromLog : ensureNumber;\n  ax.l2p = l2p;\n  ax.p2l = p2l;\n  ax.c2p = ax.type === 'log' ? function (v, clip) {\n    return l2p(toLog(v, clip));\n  } : l2p;\n  ax.p2c = ax.type === 'log' ? function (px) {\n    return fromLog(p2l(px));\n  } : p2l;\n\n  /*\n   * now type-specific conversions for **ALL** other combinations\n   * they're all written out, instead of being combinations of each other, for\n   * both clarity and speed.\n   */\n  if (['linear', '-'].indexOf(ax.type) !== -1) {\n    // all are data vals, but d and r need cleaning\n    ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n    ax.d2p = ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n    ax.p2d = ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'log') {\n    // d and c are data vals, r and l are logged (but d and r need cleaning)\n    ax.d2r = ax.d2l = function (v, clip) {\n      return toLog(cleanNumber(v), clip);\n    };\n    ax.r2d = ax.r2c = function (v) {\n      return fromLog(cleanNumber(v));\n    };\n    ax.d2c = ax.r2l = cleanNumber;\n    ax.c2d = ax.l2r = ensureNumber;\n    ax.c2r = toLog;\n    ax.l2d = fromLog;\n    ax.d2p = function (v, clip) {\n      return ax.l2p(ax.d2r(v, clip));\n    };\n    ax.p2d = function (px) {\n      return fromLog(p2l(px));\n    };\n    ax.r2p = function (v) {\n      return ax.l2p(cleanNumber(v));\n    };\n    ax.p2r = p2l;\n    ax.cleanPos = ensureNumber;\n  } else if (ax.type === 'date') {\n    // r and d are date strings, l and c are ms\n\n    /*\n     * Any of these functions with r and d on either side, calendar is the\n     * **3rd** argument. log has reserved the second argument.\n     *\n     * Unless you need the special behavior of the second arg (ms2DateTime\n     * uses this to limit precision, toLog uses true to clip negatives\n     * to offscreen low rather than undefined), it's safe to pass 0.\n     */\n    ax.d2r = ax.r2d = Lib.identity;\n    ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n    ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n    ax.d2p = ax.r2p = function (v, _, calendar) {\n      return ax.l2p(dt2ms(v, 0, calendar));\n    };\n    ax.p2d = ax.p2r = function (px, r, calendar) {\n      return ms2dt(p2l(px), r, calendar);\n    };\n    ax.cleanPos = function (v) {\n      return Lib.cleanDate(v, BADNUM, ax.calendar);\n    };\n  } else if (ax.type === 'category') {\n    // d is categories (string)\n    // c and l are indices (numbers)\n    // r is categories or numbers\n\n    ax.d2c = ax.d2l = setCategoryIndex;\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n    ax.r2c = function (v) {\n      var index = getCategoryPosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getCategoryPosition;\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n    ax.cleanPos = function (v) {\n      if (typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n  } else if (ax.type === 'multicategory') {\n    // N.B. multicategory axes don't define d2c and d2l,\n    // as 'data-to-calcdata' conversion needs to take into\n    // account all data array items as in ax.makeCalcdata.\n\n    ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n    ax.d2r = ax.d2l_noadd = getCategoryPosition;\n    ax.r2c = function (v) {\n      var index = getCategoryPosition(v);\n      return index !== undefined ? index : ax.fraction2r(0.5);\n    };\n    ax.r2c_just_indices = getCategoryIndex;\n    ax.l2r = ax.c2r = ensureNumber;\n    ax.r2l = getCategoryPosition;\n    ax.d2p = function (v) {\n      return ax.l2p(ax.r2c(v));\n    };\n    ax.p2d = function (px) {\n      return getCategoryName(p2l(px));\n    };\n    ax.r2p = ax.d2p;\n    ax.p2r = p2l;\n    ax.cleanPos = function (v) {\n      if (Array.isArray(v) || typeof v === 'string' && v !== '') return v;\n      return ensureNumber(v);\n    };\n    ax.setupMultiCategory = function (fullData) {\n      var traceIndices = ax._traceIndices;\n      var i, j;\n\n      // [ [cnt, {$cat: index}], for 1,2 ]\n      var seen = ax._multicatSeen = [[0, {}], [0, {}]];\n      // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n      var list = ax._multicatList = [];\n      for (i = 0; i < traceIndices.length; i++) {\n        var trace = fullData[traceIndices[i]];\n        if (axLetter in trace) {\n          var arrayIn = trace[axLetter];\n          var len = trace._length || Lib.minRowLength(arrayIn);\n          if (isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n            for (j = 0; j < len; j++) {\n              var v0 = arrayIn[0][j];\n              var v1 = arrayIn[1][j];\n              if (isValidCategory(v0) && isValidCategory(v1)) {\n                list.push([v0, v1]);\n                if (!(v0 in seen[0][1])) {\n                  seen[0][1][v0] = seen[0][0]++;\n                }\n                if (!(v1 in seen[1][1])) {\n                  seen[1][1][v1] = seen[1][0]++;\n                }\n              }\n            }\n          }\n        }\n      }\n      list.sort(function (a, b) {\n        var ind0 = seen[0][1];\n        var d = ind0[a[0]] - ind0[b[0]];\n        if (d) return d;\n        var ind1 = seen[1][1];\n        return ind1[a[1]] - ind1[b[1]];\n      });\n      for (i = 0; i < list.length; i++) {\n        setCategoryIndex(list[i]);\n      }\n    };\n  }\n\n  // find the range value at the specified (linear) fraction of the axis\n  ax.fraction2r = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return ax.l2r(rl0 + v * (rl1 - rl0));\n  };\n\n  // find the fraction of the range at the specified range value\n  ax.r2fraction = function (v) {\n    var rl0 = ax.r2l(ax.range[0]);\n    var rl1 = ax.r2l(ax.range[1]);\n    return (ax.r2l(v) - rl0) / (rl1 - rl0);\n  };\n\n  /*\n   * cleanRange: make sure range is a couplet of valid & distinct values\n   * keep numbers away from the limits of floating point numbers,\n   * and dates away from the ends of our date system (+/- 9999 years)\n   *\n   * optional param rangeAttr: operate on a different attribute, like\n   * ax._r, rather than ax.range\n   */\n  ax.cleanRange = function (rangeAttr, opts) {\n    if (!opts) opts = {};\n    if (!rangeAttr) rangeAttr = 'range';\n    var range = Lib.nestedProperty(ax, rangeAttr).get();\n    var i, dflt;\n    if (ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);else if (axLetter === 'y') dflt = constants.DFLTRANGEY;else dflt = opts.dfltRange || constants.DFLTRANGEX;\n\n    // make sure we don't later mutate the defaults\n    dflt = dflt.slice();\n    if (!range || range.length !== 2) {\n      Lib.nestedProperty(ax, rangeAttr).set(dflt);\n      return;\n    }\n    if (ax.type === 'date') {\n      // check if milliseconds or js date objects are provided for range\n      // and convert to date strings\n      range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n      range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n    }\n    for (i = 0; i < 2; i++) {\n      if (ax.type === 'date') {\n        if (!Lib.isDateTime(range[i], ax.calendar)) {\n          ax[rangeAttr] = dflt;\n          break;\n        }\n        if (ax.r2l(range[0]) === ax.r2l(range[1])) {\n          // split by +/- 1 second\n          var linCenter = Lib.constrain(ax.r2l(range[0]), Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n          range[0] = ax.l2r(linCenter - 1000);\n          range[1] = ax.l2r(linCenter + 1000);\n          break;\n        }\n      } else {\n        if (!isNumeric(range[i])) {\n          if (isNumeric(range[1 - i])) {\n            range[i] = range[1 - i] * (i ? 10 : 0.1);\n          } else {\n            ax[rangeAttr] = dflt;\n            break;\n          }\n        }\n        if (range[i] < -FP_SAFE) range[i] = -FP_SAFE;else if (range[i] > FP_SAFE) range[i] = FP_SAFE;\n        if (range[0] === range[1]) {\n          // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n          var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n          range[0] -= inc;\n          range[1] += inc;\n        }\n      }\n    }\n  };\n\n  // set scaling to pixels\n  ax.setScale = function (usePrivateRange) {\n    var gs = fullLayout._size;\n\n    // make sure we have a domain (pull it in from the axis\n    // this one is overlaying if necessary)\n    if (ax.overlaying) {\n      var ax2 = axisIds.getFromId({\n        _fullLayout: fullLayout\n      }, ax.overlaying);\n      ax.domain = ax2.domain;\n    }\n\n    // While transitions are occuring, occurring, we get a double-transform\n    // issue if we transform the drawn layer *and* use the new axis range to\n    // draw the data. This allows us to construct setConvert using the pre-\n    // interaction values of the range:\n    var rangeAttr = usePrivateRange && ax._r ? '_r' : 'range';\n    var calendar = ax.calendar;\n    ax.cleanRange(rangeAttr);\n    var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n    var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n    if (axLetter === 'y') {\n      ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n      ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl0 - rl1);\n      ax._b = -ax._m * rl1;\n    } else {\n      ax._offset = gs.l + ax.domain[0] * gs.w;\n      ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n      ax._m = ax._length / (rl1 - rl0);\n      ax._b = -ax._m * rl0;\n    }\n    if (!isFinite(ax._m) || !isFinite(ax._b)) {\n      fullLayout._replotting = false;\n      throw new Error('Something went wrong with axis scaling');\n    }\n  };\n\n  // makeCalcdata: takes an x or y array and converts it\n  // to a position on the axis object \"ax\"\n  // inputs:\n  //      trace - a data object from gd.data\n  //      axLetter - a string, either 'x' or 'y', for which item\n  //          to convert (TODO: is this now always the same as\n  //          the first letter of ax._id?)\n  // in case the expected data isn't there, make a list of\n  // integers based on the opposite data\n  ax.makeCalcdata = function (trace, axLetter) {\n    var arrayIn, arrayOut, i, len;\n    var axType = ax.type;\n    var cal = axType === 'date' && trace[axLetter + 'calendar'];\n    if (axLetter in trace) {\n      arrayIn = trace[axLetter];\n      len = trace._length || Lib.minRowLength(arrayIn);\n      if (Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n      if (axType === 'multicategory') {\n        return setMultiCategoryIndex(arrayIn, len);\n      }\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = ax.d2c(arrayIn[i], 0, cal);\n      }\n    } else {\n      var v0 = axLetter + '0' in trace ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n      var dv = trace['d' + axLetter] ? Number(trace['d' + axLetter]) : 1;\n\n      // the opposing data, for size if we have x and dx etc\n      arrayIn = trace[{\n        x: 'y',\n        y: 'x'\n      }[axLetter]];\n      len = trace._length || arrayIn.length;\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    }\n    return arrayOut;\n  };\n  ax.isValidRange = function (range) {\n    return Array.isArray(range) && range.length === 2 && isNumeric(ax.r2l(range[0])) && isNumeric(ax.r2l(range[1]));\n  };\n  ax.isPtWithinRange = function (d, calendar) {\n    var coord = ax.c2l(d[axLetter], null, calendar);\n    var r0 = ax.r2l(ax.range[0]);\n    var r1 = ax.r2l(ax.range[1]);\n    if (r0 < r1) {\n      return r0 <= coord && coord <= r1;\n    } else {\n      // Reversed axis case.\n      return r1 <= coord && coord <= r0;\n    }\n  };\n  ax.clearCalc = function () {\n    // initialize the category list, if there is one, so we start over\n    // to be filled in later by ax.d2c\n    ax._categories = (ax._initialCategories || []).slice();\n\n    // Build the lookup map for initialized categories\n    ax._categoriesMap = {};\n    for (var j = 0; j < ax._categories.length; j++) {\n      ax._categoriesMap[ax._categories[j]] = j;\n    }\n  };\n\n  // Propagate localization into the axis so that\n  // methods in Axes can use it w/o having to pass fullLayout\n  // Default (non-d3) number formatting uses separators directly\n  // dates and d3-formatted numbers use the d3 locale\n  // Fall back on default format for dummy axes that don't care about formatting\n  var locale = fullLayout._d3locale;\n  if (ax.type === 'date') {\n    ax._dateFormat = locale ? locale.timeFormat.utc : d3.time.format.utc;\n    ax._extraFormat = fullLayout._extraFormat;\n  }\n  // occasionally we need _numFormat to pass through\n  // even though it won't be needed by this axis\n  ax._separators = fullLayout.separators;\n  ax._numFormat = locale ? locale.numberFormat : d3.format;\n\n  // and for bar charts and box plots: reset forced minimum tick spacing\n  delete ax._minDtick;\n  delete ax._forceTick0;\n};","map":{"version":3,"names":["d3","require","isNumeric","Lib","cleanNumber","ms2DateTime","dateTime2ms","ensureNumber","isArrayOrTypedArray","numConstants","FP_SAFE","BADNUM","LOG_CLIP","constants","axisIds","fromLog","v","Math","pow","isValidCategory","undefined","module","exports","setConvert","ax","fullLayout","axLetter","_id","charAt","toLog","clip","log","LN10","range","length","r0","r1","abs","dt2ms","_","calendar","ms","msecTenths","floor","mod","msRounded","round","Date","ms2dt","r","getCategoryName","_categories","setCategoryIndex","_categoriesMap","push","curLength","setMultiCategoryIndex","arrayIn","len","arrayOut","Array","i","v0","v1","getCategoryIndex","getCategoryPosition","index","l2p","_b","_m","p2l","px","c2l","type","l2c","c2p","p2c","indexOf","d2r","r2d","d2c","r2c","d2l","r2l","c2d","c2r","l2d","l2r","d2p","r2p","p2d","p2r","cleanPos","identity","cleanDate","d2l_noadd","fraction2r","r2c_just_indices","isArray","setupMultiCategory","fullData","traceIndices","_traceIndices","j","seen","_multicatSeen","list","_multicatList","trace","_length","minRowLength","sort","a","b","ind0","d","ind1","rl0","rl1","r2fraction","cleanRange","rangeAttr","opts","nestedProperty","get","dflt","dfltRange","DFLTRANGEY","DFLTRANGEX","slice","set","isDateTime","linCenter","constrain","MIN_MS","MAX_MS","inc","max","setScale","usePrivateRange","gs","_size","overlaying","ax2","getFromId","_fullLayout","domain","_r","_offset","t","h","l","w","isFinite","_replotting","Error","makeCalcdata","axType","cal","isTypedArray","subarray","dv","Number","x","y","isValidRange","isPtWithinRange","coord","clearCalc","_initialCategories","locale","_d3locale","_dateFormat","timeFormat","utc","time","format","_extraFormat","_separators","separators","_numFormat","numberFormat","_minDtick","_forceTick0"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plots/cartesian/set_convert.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar cleanNumber = Lib.cleanNumber;\nvar ms2DateTime = Lib.ms2DateTime;\nvar dateTime2ms = Lib.dateTime2ms;\nvar ensureNumber = Lib.ensureNumber;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\nvar numConstants = require('../../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar LOG_CLIP = numConstants.LOG_CLIP;\n\nvar constants = require('./constants');\nvar axisIds = require('./axis_ids');\n\nfunction fromLog(v) {\n    return Math.pow(10, v);\n}\n\nfunction isValidCategory(v) {\n    return v !== null && v !== undefined;\n}\n\n/**\n * Define the conversion functions for an axis data is used in 5 ways:\n *\n *  d: data, in whatever form it's provided\n *  c: calcdata: turned into numbers, but not linearized\n *  l: linearized - same as c except for log axes (and other nonlinear\n *      mappings later?) this is used when we need to know if it's\n *      *possible* to show some data on this axis, without caring about\n *      the current range\n *  p: pixel value - mapped to the screen with current size and zoom\n *  r: ranges, tick0, and annotation positions match one of the above\n *     but are handled differently for different types:\n *     - linear and date: data format (d)\n *     - category: calcdata format (c), and will stay that way because\n *       the data format has no continuous mapping\n *     - log: linearized (l) format\n *       TODO: in v2.0 we plan to change it to data format. At that point\n *       shapes will work the same way as ranges, tick0, and annotations\n *       so they can use this conversion too.\n *\n * Creates/updates these conversion functions, and a few more utilities\n * like cleanRange, and makeCalcdata\n *\n * also clears the autotick constraints ._minDtick, ._forceTick0\n */\nmodule.exports = function setConvert(ax, fullLayout) {\n    fullLayout = fullLayout || {};\n\n    var axLetter = (ax._id || 'x').charAt(0);\n\n    function toLog(v, clip) {\n        if(v > 0) return Math.log(v) / Math.LN10;\n\n        else if(v <= 0 && clip && ax.range && ax.range.length === 2) {\n            // clip NaN (ie past negative infinity) to LOG_CLIP axis\n            // length past the negative edge\n            var r0 = ax.range[0];\n            var r1 = ax.range[1];\n            return 0.5 * (r0 + r1 - 2 * LOG_CLIP * Math.abs(r0 - r1));\n        }\n\n        else return BADNUM;\n    }\n\n    /*\n     * wrapped dateTime2ms that:\n     * - accepts ms numbers for backward compatibility\n     * - inserts a dummy arg so calendar is the 3rd arg (see notes below).\n     * - defaults to ax.calendar\n     */\n    function dt2ms(v, _, calendar) {\n        // NOTE: Changed this behavior: previously we took any numeric value\n        // to be a ms, even if it was a string that could be a bare year.\n        // Now we convert it as a date if at all possible, and only try\n        // as (local) ms if that fails.\n        var ms = dateTime2ms(v, calendar || ax.calendar);\n        if(ms === BADNUM) {\n            if(isNumeric(v)) {\n                v = +v;\n                // keep track of tenths of ms, that `new Date` will drop\n                // same logic as in Lib.ms2DateTime\n                var msecTenths = Math.floor(Lib.mod(v + 0.05, 1) * 10);\n                var msRounded = Math.round(v - msecTenths / 10);\n                ms = dateTime2ms(new Date(msRounded)) + msecTenths / 10;\n            }\n            else return BADNUM;\n        }\n        return ms;\n    }\n\n    // wrapped ms2DateTime to insert default ax.calendar\n    function ms2dt(v, r, calendar) {\n        return ms2DateTime(v, r, calendar || ax.calendar);\n    }\n\n    function getCategoryName(v) {\n        return ax._categories[Math.round(v)];\n    }\n\n    /*\n     * setCategoryIndex: return the index of category v,\n     * inserting it in the list if it's not already there\n     *\n     * this will enter the categories in the order it\n     * encounters them, ie all the categories from the\n     * first data set, then all the ones from the second\n     * that aren't in the first etc.\n     *\n     * it is assumed that this function is being invoked in the\n     * already sorted category order; otherwise there would be\n     * a disconnect between the array and the index returned\n     */\n    function setCategoryIndex(v) {\n        if(isValidCategory(v)) {\n            if(ax._categoriesMap === undefined) {\n                ax._categoriesMap = {};\n            }\n\n            if(ax._categoriesMap[v] !== undefined) {\n                return ax._categoriesMap[v];\n            } else {\n                ax._categories.push(v);\n\n                var curLength = ax._categories.length - 1;\n                ax._categoriesMap[v] = curLength;\n\n                return curLength;\n            }\n        }\n        return BADNUM;\n    }\n\n    function setMultiCategoryIndex(arrayIn, len) {\n        var arrayOut = new Array(len);\n\n        for(var i = 0; i < len; i++) {\n            var v0 = (arrayIn[0] || [])[i];\n            var v1 = (arrayIn[1] || [])[i];\n            arrayOut[i] = getCategoryIndex([v0, v1]);\n        }\n\n        return arrayOut;\n    }\n\n    function getCategoryIndex(v) {\n        if(ax._categoriesMap) {\n            return ax._categoriesMap[v];\n        }\n    }\n\n    function getCategoryPosition(v) {\n        // d2l/d2c variant that that won't add categories but will also\n        // allow numbers to be mapped to the linearized axis positions\n        var index = getCategoryIndex(v);\n        if(index !== undefined) return index;\n        if(isNumeric(v)) return +v;\n    }\n\n    function l2p(v) {\n        if(!isNumeric(v)) return BADNUM;\n\n        // include 2 fractional digits on pixel, for PDF zooming etc\n        return d3.round(ax._b + ax._m * v, 2);\n    }\n\n    function p2l(px) { return (px - ax._b) / ax._m; }\n\n    // conversions among c/l/p are fairly simple - do them together for all axis types\n    ax.c2l = (ax.type === 'log') ? toLog : ensureNumber;\n    ax.l2c = (ax.type === 'log') ? fromLog : ensureNumber;\n\n    ax.l2p = l2p;\n    ax.p2l = p2l;\n\n    ax.c2p = (ax.type === 'log') ? function(v, clip) { return l2p(toLog(v, clip)); } : l2p;\n    ax.p2c = (ax.type === 'log') ? function(px) { return fromLog(p2l(px)); } : p2l;\n\n    /*\n     * now type-specific conversions for **ALL** other combinations\n     * they're all written out, instead of being combinations of each other, for\n     * both clarity and speed.\n     */\n    if(['linear', '-'].indexOf(ax.type) !== -1) {\n        // all are data vals, but d and r need cleaning\n        ax.d2r = ax.r2d = ax.d2c = ax.r2c = ax.d2l = ax.r2l = cleanNumber;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ensureNumber;\n\n        ax.d2p = ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2d = ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    }\n    else if(ax.type === 'log') {\n        // d and c are data vals, r and l are logged (but d and r need cleaning)\n        ax.d2r = ax.d2l = function(v, clip) { return toLog(cleanNumber(v), clip); };\n        ax.r2d = ax.r2c = function(v) { return fromLog(cleanNumber(v)); };\n\n        ax.d2c = ax.r2l = cleanNumber;\n        ax.c2d = ax.l2r = ensureNumber;\n\n        ax.c2r = toLog;\n        ax.l2d = fromLog;\n\n        ax.d2p = function(v, clip) { return ax.l2p(ax.d2r(v, clip)); };\n        ax.p2d = function(px) { return fromLog(p2l(px)); };\n\n        ax.r2p = function(v) { return ax.l2p(cleanNumber(v)); };\n        ax.p2r = p2l;\n\n        ax.cleanPos = ensureNumber;\n    }\n    else if(ax.type === 'date') {\n        // r and d are date strings, l and c are ms\n\n        /*\n         * Any of these functions with r and d on either side, calendar is the\n         * **3rd** argument. log has reserved the second argument.\n         *\n         * Unless you need the special behavior of the second arg (ms2DateTime\n         * uses this to limit precision, toLog uses true to clip negatives\n         * to offscreen low rather than undefined), it's safe to pass 0.\n         */\n        ax.d2r = ax.r2d = Lib.identity;\n\n        ax.d2c = ax.r2c = ax.d2l = ax.r2l = dt2ms;\n        ax.c2d = ax.c2r = ax.l2d = ax.l2r = ms2dt;\n\n        ax.d2p = ax.r2p = function(v, _, calendar) { return ax.l2p(dt2ms(v, 0, calendar)); };\n        ax.p2d = ax.p2r = function(px, r, calendar) { return ms2dt(p2l(px), r, calendar); };\n\n        ax.cleanPos = function(v) { return Lib.cleanDate(v, BADNUM, ax.calendar); };\n    }\n    else if(ax.type === 'category') {\n        // d is categories (string)\n        // c and l are indices (numbers)\n        // r is categories or numbers\n\n        ax.d2c = ax.d2l = setCategoryIndex;\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getCategoryPosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getCategoryPosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(typeof v === 'string' && v !== '') return v;\n            return ensureNumber(v);\n        };\n    }\n    else if(ax.type === 'multicategory') {\n        // N.B. multicategory axes don't define d2c and d2l,\n        // as 'data-to-calcdata' conversion needs to take into\n        // account all data array items as in ax.makeCalcdata.\n\n        ax.r2d = ax.c2d = ax.l2d = getCategoryName;\n        ax.d2r = ax.d2l_noadd = getCategoryPosition;\n\n        ax.r2c = function(v) {\n            var index = getCategoryPosition(v);\n            return index !== undefined ? index : ax.fraction2r(0.5);\n        };\n\n        ax.r2c_just_indices = getCategoryIndex;\n\n        ax.l2r = ax.c2r = ensureNumber;\n        ax.r2l = getCategoryPosition;\n\n        ax.d2p = function(v) { return ax.l2p(ax.r2c(v)); };\n        ax.p2d = function(px) { return getCategoryName(p2l(px)); };\n        ax.r2p = ax.d2p;\n        ax.p2r = p2l;\n\n        ax.cleanPos = function(v) {\n            if(Array.isArray(v) || (typeof v === 'string' && v !== '')) return v;\n            return ensureNumber(v);\n        };\n\n        ax.setupMultiCategory = function(fullData) {\n            var traceIndices = ax._traceIndices;\n            var i, j;\n\n            // [ [cnt, {$cat: index}], for 1,2 ]\n            var seen = ax._multicatSeen = [[0, {}], [0, {}]];\n            // [ [arrayIn[0][i], arrayIn[1][i]], for i .. N ]\n            var list = ax._multicatList = [];\n\n            for(i = 0; i < traceIndices.length; i++) {\n                var trace = fullData[traceIndices[i]];\n\n                if(axLetter in trace) {\n                    var arrayIn = trace[axLetter];\n                    var len = trace._length || Lib.minRowLength(arrayIn);\n\n                    if(isArrayOrTypedArray(arrayIn[0]) && isArrayOrTypedArray(arrayIn[1])) {\n                        for(j = 0; j < len; j++) {\n                            var v0 = arrayIn[0][j];\n                            var v1 = arrayIn[1][j];\n\n                            if(isValidCategory(v0) && isValidCategory(v1)) {\n                                list.push([v0, v1]);\n\n                                if(!(v0 in seen[0][1])) {\n                                    seen[0][1][v0] = seen[0][0]++;\n                                }\n                                if(!(v1 in seen[1][1])) {\n                                    seen[1][1][v1] = seen[1][0]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            list.sort(function(a, b) {\n                var ind0 = seen[0][1];\n                var d = ind0[a[0]] - ind0[b[0]];\n                if(d) return d;\n\n                var ind1 = seen[1][1];\n                return ind1[a[1]] - ind1[b[1]];\n            });\n\n            for(i = 0; i < list.length; i++) {\n                setCategoryIndex(list[i]);\n            }\n        };\n    }\n\n    // find the range value at the specified (linear) fraction of the axis\n    ax.fraction2r = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return ax.l2r(rl0 + v * (rl1 - rl0));\n    };\n\n    // find the fraction of the range at the specified range value\n    ax.r2fraction = function(v) {\n        var rl0 = ax.r2l(ax.range[0]);\n        var rl1 = ax.r2l(ax.range[1]);\n        return (ax.r2l(v) - rl0) / (rl1 - rl0);\n    };\n\n    /*\n     * cleanRange: make sure range is a couplet of valid & distinct values\n     * keep numbers away from the limits of floating point numbers,\n     * and dates away from the ends of our date system (+/- 9999 years)\n     *\n     * optional param rangeAttr: operate on a different attribute, like\n     * ax._r, rather than ax.range\n     */\n    ax.cleanRange = function(rangeAttr, opts) {\n        if(!opts) opts = {};\n        if(!rangeAttr) rangeAttr = 'range';\n\n        var range = Lib.nestedProperty(ax, rangeAttr).get();\n        var i, dflt;\n\n        if(ax.type === 'date') dflt = Lib.dfltRange(ax.calendar);\n        else if(axLetter === 'y') dflt = constants.DFLTRANGEY;\n        else dflt = opts.dfltRange || constants.DFLTRANGEX;\n\n        // make sure we don't later mutate the defaults\n        dflt = dflt.slice();\n\n        if(!range || range.length !== 2) {\n            Lib.nestedProperty(ax, rangeAttr).set(dflt);\n            return;\n        }\n\n        if(ax.type === 'date') {\n            // check if milliseconds or js date objects are provided for range\n            // and convert to date strings\n            range[0] = Lib.cleanDate(range[0], BADNUM, ax.calendar);\n            range[1] = Lib.cleanDate(range[1], BADNUM, ax.calendar);\n        }\n\n        for(i = 0; i < 2; i++) {\n            if(ax.type === 'date') {\n                if(!Lib.isDateTime(range[i], ax.calendar)) {\n                    ax[rangeAttr] = dflt;\n                    break;\n                }\n\n                if(ax.r2l(range[0]) === ax.r2l(range[1])) {\n                    // split by +/- 1 second\n                    var linCenter = Lib.constrain(ax.r2l(range[0]),\n                        Lib.MIN_MS + 1000, Lib.MAX_MS - 1000);\n                    range[0] = ax.l2r(linCenter - 1000);\n                    range[1] = ax.l2r(linCenter + 1000);\n                    break;\n                }\n            }\n            else {\n                if(!isNumeric(range[i])) {\n                    if(isNumeric(range[1 - i])) {\n                        range[i] = range[1 - i] * (i ? 10 : 0.1);\n                    }\n                    else {\n                        ax[rangeAttr] = dflt;\n                        break;\n                    }\n                }\n\n                if(range[i] < -FP_SAFE) range[i] = -FP_SAFE;\n                else if(range[i] > FP_SAFE) range[i] = FP_SAFE;\n\n                if(range[0] === range[1]) {\n                    // somewhat arbitrary: split by 1 or 1ppm, whichever is bigger\n                    var inc = Math.max(1, Math.abs(range[0] * 1e-6));\n                    range[0] -= inc;\n                    range[1] += inc;\n                }\n            }\n        }\n    };\n\n    // set scaling to pixels\n    ax.setScale = function(usePrivateRange) {\n        var gs = fullLayout._size;\n\n        // make sure we have a domain (pull it in from the axis\n        // this one is overlaying if necessary)\n        if(ax.overlaying) {\n            var ax2 = axisIds.getFromId({ _fullLayout: fullLayout }, ax.overlaying);\n            ax.domain = ax2.domain;\n        }\n\n        // While transitions are occuring, occurring, we get a double-transform\n        // issue if we transform the drawn layer *and* use the new axis range to\n        // draw the data. This allows us to construct setConvert using the pre-\n        // interaction values of the range:\n        var rangeAttr = (usePrivateRange && ax._r) ? '_r' : 'range';\n        var calendar = ax.calendar;\n        ax.cleanRange(rangeAttr);\n\n        var rl0 = ax.r2l(ax[rangeAttr][0], calendar);\n        var rl1 = ax.r2l(ax[rangeAttr][1], calendar);\n\n        if(axLetter === 'y') {\n            ax._offset = gs.t + (1 - ax.domain[1]) * gs.h;\n            ax._length = gs.h * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl0 - rl1);\n            ax._b = -ax._m * rl1;\n        }\n        else {\n            ax._offset = gs.l + ax.domain[0] * gs.w;\n            ax._length = gs.w * (ax.domain[1] - ax.domain[0]);\n            ax._m = ax._length / (rl1 - rl0);\n            ax._b = -ax._m * rl0;\n        }\n\n        if(!isFinite(ax._m) || !isFinite(ax._b)) {\n            fullLayout._replotting = false;\n            throw new Error('Something went wrong with axis scaling');\n        }\n    };\n\n    // makeCalcdata: takes an x or y array and converts it\n    // to a position on the axis object \"ax\"\n    // inputs:\n    //      trace - a data object from gd.data\n    //      axLetter - a string, either 'x' or 'y', for which item\n    //          to convert (TODO: is this now always the same as\n    //          the first letter of ax._id?)\n    // in case the expected data isn't there, make a list of\n    // integers based on the opposite data\n    ax.makeCalcdata = function(trace, axLetter) {\n        var arrayIn, arrayOut, i, len;\n\n        var axType = ax.type;\n        var cal = axType === 'date' && trace[axLetter + 'calendar'];\n\n        if(axLetter in trace) {\n            arrayIn = trace[axLetter];\n            len = trace._length || Lib.minRowLength(arrayIn);\n\n            if(Lib.isTypedArray(arrayIn) && (axType === 'linear' || axType === 'log')) {\n                if(len === arrayIn.length) {\n                    return arrayIn;\n                } else if(arrayIn.subarray) {\n                    return arrayIn.subarray(0, len);\n                }\n            }\n\n            if(axType === 'multicategory') {\n                return setMultiCategoryIndex(arrayIn, len);\n            }\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = ax.d2c(arrayIn[i], 0, cal);\n            }\n        }\n        else {\n            var v0 = ((axLetter + '0') in trace) ? ax.d2c(trace[axLetter + '0'], 0, cal) : 0;\n            var dv = (trace['d' + axLetter]) ? Number(trace['d' + axLetter]) : 1;\n\n            // the opposing data, for size if we have x and dx etc\n            arrayIn = trace[{x: 'y', y: 'x'}[axLetter]];\n            len = trace._length || arrayIn.length;\n            arrayOut = new Array(len);\n\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = v0 + i * dv;\n            }\n        }\n\n        return arrayOut;\n    };\n\n    ax.isValidRange = function(range) {\n        return (\n            Array.isArray(range) &&\n            range.length === 2 &&\n            isNumeric(ax.r2l(range[0])) &&\n            isNumeric(ax.r2l(range[1]))\n        );\n    };\n\n    ax.isPtWithinRange = function(d, calendar) {\n        var coord = ax.c2l(d[axLetter], null, calendar);\n        var r0 = ax.r2l(ax.range[0]);\n        var r1 = ax.r2l(ax.range[1]);\n\n        if(r0 < r1) {\n            return r0 <= coord && coord <= r1;\n        } else {\n            // Reversed axis case.\n            return r1 <= coord && coord <= r0;\n        }\n    };\n\n    ax.clearCalc = function() {\n        // initialize the category list, if there is one, so we start over\n        // to be filled in later by ax.d2c\n        ax._categories = (ax._initialCategories || []).slice();\n\n        // Build the lookup map for initialized categories\n        ax._categoriesMap = {};\n        for(var j = 0; j < ax._categories.length; j++) {\n            ax._categoriesMap[ax._categories[j]] = j;\n        }\n    };\n\n    // Propagate localization into the axis so that\n    // methods in Axes can use it w/o having to pass fullLayout\n    // Default (non-d3) number formatting uses separators directly\n    // dates and d3-formatted numbers use the d3 locale\n    // Fall back on default format for dummy axes that don't care about formatting\n    var locale = fullLayout._d3locale;\n    if(ax.type === 'date') {\n        ax._dateFormat = locale ? locale.timeFormat.utc : d3.time.format.utc;\n        ax._extraFormat = fullLayout._extraFormat;\n    }\n    // occasionally we need _numFormat to pass through\n    // even though it won't be needed by this axis\n    ax._separators = fullLayout.separators;\n    ax._numFormat = locale ? locale.numberFormat : d3.format;\n\n    // and for bar charts and box plots: reset forced minimum tick spacing\n    delete ax._minDtick;\n    delete ax._forceTick0;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}