{"ast":null,"code":"'use strict';\n\nvar isAllBlank = require('is-string-blank');\nvar createBuffer = require('gl-buffer');\nvar createVAO = require('gl-vao');\nvar pool = require('typedarray-pool');\nvar mat4mult = require('gl-mat4/multiply');\nvar shaders = require('./lib/shaders');\nvar getGlyph = require('./lib/glyphs');\nvar getSimpleString = require('./lib/get-simple-string');\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nmodule.exports = createPointCloud;\nfunction transformMat4(x, m) {\n  var x0 = x[0];\n  var x1 = x[1];\n  var x2 = x[2];\n  var x3 = x[3];\n  x[0] = m[0] * x0 + m[4] * x1 + m[8] * x2 + m[12] * x3;\n  x[1] = m[1] * x0 + m[5] * x1 + m[9] * x2 + m[13] * x3;\n  x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3;\n  x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3;\n  return x;\n}\nfunction project(p, v, m, x) {\n  transformMat4(x, x, m);\n  transformMat4(x, x, v);\n  return transformMat4(x, x, p);\n}\nfunction ScatterPlotPickResult(index, position) {\n  this.index = index;\n  this.dataCoordinate = this.position = position;\n}\nfunction fixOpacity(a) {\n  if (a === true) return 1;\n  if (a > 1) return 1;\n  return a;\n}\nfunction PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader) {\n  this.gl = gl;\n  this.pixelRatio = 1;\n  this.shader = shader;\n  this.orthoShader = orthoShader;\n  this.projectShader = projectShader;\n  this.pointBuffer = pointBuffer;\n  this.colorBuffer = colorBuffer;\n  this.glyphBuffer = glyphBuffer;\n  this.idBuffer = idBuffer;\n  this.vao = vao;\n  this.vertexCount = 0;\n  this.lineVertexCount = 0;\n  this.opacity = 1;\n  this.hasAlpha = false;\n  this.lineWidth = 0;\n  this.projectScale = [2.0 / 3.0, 2.0 / 3.0, 2.0 / 3.0];\n  this.projectOpacity = [1, 1, 1];\n  this.projectHasAlpha = false;\n  this.pickId = 0;\n  this.pickPerspectiveShader = pickPerspectiveShader;\n  this.pickOrthoShader = pickOrthoShader;\n  this.pickProjectShader = pickProjectShader;\n  this.points = [];\n  this._selectResult = new ScatterPlotPickResult(0, [0, 0, 0]);\n  this.useOrtho = true;\n  this.bounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n\n  //Axes projections\n  this.axesProject = [true, true, true];\n  this.axesBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.highlightId = [1, 1, 1, 1];\n  this.highlightScale = 2;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.dirty = true;\n}\nvar proto = PointCloud.prototype;\nproto.pickSlots = 1;\nproto.setPickBase = function (pickBase) {\n  this.pickId = pickBase;\n};\nproto.isTransparent = function () {\n  if (this.hasAlpha) {\n    return true;\n  }\n  for (var i = 0; i < 3; ++i) {\n    if (this.axesProject[i] && this.projectHasAlpha) {\n      return true;\n    }\n  }\n  return false;\n};\nproto.isOpaque = function () {\n  if (!this.hasAlpha) {\n    return true;\n  }\n  for (var i = 0; i < 3; ++i) {\n    if (this.axesProject[i] && !this.projectHasAlpha) {\n      return true;\n    }\n  }\n  return false;\n};\nvar VIEW_SHAPE = [0, 0];\nvar U_VEC = [0, 0, 0];\nvar V_VEC = [0, 0, 0];\nvar MU_VEC = [0, 0, 0, 1];\nvar MV_VEC = [0, 0, 0, 1];\nvar SCRATCH_MATRIX = IDENTITY.slice();\nvar SCRATCH_VEC = [0, 0, 0];\nvar CLIP_BOUNDS = [[0, 0, 0], [0, 0, 0]];\nfunction zeroVec(a) {\n  a[0] = a[1] = a[2] = 0;\n  return a;\n}\nfunction augment(hg, af) {\n  hg[0] = af[0];\n  hg[1] = af[1];\n  hg[2] = af[2];\n  hg[3] = 1;\n  return hg;\n}\nfunction setComponent(out, v, i, x) {\n  out[0] = v[0];\n  out[1] = v[1];\n  out[2] = v[2];\n  out[i] = x;\n  return out;\n}\nfunction getClipBounds(bounds) {\n  var result = CLIP_BOUNDS;\n  for (var i = 0; i < 2; ++i) {\n    for (var j = 0; j < 3; ++j) {\n      result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8);\n    }\n  }\n  return result;\n}\nfunction drawProject(shader, points, camera, pixelRatio) {\n  var axesProject = points.axesProject;\n  var gl = points.gl;\n  var uniforms = shader.uniforms;\n  var model = camera.model || IDENTITY;\n  var view = camera.view || IDENTITY;\n  var projection = camera.projection || IDENTITY;\n  var bounds = points.axesBounds;\n  var clipBounds = getClipBounds(points.clipBounds);\n  var cubeAxis;\n  if (points.axes && points.axes.lastCubeProps) {\n    cubeAxis = points.axes.lastCubeProps.axis;\n  } else {\n    cubeAxis = [1, 1, 1];\n  }\n  VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n  VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n  shader.bind();\n  uniforms.view = view;\n  uniforms.projection = projection;\n  uniforms.screenSize = VIEW_SHAPE;\n  uniforms.highlightId = points.highlightId;\n  uniforms.highlightScale = points.highlightScale;\n  uniforms.clipBounds = clipBounds;\n  uniforms.pickGroup = points.pickId / 255.0;\n  uniforms.pixelRatio = pixelRatio;\n  for (var i = 0; i < 3; ++i) {\n    if (!axesProject[i]) {\n      continue;\n    }\n    uniforms.scale = points.projectScale[i];\n    uniforms.opacity = points.projectOpacity[i];\n\n    //Project model matrix\n    var pmodel = SCRATCH_MATRIX;\n    for (var j = 0; j < 16; ++j) {\n      pmodel[j] = 0;\n    }\n    for (var j = 0; j < 4; ++j) {\n      pmodel[5 * j] = 1;\n    }\n    pmodel[5 * i] = 0;\n    if (cubeAxis[i] < 0) {\n      pmodel[12 + i] = bounds[0][i];\n    } else {\n      pmodel[12 + i] = bounds[1][i];\n    }\n    mat4mult(pmodel, model, pmodel);\n    uniforms.model = pmodel;\n\n    //Compute initial axes\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    var du = zeroVec(U_VEC);\n    var dv = zeroVec(V_VEC);\n    du[u] = 1;\n    dv[v] = 1;\n\n    //Align orientation relative to viewer\n    var mdu = project(projection, view, model, augment(MU_VEC, du));\n    var mdv = project(projection, view, model, augment(MV_VEC, dv));\n    if (Math.abs(mdu[1]) > Math.abs(mdv[1])) {\n      var tmp = mdu;\n      mdu = mdv;\n      mdv = tmp;\n      tmp = du;\n      du = dv;\n      dv = tmp;\n      var t = u;\n      u = v;\n      v = t;\n    }\n    if (mdu[0] < 0) {\n      du[u] = -1;\n    }\n    if (mdv[1] > 0) {\n      dv[v] = -1;\n    }\n    var su = 0.0;\n    var sv = 0.0;\n    for (var j = 0; j < 4; ++j) {\n      su += Math.pow(model[4 * u + j], 2);\n      sv += Math.pow(model[4 * v + j], 2);\n    }\n    du[u] /= Math.sqrt(su);\n    dv[v] /= Math.sqrt(sv);\n    uniforms.axes[0] = du;\n    uniforms.axes[1] = dv;\n\n    //Update fragment clip bounds\n    uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8);\n    uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8);\n    points.vao.bind();\n\n    //Draw interior\n    points.vao.draw(gl.TRIANGLES, points.vertexCount);\n\n    //Draw edges\n    if (points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio);\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n    }\n    points.vao.unbind();\n  }\n}\nvar NEG_INFINITY3 = [-1e8, -1e8, -1e8];\nvar POS_INFINITY3 = [1e8, 1e8, 1e8];\nvar CLIP_GROUP = [NEG_INFINITY3, POS_INFINITY3];\nfunction drawFull(shader, pshader, points, camera, pixelRatio, transparent, forceDraw) {\n  var gl = points.gl;\n  if (transparent === points.projectHasAlpha || forceDraw) {\n    drawProject(pshader, points, camera, pixelRatio);\n  }\n  if (transparent === points.hasAlpha || forceDraw) {\n    shader.bind();\n    var uniforms = shader.uniforms;\n    uniforms.model = camera.model || IDENTITY;\n    uniforms.view = camera.view || IDENTITY;\n    uniforms.projection = camera.projection || IDENTITY;\n    VIEW_SHAPE[0] = 2.0 / gl.drawingBufferWidth;\n    VIEW_SHAPE[1] = 2.0 / gl.drawingBufferHeight;\n    uniforms.screenSize = VIEW_SHAPE;\n    uniforms.highlightId = points.highlightId;\n    uniforms.highlightScale = points.highlightScale;\n    uniforms.fragClipBounds = CLIP_GROUP;\n    uniforms.clipBounds = points.axes.bounds;\n    uniforms.opacity = points.opacity;\n    uniforms.pickGroup = points.pickId / 255.0;\n    uniforms.pixelRatio = pixelRatio;\n    points.vao.bind();\n\n    //Draw interior\n    points.vao.draw(gl.TRIANGLES, points.vertexCount);\n\n    //Draw edges\n    if (points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio);\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount);\n    }\n    points.vao.unbind();\n  }\n}\nproto.draw = function (camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader;\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, false, false);\n};\nproto.drawTransparent = function (camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader;\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, true, false);\n};\nproto.drawPick = function (camera) {\n  var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader;\n  drawFull(shader, this.pickProjectShader, this, camera, 1, true, true);\n};\nproto.pick = function (selected) {\n  if (!selected) {\n    return null;\n  }\n  if (selected.id !== this.pickId) {\n    return null;\n  }\n  var x = selected.value[2] + (selected.value[1] << 8) + (selected.value[0] << 16);\n  if (x >= this.pointCount || x < 0) {\n    return null;\n  }\n\n  //Unpack result\n  var coord = this.points[x];\n  var result = this._selectResult;\n  result.index = x;\n  for (var i = 0; i < 3; ++i) {\n    result.position[i] = result.dataCoordinate[i] = coord[i];\n  }\n  return result;\n};\nproto.highlight = function (selection) {\n  if (!selection) {\n    this.highlightId = [1, 1, 1, 1];\n  } else {\n    var pointId = selection.index;\n    var a0 = pointId & 0xff;\n    var a1 = pointId >> 8 & 0xff;\n    var a2 = pointId >> 16 & 0xff;\n    this.highlightId = [a0 / 255.0, a1 / 255.0, a2 / 255.0, 0];\n  }\n};\nfunction get_glyphData(glyphs, index, font, pixelRatio) {\n  var str;\n\n  // use the data if presented in an array\n  if (Array.isArray(glyphs)) {\n    if (index < glyphs.length) {\n      str = glyphs[index];\n    } else {\n      str = undefined;\n    }\n  } else {\n    str = glyphs;\n  }\n  str = getSimpleString(str); // this would handle undefined cases\n\n  var visible = true;\n  if (isAllBlank(str)) {\n    str = '▼'; // Note: this special character may have minimum number of surfaces\n    visible = false;\n  }\n  var glyph = getGlyph(str, font, pixelRatio);\n  return {\n    mesh: glyph[0],\n    lines: glyph[1],\n    bounds: glyph[2],\n    visible: visible\n  };\n}\nproto.update = function (options) {\n  options = options || {};\n  if ('perspective' in options) {\n    this.useOrtho = !options.perspective;\n  }\n  if ('orthographic' in options) {\n    this.useOrtho = !!options.orthographic;\n  }\n  if ('lineWidth' in options) {\n    this.lineWidth = options.lineWidth;\n  }\n  if ('project' in options) {\n    if (Array.isArray(options.project)) {\n      this.axesProject = options.project;\n    } else {\n      var v = !!options.project;\n      this.axesProject = [v, v, v];\n    }\n  }\n  if ('projectScale' in options) {\n    if (Array.isArray(options.projectScale)) {\n      this.projectScale = options.projectScale.slice();\n    } else {\n      var s = +options.projectScale;\n      this.projectScale = [s, s, s];\n    }\n  }\n  this.projectHasAlpha = false; // default to no transparent draw\n  if ('projectOpacity' in options) {\n    if (Array.isArray(options.projectOpacity)) {\n      this.projectOpacity = options.projectOpacity.slice();\n    } else {\n      var s = +options.projectOpacity;\n      this.projectOpacity = [s, s, s];\n    }\n    for (var i = 0; i < 3; ++i) {\n      this.projectOpacity[i] = fixOpacity(this.projectOpacity[i]);\n      if (this.projectOpacity[i] < 1) {\n        this.projectHasAlpha = true;\n      }\n    }\n  }\n  this.hasAlpha = false; // default to no transparent draw\n  if ('opacity' in options) {\n    this.opacity = fixOpacity(options.opacity);\n    if (this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  }\n\n  //Set dirty flag\n  this.dirty = true;\n\n  //Create new buffers\n  var points = options.position;\n\n  //Text font\n  var font = options.font || 'normal';\n  var alignment = options.alignment || [0, 0];\n  var alignmentX;\n  var alignmentY;\n  if (alignment.length === 2) {\n    alignmentX = alignment[0];\n    alignmentY = alignment[1];\n  } else {\n    alignmentX = [];\n    alignmentY = [];\n    for (var i = 0; i < alignment.length; ++i) {\n      alignmentX[i] = alignment[i][0];\n      alignmentY[i] = alignment[i][1];\n    }\n  }\n\n  //Bounds\n  var lowerBound = [Infinity, Infinity, Infinity];\n  var upperBound = [-Infinity, -Infinity, -Infinity];\n\n  //Unpack options\n  var glyphs = options.glyph;\n  var colors = options.color;\n  var sizes = options.size;\n  var angles = options.angle;\n  var lineColors = options.lineColor;\n\n  //Picking geometry\n  var pickCounter = -1;\n\n  //First do pass to compute buffer sizes\n  var triVertexCount = 0;\n  var lineVertexCount = 0;\n  var numPoints = 0;\n  if (points.length) {\n    //Count number of points and buffer size\n    numPoints = points.length;\n    count_loop: for (var i = 0; i < numPoints; ++i) {\n      var x = points[i];\n      for (var j = 0; j < 3; ++j) {\n        if (isNaN(x[j]) || !isFinite(x[j])) {\n          continue count_loop;\n        }\n      }\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n      var glyphMesh = glyphData.mesh;\n      var glyphLines = glyphData.lines;\n      var glyphBounds = glyphData.bounds;\n      triVertexCount += glyphMesh.cells.length * 3;\n      lineVertexCount += glyphLines.edges.length * 2;\n    }\n  }\n  var vertexCount = triVertexCount + lineVertexCount;\n\n  //Preallocate data\n  var positionArray = pool.mallocFloat(3 * vertexCount);\n  var colorArray = pool.mallocFloat(4 * vertexCount);\n  var glyphArray = pool.mallocFloat(2 * vertexCount);\n  var idArray = pool.mallocUint32(vertexCount);\n  if (vertexCount > 0) {\n    var triOffset = 0;\n    var lineOffset = triVertexCount;\n    var color = [0, 0, 0, 1];\n    var lineColor = [0, 0, 0, 1];\n    var isColorArray = Array.isArray(colors) && Array.isArray(colors[0]);\n    var isLineColorArray = Array.isArray(lineColors) && Array.isArray(lineColors[0]);\n    fill_loop: for (var i = 0; i < numPoints; ++i) {\n      //Increment pickCounter\n      pickCounter += 1;\n      var x = points[i];\n      for (var j = 0; j < 3; ++j) {\n        if (isNaN(x[j]) || !isFinite(x[j])) {\n          continue fill_loop;\n        }\n        upperBound[j] = Math.max(upperBound[j], x[j]);\n        lowerBound[j] = Math.min(lowerBound[j], x[j]);\n      }\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio);\n      var glyphMesh = glyphData.mesh;\n      var glyphLines = glyphData.lines;\n      var glyphBounds = glyphData.bounds;\n      var glyphVisible = glyphData.visible;\n\n      //Get color\n      if (!glyphVisible) color = [1, 1, 1, 0];else if (Array.isArray(colors)) {\n        var c;\n        if (isColorArray) {\n          if (i < colors.length) {\n            c = colors[i];\n          } else {\n            c = [0, 0, 0, 0];\n          }\n        } else {\n          c = colors;\n        }\n        if (c.length === 3) {\n          for (var j = 0; j < 3; ++j) {\n            color[j] = c[j];\n          }\n          color[3] = 1;\n        } else if (c.length === 4) {\n          for (var j = 0; j < 4; ++j) {\n            color[j] = c[j];\n          }\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n      } else {\n        color[0] = color[1] = color[2] = 0;\n        color[3] = 1;\n      }\n\n      //Get lineColor\n      if (!glyphVisible) lineColor = [1, 1, 1, 0];else if (Array.isArray(lineColors)) {\n        var c;\n        if (isLineColorArray) {\n          if (i < lineColors.length) {\n            c = lineColors[i];\n          } else {\n            c = [0, 0, 0, 0];\n          }\n        } else {\n          c = lineColors;\n        }\n        if (c.length === 3) {\n          for (var j = 0; j < 3; ++j) {\n            lineColor[j] = c[j];\n          }\n          lineColor[j] = 1;\n        } else if (c.length === 4) {\n          for (var j = 0; j < 4; ++j) {\n            lineColor[j] = c[j];\n          }\n          if (!this.hasAlpha && c[3] < 1) this.hasAlpha = true;\n        }\n      } else {\n        lineColor[0] = lineColor[1] = lineColor[2] = 0;\n        lineColor[3] = 1;\n      }\n      var size = 0.5;\n      if (!glyphVisible) size = 0.0;else if (Array.isArray(sizes)) {\n        if (i < sizes.length) {\n          size = +sizes[i];\n        } else {\n          size = 12;\n        }\n      } else if (sizes) {\n        size = +sizes;\n      } else if (this.useOrtho) {\n        size = 12;\n      }\n      var angle = 0;\n      if (Array.isArray(angles)) {\n        if (i < angles.length) {\n          angle = +angles[i];\n        } else {\n          angle = 0;\n        }\n      } else if (angles) {\n        angle = +angles;\n      }\n\n      //Loop through markers and append to buffers\n      var cos = Math.cos(angle);\n      var sin = Math.sin(angle);\n      var x = points[i];\n      for (var j = 0; j < 3; ++j) {\n        upperBound[j] = Math.max(upperBound[j], x[j]);\n        lowerBound[j] = Math.min(lowerBound[j], x[j]);\n      }\n\n      //Calculate text offset\n      var textOffsetX = alignmentX;\n      var textOffsetY = alignmentY;\n      var textOffsetX = 0;\n      if (Array.isArray(alignmentX)) {\n        if (i < alignmentX.length) {\n          textOffsetX = alignmentX[i];\n        } else {\n          textOffsetX = 0;\n        }\n      } else if (alignmentX) {\n        textOffsetX = alignmentX;\n      }\n      var textOffsetY = 0;\n      if (Array.isArray(alignmentY)) {\n        if (i < alignmentY.length) {\n          textOffsetY = alignmentY[i];\n        } else {\n          textOffsetY = 0;\n        }\n      } else if (alignmentY) {\n        textOffsetY = alignmentY;\n      }\n      textOffsetX *= textOffsetX > 0 ? 1 - glyphBounds[0][0] : textOffsetX < 0 ? 1 + glyphBounds[1][0] : 1;\n      textOffsetY *= textOffsetY > 0 ? 1 - glyphBounds[0][1] : textOffsetY < 0 ? 1 + glyphBounds[1][1] : 1;\n      var textOffset = [textOffsetX, textOffsetY];\n\n      //Write out inner marker\n      var cells = glyphMesh.cells || [];\n      var verts = glyphMesh.positions || [];\n      for (var j = 0; j < cells.length; ++j) {\n        var cell = cells[j];\n        for (var k = 0; k < 3; ++k) {\n          for (var l = 0; l < 3; ++l) {\n            positionArray[3 * triOffset + l] = x[l];\n          }\n          for (var l = 0; l < 4; ++l) {\n            colorArray[4 * triOffset + l] = color[l];\n          }\n          idArray[triOffset] = pickCounter;\n          var p = verts[cell[k]];\n          glyphArray[2 * triOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n          glyphArray[2 * triOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n          triOffset += 1;\n        }\n      }\n      var cells = glyphLines.edges;\n      var verts = glyphLines.positions;\n      for (var j = 0; j < cells.length; ++j) {\n        var cell = cells[j];\n        for (var k = 0; k < 2; ++k) {\n          for (var l = 0; l < 3; ++l) {\n            positionArray[3 * lineOffset + l] = x[l];\n          }\n          for (var l = 0; l < 4; ++l) {\n            colorArray[4 * lineOffset + l] = lineColor[l];\n          }\n          idArray[lineOffset] = pickCounter;\n          var p = verts[cell[k]];\n          glyphArray[2 * lineOffset] = size * (cos * p[0] - sin * p[1] + textOffset[0]);\n          glyphArray[2 * lineOffset + 1] = size * (sin * p[0] + cos * p[1] + textOffset[1]);\n          lineOffset += 1;\n        }\n      }\n    }\n  }\n\n  //Update bounds\n  this.bounds = [lowerBound, upperBound];\n\n  //Save points\n  this.points = points;\n\n  //Save number of points\n  this.pointCount = points.length;\n\n  //Update vertex counts\n  this.vertexCount = triVertexCount;\n  this.lineVertexCount = lineVertexCount;\n  this.pointBuffer.update(positionArray);\n  this.colorBuffer.update(colorArray);\n  this.glyphBuffer.update(glyphArray);\n  //this.idBuffer.update(new Uint32Array(idArray))\n  this.idBuffer.update(idArray);\n  pool.free(positionArray);\n  pool.free(colorArray);\n  pool.free(glyphArray);\n  pool.free(idArray);\n};\nproto.dispose = function () {\n  //Shaders\n  this.shader.dispose();\n  this.orthoShader.dispose();\n  this.pickPerspectiveShader.dispose();\n  this.pickOrthoShader.dispose();\n\n  //Vertex array\n  this.vao.dispose();\n\n  //Buffers\n  this.pointBuffer.dispose();\n  this.colorBuffer.dispose();\n  this.glyphBuffer.dispose();\n  this.idBuffer.dispose();\n};\nfunction createPointCloud(options) {\n  var gl = options.gl;\n  var shader = shaders.createPerspective(gl);\n  var orthoShader = shaders.createOrtho(gl);\n  var projectShader = shaders.createProject(gl);\n  var pickPerspectiveShader = shaders.createPickPerspective(gl);\n  var pickOrthoShader = shaders.createPickOrtho(gl);\n  var pickProjectShader = shaders.createPickProject(gl);\n  var pointBuffer = createBuffer(gl);\n  var colorBuffer = createBuffer(gl);\n  var glyphBuffer = createBuffer(gl);\n  var idBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: pointBuffer,\n    size: 3,\n    type: gl.FLOAT\n  }, {\n    buffer: colorBuffer,\n    size: 4,\n    type: gl.FLOAT\n  }, {\n    buffer: glyphBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }, {\n    buffer: idBuffer,\n    size: 4,\n    type: gl.UNSIGNED_BYTE,\n    normalized: true\n  }]);\n  var pointCloud = new PointCloud(gl, shader, orthoShader, projectShader, pointBuffer, colorBuffer, glyphBuffer, idBuffer, vao, pickPerspectiveShader, pickOrthoShader, pickProjectShader);\n  pointCloud.update(options);\n  return pointCloud;\n}","map":{"version":3,"names":["isAllBlank","require","createBuffer","createVAO","pool","mat4mult","shaders","getGlyph","getSimpleString","IDENTITY","module","exports","createPointCloud","transformMat4","x","m","x0","x1","x2","x3","project","p","v","ScatterPlotPickResult","index","position","dataCoordinate","fixOpacity","a","PointCloud","gl","shader","orthoShader","projectShader","pointBuffer","colorBuffer","glyphBuffer","idBuffer","vao","pickPerspectiveShader","pickOrthoShader","pickProjectShader","pixelRatio","vertexCount","lineVertexCount","opacity","hasAlpha","lineWidth","projectScale","projectOpacity","projectHasAlpha","pickId","points","_selectResult","useOrtho","bounds","Infinity","axesProject","axesBounds","highlightId","highlightScale","clipBounds","dirty","proto","prototype","pickSlots","setPickBase","pickBase","isTransparent","i","isOpaque","VIEW_SHAPE","U_VEC","V_VEC","MU_VEC","MV_VEC","SCRATCH_MATRIX","slice","SCRATCH_VEC","CLIP_BOUNDS","zeroVec","augment","hg","af","setComponent","out","getClipBounds","result","j","Math","max","min","drawProject","camera","uniforms","model","view","projection","cubeAxis","axes","lastCubeProps","axis","drawingBufferWidth","drawingBufferHeight","bind","screenSize","pickGroup","scale","pmodel","u","du","dv","mdu","mdv","abs","tmp","t","su","sv","pow","sqrt","fragClipBounds","draw","TRIANGLES","LINES","unbind","NEG_INFINITY3","POS_INFINITY3","CLIP_GROUP","drawFull","pshader","transparent","forceDraw","drawTransparent","drawPick","pick","selected","id","value","pointCount","coord","highlight","selection","pointId","a0","a1","a2","get_glyphData","glyphs","font","str","Array","isArray","length","undefined","visible","glyph","mesh","lines","update","options","perspective","orthographic","s","alignment","alignmentX","alignmentY","lowerBound","upperBound","colors","color","sizes","size","angles","angle","lineColors","lineColor","pickCounter","triVertexCount","numPoints","count_loop","isNaN","isFinite","glyphData","glyphMesh","glyphLines","glyphBounds","cells","edges","positionArray","mallocFloat","colorArray","glyphArray","idArray","mallocUint32","triOffset","lineOffset","isColorArray","isLineColorArray","fill_loop","glyphVisible","c","cos","sin","textOffsetX","textOffsetY","textOffset","verts","positions","cell","k","l","free","dispose","createPerspective","createOrtho","createProject","createPickPerspective","createPickOrtho","createPickProject","buffer","type","FLOAT","UNSIGNED_BYTE","normalized","pointCloud"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/gl-scatter3d/pointcloud.js"],"sourcesContent":["'use strict'\n\nvar isAllBlank      = require('is-string-blank')\nvar createBuffer    = require('gl-buffer')\nvar createVAO       = require('gl-vao')\nvar pool            = require('typedarray-pool')\nvar mat4mult        = require('gl-mat4/multiply')\nvar shaders         = require('./lib/shaders')\nvar getGlyph        = require('./lib/glyphs')\nvar getSimpleString = require('./lib/get-simple-string')\n\nvar IDENTITY = [1,0,0,0,\n                0,1,0,0,\n                0,0,1,0,\n                0,0,0,1]\n\nmodule.exports = createPointCloud\n\nfunction transformMat4(x, m) {\n  var x0 = x[0]\n  var x1 = x[1]\n  var x2 = x[2]\n  var x3 = x[3]\n  x[0] = m[0] * x0 + m[4] * x1 + m[8]  * x2 + m[12] * x3\n  x[1] = m[1] * x0 + m[5] * x1 + m[9]  * x2 + m[13] * x3\n  x[2] = m[2] * x0 + m[6] * x1 + m[10] * x2 + m[14] * x3\n  x[3] = m[3] * x0 + m[7] * x1 + m[11] * x2 + m[15] * x3\n  return x\n}\n\nfunction project(p, v, m, x) {\n  transformMat4(x, x, m)\n  transformMat4(x, x, v)\n  return transformMat4(x, x, p)\n}\n\nfunction ScatterPlotPickResult(index, position) {\n  this.index = index\n  this.dataCoordinate = this.position = position\n}\n\nfunction fixOpacity(a) {\n  if(a === true) return 1\n  if(a > 1) return 1\n  return a\n}\n\nfunction PointCloud(\n  gl,\n  shader,\n  orthoShader,\n  projectShader,\n  pointBuffer,\n  colorBuffer,\n  glyphBuffer,\n  idBuffer,\n  vao,\n  pickPerspectiveShader,\n  pickOrthoShader,\n  pickProjectShader) {\n\n  this.gl              = gl\n\n  this.pixelRatio      = 1\n\n  this.shader          = shader\n  this.orthoShader     = orthoShader\n  this.projectShader   = projectShader\n\n  this.pointBuffer     = pointBuffer\n  this.colorBuffer     = colorBuffer\n  this.glyphBuffer     = glyphBuffer\n  this.idBuffer        = idBuffer\n  this.vao             = vao\n  this.vertexCount     = 0\n  this.lineVertexCount = 0\n\n  this.opacity         = 1\n  this.hasAlpha        = false\n\n  this.lineWidth       = 0\n  this.projectScale    = [2.0/3.0, 2.0/3.0, 2.0/3.0]\n  this.projectOpacity  = [1, 1, 1]\n  this.projectHasAlpha  = false\n\n  this.pickId                = 0\n  this.pickPerspectiveShader = pickPerspectiveShader\n  this.pickOrthoShader       = pickOrthoShader\n  this.pickProjectShader     = pickProjectShader\n  this.points                = []\n\n  this._selectResult = new ScatterPlotPickResult(0, [0,0,0])\n\n  this.useOrtho = true\n  this.bounds   = [[ Infinity,Infinity,Infinity],\n                   [-Infinity,-Infinity,-Infinity]]\n\n  //Axes projections\n  this.axesProject = [ true, true, true ]\n  this.axesBounds = [[-Infinity,-Infinity,-Infinity],\n                     [ Infinity, Infinity, Infinity]]\n\n  this.highlightId    = [1,1,1,1]\n  this.highlightScale = 2\n\n  this.clipBounds = [[-Infinity,-Infinity,-Infinity],\n                     [ Infinity, Infinity, Infinity]]\n\n  this.dirty = true\n}\n\nvar proto = PointCloud.prototype\n\nproto.pickSlots = 1\n\nproto.setPickBase = function(pickBase) {\n  this.pickId = pickBase\n}\n\nproto.isTransparent = function() {\n  if(this.hasAlpha)  {\n    return true\n  }\n  for(var i=0; i<3; ++i) {\n    if(this.axesProject[i] && this.projectHasAlpha) {\n      return true\n    }\n  }\n  return false\n}\n\nproto.isOpaque = function() {\n  if(!this.hasAlpha)  {\n    return true\n  }\n  for(var i=0; i<3; ++i) {\n    if(this.axesProject[i] && !this.projectHasAlpha) {\n      return true\n    }\n  }\n  return false\n}\n\nvar VIEW_SHAPE = [0,0]\nvar U_VEC = [0,0,0]\nvar V_VEC = [0,0,0]\nvar MU_VEC = [0,0,0,1]\nvar MV_VEC = [0,0,0,1]\nvar SCRATCH_MATRIX = IDENTITY.slice()\nvar SCRATCH_VEC = [0,0,0]\nvar CLIP_BOUNDS = [[0,0,0], [0,0,0]]\n\nfunction zeroVec(a) {\n  a[0] = a[1] = a[2] = 0\n  return a\n}\n\nfunction augment(hg, af) {\n  hg[0] = af[0]\n  hg[1] = af[1]\n  hg[2] = af[2]\n  hg[3] = 1\n  return hg\n}\n\nfunction setComponent(out, v, i, x) {\n  out[0] = v[0]\n  out[1] = v[1]\n  out[2] = v[2]\n  out[i] = x\n  return out\n}\n\nfunction getClipBounds(bounds) {\n  var result = CLIP_BOUNDS\n  for(var i=0; i<2; ++i) {\n    for(var j=0; j<3; ++j) {\n      result[i][j] = Math.max(Math.min(bounds[i][j], 1e8), -1e8)\n    }\n  }\n  return result\n}\n\nfunction drawProject(shader, points, camera, pixelRatio) {\n  var axesProject = points.axesProject\n\n  var gl         = points.gl\n  var uniforms   = shader.uniforms\n  var model      = camera.model      || IDENTITY\n  var view       = camera.view       || IDENTITY\n  var projection = camera.projection || IDENTITY\n  var bounds     = points.axesBounds\n  var clipBounds = getClipBounds(points.clipBounds)\n\n  var cubeAxis\n  if(points.axes && points.axes.lastCubeProps) {\n    cubeAxis = points.axes.lastCubeProps.axis\n  } else {\n    cubeAxis = [1,1,1]\n  }\n\n  VIEW_SHAPE[0] = 2.0/gl.drawingBufferWidth\n  VIEW_SHAPE[1] = 2.0/gl.drawingBufferHeight\n\n  shader.bind()\n  uniforms.view           = view\n  uniforms.projection     = projection\n  uniforms.screenSize     = VIEW_SHAPE\n  uniforms.highlightId    = points.highlightId\n  uniforms.highlightScale = points.highlightScale\n  uniforms.clipBounds     = clipBounds\n  uniforms.pickGroup      = points.pickId / 255.0\n  uniforms.pixelRatio     = pixelRatio\n\n  for(var i=0; i<3; ++i) {\n    if(!axesProject[i]) {\n      continue\n    }\n\n    uniforms.scale          = points.projectScale[i]\n    uniforms.opacity        = points.projectOpacity[i]\n\n    //Project model matrix\n    var pmodel = SCRATCH_MATRIX\n    for(var j=0; j<16; ++j) {\n      pmodel[j] = 0\n    }\n    for(var j=0; j<4; ++j) {\n      pmodel[5*j] = 1\n    }\n    pmodel[5*i] = 0\n    if(cubeAxis[i] < 0) {\n      pmodel[12+i] = bounds[0][i]\n    } else {\n      pmodel[12+i] = bounds[1][i]\n    }\n    mat4mult(pmodel, model, pmodel)\n    uniforms.model = pmodel\n\n    //Compute initial axes\n    var u = (i+1)%3\n    var v = (i+2)%3\n    var du = zeroVec(U_VEC)\n    var dv = zeroVec(V_VEC)\n    du[u] = 1\n    dv[v] = 1\n\n    //Align orientation relative to viewer\n    var mdu = project(projection, view, model, augment(MU_VEC, du))\n    var mdv = project(projection, view, model, augment(MV_VEC, dv))\n    if(Math.abs(mdu[1]) > Math.abs(mdv[1])) {\n      var tmp = mdu\n      mdu = mdv\n      mdv = tmp\n      tmp = du\n      du = dv\n      dv = tmp\n      var t = u\n      u = v\n      v = t\n    }\n    if(mdu[0] < 0) {\n      du[u] = -1\n    }\n    if(mdv[1] > 0) {\n      dv[v] = -1\n    }\n    var su = 0.0\n    var sv = 0.0\n    for(var j=0; j<4; ++j) {\n      su += Math.pow(model[4*u+j], 2)\n      sv += Math.pow(model[4*v+j], 2)\n    }\n    du[u] /= Math.sqrt(su)\n    dv[v] /= Math.sqrt(sv)\n    uniforms.axes[0] = du\n    uniforms.axes[1] = dv\n\n    //Update fragment clip bounds\n    uniforms.fragClipBounds[0] = setComponent(SCRATCH_VEC, clipBounds[0], i, -1e8)\n    uniforms.fragClipBounds[1] = setComponent(SCRATCH_VEC, clipBounds[1], i, 1e8)\n\n    points.vao.bind()\n\n    //Draw interior\n    points.vao.draw(gl.TRIANGLES, points.vertexCount)\n\n    //Draw edges\n    if(points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio)\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount)\n    }\n\n    points.vao.unbind()\n  }\n}\n\n\nvar NEG_INFINITY3 = [-1e8, -1e8, -1e8]\nvar POS_INFINITY3 = [1e8, 1e8, 1e8]\nvar CLIP_GROUP    = [NEG_INFINITY3, POS_INFINITY3]\n\nfunction drawFull(shader, pshader, points, camera, pixelRatio, transparent, forceDraw) {\n  var gl = points.gl\n\n  if(transparent === points.projectHasAlpha || forceDraw) {\n    drawProject(pshader, points, camera, pixelRatio)\n  }\n\n  if(transparent === points.hasAlpha || forceDraw) {\n\n    shader.bind()\n    var uniforms = shader.uniforms\n\n    uniforms.model      = camera.model      || IDENTITY\n    uniforms.view       = camera.view       || IDENTITY\n    uniforms.projection = camera.projection || IDENTITY\n\n    VIEW_SHAPE[0]       = 2.0/gl.drawingBufferWidth\n    VIEW_SHAPE[1]       = 2.0/gl.drawingBufferHeight\n    uniforms.screenSize = VIEW_SHAPE\n\n    uniforms.highlightId    = points.highlightId\n    uniforms.highlightScale = points.highlightScale\n\n    uniforms.fragClipBounds = CLIP_GROUP\n    uniforms.clipBounds     = points.axes.bounds\n\n    uniforms.opacity    = points.opacity\n    uniforms.pickGroup  = points.pickId / 255.0\n\n    uniforms.pixelRatio = pixelRatio\n\n    points.vao.bind()\n\n    //Draw interior\n    points.vao.draw(gl.TRIANGLES, points.vertexCount)\n\n    //Draw edges\n    if(points.lineWidth > 0) {\n      gl.lineWidth(points.lineWidth * pixelRatio)\n      points.vao.draw(gl.LINES, points.lineVertexCount, points.vertexCount)\n    }\n\n    points.vao.unbind()\n  }\n\n\n}\n\nproto.draw = function(camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, false, false)\n}\n\nproto.drawTransparent = function(camera) {\n  var shader = this.useOrtho ? this.orthoShader : this.shader\n  drawFull(shader, this.projectShader, this, camera, this.pixelRatio, true, false)\n}\n\nproto.drawPick = function(camera) {\n  var shader = this.useOrtho ? this.pickOrthoShader : this.pickPerspectiveShader\n  drawFull(shader, this.pickProjectShader, this, camera, 1, true, true)\n}\n\nproto.pick = function(selected) {\n  if(!selected) {\n    return null\n  }\n  if(selected.id !== this.pickId) {\n    return null\n  }\n  var x = selected.value[2] + (selected.value[1]<<8) + (selected.value[0]<<16)\n  if(x >= this.pointCount || x < 0) {\n    return null\n  }\n\n  //Unpack result\n  var coord = this.points[x]\n  var result = this._selectResult\n  result.index = x\n  for(var i=0; i<3; ++i) {\n    result.position[i] = result.dataCoordinate[i] = coord[i]\n  }\n  return result\n}\n\nproto.highlight = function(selection) {\n  if(!selection) {\n    this.highlightId = [1,1,1,1]\n  } else {\n    var pointId = selection.index\n    var a0 =  pointId     &0xff\n    var a1 = (pointId>>8) &0xff\n    var a2 = (pointId>>16)&0xff\n    this.highlightId = [a0/255.0, a1/255.0, a2/255.0, 0]\n  }\n}\n\nfunction get_glyphData(glyphs, index, font, pixelRatio) {\n  var str\n\n  // use the data if presented in an array\n  if(Array.isArray(glyphs)) {\n    if(index < glyphs.length) {\n      str = glyphs[index]\n    } else {\n      str = undefined\n    }\n  } else {\n    str = glyphs\n  }\n\n  str = getSimpleString(str) // this would handle undefined cases\n\n  var visible = true\n  if(isAllBlank(str)) {\n    str = '▼' // Note: this special character may have minimum number of surfaces\n    visible = false\n  }\n\n  var glyph = getGlyph(str, font, pixelRatio)\n\n  return { mesh:glyph[0],\n          lines:glyph[1],\n         bounds:glyph[2],\n        visible:visible };\n}\n\n\n\nproto.update = function(options) {\n\n  options = options || {}\n\n  if('perspective' in options) {\n    this.useOrtho = !options.perspective\n  }\n  if('orthographic' in options) {\n    this.useOrtho = !!options.orthographic\n  }\n  if('lineWidth' in options) {\n    this.lineWidth = options.lineWidth\n  }\n  if('project' in options) {\n    if(Array.isArray(options.project)) {\n      this.axesProject = options.project\n    } else {\n      var v = !!options.project\n      this.axesProject = [v,v,v]\n    }\n  }\n  if('projectScale' in options) {\n    if(Array.isArray(options.projectScale)) {\n      this.projectScale = options.projectScale.slice()\n    } else {\n      var s = +options.projectScale\n      this.projectScale = [s,s,s]\n    }\n  }\n\n  this.projectHasAlpha = false // default to no transparent draw\n  if('projectOpacity' in options) {\n    if(Array.isArray(options.projectOpacity)) {\n      this.projectOpacity = options.projectOpacity.slice()\n    } else {\n      var s = +options.projectOpacity\n      this.projectOpacity = [s,s,s]\n    }\n    for(var i=0; i<3; ++i) {\n      this.projectOpacity[i] = fixOpacity(this.projectOpacity[i]);\n      if(this.projectOpacity[i] < 1) {\n        this.projectHasAlpha = true;\n      }\n    }\n  }\n\n  this.hasAlpha = false // default to no transparent draw\n  if('opacity' in options) {\n    this.opacity = fixOpacity(options.opacity)\n    if(this.opacity < 1) {\n      this.hasAlpha = true;\n    }\n  }\n\n  //Set dirty flag\n  this.dirty = true\n\n  //Create new buffers\n  var points = options.position\n\n  //Text font\n  var font      = options.font      || 'normal'\n  var alignment = options.alignment || [0,0]\n\n  var alignmentX;\n  var alignmentY;\n  if (alignment.length === 2) {\n    alignmentX = alignment[0]\n    alignmentY = alignment[1]\n  } else {\n    alignmentX = []\n    alignmentY = []\n    for (var i = 0; i < alignment.length; ++i) {\n      alignmentX[i] = alignment[i][0]\n      alignmentY[i] = alignment[i][1]\n    }\n  }\n\n  //Bounds\n  var lowerBound = [ Infinity, Infinity, Infinity]\n  var upperBound = [-Infinity,-Infinity,-Infinity]\n\n  //Unpack options\n  var glyphs     = options.glyph\n  var colors     = options.color\n  var sizes      = options.size\n  var angles     = options.angle\n  var lineColors = options.lineColor\n\n  //Picking geometry\n  var pickCounter = -1\n\n  //First do pass to compute buffer sizes\n  var triVertexCount  = 0\n  var lineVertexCount = 0\n\n  var numPoints = 0;\n\n  if(points.length) {\n\n    //Count number of points and buffer size\n    numPoints = points.length\n\n  count_loop:\n    for(var i=0; i<numPoints; ++i) {\n      var x = points[i]\n      for(var j=0; j<3; ++j) {\n        if(isNaN(x[j]) || !isFinite(x[j])) {\n          continue count_loop\n        }\n      }\n\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio)\n\n      var glyphMesh   = glyphData.mesh\n      var glyphLines  = glyphData.lines\n      var glyphBounds = glyphData.bounds\n\n      triVertexCount  += glyphMesh.cells.length * 3\n      lineVertexCount += glyphLines.edges.length * 2\n    }\n  }\n\n  var vertexCount   = triVertexCount + lineVertexCount\n\n  //Preallocate data\n  var positionArray = pool.mallocFloat(3*vertexCount)\n  var colorArray    = pool.mallocFloat(4*vertexCount)\n  var glyphArray    = pool.mallocFloat(2*vertexCount)\n  var idArray       = pool.mallocUint32(vertexCount)\n\n  if(vertexCount > 0) {\n    var triOffset  = 0\n    var lineOffset = triVertexCount\n    var color      = [0,0,0,1]\n    var lineColor  = [0,0,0,1]\n\n    var isColorArray      = Array.isArray(colors)     && Array.isArray(colors[0])\n    var isLineColorArray  = Array.isArray(lineColors) && Array.isArray(lineColors[0])\n\n  fill_loop:\n    for(var i=0; i<numPoints; ++i) {\n      //Increment pickCounter\n      pickCounter += 1\n\n      var x = points[i]\n      for(var j=0; j<3; ++j) {\n        if(isNaN(x[j]) || !isFinite(x[j])) {\n          continue fill_loop\n        }\n\n        upperBound[j] = Math.max(upperBound[j], x[j])\n        lowerBound[j] = Math.min(lowerBound[j], x[j])\n      }\n\n      var glyphData = get_glyphData(glyphs, i, font, this.pixelRatio)\n\n      var glyphMesh   = glyphData.mesh\n      var glyphLines  = glyphData.lines\n      var glyphBounds = glyphData.bounds\n      var glyphVisible = glyphData.visible\n\n      //Get color\n      if(!glyphVisible) color = [1,1,1,0]\n      else if(Array.isArray(colors)) {\n        var c\n        if(isColorArray) {\n          if(i < colors.length) {\n            c = colors[i]\n          } else {\n            c = [0,0,0,0]\n          }\n        } else {\n          c = colors\n        }\n\n        if(c.length === 3) {\n          for(var j=0; j<3; ++j) {\n            color[j] = c[j]\n          }\n          color[3] = 1\n        } else if(c.length === 4) {\n          for(var j=0; j<4; ++j) {\n            color[j] = c[j]\n          }\n          if(!this.hasAlpha && c[3] < 1) this.hasAlpha = true\n        }\n      } else {\n        color[0] = color[1] = color[2] = 0\n        color[3] = 1\n      }\n\n\n      //Get lineColor\n      if(!glyphVisible) lineColor = [1,1,1,0]\n      else if(Array.isArray(lineColors)) {\n        var c\n        if(isLineColorArray) {\n          if(i < lineColors.length) {\n            c = lineColors[i]\n          } else {\n            c = [0,0,0,0]\n          }\n        } else {\n          c = lineColors\n        }\n\n        if(c.length === 3) {\n          for(var j=0; j<3; ++j) {\n            lineColor[j] = c[j]\n          }\n          lineColor[j] = 1\n        } else if(c.length === 4) {\n          for(var j=0; j<4; ++j) {\n            lineColor[j] = c[j]\n          }\n          if(!this.hasAlpha && c[3] < 1) this.hasAlpha = true\n        }\n      } else {\n        lineColor[0] = lineColor[1] = lineColor[2] = 0\n        lineColor[3] = 1\n      }\n\n\n      var size = 0.5\n      if(!glyphVisible) size = 0.0\n      else if(Array.isArray(sizes)) {\n        if(i < sizes.length) {\n          size = +sizes[i]\n        } else {\n          size = 12\n        }\n      } else if(sizes) {\n        size = +sizes\n      } else if(this.useOrtho) {\n        size = 12\n      }\n\n\n      var angle = 0\n      if(Array.isArray(angles)) {\n        if(i < angles.length) {\n          angle = +angles[i]\n        } else {\n          angle = 0\n        }\n      } else if(angles) {\n        angle = +angles\n      }\n\n      //Loop through markers and append to buffers\n      var cos = Math.cos(angle)\n      var sin = Math.sin(angle)\n\n      var x = points[i]\n      for(var j=0; j<3; ++j) {\n        upperBound[j] = Math.max(upperBound[j], x[j])\n        lowerBound[j] = Math.min(lowerBound[j], x[j])\n      }\n\n      //Calculate text offset\n      var textOffsetX = alignmentX\n      var textOffsetY = alignmentY\n\n      var textOffsetX = 0\n      if(Array.isArray(alignmentX)) {\n        if(i < alignmentX.length) {\n          textOffsetX = alignmentX[i]\n        } else {\n          textOffsetX = 0\n        }\n      } else if(alignmentX) {\n        textOffsetX = alignmentX\n      }\n\n      var textOffsetY = 0\n      if(Array.isArray(alignmentY)) {\n        if(i < alignmentY.length) {\n          textOffsetY = alignmentY[i]\n        } else {\n          textOffsetY = 0\n        }\n      } else if(alignmentY) {\n        textOffsetY = alignmentY\n      }\n\n      textOffsetX *= (textOffsetX > 0) ? (1 - glyphBounds[0][0]) :\n                     (textOffsetX < 0) ? (1 + glyphBounds[1][0]) : 1;\n\n      textOffsetY *= (textOffsetY > 0) ? (1 - glyphBounds[0][1]) :\n                     (textOffsetY < 0) ? (1 + glyphBounds[1][1]) : 1;\n\n      var textOffset = [textOffsetX, textOffsetY]\n\n      //Write out inner marker\n      var cells = glyphMesh.cells || []\n      var verts = glyphMesh.positions || []\n\n      for(var j=0; j<cells.length; ++j) {\n        var cell = cells[j]\n        for(var k=0; k<3; ++k) {\n          for(var l=0; l<3; ++l) {\n            positionArray[3*triOffset+l] = x[l]\n          }\n          for(var l=0; l<4; ++l) {\n            colorArray[4*triOffset+l] = color[l]\n          }\n          idArray[triOffset] = pickCounter\n          var p = verts[cell[k]]\n          glyphArray[2*triOffset]   = size * (cos*p[0] - sin*p[1] + textOffset[0])\n          glyphArray[2*triOffset+1] = size * (sin*p[0] + cos*p[1] + textOffset[1])\n          triOffset += 1\n        }\n      }\n\n      var cells = glyphLines.edges\n      var verts = glyphLines.positions\n\n      for(var j=0; j<cells.length; ++j) {\n        var cell = cells[j]\n        for(var k=0; k<2; ++k) {\n          for(var l=0; l<3; ++l) {\n            positionArray[3*lineOffset+l] = x[l]\n          }\n          for(var l=0; l<4; ++l) {\n            colorArray[4*lineOffset+l] = lineColor[l]\n          }\n          idArray[lineOffset] = pickCounter\n          var p = verts[cell[k]]\n          glyphArray[2*lineOffset]   = size * (cos*p[0] - sin*p[1] + textOffset[0])\n          glyphArray[2*lineOffset+1] = size * (sin*p[0] + cos*p[1] + textOffset[1])\n          lineOffset += 1\n        }\n      }\n\n    }\n\n\n\n  }\n\n  //Update bounds\n  this.bounds = [lowerBound, upperBound]\n\n  //Save points\n  this.points = points\n\n  //Save number of points\n  this.pointCount = points.length\n\n  //Update vertex counts\n  this.vertexCount      = triVertexCount\n  this.lineVertexCount  = lineVertexCount\n\n  this.pointBuffer.update(positionArray)\n  this.colorBuffer.update(colorArray)\n  this.glyphBuffer.update(glyphArray)\n  //this.idBuffer.update(new Uint32Array(idArray))\n  this.idBuffer.update(idArray)\n\n  pool.free(positionArray)\n  pool.free(colorArray)\n  pool.free(glyphArray)\n  pool.free(idArray)\n}\n\nproto.dispose = function() {\n  //Shaders\n  this.shader.dispose()\n  this.orthoShader.dispose()\n  this.pickPerspectiveShader.dispose()\n  this.pickOrthoShader.dispose()\n\n  //Vertex array\n  this.vao.dispose()\n\n  //Buffers\n  this.pointBuffer.dispose()\n  this.colorBuffer.dispose()\n  this.glyphBuffer.dispose()\n  this.idBuffer.dispose()\n}\n\nfunction createPointCloud(options) {\n  var gl = options.gl\n\n  var shader                = shaders.createPerspective(gl)\n  var orthoShader           = shaders.createOrtho(gl)\n  var projectShader         = shaders.createProject(gl)\n  var pickPerspectiveShader = shaders.createPickPerspective(gl)\n  var pickOrthoShader       = shaders.createPickOrtho(gl)\n  var pickProjectShader     = shaders.createPickProject(gl)\n\n  var pointBuffer = createBuffer(gl)\n  var colorBuffer = createBuffer(gl)\n  var glyphBuffer = createBuffer(gl)\n  var idBuffer    = createBuffer(gl)\n  var vao = createVAO(gl, [\n    {\n      buffer: pointBuffer,\n      size: 3,\n      type: gl.FLOAT\n    },\n    {\n      buffer: colorBuffer,\n      size: 4,\n      type: gl.FLOAT\n    },\n    {\n      buffer: glyphBuffer,\n      size: 2,\n      type: gl.FLOAT\n    },\n    {\n      buffer: idBuffer,\n      size: 4,\n      type: gl.UNSIGNED_BYTE,\n      normalized: true\n    }\n  ])\n\n  var pointCloud = new PointCloud(\n    gl,\n    shader,\n    orthoShader,\n    projectShader,\n    pointBuffer,\n    colorBuffer,\n    glyphBuffer,\n    idBuffer,\n    vao,\n    pickPerspectiveShader,\n    pickOrthoShader,\n    pickProjectShader)\n\n  pointCloud.update(options)\n\n  return pointCloud\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}