{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\nmodule.exports = function (carpet, carpetcd, a, b) {\n  var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n  var p0, p1, v0, v1, start, end, range;\n  var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n  var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n  var smoothing = ax.smoothing;\n  var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n  var pt = axis === 'a' ? a : b;\n  var iso = axis === 'a' ? b : a;\n  var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n  var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n  var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n  var xy = axis === 'a' ? function (value) {\n    return carpet.evalxy([], value, isoIdx);\n  } : function (value) {\n    return carpet.evalxy([], isoIdx, value);\n  };\n  if (smoothing) {\n    tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n    tanIsoPar = isoIdx - tanIsoIdx;\n    tangent = axis === 'a' ? function (i, ti) {\n      return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n    } : function (j, tj) {\n      return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n    };\n  }\n  var vstart = toIdx(pt[0]);\n  var vend = toIdx(pt[1]);\n\n  // So that we can make this work in two directions, flip all of the\n  // math functions if the direction is from higher to lower indices:\n  //\n  // Note that the tolerance is directional!\n  var dir = vstart < vend ? 1 : -1;\n  var tol = (vend - vstart) * 1e-8;\n  var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n  var dirceil = dir > 0 ? Math.ceil : Math.floor;\n  var dirmin = dir > 0 ? Math.min : Math.max;\n  var dirmax = dir > 0 ? Math.max : Math.min;\n  var idx0 = dirfloor(vstart + tol);\n  var idx1 = dirceil(vend - tol);\n  p0 = xy(vstart);\n  var segments = [[p0]];\n  for (idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n    segment = [];\n    start = dirmax(vstart, idx);\n    end = dirmin(vend, idx + dir);\n    range = end - start;\n\n    // In order to figure out which cell we're in for the derivative (remember,\n    // the derivatives are *not* constant across grid lines), let's just average\n    // the start and end points. This cuts out just a tiny bit of logic and\n    // there's really no computational difference:\n    refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n    p1 = xy(end);\n    if (smoothing) {\n      v0 = tangent(refidx, start - refidx);\n      v1 = tangent(refidx, end - refidx);\n      segment.push([p0[0] + v0[0] / 3 * range, p0[1] + v0[1] / 3 * range]);\n      segment.push([p1[0] - v1[0] / 3 * range, p1[1] - v1[1] / 3 * range]);\n    }\n    segment.push(p1);\n    segments.push(segment);\n    p0 = p1;\n  }\n  return segments;\n};","map":{"version":3,"names":["isArrayOrTypedArray","require","module","exports","carpet","carpetcd","a","b","idx","tangent","tanIsoIdx","tanIsoPar","segment","refidx","p0","p1","v0","v1","start","end","range","axis","ax","aaxis","baxis","smoothing","toIdx","a2i","b2j","pt","iso","n","length","m","isoIdx","Math","floor","xy","value","evalxy","max","min","i","ti","dxydi","j","tj","dxydj","vstart","vend","dir","tol","dirfloor","ceil","dirceil","dirmin","dirmax","idx0","idx1","segments","push"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/carpet/axis_aligned_line.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\n\n/* This function retrns a set of control points that define a curve aligned along\n * either the a or b axis. Exactly one of a or b must be an array defining the range\n * spanned.\n *\n * Honestly this is the most complicated function I've implemente here so far because\n * of the way it handles knot insertion and direction/axis-agnostic slices.\n */\nmodule.exports = function(carpet, carpetcd, a, b) {\n    var idx, tangent, tanIsoIdx, tanIsoPar, segment, refidx;\n    var p0, p1, v0, v1, start, end, range;\n\n    var axis = isArrayOrTypedArray(a) ? 'a' : 'b';\n    var ax = axis === 'a' ? carpet.aaxis : carpet.baxis;\n    var smoothing = ax.smoothing;\n    var toIdx = axis === 'a' ? carpet.a2i : carpet.b2j;\n    var pt = axis === 'a' ? a : b;\n    var iso = axis === 'a' ? b : a;\n    var n = axis === 'a' ? carpetcd.a.length : carpetcd.b.length;\n    var m = axis === 'a' ? carpetcd.b.length : carpetcd.a.length;\n    var isoIdx = Math.floor(axis === 'a' ? carpet.b2j(iso) : carpet.a2i(iso));\n\n    var xy = axis === 'a' ? function(value) {\n        return carpet.evalxy([], value, isoIdx);\n    } : function(value) {\n        return carpet.evalxy([], isoIdx, value);\n    };\n\n    if(smoothing) {\n        tanIsoIdx = Math.max(0, Math.min(m - 2, isoIdx));\n        tanIsoPar = isoIdx - tanIsoIdx;\n        tangent = axis === 'a' ? function(i, ti) {\n            return carpet.dxydi([], i, tanIsoIdx, ti, tanIsoPar);\n        } : function(j, tj) {\n            return carpet.dxydj([], tanIsoIdx, j, tanIsoPar, tj);\n        };\n    }\n\n    var vstart = toIdx(pt[0]);\n    var vend = toIdx(pt[1]);\n\n    // So that we can make this work in two directions, flip all of the\n    // math functions if the direction is from higher to lower indices:\n    //\n    // Note that the tolerance is directional!\n    var dir = vstart < vend ? 1 : -1;\n    var tol = (vend - vstart) * 1e-8;\n    var dirfloor = dir > 0 ? Math.floor : Math.ceil;\n    var dirceil = dir > 0 ? Math.ceil : Math.floor;\n    var dirmin = dir > 0 ? Math.min : Math.max;\n    var dirmax = dir > 0 ? Math.max : Math.min;\n\n    var idx0 = dirfloor(vstart + tol);\n    var idx1 = dirceil(vend - tol);\n\n    p0 = xy(vstart);\n    var segments = [[p0]];\n\n    for(idx = idx0; idx * dir < idx1 * dir; idx += dir) {\n        segment = [];\n        start = dirmax(vstart, idx);\n        end = dirmin(vend, idx + dir);\n        range = end - start;\n\n        // In order to figure out which cell we're in for the derivative (remember,\n        // the derivatives are *not* constant across grid lines), let's just average\n        // the start and end points. This cuts out just a tiny bit of logic and\n        // there's really no computational difference:\n        refidx = Math.max(0, Math.min(n - 2, Math.floor(0.5 * (start + end))));\n\n        p1 = xy(end);\n        if(smoothing) {\n            v0 = tangent(refidx, start - refidx);\n            v1 = tangent(refidx, end - refidx);\n\n            segment.push([\n                p0[0] + v0[0] / 3 * range,\n                p0[1] + v0[1] / 3 * range\n            ]);\n\n            segment.push([\n                p1[0] - v1[0] / 3 * range,\n                p1[1] - v1[1] / 3 * range\n            ]);\n        }\n\n        segment.push(p1);\n\n        segments.push(segment);\n        p0 = p1;\n    }\n\n    return segments;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}