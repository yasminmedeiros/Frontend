{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function (gd, container, commandList, onchange) {\n  var ret = {};\n  var enabled = true;\n  if (container && container._commandObserver) {\n    ret = container._commandObserver;\n  }\n  if (!ret.cache) {\n    ret.cache = {};\n  }\n\n  // Either create or just recompute this:\n  ret.lookupTable = {};\n  var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n  if (container && container._commandObserver) {\n    if (!binding) {\n      // If container exists and there are no longer any bindings,\n      // remove existing:\n      if (container._commandObserver.remove) {\n        container._commandObserver.remove();\n        container._commandObserver = null;\n        return ret;\n      }\n    } else {\n      // If container exists and there *are* bindings, then the lookup\n      // table should have been updated and check is already attached,\n      // so there's nothing to be done:\n      return ret;\n    }\n  }\n\n  // Determine whether there's anything to do for this binding:\n\n  if (binding) {\n    // Build the cache:\n    bindingValueHasChanged(gd, binding, ret.cache);\n    ret.check = function check() {\n      if (!enabled) return;\n      var update = bindingValueHasChanged(gd, binding, ret.cache);\n      if (update.changed && onchange) {\n        // Disable checks for the duration of this command in order to avoid\n        // infinite loops:\n        if (ret.lookupTable[update.value] !== undefined) {\n          ret.disable();\n          Promise.resolve(onchange({\n            value: update.value,\n            type: binding.type,\n            prop: binding.prop,\n            traces: binding.traces,\n            index: ret.lookupTable[update.value]\n          })).then(ret.enable, ret.enable);\n        }\n      }\n      return update.changed;\n    };\n    var checkEvents = ['plotly_relayout', 'plotly_redraw', 'plotly_restyle', 'plotly_update', 'plotly_animatingframe', 'plotly_afterplot'];\n    for (var i = 0; i < checkEvents.length; i++) {\n      gd._internalOn(checkEvents[i], ret.check);\n    }\n    ret.remove = function () {\n      for (var i = 0; i < checkEvents.length; i++) {\n        gd._removeInternalListener(checkEvents[i], ret.check);\n      }\n    };\n  } else {\n    // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n    // is a start\n    Lib.log('Unable to automatically bind plot updates to API command');\n    ret.lookupTable = {};\n    ret.remove = function () {};\n  }\n  ret.disable = function disable() {\n    enabled = false;\n  };\n  ret.enable = function enable() {\n    enabled = true;\n  };\n  if (container) {\n    container._commandObserver = ret;\n  }\n  return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function (gd, commandList, bindingsByValue) {\n  var i;\n  var n = commandList.length;\n  var refBinding;\n  for (i = 0; i < n; i++) {\n    var binding;\n    var command = commandList[i];\n    var method = command.method;\n    var args = command.args;\n    if (!Array.isArray(args)) args = [];\n\n    // If any command has no method, refuse to bind:\n    if (!method) {\n      return false;\n    }\n    var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n    // Right now, handle one and *only* one property being set:\n    if (bindings.length !== 1) {\n      return false;\n    }\n    if (!refBinding) {\n      refBinding = bindings[0];\n      if (Array.isArray(refBinding.traces)) {\n        refBinding.traces.sort();\n      }\n    } else {\n      binding = bindings[0];\n      if (binding.type !== refBinding.type) {\n        return false;\n      }\n      if (binding.prop !== refBinding.prop) {\n        return false;\n      }\n      if (Array.isArray(refBinding.traces)) {\n        if (Array.isArray(binding.traces)) {\n          binding.traces.sort();\n          for (var j = 0; j < refBinding.traces.length; j++) {\n            if (refBinding.traces[j] !== binding.traces[j]) {\n              return false;\n            }\n          }\n        } else {\n          return false;\n        }\n      } else {\n        if (binding.prop !== refBinding.prop) {\n          return false;\n        }\n      }\n    }\n    binding = bindings[0];\n    var value = binding.value;\n    if (Array.isArray(value)) {\n      if (value.length === 1) {\n        value = value[0];\n      } else {\n        return false;\n      }\n    }\n    if (bindingsByValue) {\n      bindingsByValue[value] = i;\n    }\n  }\n  return refBinding;\n};\nfunction bindingValueHasChanged(gd, binding, cache) {\n  var container, value, obj;\n  var changed = false;\n  if (binding.type === 'data') {\n    // If it's data, we need to get a trace. Based on the limited scope\n    // of what we cover, we can just take the first trace from the list,\n    // or otherwise just the first trace:\n    container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n  } else if (binding.type === 'layout') {\n    container = gd._fullLayout;\n  } else {\n    return false;\n  }\n  value = Lib.nestedProperty(container, binding.prop).get();\n  obj = cache[binding.type] = cache[binding.type] || {};\n  if (obj.hasOwnProperty(binding.prop)) {\n    if (obj[binding.prop] !== value) {\n      changed = true;\n    }\n  }\n  obj[binding.prop] = value;\n  return {\n    changed: changed,\n    value: value\n  };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function (gd, method, args) {\n  if (method === 'skip') return Promise.resolve();\n  var _method = Registry.apiMethodRegistry[method];\n  var allArgs = [gd];\n  if (!Array.isArray(args)) args = [];\n  for (var i = 0; i < args.length; i++) {\n    allArgs.push(args[i]);\n  }\n  return _method.apply(null, allArgs).catch(function (err) {\n    Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n    return Promise.reject(err);\n  });\n};\nexports.computeAPICommandBindings = function (gd, method, args) {\n  var bindings;\n  if (!Array.isArray(args)) args = [];\n  switch (method) {\n    case 'restyle':\n      bindings = computeDataBindings(gd, args);\n      break;\n    case 'relayout':\n      bindings = computeLayoutBindings(gd, args);\n      break;\n    case 'update':\n      bindings = computeDataBindings(gd, [args[0], args[2]]).concat(computeLayoutBindings(gd, [args[1]]));\n      break;\n    case 'animate':\n      bindings = computeAnimateBindings(gd, args);\n      break;\n    default:\n      // This is the case where intelligent logic about what affects\n      // this command is not implemented. It causes no ill effects.\n      // For example, addFrames simply won't bind to a control component.\n      bindings = [];\n  }\n  return bindings;\n};\nfunction computeAnimateBindings(gd, args) {\n  // We'll assume that the only relevant modification an animation\n  // makes that's meaningfully tracked is the frame:\n  if (Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n    return [{\n      type: 'layout',\n      prop: '_currentFrame',\n      value: args[0][0].toString()\n    }];\n  } else {\n    return [];\n  }\n}\nfunction computeLayoutBindings(gd, args) {\n  var bindings = [];\n  var astr = args[0];\n  var aobj = {};\n  if (typeof astr === 'string') {\n    aobj[astr] = args[1];\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = astr;\n  } else {\n    return bindings;\n  }\n  crawl(aobj, function (path, attrName, attr) {\n    bindings.push({\n      type: 'layout',\n      prop: path,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\nfunction computeDataBindings(gd, args) {\n  var traces, astr, val, aobj;\n  var bindings = [];\n\n  // Logic copied from Plotly.restyle:\n  astr = args[0];\n  val = args[1];\n  traces = args[2];\n  aobj = {};\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = astr;\n    if (traces === undefined) {\n      traces = val;\n    }\n  } else {\n    return bindings;\n  }\n  if (traces === undefined) {\n    // Explicitly assign this to null instead of undefined:\n    traces = null;\n  }\n  crawl(aobj, function (path, attrName, attr) {\n    var thisTraces;\n    if (Array.isArray(attr)) {\n      var nAttr = Math.min(attr.length, gd.data.length);\n      if (traces) {\n        nAttr = Math.min(nAttr, traces.length);\n      }\n      thisTraces = [];\n      for (var j = 0; j < nAttr; j++) {\n        thisTraces[j] = traces ? traces[j] : j;\n      }\n    } else {\n      thisTraces = traces ? traces.slice(0) : null;\n    }\n\n    // Convert [7] to just 7 when traces is null:\n    if (thisTraces === null) {\n      if (Array.isArray(attr)) {\n        attr = attr[0];\n      }\n    } else if (Array.isArray(thisTraces)) {\n      if (!Array.isArray(attr)) {\n        var tmp = attr;\n        attr = [];\n        for (var i = 0; i < thisTraces.length; i++) {\n          attr[i] = tmp;\n        }\n      }\n      attr.length = Math.min(thisTraces.length, attr.length);\n    }\n    bindings.push({\n      type: 'data',\n      prop: path,\n      traces: thisTraces,\n      value: attr\n    });\n  }, '', 0);\n  return bindings;\n}\nfunction crawl(attrs, callback, path, depth) {\n  Object.keys(attrs).forEach(function (attrName) {\n    var attr = attrs[attrName];\n    if (attrName[0] === '_') return;\n    var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n    if (Lib.isPlainObject(attr)) {\n      crawl(attr, callback, thisPath, depth + 1);\n    } else {\n      // Only execute the callback on leaf nodes:\n      callback(thisPath, attrName, attr);\n    }\n  });\n}","map":{"version":3,"names":["Registry","require","Lib","exports","manageCommandObserver","gd","container","commandList","onchange","ret","enabled","_commandObserver","cache","lookupTable","binding","hasSimpleAPICommandBindings","remove","bindingValueHasChanged","check","update","changed","value","undefined","disable","Promise","resolve","type","prop","traces","index","then","enable","checkEvents","i","length","_internalOn","_removeInternalListener","log","bindingsByValue","n","refBinding","command","method","args","Array","isArray","bindings","computeAPICommandBindings","sort","j","obj","_fullData","_fullLayout","nestedProperty","get","hasOwnProperty","executeAPICommand","_method","apiMethodRegistry","allArgs","push","apply","catch","err","warn","reject","computeDataBindings","computeLayoutBindings","concat","computeAnimateBindings","indexOf","toString","astr","aobj","isPlainObject","crawl","path","attrName","attr","val","thisTraces","nAttr","Math","min","data","slice","tmp","attrs","callback","depth","Object","keys","forEach","thisPath"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/plots/command.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../registry');\nvar Lib = require('../lib');\n\n/*\n * Create or update an observer. This function is designed to be\n * idempotent so that it can be called over and over as the component\n * updates, and will attach and detach listeners as needed.\n *\n * @param {optional object} container\n *      An object on which the observer is stored. This is the mechanism\n *      by which it is idempotent. If it already exists, another won't be\n *      added. Each time it's called, the value lookup table is updated.\n * @param {array} commandList\n *      An array of commands, following either `buttons` of `updatemenus`\n *      or `steps` of `sliders`.\n * @param {function} onchange\n *      A listener called when the value is changed. Receives data object\n *      with information about the new state.\n */\nexports.manageCommandObserver = function(gd, container, commandList, onchange) {\n    var ret = {};\n    var enabled = true;\n\n    if(container && container._commandObserver) {\n        ret = container._commandObserver;\n    }\n\n    if(!ret.cache) {\n        ret.cache = {};\n    }\n\n    // Either create or just recompute this:\n    ret.lookupTable = {};\n\n    var binding = exports.hasSimpleAPICommandBindings(gd, commandList, ret.lookupTable);\n\n    if(container && container._commandObserver) {\n        if(!binding) {\n            // If container exists and there are no longer any bindings,\n            // remove existing:\n            if(container._commandObserver.remove) {\n                container._commandObserver.remove();\n                container._commandObserver = null;\n                return ret;\n            }\n        } else {\n            // If container exists and there *are* bindings, then the lookup\n            // table should have been updated and check is already attached,\n            // so there's nothing to be done:\n            return ret;\n\n\n        }\n    }\n\n    // Determine whether there's anything to do for this binding:\n\n    if(binding) {\n        // Build the cache:\n        bindingValueHasChanged(gd, binding, ret.cache);\n\n        ret.check = function check() {\n            if(!enabled) return;\n\n            var update = bindingValueHasChanged(gd, binding, ret.cache);\n\n            if(update.changed && onchange) {\n                // Disable checks for the duration of this command in order to avoid\n                // infinite loops:\n                if(ret.lookupTable[update.value] !== undefined) {\n                    ret.disable();\n                    Promise.resolve(onchange({\n                        value: update.value,\n                        type: binding.type,\n                        prop: binding.prop,\n                        traces: binding.traces,\n                        index: ret.lookupTable[update.value]\n                    })).then(ret.enable, ret.enable);\n                }\n            }\n\n            return update.changed;\n        };\n\n        var checkEvents = [\n            'plotly_relayout',\n            'plotly_redraw',\n            'plotly_restyle',\n            'plotly_update',\n            'plotly_animatingframe',\n            'plotly_afterplot'\n        ];\n\n        for(var i = 0; i < checkEvents.length; i++) {\n            gd._internalOn(checkEvents[i], ret.check);\n        }\n\n        ret.remove = function() {\n            for(var i = 0; i < checkEvents.length; i++) {\n                gd._removeInternalListener(checkEvents[i], ret.check);\n            }\n        };\n    } else {\n        // TODO: It'd be really neat to actually give a *reason* for this, but at least a warning\n        // is a start\n        Lib.log('Unable to automatically bind plot updates to API command');\n\n        ret.lookupTable = {};\n        ret.remove = function() {};\n    }\n\n    ret.disable = function disable() {\n        enabled = false;\n    };\n\n    ret.enable = function enable() {\n        enabled = true;\n    };\n\n    if(container) {\n        container._commandObserver = ret;\n    }\n\n    return ret;\n};\n\n/*\n * This function checks to see if an array of objects containing\n * method and args properties is compatible with automatic two-way\n * binding. The criteria right now are that\n *\n *   1. multiple traces may be affected\n *   2. only one property may be affected\n *   3. the same property must be affected by all commands\n */\nexports.hasSimpleAPICommandBindings = function(gd, commandList, bindingsByValue) {\n    var i;\n    var n = commandList.length;\n\n    var refBinding;\n\n    for(i = 0; i < n; i++) {\n        var binding;\n        var command = commandList[i];\n        var method = command.method;\n        var args = command.args;\n\n        if(!Array.isArray(args)) args = [];\n\n        // If any command has no method, refuse to bind:\n        if(!method) {\n            return false;\n        }\n        var bindings = exports.computeAPICommandBindings(gd, method, args);\n\n        // Right now, handle one and *only* one property being set:\n        if(bindings.length !== 1) {\n            return false;\n        }\n\n        if(!refBinding) {\n            refBinding = bindings[0];\n            if(Array.isArray(refBinding.traces)) {\n                refBinding.traces.sort();\n            }\n        } else {\n            binding = bindings[0];\n            if(binding.type !== refBinding.type) {\n                return false;\n            }\n            if(binding.prop !== refBinding.prop) {\n                return false;\n            }\n            if(Array.isArray(refBinding.traces)) {\n                if(Array.isArray(binding.traces)) {\n                    binding.traces.sort();\n                    for(var j = 0; j < refBinding.traces.length; j++) {\n                        if(refBinding.traces[j] !== binding.traces[j]) {\n                            return false;\n                        }\n                    }\n                } else {\n                    return false;\n                }\n            } else {\n                if(binding.prop !== refBinding.prop) {\n                    return false;\n                }\n            }\n        }\n\n        binding = bindings[0];\n        var value = binding.value;\n        if(Array.isArray(value)) {\n            if(value.length === 1) {\n                value = value[0];\n            } else {\n                return false;\n            }\n        }\n        if(bindingsByValue) {\n            bindingsByValue[value] = i;\n        }\n    }\n\n    return refBinding;\n};\n\nfunction bindingValueHasChanged(gd, binding, cache) {\n    var container, value, obj;\n    var changed = false;\n\n    if(binding.type === 'data') {\n        // If it's data, we need to get a trace. Based on the limited scope\n        // of what we cover, we can just take the first trace from the list,\n        // or otherwise just the first trace:\n        container = gd._fullData[binding.traces !== null ? binding.traces[0] : 0];\n    } else if(binding.type === 'layout') {\n        container = gd._fullLayout;\n    } else {\n        return false;\n    }\n\n    value = Lib.nestedProperty(container, binding.prop).get();\n\n    obj = cache[binding.type] = cache[binding.type] || {};\n\n    if(obj.hasOwnProperty(binding.prop)) {\n        if(obj[binding.prop] !== value) {\n            changed = true;\n        }\n    }\n\n    obj[binding.prop] = value;\n\n    return {\n        changed: changed,\n        value: value\n    };\n}\n\n/*\n * Execute an API command. There's really not much to this; it just provides\n * a common hook so that implementations don't need to be synchronized across\n * multiple components with the ability to invoke API commands.\n *\n * @param {string} method\n *      The name of the plotly command to execute. Must be one of 'animate',\n *      'restyle', 'relayout', 'update'.\n * @param {array} args\n *      A list of arguments passed to the API command\n */\nexports.executeAPICommand = function(gd, method, args) {\n    if(method === 'skip') return Promise.resolve();\n\n    var _method = Registry.apiMethodRegistry[method];\n    var allArgs = [gd];\n    if(!Array.isArray(args)) args = [];\n\n    for(var i = 0; i < args.length; i++) {\n        allArgs.push(args[i]);\n    }\n\n    return _method.apply(null, allArgs).catch(function(err) {\n        Lib.warn('API call to Plotly.' + method + ' rejected.', err);\n        return Promise.reject(err);\n    });\n};\n\nexports.computeAPICommandBindings = function(gd, method, args) {\n    var bindings;\n\n    if(!Array.isArray(args)) args = [];\n\n    switch(method) {\n        case 'restyle':\n            bindings = computeDataBindings(gd, args);\n            break;\n        case 'relayout':\n            bindings = computeLayoutBindings(gd, args);\n            break;\n        case 'update':\n            bindings = computeDataBindings(gd, [args[0], args[2]])\n                .concat(computeLayoutBindings(gd, [args[1]]));\n            break;\n        case 'animate':\n            bindings = computeAnimateBindings(gd, args);\n            break;\n        default:\n            // This is the case where intelligent logic about what affects\n            // this command is not implemented. It causes no ill effects.\n            // For example, addFrames simply won't bind to a control component.\n            bindings = [];\n    }\n    return bindings;\n};\n\nfunction computeAnimateBindings(gd, args) {\n    // We'll assume that the only relevant modification an animation\n    // makes that's meaningfully tracked is the frame:\n    if(Array.isArray(args[0]) && args[0].length === 1 && ['string', 'number'].indexOf(typeof args[0][0]) !== -1) {\n        return [{type: 'layout', prop: '_currentFrame', value: args[0][0].toString()}];\n    } else {\n        return [];\n    }\n}\n\nfunction computeLayoutBindings(gd, args) {\n    var bindings = [];\n\n    var astr = args[0];\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = args[1];\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = astr;\n    } else {\n        return bindings;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        bindings.push({type: 'layout', prop: path, value: attr});\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction computeDataBindings(gd, args) {\n    var traces, astr, val, aobj;\n    var bindings = [];\n\n    // Logic copied from Plotly.restyle:\n    astr = args[0];\n    val = args[1];\n    traces = args[2];\n    aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = astr;\n\n        if(traces === undefined) {\n            traces = val;\n        }\n    } else {\n        return bindings;\n    }\n\n    if(traces === undefined) {\n        // Explicitly assign this to null instead of undefined:\n        traces = null;\n    }\n\n    crawl(aobj, function(path, attrName, attr) {\n        var thisTraces;\n        if(Array.isArray(attr)) {\n            var nAttr = Math.min(attr.length, gd.data.length);\n            if(traces) {\n                nAttr = Math.min(nAttr, traces.length);\n            }\n            thisTraces = [];\n            for(var j = 0; j < nAttr; j++) {\n                thisTraces[j] = traces ? traces[j] : j;\n            }\n        } else {\n            thisTraces = traces ? traces.slice(0) : null;\n        }\n\n        // Convert [7] to just 7 when traces is null:\n        if(thisTraces === null) {\n            if(Array.isArray(attr)) {\n                attr = attr[0];\n            }\n        } else if(Array.isArray(thisTraces)) {\n            if(!Array.isArray(attr)) {\n                var tmp = attr;\n                attr = [];\n                for(var i = 0; i < thisTraces.length; i++) {\n                    attr[i] = tmp;\n                }\n            }\n            attr.length = Math.min(thisTraces.length, attr.length);\n        }\n\n        bindings.push({\n            type: 'data',\n            prop: path,\n            traces: thisTraces,\n            value: attr\n        });\n    }, '', 0);\n\n    return bindings;\n}\n\nfunction crawl(attrs, callback, path, depth) {\n    Object.keys(attrs).forEach(function(attrName) {\n        var attr = attrs[attrName];\n\n        if(attrName[0] === '_') return;\n\n        var thisPath = path + (depth > 0 ? '.' : '') + attrName;\n\n        if(Lib.isPlainObject(attr)) {\n            crawl(attr, callback, thisPath, depth + 1);\n        } else {\n            // Only execute the callback on leaf nodes:\n            callback(thisPath, attrName, attr);\n        }\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}