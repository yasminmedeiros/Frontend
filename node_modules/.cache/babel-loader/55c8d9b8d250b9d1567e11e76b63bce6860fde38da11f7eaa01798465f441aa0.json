{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar numConstants = require('../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\nvar lib = module.exports = {};\nlib.nestedProperty = require('./nested_property');\nlib.keyedContainer = require('./keyed_container');\nlib.relativeAttr = require('./relative_attr');\nlib.isPlainObject = require('./is_plain_object');\nlib.toLogRange = require('./to_log_range');\nlib.relinkPrivateKeys = require('./relink_private');\nvar arrayModule = require('./array');\nlib.isTypedArray = arrayModule.isTypedArray;\nlib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;\nlib.isArray1D = arrayModule.isArray1D;\nlib.ensureArray = arrayModule.ensureArray;\nlib.concat = arrayModule.concat;\nlib.maxRowLength = arrayModule.maxRowLength;\nlib.minRowLength = arrayModule.minRowLength;\nvar modModule = require('./mod');\nlib.mod = modModule.mod;\nlib.modHalf = modModule.modHalf;\nvar coerceModule = require('./coerce');\nlib.valObjectMeta = coerceModule.valObjectMeta;\nlib.coerce = coerceModule.coerce;\nlib.coerce2 = coerceModule.coerce2;\nlib.coerceFont = coerceModule.coerceFont;\nlib.coerceHoverinfo = coerceModule.coerceHoverinfo;\nlib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;\nlib.validate = coerceModule.validate;\nvar datesModule = require('./dates');\nlib.dateTime2ms = datesModule.dateTime2ms;\nlib.isDateTime = datesModule.isDateTime;\nlib.ms2DateTime = datesModule.ms2DateTime;\nlib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;\nlib.cleanDate = datesModule.cleanDate;\nlib.isJSDate = datesModule.isJSDate;\nlib.formatDate = datesModule.formatDate;\nlib.incrementMonth = datesModule.incrementMonth;\nlib.dateTick0 = datesModule.dateTick0;\nlib.dfltRange = datesModule.dfltRange;\nlib.findExactDates = datesModule.findExactDates;\nlib.MIN_MS = datesModule.MIN_MS;\nlib.MAX_MS = datesModule.MAX_MS;\nvar searchModule = require('./search');\nlib.findBin = searchModule.findBin;\nlib.sorterAsc = searchModule.sorterAsc;\nlib.sorterDes = searchModule.sorterDes;\nlib.distinctVals = searchModule.distinctVals;\nlib.roundUp = searchModule.roundUp;\nlib.sort = searchModule.sort;\nlib.findIndexOfMin = searchModule.findIndexOfMin;\nvar statsModule = require('./stats');\nlib.aggNums = statsModule.aggNums;\nlib.len = statsModule.len;\nlib.mean = statsModule.mean;\nlib.midRange = statsModule.midRange;\nlib.variance = statsModule.variance;\nlib.stdev = statsModule.stdev;\nlib.interp = statsModule.interp;\nvar matrixModule = require('./matrix');\nlib.init2dArray = matrixModule.init2dArray;\nlib.transposeRagged = matrixModule.transposeRagged;\nlib.dot = matrixModule.dot;\nlib.translationMatrix = matrixModule.translationMatrix;\nlib.rotationMatrix = matrixModule.rotationMatrix;\nlib.rotationXYMatrix = matrixModule.rotationXYMatrix;\nlib.apply2DTransform = matrixModule.apply2DTransform;\nlib.apply2DTransform2 = matrixModule.apply2DTransform2;\nvar anglesModule = require('./angles');\nlib.deg2rad = anglesModule.deg2rad;\nlib.rad2deg = anglesModule.rad2deg;\nlib.angleDelta = anglesModule.angleDelta;\nlib.angleDist = anglesModule.angleDist;\nlib.isFullCircle = anglesModule.isFullCircle;\nlib.isAngleInsideSector = anglesModule.isAngleInsideSector;\nlib.isPtInsideSector = anglesModule.isPtInsideSector;\nlib.pathArc = anglesModule.pathArc;\nlib.pathSector = anglesModule.pathSector;\nlib.pathAnnulus = anglesModule.pathAnnulus;\nvar anchorUtils = require('./anchor_utils');\nlib.isLeftAnchor = anchorUtils.isLeftAnchor;\nlib.isCenterAnchor = anchorUtils.isCenterAnchor;\nlib.isRightAnchor = anchorUtils.isRightAnchor;\nlib.isTopAnchor = anchorUtils.isTopAnchor;\nlib.isMiddleAnchor = anchorUtils.isMiddleAnchor;\nlib.isBottomAnchor = anchorUtils.isBottomAnchor;\nvar geom2dModule = require('./geometry2d');\nlib.segmentsIntersect = geom2dModule.segmentsIntersect;\nlib.segmentDistance = geom2dModule.segmentDistance;\nlib.getTextLocation = geom2dModule.getTextLocation;\nlib.clearLocationCache = geom2dModule.clearLocationCache;\nlib.getVisibleSegment = geom2dModule.getVisibleSegment;\nlib.findPointOnPath = geom2dModule.findPointOnPath;\nvar extendModule = require('./extend');\nlib.extendFlat = extendModule.extendFlat;\nlib.extendDeep = extendModule.extendDeep;\nlib.extendDeepAll = extendModule.extendDeepAll;\nlib.extendDeepNoArrays = extendModule.extendDeepNoArrays;\nvar loggersModule = require('./loggers');\nlib.log = loggersModule.log;\nlib.warn = loggersModule.warn;\nlib.error = loggersModule.error;\nvar regexModule = require('./regex');\nlib.counterRegex = regexModule.counter;\nvar throttleModule = require('./throttle');\nlib.throttle = throttleModule.throttle;\nlib.throttleDone = throttleModule.done;\nlib.clearThrottle = throttleModule.clear;\nlib.getGraphDiv = require('./get_graph_div');\nlib.clearResponsive = require('./clear_responsive');\nlib.makeTraceGroups = require('./make_trace_groups');\nlib._ = require('./localize');\nlib.notifier = require('./notifier');\nlib.filterUnique = require('./filter_unique');\nlib.filterVisible = require('./filter_visible');\nlib.pushUnique = require('./push_unique');\nlib.cleanNumber = require('./clean_number');\nlib.ensureNumber = function num(v) {\n  if (!isNumeric(v)) return BADNUM;\n  v = Number(v);\n  if (v < -FP_SAFE || v > FP_SAFE) return BADNUM;\n  return isNumeric(v) ? Number(v) : BADNUM;\n};\n\n/**\n * Is v a valid array index? Accepts numeric strings as well as numbers.\n *\n * @param {any} v: the value to test\n * @param {Optional[integer]} len: the array length we are indexing\n *\n * @return {bool}: v is a valid array index\n */\nlib.isIndex = function (v, len) {\n  if (len !== undefined && v >= len) return false;\n  return isNumeric(v) && v >= 0 && v % 1 === 0;\n};\nlib.noop = require('./noop');\nlib.identity = require('./identity');\n\n/**\n * create an array of length 'cnt' filled with 'v' at all indices\n *\n * @param {any} v\n * @param {number} cnt\n * @return {array}\n */\nlib.repeat = function (v, cnt) {\n  var out = new Array(cnt);\n  for (var i = 0; i < cnt; i++) {\n    out[i] = v;\n  }\n  return out;\n};\n\n/**\n * swap x and y of the same attribute in container cont\n * specify attr with a ? in place of x/y\n * you can also swap other things than x/y by providing part1 and part2\n */\nlib.swapAttrs = function (cont, attrList, part1, part2) {\n  if (!part1) part1 = 'x';\n  if (!part2) part2 = 'y';\n  for (var i = 0; i < attrList.length; i++) {\n    var attr = attrList[i];\n    var xp = lib.nestedProperty(cont, attr.replace('?', part1));\n    var yp = lib.nestedProperty(cont, attr.replace('?', part2));\n    var temp = xp.get();\n    xp.set(yp.get());\n    yp.set(temp);\n  }\n};\n\n/**\n * SVG painter's algo worked around with reinsertion\n */\nlib.raiseToTop = function raiseToTop(elem) {\n  elem.parentNode.appendChild(elem);\n};\n\n/**\n * cancel a possibly pending transition; returned selection may be used by caller\n */\nlib.cancelTransition = function (selection) {\n  return selection.transition().duration(0);\n};\n\n// constrain - restrict a number v to be between v0 and v1\nlib.constrain = function (v, v0, v1) {\n  if (v0 > v1) return Math.max(v1, Math.min(v0, v));\n  return Math.max(v0, Math.min(v1, v));\n};\n\n/**\n * do two bounding boxes from getBoundingClientRect,\n * ie {left,right,top,bottom,width,height}, overlap?\n * takes optional padding pixels\n */\nlib.bBoxIntersect = function (a, b, pad) {\n  pad = pad || 0;\n  return a.left <= b.right + pad && b.left <= a.right + pad && a.top <= b.bottom + pad && b.top <= a.bottom + pad;\n};\n\n/*\n * simpleMap: alternative to Array.map that only\n * passes on the element and up to 2 extra args you\n * provide (but not the array index or the whole array)\n *\n * array: the array to map it to\n * func: the function to apply\n * x1, x2: optional extra args\n */\nlib.simpleMap = function (array, func, x1, x2) {\n  var len = array.length;\n  var out = new Array(len);\n  for (var i = 0; i < len; i++) {\n    out[i] = func(array[i], x1, x2);\n  }\n  return out;\n};\n\n/**\n * Random string generator\n *\n * @param {object} existing\n *     pass in strings to avoid as keys with truthy values\n * @param {int} bits\n *     bits of information in the output string, default 24\n * @param {int} base\n *     base of string representation, default 16. Should be a power of 2.\n */\nlib.randstr = function randstr(existing, bits, base, _recursion) {\n  if (!base) base = 16;\n  if (bits === undefined) bits = 24;\n  if (bits <= 0) return '0';\n  var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n  var res = '';\n  var i, b, x;\n  for (i = 2; digits === Infinity; i *= 2) {\n    digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n  }\n  var rem = digits - Math.floor(digits);\n  for (i = 0; i < Math.floor(digits); i++) {\n    x = Math.floor(Math.random() * base).toString(base);\n    res = x + res;\n  }\n  if (rem) {\n    b = Math.pow(base, rem);\n    x = Math.floor(Math.random() * b).toString(base);\n    res = x + res;\n  }\n  var parsed = parseInt(res, base);\n  if (existing && existing[res] || parsed !== Infinity && parsed >= Math.pow(2, bits)) {\n    if (_recursion > 10) {\n      lib.warn('randstr failed uniqueness');\n      return res;\n    }\n    return randstr(existing, bits, base, (_recursion || 0) + 1);\n  } else return res;\n};\nlib.OptionControl = function (opt, optname) {\n  /*\n   * An environment to contain all option setters and\n   * getters that collectively modify opts.\n   *\n   * You can call up opts from any function in new object\n   * as this.optname || this.opt\n   *\n   * See FitOpts for example of usage\n   */\n  if (!opt) opt = {};\n  if (!optname) optname = 'opt';\n  var self = {};\n  self.optionList = [];\n  self._newoption = function (optObj) {\n    optObj[optname] = opt;\n    self[optObj.name] = optObj;\n    self.optionList.push(optObj);\n  };\n  self['_' + optname] = opt;\n  return self;\n};\n\n/**\n * lib.smooth: smooth arrayIn by convolving with\n * a hann window with given full width at half max\n * bounce the ends in, so the output has the same length as the input\n */\nlib.smooth = function (arrayIn, FWHM) {\n  FWHM = Math.round(FWHM) || 0; // only makes sense for integers\n  if (FWHM < 2) return arrayIn;\n  var alen = arrayIn.length;\n  var alen2 = 2 * alen;\n  var wlen = 2 * FWHM - 1;\n  var w = new Array(wlen);\n  var arrayOut = new Array(alen);\n  var i;\n  var j;\n  var k;\n  var v;\n\n  // first make the window array\n  for (i = 0; i < wlen; i++) {\n    w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);\n  }\n\n  // now do the convolution\n  for (i = 0; i < alen; i++) {\n    v = 0;\n    for (j = 0; j < wlen; j++) {\n      k = i + j + 1 - FWHM;\n\n      // multibounce\n      if (k < -alen) k -= alen2 * Math.round(k / alen2);else if (k >= alen2) k -= alen2 * Math.floor(k / alen2);\n\n      // single bounce\n      if (k < 0) k = -1 - k;else if (k >= alen) k = alen2 - 1 - k;\n      v += arrayIn[k] * w[j];\n    }\n    arrayOut[i] = v;\n  }\n  return arrayOut;\n};\n\n/**\n * syncOrAsync: run a sequence of functions synchronously\n * as long as its returns are not promises (ie have no .then)\n * includes one argument arg to send to all functions...\n * this is mainly just to prevent us having to make wrapper functions\n * when the only purpose of the wrapper is to reference gd\n * and a final step to be executed at the end\n * TODO: if there's an error and everything is sync,\n * this doesn't happen yet because we want to make sure\n * that it gets reported\n */\nlib.syncOrAsync = function (sequence, arg, finalStep) {\n  var ret, fni;\n  function continueAsync() {\n    return lib.syncOrAsync(sequence, arg, finalStep);\n  }\n  while (sequence.length) {\n    fni = sequence.splice(0, 1)[0];\n    ret = fni(arg);\n    if (ret && ret.then) {\n      return ret.then(continueAsync).then(undefined, lib.promiseError);\n    }\n  }\n  return finalStep && finalStep(arg);\n};\n\n/**\n * Helper to strip trailing slash, from\n * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash\n */\nlib.stripTrailingSlash = function (str) {\n  if (str.substr(-1) === '/') return str.substr(0, str.length - 1);\n  return str;\n};\nlib.noneOrAll = function (containerIn, containerOut, attrList) {\n  /**\n   * some attributes come together, so if you have one of them\n   * in the input, you should copy the default values of the others\n   * to the input as well.\n   */\n  if (!containerIn) return;\n  var hasAny = false;\n  var hasAll = true;\n  var i;\n  var val;\n  for (i = 0; i < attrList.length; i++) {\n    val = containerIn[attrList[i]];\n    if (val !== undefined && val !== null) hasAny = true;else hasAll = false;\n  }\n  if (hasAny && !hasAll) {\n    for (i = 0; i < attrList.length; i++) {\n      containerIn[attrList[i]] = containerOut[attrList[i]];\n    }\n  }\n};\n\n/** merges calcdata field (given by cdAttr) with traceAttr values\n *\n * N.B. Loop over minimum of cd.length and traceAttr.length\n * i.e. it does not try to fill in beyond traceAttr.length-1\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n */\nlib.mergeArray = function (traceAttr, cd, cdAttr) {\n  if (lib.isArrayOrTypedArray(traceAttr)) {\n    var imax = Math.min(traceAttr.length, cd.length);\n    for (var i = 0; i < imax; i++) {\n      cd[i][cdAttr] = traceAttr[i];\n    }\n  }\n};\n\n/** fills calcdata field (given by cdAttr) with traceAttr values\n *  or function of traceAttr values (e.g. some fallback)\n *\n * N.B. Loops over all cd items.\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n * @param {function} [fn] : optional function to apply to each array item\n */\nlib.fillArray = function (traceAttr, cd, cdAttr, fn) {\n  fn = fn || lib.identity;\n  if (lib.isArrayOrTypedArray(traceAttr)) {\n    for (var i = 0; i < cd.length; i++) {\n      cd[i][cdAttr] = fn(traceAttr[i]);\n    }\n  }\n};\n\n/** Handler for trace-wide vs per-point options\n *\n * @param {object} trace : (full) trace object\n * @param {number} ptNumber : index of the point in question\n * @param {string} astr : attribute string\n * @param {function} [fn] : optional function to apply to each array item\n *\n * @return {any}\n */\nlib.castOption = function (trace, ptNumber, astr, fn) {\n  fn = fn || lib.identity;\n  var val = lib.nestedProperty(trace, astr).get();\n  if (lib.isArrayOrTypedArray(val)) {\n    if (Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {\n      return fn(val[ptNumber[0]][ptNumber[1]]);\n    } else {\n      return fn(val[ptNumber]);\n    }\n  } else {\n    return val;\n  }\n};\n\n/** Extract option from calcdata item, correctly falling back to\n *  trace value if not found.\n *\n *  @param {object} calcPt : calcdata[i][j] item\n *  @param {object} trace : (full) trace object\n *  @param {string} calcKey : calcdata key\n *  @param {string} traceKey : aka trace attribute string\n *  @return {any}\n */\nlib.extractOption = function (calcPt, trace, calcKey, traceKey) {\n  if (calcKey in calcPt) return calcPt[calcKey];\n\n  // fallback to trace value,\n  //   must check if value isn't itself an array\n  //   which means the trace attribute has a corresponding\n  //   calcdata key, but its value is falsy\n  var traceVal = lib.nestedProperty(trace, traceKey).get();\n  if (!Array.isArray(traceVal)) return traceVal;\n};\nfunction makePtIndex2PtNumber(indexToPoints) {\n  var ptIndex2ptNumber = {};\n  for (var k in indexToPoints) {\n    var pts = indexToPoints[k];\n    for (var j = 0; j < pts.length; j++) {\n      ptIndex2ptNumber[pts[j]] = +k;\n    }\n  }\n  return ptIndex2ptNumber;\n}\n\n/** Tag selected calcdata items\n *\n * N.B. note that point 'index' corresponds to input data array index\n *  whereas 'number' is its post-transform version.\n *\n * @param {array} calcTrace\n * @param {object} trace\n *  - selectedpoints {array}\n *  - _indexToPoints {object}\n * @param {ptNumber2cdIndex} ptNumber2cdIndex (optional)\n *  optional map object for trace types that do not have 1-to-1 point number to\n *  calcdata item index correspondence (e.g. histogram)\n */\nlib.tagSelected = function (calcTrace, trace, ptNumber2cdIndex) {\n  var selectedpoints = trace.selectedpoints;\n  var indexToPoints = trace._indexToPoints;\n  var ptIndex2ptNumber;\n\n  // make pt index-to-number map object, which takes care of transformed traces\n  if (indexToPoints) {\n    ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);\n  }\n  function isCdIndexValid(v) {\n    return v !== undefined && v < calcTrace.length;\n  }\n  for (var i = 0; i < selectedpoints.length; i++) {\n    var ptIndex = selectedpoints[i];\n    if (lib.isIndex(ptIndex)) {\n      var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;\n      var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;\n      if (isCdIndexValid(cdIndex)) {\n        calcTrace[cdIndex].selected = 1;\n      }\n    }\n  }\n};\nlib.selIndices2selPoints = function (trace) {\n  var selectedpoints = trace.selectedpoints;\n  var indexToPoints = trace._indexToPoints;\n  if (indexToPoints) {\n    var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);\n    var out = [];\n    for (var i = 0; i < selectedpoints.length; i++) {\n      var ptIndex = selectedpoints[i];\n      if (lib.isIndex(ptIndex)) {\n        var ptNumber = ptIndex2ptNumber[ptIndex];\n        if (lib.isIndex(ptNumber)) {\n          out.push(ptNumber);\n        }\n      }\n    }\n    return out;\n  } else {\n    return selectedpoints;\n  }\n};\n\n/** Returns target as set by 'target' transform attribute\n *\n * @param {object} trace : full trace object\n * @param {object} transformOpts : transform option object\n *  - target (string} :\n *      either an attribute string referencing an array in the trace object, or\n *      a set array.\n *\n * @return {array or false} : the target array (NOT a copy!!) or false if invalid\n */\nlib.getTargetArray = function (trace, transformOpts) {\n  var target = transformOpts.target;\n  if (typeof target === 'string' && target) {\n    var array = lib.nestedProperty(trace, target).get();\n    return Array.isArray(array) ? array : false;\n  } else if (Array.isArray(target)) {\n    return target;\n  }\n  return false;\n};\n\n/**\n * modified version of jQuery's extend to strip out private objs and functions,\n * and cut arrays down to first <arraylen> or 1 elements\n * because extend-like algorithms are hella slow\n * obj2 is assumed to already be clean of these things (including no arrays)\n */\nlib.minExtend = function (obj1, obj2) {\n  var objOut = {};\n  if (typeof obj2 !== 'object') obj2 = {};\n  var arrayLen = 3;\n  var keys = Object.keys(obj1);\n  var i, k, v;\n  for (i = 0; i < keys.length; i++) {\n    k = keys[i];\n    v = obj1[k];\n    if (k.charAt(0) === '_' || typeof v === 'function') continue;else if (k === 'module') objOut[k] = v;else if (Array.isArray(v)) {\n      if (k === 'colorscale') {\n        objOut[k] = v.slice();\n      } else {\n        objOut[k] = v.slice(0, arrayLen);\n      }\n    } else if (v && typeof v === 'object') objOut[k] = lib.minExtend(obj1[k], obj2[k]);else objOut[k] = v;\n  }\n  keys = Object.keys(obj2);\n  for (i = 0; i < keys.length; i++) {\n    k = keys[i];\n    v = obj2[k];\n    if (typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {\n      objOut[k] = v;\n    }\n  }\n  return objOut;\n};\nlib.titleCase = function (s) {\n  return s.charAt(0).toUpperCase() + s.substr(1);\n};\nlib.containsAny = function (s, fragments) {\n  for (var i = 0; i < fragments.length; i++) {\n    if (s.indexOf(fragments[i]) !== -1) return true;\n  }\n  return false;\n};\nlib.isPlotDiv = function (el) {\n  var el3 = d3.select(el);\n  return el3.node() instanceof HTMLElement && el3.size() && el3.classed('js-plotly-plot');\n};\nlib.removeElement = function (el) {\n  var elParent = el && el.parentNode;\n  if (elParent) elParent.removeChild(el);\n};\n\n/**\n * for dynamically adding style rules\n * makes one stylesheet that contains all rules added\n * by all calls to this function\n */\nlib.addStyleRule = function (selector, styleString) {\n  lib.addRelatedStyleRule('global', selector, styleString);\n};\n\n/**\n * for dynamically adding style rules\n * to a stylesheet uniquely identified by a uid\n */\nlib.addRelatedStyleRule = function (uid, selector, styleString) {\n  var id = 'plotly.js-style-' + uid;\n  var style = document.getElementById(id);\n  if (!style) {\n    style = document.createElement('style');\n    style.setAttribute('id', id);\n    // WebKit hack :(\n    style.appendChild(document.createTextNode(''));\n    document.head.appendChild(style);\n  }\n  var styleSheet = style.sheet;\n  if (styleSheet.insertRule) {\n    styleSheet.insertRule(selector + '{' + styleString + '}', 0);\n  } else if (styleSheet.addRule) {\n    styleSheet.addRule(selector, styleString, 0);\n  } else lib.warn('addStyleRule failed');\n};\n\n/**\n * to remove from the page a stylesheet identified by a given uid\n */\nlib.deleteRelatedStyleRule = function (uid) {\n  var id = 'plotly.js-style-' + uid;\n  var style = document.getElementById(id);\n  if (style) lib.removeElement(style);\n};\nlib.isIE = function () {\n  return typeof window.navigator.msSaveBlob !== 'undefined';\n};\n\n/**\n * Duck typing to recognize a d3 selection, mostly for IE9's benefit\n * because it doesn't handle instanceof like modern browsers\n */\nlib.isD3Selection = function (obj) {\n  return obj && typeof obj.classed === 'function';\n};\n\n/**\n * Append element to DOM only if not present.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} className (optional) : class name of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n *\n * Previously, we were using the following pattern:\n *\n * ```\n * var sel = parent.selectAll('.' + className)\n *     .data([0]);\n *\n * sel.enter().append(nodeType)\n *     .classed(className, true);\n *\n * return sel;\n * ```\n *\n * in numerous places in our codebase to achieve the same behavior.\n *\n * The logic below performs much better, mostly as we are using\n * `.select` instead `.selectAll` that is `querySelector` instead of\n * `querySelectorAll`.\n *\n */\nlib.ensureSingle = function (parent, nodeType, className, enterFn) {\n  var sel = parent.select(nodeType + (className ? '.' + className : ''));\n  if (sel.size()) return sel;\n  var layer = parent.append(nodeType);\n  if (className) layer.classed(className, true);\n  if (enterFn) layer.call(enterFn);\n  return layer;\n};\n\n/**\n * Same as Lib.ensureSingle, but using id as selector.\n * This version is mostly used for clipPath nodes.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} id : id of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n */\nlib.ensureSingleById = function (parent, nodeType, id, enterFn) {\n  var sel = parent.select(nodeType + '#' + id);\n  if (sel.size()) return sel;\n  var layer = parent.append(nodeType).attr('id', id);\n  if (enterFn) layer.call(enterFn);\n  return layer;\n};\n\n/**\n * Converts a string path to an object.\n *\n * When given a string containing an array element, it will create a `null`\n * filled array of the given size.\n *\n * @example\n * lib.objectFromPath('nested.test[2].path', 'value');\n * // returns { nested: { test: [null, null, { path: 'value' }]}\n *\n * @param   {string}    path to nested value\n * @param   {*}         any value to be set\n *\n * @return {Object} the constructed object with a full nested path\n */\nlib.objectFromPath = function (path, value) {\n  var keys = path.split('.');\n  var tmpObj;\n  var obj = tmpObj = {};\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var el = null;\n    var parts = keys[i].match(/(.*)\\[([0-9]+)\\]/);\n    if (parts) {\n      key = parts[1];\n      el = parts[2];\n      tmpObj = tmpObj[key] = [];\n      if (i === keys.length - 1) {\n        tmpObj[el] = value;\n      } else {\n        tmpObj[el] = {};\n      }\n      tmpObj = tmpObj[el];\n    } else {\n      if (i === keys.length - 1) {\n        tmpObj[key] = value;\n      } else {\n        tmpObj[key] = {};\n      }\n      tmpObj = tmpObj[key];\n    }\n  }\n  return obj;\n};\n\n/**\n * Iterate through an object in-place, converting dotted properties to objects.\n *\n * Examples:\n *\n *   lib.expandObjectPaths({'nested.test.path': 'value'});\n *     => { nested: { test: {path: 'value'}}}\n *\n * It also handles array notation, e.g.:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 'value'});\n *     => { foo: [null, {bar: value}] }\n *\n * It handles merges the results when two properties are specified in parallel:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 10, 'foo[0].bar': 20});\n *     => { foo: [{bar: 10}, {bar: 20}] }\n *\n * It does NOT, however, merge mulitple mutliply-nested arrays::\n *\n *   lib.expandObjectPaths({'marker[1].range[1]': 5, 'marker[1].range[0]': 4})\n *     => { marker: [null, {range: 4}] }\n */\n\n// Store this to avoid recompiling regex on *every* prop since this may happen many\n// many times for animations. Could maybe be inside the function. Not sure about\n// scoping vs. recompilation tradeoff, but at least it's not just inlining it into\n// the inner loop.\nvar dottedPropertyRegex = /^([^\\[\\.]+)\\.(.+)?/;\nvar indexedPropertyRegex = /^([^\\.]+)\\[([0-9]+)\\](\\.)?(.+)?/;\nlib.expandObjectPaths = function (data) {\n  var match, key, prop, datum, idx, dest, trailingPath;\n  if (typeof data === 'object' && !Array.isArray(data)) {\n    for (key in data) {\n      if (data.hasOwnProperty(key)) {\n        if (match = key.match(dottedPropertyRegex)) {\n          datum = data[key];\n          prop = match[1];\n          delete data[key];\n          data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);\n        } else if (match = key.match(indexedPropertyRegex)) {\n          datum = data[key];\n          prop = match[1];\n          idx = parseInt(match[2]);\n          delete data[key];\n          data[prop] = data[prop] || [];\n          if (match[3] === '.') {\n            // This is the case where theere are subsequent properties into which\n            // we must recurse, e.g. transforms[0].value\n            trailingPath = match[4];\n            dest = data[prop][idx] = data[prop][idx] || {};\n\n            // NB: Extend deep no arrays prevents this from working on multiple\n            // nested properties in the same object, e.g.\n            //\n            // {\n            //   foo[0].bar[1].range\n            //   foo[0].bar[0].range\n            // }\n            //\n            // In this case, the extendDeepNoArrays will overwrite one array with\n            // the other, so that both properties *will not* be present in the\n            // result. Fixing this would require a more intelligent tracking\n            // of changes and merging than extendDeepNoArrays currently accomplishes.\n            lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));\n          } else {\n            // This is the case where this property is the end of the line,\n            // e.g. xaxis.range[0]\n            data[prop][idx] = lib.expandObjectPaths(datum);\n          }\n        } else {\n          data[key] = lib.expandObjectPaths(data[key]);\n        }\n      }\n    }\n  }\n  return data;\n};\n\n/**\n * Converts value to string separated by the provided separators.\n *\n * @example\n * lib.numSeparate(2016, '.,');\n * // returns '2016'\n *\n * @example\n * lib.numSeparate(3000, '.,', true);\n * // returns '3,000'\n *\n * @example\n * lib.numSeparate(1234.56, '|,')\n * // returns '1,234|56'\n *\n * @param   {string|number} value       the value to be converted\n * @param   {string}    separators  string of decimal, then thousands separators\n * @param   {boolean}    separatethousands  boolean, 4-digit integers are separated if true\n *\n * @return  {string}    the value that has been separated\n */\nlib.numSeparate = function (value, separators, separatethousands) {\n  if (!separatethousands) separatethousands = false;\n  if (typeof separators !== 'string' || separators.length === 0) {\n    throw new Error('Separator string required for formatting!');\n  }\n  if (typeof value === 'number') {\n    value = String(value);\n  }\n  var thousandsRe = /(\\d+)(\\d{3})/;\n  var decimalSep = separators.charAt(0);\n  var thouSep = separators.charAt(1);\n  var x = value.split('.');\n  var x1 = x[0];\n  var x2 = x.length > 1 ? decimalSep + x[1] : '';\n\n  // Years are ignored for thousands separators\n  if (thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {\n    while (thousandsRe.test(x1)) {\n      x1 = x1.replace(thousandsRe, '$1' + thouSep + '$2');\n    }\n  }\n  return x1 + x2;\n};\nvar TEMPLATE_STRING_REGEX = /%{([^\\s%{}:]*)(:[^}]*)?}/g;\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n/**\n * Substitute values from an object into a string\n *\n * Examples:\n *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *\n * @param {string}  input string containing %{...} template strings\n * @param {obj}     data object containing substitution values\n *\n * @return {string} templated string\n */\nlib.templateString = function (string, obj) {\n  // Not all that useful, but cache nestedProperty instantiation\n  // just in case it speeds things up *slightly*:\n  var getterCache = {};\n  return string.replace(TEMPLATE_STRING_REGEX, function (dummy, key) {\n    if (SIMPLE_PROPERTY_REGEX.test(key)) {\n      return obj[key] || '';\n    }\n    getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;\n    return getterCache[key]() || '';\n  });\n};\nvar TEMPLATE_STRING_FORMAT_SEPARATOR = /^:/;\nvar numberOfHoverTemplateWarnings = 0;\nvar maximumNumberOfHoverTemplateWarnings = 10;\n/**\n * Substitute values from an object into a string and optionally formats them using d3-format,\n * or fallback to associated labels.\n *\n * Examples:\n *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *  Lib.templateString('price: %{y:$.2f}', {y: 1}) --> 'price: $1.00'\n *\n * @param {string}  input string containing %{...:...} template strings\n * @param {obj}     data object containing fallback text when no formatting is specified, ex.: {yLabel: 'formattedYValue'}\n * @param {obj}     data objects containing substitution values\n *\n * @return {string} templated string\n */\nlib.hovertemplateString = function (string, labels) {\n  var args = arguments;\n  // Not all that useful, but cache nestedProperty instantiation\n  // just in case it speeds things up *slightly*:\n  var getterCache = {};\n  return string.replace(TEMPLATE_STRING_REGEX, function (match, key, format) {\n    var obj, value, i;\n    for (i = 2; i < args.length; i++) {\n      obj = args[i];\n      if (obj.hasOwnProperty(key)) {\n        value = obj[key];\n        break;\n      }\n      if (!SIMPLE_PROPERTY_REGEX.test(key)) {\n        value = getterCache[key] || lib.nestedProperty(obj, key).get();\n        if (value) getterCache[key] = value;\n      }\n      if (value !== undefined) break;\n    }\n    if (value === undefined) {\n      if (numberOfHoverTemplateWarnings < maximumNumberOfHoverTemplateWarnings) {\n        lib.warn('Variable \\'' + key + '\\' in hovertemplate could not be found!');\n        value = match;\n      }\n      if (numberOfHoverTemplateWarnings === maximumNumberOfHoverTemplateWarnings) {\n        lib.warn('Too many hovertemplate warnings - additional warnings will be suppressed');\n      }\n      numberOfHoverTemplateWarnings++;\n    }\n    if (format) {\n      value = d3.format(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ''))(value);\n    } else {\n      if (labels.hasOwnProperty(key + 'Label')) value = labels[key + 'Label'];\n    }\n    return value;\n  });\n};\n\n/*\n * alphanumeric string sort, tailored for subplot IDs like scene2, scene10, x10y13 etc\n */\nvar char0 = 48;\nvar char9 = 57;\nlib.subplotSort = function (a, b) {\n  var l = Math.min(a.length, b.length) + 1;\n  var numA = 0;\n  var numB = 0;\n  for (var i = 0; i < l; i++) {\n    var charA = a.charCodeAt(i) || 0;\n    var charB = b.charCodeAt(i) || 0;\n    var isNumA = charA >= char0 && charA <= char9;\n    var isNumB = charB >= char0 && charB <= char9;\n    if (isNumA) numA = 10 * numA + charA - char0;\n    if (isNumB) numB = 10 * numB + charB - char0;\n    if (!isNumA || !isNumB) {\n      if (numA !== numB) return numA - numB;\n      if (charA !== charB) return charA - charB;\n    }\n  }\n  return numB - numA;\n};\n\n// repeatable pseudorandom generator\nvar randSeed = 2000000000;\nlib.seedPseudoRandom = function () {\n  randSeed = 2000000000;\n};\nlib.pseudoRandom = function () {\n  var lastVal = randSeed;\n  randSeed = (69069 * randSeed + 1) % 4294967296;\n  // don't let consecutive vals be too close together\n  // gets away from really trying to be random, in favor of better local uniformity\n  if (Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();\n  return randSeed / 4294967296;\n};","map":{"version":3,"names":["d3","require","isNumeric","numConstants","FP_SAFE","BADNUM","lib","module","exports","nestedProperty","keyedContainer","relativeAttr","isPlainObject","toLogRange","relinkPrivateKeys","arrayModule","isTypedArray","isArrayOrTypedArray","isArray1D","ensureArray","concat","maxRowLength","minRowLength","modModule","mod","modHalf","coerceModule","valObjectMeta","coerce","coerce2","coerceFont","coerceHoverinfo","coerceSelectionMarkerOpacity","validate","datesModule","dateTime2ms","isDateTime","ms2DateTime","ms2DateTimeLocal","cleanDate","isJSDate","formatDate","incrementMonth","dateTick0","dfltRange","findExactDates","MIN_MS","MAX_MS","searchModule","findBin","sorterAsc","sorterDes","distinctVals","roundUp","sort","findIndexOfMin","statsModule","aggNums","len","mean","midRange","variance","stdev","interp","matrixModule","init2dArray","transposeRagged","dot","translationMatrix","rotationMatrix","rotationXYMatrix","apply2DTransform","apply2DTransform2","anglesModule","deg2rad","rad2deg","angleDelta","angleDist","isFullCircle","isAngleInsideSector","isPtInsideSector","pathArc","pathSector","pathAnnulus","anchorUtils","isLeftAnchor","isCenterAnchor","isRightAnchor","isTopAnchor","isMiddleAnchor","isBottomAnchor","geom2dModule","segmentsIntersect","segmentDistance","getTextLocation","clearLocationCache","getVisibleSegment","findPointOnPath","extendModule","extendFlat","extendDeep","extendDeepAll","extendDeepNoArrays","loggersModule","log","warn","error","regexModule","counterRegex","counter","throttleModule","throttle","throttleDone","done","clearThrottle","clear","getGraphDiv","clearResponsive","makeTraceGroups","_","notifier","filterUnique","filterVisible","pushUnique","cleanNumber","ensureNumber","num","v","Number","isIndex","undefined","noop","identity","repeat","cnt","out","Array","i","swapAttrs","cont","attrList","part1","part2","length","attr","xp","replace","yp","temp","get","set","raiseToTop","elem","parentNode","appendChild","cancelTransition","selection","transition","duration","constrain","v0","v1","Math","max","min","bBoxIntersect","a","b","pad","left","right","top","bottom","simpleMap","array","func","x1","x2","randstr","existing","bits","base","_recursion","digits","pow","res","x","Infinity","rem","floor","random","toString","parsed","parseInt","OptionControl","opt","optname","self","optionList","_newoption","optObj","name","push","smooth","arrayIn","FWHM","round","alen","alen2","wlen","w","arrayOut","j","k","cos","PI","syncOrAsync","sequence","arg","finalStep","ret","fni","continueAsync","splice","then","promiseError","stripTrailingSlash","str","substr","noneOrAll","containerIn","containerOut","hasAny","hasAll","val","mergeArray","traceAttr","cd","cdAttr","imax","fillArray","fn","castOption","trace","ptNumber","astr","isArray","extractOption","calcPt","calcKey","traceKey","traceVal","makePtIndex2PtNumber","indexToPoints","ptIndex2ptNumber","pts","tagSelected","calcTrace","ptNumber2cdIndex","selectedpoints","_indexToPoints","isCdIndexValid","ptIndex","cdIndex","selected","selIndices2selPoints","getTargetArray","transformOpts","target","minExtend","obj1","obj2","objOut","arrayLen","keys","Object","charAt","slice","titleCase","s","toUpperCase","containsAny","fragments","indexOf","isPlotDiv","el","el3","select","node","HTMLElement","size","classed","removeElement","elParent","removeChild","addStyleRule","selector","styleString","addRelatedStyleRule","uid","id","style","document","getElementById","createElement","setAttribute","createTextNode","head","styleSheet","sheet","insertRule","addRule","deleteRelatedStyleRule","isIE","window","navigator","msSaveBlob","isD3Selection","obj","ensureSingle","parent","nodeType","className","enterFn","sel","layer","append","call","ensureSingleById","objectFromPath","path","value","split","tmpObj","key","parts","match","dottedPropertyRegex","indexedPropertyRegex","expandObjectPaths","data","prop","datum","idx","dest","trailingPath","hasOwnProperty","numSeparate","separators","separatethousands","Error","String","thousandsRe","decimalSep","thouSep","test","TEMPLATE_STRING_REGEX","SIMPLE_PROPERTY_REGEX","templateString","string","getterCache","dummy","TEMPLATE_STRING_FORMAT_SEPARATOR","numberOfHoverTemplateWarnings","maximumNumberOfHoverTemplateWarnings","hovertemplateString","labels","args","arguments","format","char0","char9","subplotSort","l","numA","numB","charA","charCodeAt","charB","isNumA","isNumB","randSeed","seedPseudoRandom","pseudoRandom","lastVal","abs"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/lib/index.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar numConstants = require('../constants/numerical');\nvar FP_SAFE = numConstants.FP_SAFE;\nvar BADNUM = numConstants.BADNUM;\n\nvar lib = module.exports = {};\n\nlib.nestedProperty = require('./nested_property');\nlib.keyedContainer = require('./keyed_container');\nlib.relativeAttr = require('./relative_attr');\nlib.isPlainObject = require('./is_plain_object');\nlib.toLogRange = require('./to_log_range');\nlib.relinkPrivateKeys = require('./relink_private');\n\nvar arrayModule = require('./array');\nlib.isTypedArray = arrayModule.isTypedArray;\nlib.isArrayOrTypedArray = arrayModule.isArrayOrTypedArray;\nlib.isArray1D = arrayModule.isArray1D;\nlib.ensureArray = arrayModule.ensureArray;\nlib.concat = arrayModule.concat;\nlib.maxRowLength = arrayModule.maxRowLength;\nlib.minRowLength = arrayModule.minRowLength;\n\nvar modModule = require('./mod');\nlib.mod = modModule.mod;\nlib.modHalf = modModule.modHalf;\n\nvar coerceModule = require('./coerce');\nlib.valObjectMeta = coerceModule.valObjectMeta;\nlib.coerce = coerceModule.coerce;\nlib.coerce2 = coerceModule.coerce2;\nlib.coerceFont = coerceModule.coerceFont;\nlib.coerceHoverinfo = coerceModule.coerceHoverinfo;\nlib.coerceSelectionMarkerOpacity = coerceModule.coerceSelectionMarkerOpacity;\nlib.validate = coerceModule.validate;\n\nvar datesModule = require('./dates');\nlib.dateTime2ms = datesModule.dateTime2ms;\nlib.isDateTime = datesModule.isDateTime;\nlib.ms2DateTime = datesModule.ms2DateTime;\nlib.ms2DateTimeLocal = datesModule.ms2DateTimeLocal;\nlib.cleanDate = datesModule.cleanDate;\nlib.isJSDate = datesModule.isJSDate;\nlib.formatDate = datesModule.formatDate;\nlib.incrementMonth = datesModule.incrementMonth;\nlib.dateTick0 = datesModule.dateTick0;\nlib.dfltRange = datesModule.dfltRange;\nlib.findExactDates = datesModule.findExactDates;\nlib.MIN_MS = datesModule.MIN_MS;\nlib.MAX_MS = datesModule.MAX_MS;\n\nvar searchModule = require('./search');\nlib.findBin = searchModule.findBin;\nlib.sorterAsc = searchModule.sorterAsc;\nlib.sorterDes = searchModule.sorterDes;\nlib.distinctVals = searchModule.distinctVals;\nlib.roundUp = searchModule.roundUp;\nlib.sort = searchModule.sort;\nlib.findIndexOfMin = searchModule.findIndexOfMin;\n\nvar statsModule = require('./stats');\nlib.aggNums = statsModule.aggNums;\nlib.len = statsModule.len;\nlib.mean = statsModule.mean;\nlib.midRange = statsModule.midRange;\nlib.variance = statsModule.variance;\nlib.stdev = statsModule.stdev;\nlib.interp = statsModule.interp;\n\nvar matrixModule = require('./matrix');\nlib.init2dArray = matrixModule.init2dArray;\nlib.transposeRagged = matrixModule.transposeRagged;\nlib.dot = matrixModule.dot;\nlib.translationMatrix = matrixModule.translationMatrix;\nlib.rotationMatrix = matrixModule.rotationMatrix;\nlib.rotationXYMatrix = matrixModule.rotationXYMatrix;\nlib.apply2DTransform = matrixModule.apply2DTransform;\nlib.apply2DTransform2 = matrixModule.apply2DTransform2;\n\nvar anglesModule = require('./angles');\nlib.deg2rad = anglesModule.deg2rad;\nlib.rad2deg = anglesModule.rad2deg;\nlib.angleDelta = anglesModule.angleDelta;\nlib.angleDist = anglesModule.angleDist;\nlib.isFullCircle = anglesModule.isFullCircle;\nlib.isAngleInsideSector = anglesModule.isAngleInsideSector;\nlib.isPtInsideSector = anglesModule.isPtInsideSector;\nlib.pathArc = anglesModule.pathArc;\nlib.pathSector = anglesModule.pathSector;\nlib.pathAnnulus = anglesModule.pathAnnulus;\n\nvar anchorUtils = require('./anchor_utils');\nlib.isLeftAnchor = anchorUtils.isLeftAnchor;\nlib.isCenterAnchor = anchorUtils.isCenterAnchor;\nlib.isRightAnchor = anchorUtils.isRightAnchor;\nlib.isTopAnchor = anchorUtils.isTopAnchor;\nlib.isMiddleAnchor = anchorUtils.isMiddleAnchor;\nlib.isBottomAnchor = anchorUtils.isBottomAnchor;\n\nvar geom2dModule = require('./geometry2d');\nlib.segmentsIntersect = geom2dModule.segmentsIntersect;\nlib.segmentDistance = geom2dModule.segmentDistance;\nlib.getTextLocation = geom2dModule.getTextLocation;\nlib.clearLocationCache = geom2dModule.clearLocationCache;\nlib.getVisibleSegment = geom2dModule.getVisibleSegment;\nlib.findPointOnPath = geom2dModule.findPointOnPath;\n\nvar extendModule = require('./extend');\nlib.extendFlat = extendModule.extendFlat;\nlib.extendDeep = extendModule.extendDeep;\nlib.extendDeepAll = extendModule.extendDeepAll;\nlib.extendDeepNoArrays = extendModule.extendDeepNoArrays;\n\nvar loggersModule = require('./loggers');\nlib.log = loggersModule.log;\nlib.warn = loggersModule.warn;\nlib.error = loggersModule.error;\n\nvar regexModule = require('./regex');\nlib.counterRegex = regexModule.counter;\n\nvar throttleModule = require('./throttle');\nlib.throttle = throttleModule.throttle;\nlib.throttleDone = throttleModule.done;\nlib.clearThrottle = throttleModule.clear;\n\nlib.getGraphDiv = require('./get_graph_div');\n\nlib.clearResponsive = require('./clear_responsive');\n\nlib.makeTraceGroups = require('./make_trace_groups');\n\nlib._ = require('./localize');\n\nlib.notifier = require('./notifier');\n\nlib.filterUnique = require('./filter_unique');\nlib.filterVisible = require('./filter_visible');\nlib.pushUnique = require('./push_unique');\n\nlib.cleanNumber = require('./clean_number');\n\nlib.ensureNumber = function num(v) {\n    if(!isNumeric(v)) return BADNUM;\n    v = Number(v);\n    if(v < -FP_SAFE || v > FP_SAFE) return BADNUM;\n    return isNumeric(v) ? Number(v) : BADNUM;\n};\n\n/**\n * Is v a valid array index? Accepts numeric strings as well as numbers.\n *\n * @param {any} v: the value to test\n * @param {Optional[integer]} len: the array length we are indexing\n *\n * @return {bool}: v is a valid array index\n */\nlib.isIndex = function(v, len) {\n    if(len !== undefined && v >= len) return false;\n    return isNumeric(v) && (v >= 0) && (v % 1 === 0);\n};\n\nlib.noop = require('./noop');\nlib.identity = require('./identity');\n\n/**\n * create an array of length 'cnt' filled with 'v' at all indices\n *\n * @param {any} v\n * @param {number} cnt\n * @return {array}\n */\nlib.repeat = function(v, cnt) {\n    var out = new Array(cnt);\n    for(var i = 0; i < cnt; i++) {\n        out[i] = v;\n    }\n    return out;\n};\n\n/**\n * swap x and y of the same attribute in container cont\n * specify attr with a ? in place of x/y\n * you can also swap other things than x/y by providing part1 and part2\n */\nlib.swapAttrs = function(cont, attrList, part1, part2) {\n    if(!part1) part1 = 'x';\n    if(!part2) part2 = 'y';\n    for(var i = 0; i < attrList.length; i++) {\n        var attr = attrList[i];\n        var xp = lib.nestedProperty(cont, attr.replace('?', part1));\n        var yp = lib.nestedProperty(cont, attr.replace('?', part2));\n        var temp = xp.get();\n        xp.set(yp.get());\n        yp.set(temp);\n    }\n};\n\n/**\n * SVG painter's algo worked around with reinsertion\n */\nlib.raiseToTop = function raiseToTop(elem) {\n    elem.parentNode.appendChild(elem);\n};\n\n/**\n * cancel a possibly pending transition; returned selection may be used by caller\n */\nlib.cancelTransition = function(selection) {\n    return selection.transition().duration(0);\n};\n\n// constrain - restrict a number v to be between v0 and v1\nlib.constrain = function(v, v0, v1) {\n    if(v0 > v1) return Math.max(v1, Math.min(v0, v));\n    return Math.max(v0, Math.min(v1, v));\n};\n\n/**\n * do two bounding boxes from getBoundingClientRect,\n * ie {left,right,top,bottom,width,height}, overlap?\n * takes optional padding pixels\n */\nlib.bBoxIntersect = function(a, b, pad) {\n    pad = pad || 0;\n    return (a.left <= b.right + pad &&\n            b.left <= a.right + pad &&\n            a.top <= b.bottom + pad &&\n            b.top <= a.bottom + pad);\n};\n\n/*\n * simpleMap: alternative to Array.map that only\n * passes on the element and up to 2 extra args you\n * provide (but not the array index or the whole array)\n *\n * array: the array to map it to\n * func: the function to apply\n * x1, x2: optional extra args\n */\nlib.simpleMap = function(array, func, x1, x2) {\n    var len = array.length;\n    var out = new Array(len);\n    for(var i = 0; i < len; i++) out[i] = func(array[i], x1, x2);\n    return out;\n};\n\n/**\n * Random string generator\n *\n * @param {object} existing\n *     pass in strings to avoid as keys with truthy values\n * @param {int} bits\n *     bits of information in the output string, default 24\n * @param {int} base\n *     base of string representation, default 16. Should be a power of 2.\n */\nlib.randstr = function randstr(existing, bits, base, _recursion) {\n    if(!base) base = 16;\n    if(bits === undefined) bits = 24;\n    if(bits <= 0) return '0';\n\n    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);\n    var res = '';\n    var i, b, x;\n\n    for(i = 2; digits === Infinity; i *= 2) {\n        digits = Math.log(Math.pow(2, bits / i)) / Math.log(base) * i;\n    }\n\n    var rem = digits - Math.floor(digits);\n\n    for(i = 0; i < Math.floor(digits); i++) {\n        x = Math.floor(Math.random() * base).toString(base);\n        res = x + res;\n    }\n\n    if(rem) {\n        b = Math.pow(base, rem);\n        x = Math.floor(Math.random() * b).toString(base);\n        res = x + res;\n    }\n\n    var parsed = parseInt(res, base);\n    if((existing && existing[res]) ||\n         (parsed !== Infinity && parsed >= Math.pow(2, bits))) {\n        if(_recursion > 10) {\n            lib.warn('randstr failed uniqueness');\n            return res;\n        }\n        return randstr(existing, bits, base, (_recursion || 0) + 1);\n    }\n    else return res;\n};\n\nlib.OptionControl = function(opt, optname) {\n    /*\n     * An environment to contain all option setters and\n     * getters that collectively modify opts.\n     *\n     * You can call up opts from any function in new object\n     * as this.optname || this.opt\n     *\n     * See FitOpts for example of usage\n     */\n    if(!opt) opt = {};\n    if(!optname) optname = 'opt';\n\n    var self = {};\n    self.optionList = [];\n\n    self._newoption = function(optObj) {\n        optObj[optname] = opt;\n        self[optObj.name] = optObj;\n        self.optionList.push(optObj);\n    };\n\n    self['_' + optname] = opt;\n    return self;\n};\n\n/**\n * lib.smooth: smooth arrayIn by convolving with\n * a hann window with given full width at half max\n * bounce the ends in, so the output has the same length as the input\n */\nlib.smooth = function(arrayIn, FWHM) {\n    FWHM = Math.round(FWHM) || 0; // only makes sense for integers\n    if(FWHM < 2) return arrayIn;\n\n    var alen = arrayIn.length;\n    var alen2 = 2 * alen;\n    var wlen = 2 * FWHM - 1;\n    var w = new Array(wlen);\n    var arrayOut = new Array(alen);\n    var i;\n    var j;\n    var k;\n    var v;\n\n    // first make the window array\n    for(i = 0; i < wlen; i++) {\n        w[i] = (1 - Math.cos(Math.PI * (i + 1) / FWHM)) / (2 * FWHM);\n    }\n\n    // now do the convolution\n    for(i = 0; i < alen; i++) {\n        v = 0;\n        for(j = 0; j < wlen; j++) {\n            k = i + j + 1 - FWHM;\n\n            // multibounce\n            if(k < -alen) k -= alen2 * Math.round(k / alen2);\n            else if(k >= alen2) k -= alen2 * Math.floor(k / alen2);\n\n            // single bounce\n            if(k < 0) k = - 1 - k;\n            else if(k >= alen) k = alen2 - 1 - k;\n\n            v += arrayIn[k] * w[j];\n        }\n        arrayOut[i] = v;\n    }\n\n    return arrayOut;\n};\n\n/**\n * syncOrAsync: run a sequence of functions synchronously\n * as long as its returns are not promises (ie have no .then)\n * includes one argument arg to send to all functions...\n * this is mainly just to prevent us having to make wrapper functions\n * when the only purpose of the wrapper is to reference gd\n * and a final step to be executed at the end\n * TODO: if there's an error and everything is sync,\n * this doesn't happen yet because we want to make sure\n * that it gets reported\n */\nlib.syncOrAsync = function(sequence, arg, finalStep) {\n    var ret, fni;\n\n    function continueAsync() {\n        return lib.syncOrAsync(sequence, arg, finalStep);\n    }\n\n    while(sequence.length) {\n        fni = sequence.splice(0, 1)[0];\n        ret = fni(arg);\n\n        if(ret && ret.then) {\n            return ret.then(continueAsync)\n                .then(undefined, lib.promiseError);\n        }\n    }\n\n    return finalStep && finalStep(arg);\n};\n\n\n/**\n * Helper to strip trailing slash, from\n * http://stackoverflow.com/questions/6680825/return-string-without-trailing-slash\n */\nlib.stripTrailingSlash = function(str) {\n    if(str.substr(-1) === '/') return str.substr(0, str.length - 1);\n    return str;\n};\n\nlib.noneOrAll = function(containerIn, containerOut, attrList) {\n    /**\n     * some attributes come together, so if you have one of them\n     * in the input, you should copy the default values of the others\n     * to the input as well.\n     */\n    if(!containerIn) return;\n\n    var hasAny = false;\n    var hasAll = true;\n    var i;\n    var val;\n\n    for(i = 0; i < attrList.length; i++) {\n        val = containerIn[attrList[i]];\n        if(val !== undefined && val !== null) hasAny = true;\n        else hasAll = false;\n    }\n\n    if(hasAny && !hasAll) {\n        for(i = 0; i < attrList.length; i++) {\n            containerIn[attrList[i]] = containerOut[attrList[i]];\n        }\n    }\n};\n\n/** merges calcdata field (given by cdAttr) with traceAttr values\n *\n * N.B. Loop over minimum of cd.length and traceAttr.length\n * i.e. it does not try to fill in beyond traceAttr.length-1\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n */\nlib.mergeArray = function(traceAttr, cd, cdAttr) {\n    if(lib.isArrayOrTypedArray(traceAttr)) {\n        var imax = Math.min(traceAttr.length, cd.length);\n        for(var i = 0; i < imax; i++) cd[i][cdAttr] = traceAttr[i];\n    }\n};\n\n/** fills calcdata field (given by cdAttr) with traceAttr values\n *  or function of traceAttr values (e.g. some fallback)\n *\n * N.B. Loops over all cd items.\n *\n * @param {array} traceAttr : trace attribute\n * @param {object} cd : calcdata trace\n * @param {string} cdAttr : calcdata key\n * @param {function} [fn] : optional function to apply to each array item\n */\nlib.fillArray = function(traceAttr, cd, cdAttr, fn) {\n    fn = fn || lib.identity;\n\n    if(lib.isArrayOrTypedArray(traceAttr)) {\n        for(var i = 0; i < cd.length; i++) {\n            cd[i][cdAttr] = fn(traceAttr[i]);\n        }\n    }\n};\n\n/** Handler for trace-wide vs per-point options\n *\n * @param {object} trace : (full) trace object\n * @param {number} ptNumber : index of the point in question\n * @param {string} astr : attribute string\n * @param {function} [fn] : optional function to apply to each array item\n *\n * @return {any}\n */\nlib.castOption = function(trace, ptNumber, astr, fn) {\n    fn = fn || lib.identity;\n\n    var val = lib.nestedProperty(trace, astr).get();\n\n    if(lib.isArrayOrTypedArray(val)) {\n        if(Array.isArray(ptNumber) && lib.isArrayOrTypedArray(val[ptNumber[0]])) {\n            return fn(val[ptNumber[0]][ptNumber[1]]);\n        } else {\n            return fn(val[ptNumber]);\n        }\n    } else {\n        return val;\n    }\n};\n\n/** Extract option from calcdata item, correctly falling back to\n *  trace value if not found.\n *\n *  @param {object} calcPt : calcdata[i][j] item\n *  @param {object} trace : (full) trace object\n *  @param {string} calcKey : calcdata key\n *  @param {string} traceKey : aka trace attribute string\n *  @return {any}\n */\nlib.extractOption = function(calcPt, trace, calcKey, traceKey) {\n    if(calcKey in calcPt) return calcPt[calcKey];\n\n    // fallback to trace value,\n    //   must check if value isn't itself an array\n    //   which means the trace attribute has a corresponding\n    //   calcdata key, but its value is falsy\n    var traceVal = lib.nestedProperty(trace, traceKey).get();\n    if(!Array.isArray(traceVal)) return traceVal;\n};\n\nfunction makePtIndex2PtNumber(indexToPoints) {\n    var ptIndex2ptNumber = {};\n    for(var k in indexToPoints) {\n        var pts = indexToPoints[k];\n        for(var j = 0; j < pts.length; j++) {\n            ptIndex2ptNumber[pts[j]] = +k;\n        }\n    }\n    return ptIndex2ptNumber;\n}\n\n/** Tag selected calcdata items\n *\n * N.B. note that point 'index' corresponds to input data array index\n *  whereas 'number' is its post-transform version.\n *\n * @param {array} calcTrace\n * @param {object} trace\n *  - selectedpoints {array}\n *  - _indexToPoints {object}\n * @param {ptNumber2cdIndex} ptNumber2cdIndex (optional)\n *  optional map object for trace types that do not have 1-to-1 point number to\n *  calcdata item index correspondence (e.g. histogram)\n */\nlib.tagSelected = function(calcTrace, trace, ptNumber2cdIndex) {\n    var selectedpoints = trace.selectedpoints;\n    var indexToPoints = trace._indexToPoints;\n    var ptIndex2ptNumber;\n\n    // make pt index-to-number map object, which takes care of transformed traces\n    if(indexToPoints) {\n        ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);\n    }\n\n    function isCdIndexValid(v) {\n        return v !== undefined && v < calcTrace.length;\n    }\n\n    for(var i = 0; i < selectedpoints.length; i++) {\n        var ptIndex = selectedpoints[i];\n\n        if(lib.isIndex(ptIndex)) {\n            var ptNumber = ptIndex2ptNumber ? ptIndex2ptNumber[ptIndex] : ptIndex;\n            var cdIndex = ptNumber2cdIndex ? ptNumber2cdIndex[ptNumber] : ptNumber;\n\n            if(isCdIndexValid(cdIndex)) {\n                calcTrace[cdIndex].selected = 1;\n            }\n        }\n    }\n};\n\nlib.selIndices2selPoints = function(trace) {\n    var selectedpoints = trace.selectedpoints;\n    var indexToPoints = trace._indexToPoints;\n\n    if(indexToPoints) {\n        var ptIndex2ptNumber = makePtIndex2PtNumber(indexToPoints);\n        var out = [];\n\n        for(var i = 0; i < selectedpoints.length; i++) {\n            var ptIndex = selectedpoints[i];\n            if(lib.isIndex(ptIndex)) {\n                var ptNumber = ptIndex2ptNumber[ptIndex];\n                if(lib.isIndex(ptNumber)) {\n                    out.push(ptNumber);\n                }\n            }\n        }\n\n        return out;\n    } else {\n        return selectedpoints;\n    }\n};\n\n/** Returns target as set by 'target' transform attribute\n *\n * @param {object} trace : full trace object\n * @param {object} transformOpts : transform option object\n *  - target (string} :\n *      either an attribute string referencing an array in the trace object, or\n *      a set array.\n *\n * @return {array or false} : the target array (NOT a copy!!) or false if invalid\n */\nlib.getTargetArray = function(trace, transformOpts) {\n    var target = transformOpts.target;\n\n    if(typeof target === 'string' && target) {\n        var array = lib.nestedProperty(trace, target).get();\n        return Array.isArray(array) ? array : false;\n    } else if(Array.isArray(target)) {\n        return target;\n    }\n\n    return false;\n};\n\n/**\n * modified version of jQuery's extend to strip out private objs and functions,\n * and cut arrays down to first <arraylen> or 1 elements\n * because extend-like algorithms are hella slow\n * obj2 is assumed to already be clean of these things (including no arrays)\n */\nlib.minExtend = function(obj1, obj2) {\n    var objOut = {};\n    if(typeof obj2 !== 'object') obj2 = {};\n    var arrayLen = 3;\n    var keys = Object.keys(obj1);\n    var i, k, v;\n\n    for(i = 0; i < keys.length; i++) {\n        k = keys[i];\n        v = obj1[k];\n        if(k.charAt(0) === '_' || typeof v === 'function') continue;\n        else if(k === 'module') objOut[k] = v;\n        else if(Array.isArray(v)) {\n            if(k === 'colorscale') {\n                objOut[k] = v.slice();\n            } else {\n                objOut[k] = v.slice(0, arrayLen);\n            }\n        }\n        else if(v && (typeof v === 'object')) objOut[k] = lib.minExtend(obj1[k], obj2[k]);\n        else objOut[k] = v;\n    }\n\n    keys = Object.keys(obj2);\n    for(i = 0; i < keys.length; i++) {\n        k = keys[i];\n        v = obj2[k];\n        if(typeof v !== 'object' || !(k in objOut) || typeof objOut[k] !== 'object') {\n            objOut[k] = v;\n        }\n    }\n\n    return objOut;\n};\n\nlib.titleCase = function(s) {\n    return s.charAt(0).toUpperCase() + s.substr(1);\n};\n\nlib.containsAny = function(s, fragments) {\n    for(var i = 0; i < fragments.length; i++) {\n        if(s.indexOf(fragments[i]) !== -1) return true;\n    }\n    return false;\n};\n\nlib.isPlotDiv = function(el) {\n    var el3 = d3.select(el);\n    return el3.node() instanceof HTMLElement &&\n        el3.size() &&\n        el3.classed('js-plotly-plot');\n};\n\nlib.removeElement = function(el) {\n    var elParent = el && el.parentNode;\n    if(elParent) elParent.removeChild(el);\n};\n\n/**\n * for dynamically adding style rules\n * makes one stylesheet that contains all rules added\n * by all calls to this function\n */\nlib.addStyleRule = function(selector, styleString) {\n    lib.addRelatedStyleRule('global', selector, styleString);\n};\n\n/**\n * for dynamically adding style rules\n * to a stylesheet uniquely identified by a uid\n */\nlib.addRelatedStyleRule = function(uid, selector, styleString) {\n    var id = 'plotly.js-style-' + uid;\n    var style = document.getElementById(id);\n    if(!style) {\n        style = document.createElement('style');\n        style.setAttribute('id', id);\n        // WebKit hack :(\n        style.appendChild(document.createTextNode(''));\n        document.head.appendChild(style);\n    }\n    var styleSheet = style.sheet;\n\n    if(styleSheet.insertRule) {\n        styleSheet.insertRule(selector + '{' + styleString + '}', 0);\n    }\n    else if(styleSheet.addRule) {\n        styleSheet.addRule(selector, styleString, 0);\n    }\n    else lib.warn('addStyleRule failed');\n};\n\n/**\n * to remove from the page a stylesheet identified by a given uid\n */\nlib.deleteRelatedStyleRule = function(uid) {\n    var id = 'plotly.js-style-' + uid;\n    var style = document.getElementById(id);\n    if(style) lib.removeElement(style);\n};\n\nlib.isIE = function() {\n    return typeof window.navigator.msSaveBlob !== 'undefined';\n};\n\n/**\n * Duck typing to recognize a d3 selection, mostly for IE9's benefit\n * because it doesn't handle instanceof like modern browsers\n */\nlib.isD3Selection = function(obj) {\n    return obj && (typeof obj.classed === 'function');\n};\n\n/**\n * Append element to DOM only if not present.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} className (optional) : class name of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n *\n * Previously, we were using the following pattern:\n *\n * ```\n * var sel = parent.selectAll('.' + className)\n *     .data([0]);\n *\n * sel.enter().append(nodeType)\n *     .classed(className, true);\n *\n * return sel;\n * ```\n *\n * in numerous places in our codebase to achieve the same behavior.\n *\n * The logic below performs much better, mostly as we are using\n * `.select` instead `.selectAll` that is `querySelector` instead of\n * `querySelectorAll`.\n *\n */\nlib.ensureSingle = function(parent, nodeType, className, enterFn) {\n    var sel = parent.select(nodeType + (className ? '.' + className : ''));\n    if(sel.size()) return sel;\n\n    var layer = parent.append(nodeType);\n    if(className) layer.classed(className, true);\n    if(enterFn) layer.call(enterFn);\n\n    return layer;\n};\n\n/**\n * Same as Lib.ensureSingle, but using id as selector.\n * This version is mostly used for clipPath nodes.\n *\n * @param {d3 selection} parent : parent selection of the element in question\n * @param {string} nodeType : node type of element to append\n * @param {string} id : id of element in question\n * @param {fn} enterFn (optional) : optional fn applied to entering elements only\n * @return {d3 selection} selection of new layer\n */\nlib.ensureSingleById = function(parent, nodeType, id, enterFn) {\n    var sel = parent.select(nodeType + '#' + id);\n    if(sel.size()) return sel;\n\n    var layer = parent.append(nodeType).attr('id', id);\n    if(enterFn) layer.call(enterFn);\n\n    return layer;\n};\n\n/**\n * Converts a string path to an object.\n *\n * When given a string containing an array element, it will create a `null`\n * filled array of the given size.\n *\n * @example\n * lib.objectFromPath('nested.test[2].path', 'value');\n * // returns { nested: { test: [null, null, { path: 'value' }]}\n *\n * @param   {string}    path to nested value\n * @param   {*}         any value to be set\n *\n * @return {Object} the constructed object with a full nested path\n */\nlib.objectFromPath = function(path, value) {\n    var keys = path.split('.');\n    var tmpObj;\n    var obj = tmpObj = {};\n\n    for(var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        var el = null;\n\n        var parts = keys[i].match(/(.*)\\[([0-9]+)\\]/);\n\n        if(parts) {\n            key = parts[1];\n            el = parts[2];\n\n            tmpObj = tmpObj[key] = [];\n\n            if(i === keys.length - 1) {\n                tmpObj[el] = value;\n            } else {\n                tmpObj[el] = {};\n            }\n\n            tmpObj = tmpObj[el];\n        } else {\n\n            if(i === keys.length - 1) {\n                tmpObj[key] = value;\n            } else {\n                tmpObj[key] = {};\n            }\n\n            tmpObj = tmpObj[key];\n        }\n    }\n\n    return obj;\n};\n\n/**\n * Iterate through an object in-place, converting dotted properties to objects.\n *\n * Examples:\n *\n *   lib.expandObjectPaths({'nested.test.path': 'value'});\n *     => { nested: { test: {path: 'value'}}}\n *\n * It also handles array notation, e.g.:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 'value'});\n *     => { foo: [null, {bar: value}] }\n *\n * It handles merges the results when two properties are specified in parallel:\n *\n *   lib.expandObjectPaths({'foo[1].bar': 10, 'foo[0].bar': 20});\n *     => { foo: [{bar: 10}, {bar: 20}] }\n *\n * It does NOT, however, merge mulitple mutliply-nested arrays::\n *\n *   lib.expandObjectPaths({'marker[1].range[1]': 5, 'marker[1].range[0]': 4})\n *     => { marker: [null, {range: 4}] }\n */\n\n// Store this to avoid recompiling regex on *every* prop since this may happen many\n// many times for animations. Could maybe be inside the function. Not sure about\n// scoping vs. recompilation tradeoff, but at least it's not just inlining it into\n// the inner loop.\nvar dottedPropertyRegex = /^([^\\[\\.]+)\\.(.+)?/;\nvar indexedPropertyRegex = /^([^\\.]+)\\[([0-9]+)\\](\\.)?(.+)?/;\n\nlib.expandObjectPaths = function(data) {\n    var match, key, prop, datum, idx, dest, trailingPath;\n    if(typeof data === 'object' && !Array.isArray(data)) {\n        for(key in data) {\n            if(data.hasOwnProperty(key)) {\n                if((match = key.match(dottedPropertyRegex))) {\n                    datum = data[key];\n                    prop = match[1];\n\n                    delete data[key];\n\n                    data[prop] = lib.extendDeepNoArrays(data[prop] || {}, lib.objectFromPath(key, lib.expandObjectPaths(datum))[prop]);\n                } else if((match = key.match(indexedPropertyRegex))) {\n                    datum = data[key];\n\n                    prop = match[1];\n                    idx = parseInt(match[2]);\n\n                    delete data[key];\n\n                    data[prop] = data[prop] || [];\n\n                    if(match[3] === '.') {\n                        // This is the case where theere are subsequent properties into which\n                        // we must recurse, e.g. transforms[0].value\n                        trailingPath = match[4];\n                        dest = data[prop][idx] = data[prop][idx] || {};\n\n                        // NB: Extend deep no arrays prevents this from working on multiple\n                        // nested properties in the same object, e.g.\n                        //\n                        // {\n                        //   foo[0].bar[1].range\n                        //   foo[0].bar[0].range\n                        // }\n                        //\n                        // In this case, the extendDeepNoArrays will overwrite one array with\n                        // the other, so that both properties *will not* be present in the\n                        // result. Fixing this would require a more intelligent tracking\n                        // of changes and merging than extendDeepNoArrays currently accomplishes.\n                        lib.extendDeepNoArrays(dest, lib.objectFromPath(trailingPath, lib.expandObjectPaths(datum)));\n                    } else {\n                        // This is the case where this property is the end of the line,\n                        // e.g. xaxis.range[0]\n                        data[prop][idx] = lib.expandObjectPaths(datum);\n                    }\n                } else {\n                    data[key] = lib.expandObjectPaths(data[key]);\n                }\n            }\n        }\n    }\n\n    return data;\n};\n\n/**\n * Converts value to string separated by the provided separators.\n *\n * @example\n * lib.numSeparate(2016, '.,');\n * // returns '2016'\n *\n * @example\n * lib.numSeparate(3000, '.,', true);\n * // returns '3,000'\n *\n * @example\n * lib.numSeparate(1234.56, '|,')\n * // returns '1,234|56'\n *\n * @param   {string|number} value       the value to be converted\n * @param   {string}    separators  string of decimal, then thousands separators\n * @param   {boolean}    separatethousands  boolean, 4-digit integers are separated if true\n *\n * @return  {string}    the value that has been separated\n */\nlib.numSeparate = function(value, separators, separatethousands) {\n    if(!separatethousands) separatethousands = false;\n\n    if(typeof separators !== 'string' || separators.length === 0) {\n        throw new Error('Separator string required for formatting!');\n    }\n\n    if(typeof value === 'number') {\n        value = String(value);\n    }\n\n    var thousandsRe = /(\\d+)(\\d{3})/;\n    var decimalSep = separators.charAt(0);\n    var thouSep = separators.charAt(1);\n\n    var x = value.split('.');\n    var x1 = x[0];\n    var x2 = x.length > 1 ? decimalSep + x[1] : '';\n\n    // Years are ignored for thousands separators\n    if(thouSep && (x.length > 1 || x1.length > 4 || separatethousands)) {\n        while(thousandsRe.test(x1)) {\n            x1 = x1.replace(thousandsRe, '$1' + thouSep + '$2');\n        }\n    }\n\n    return x1 + x2;\n};\n\nvar TEMPLATE_STRING_REGEX = /%{([^\\s%{}:]*)(:[^}]*)?}/g;\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n/**\n * Substitute values from an object into a string\n *\n * Examples:\n *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *\n * @param {string}  input string containing %{...} template strings\n * @param {obj}     data object containing substitution values\n *\n * @return {string} templated string\n */\nlib.templateString = function(string, obj) {\n    // Not all that useful, but cache nestedProperty instantiation\n    // just in case it speeds things up *slightly*:\n    var getterCache = {};\n\n    return string.replace(TEMPLATE_STRING_REGEX, function(dummy, key) {\n        if(SIMPLE_PROPERTY_REGEX.test(key)) {\n            return obj[key] || '';\n        }\n        getterCache[key] = getterCache[key] || lib.nestedProperty(obj, key).get;\n        return getterCache[key]() || '';\n    });\n};\n\nvar TEMPLATE_STRING_FORMAT_SEPARATOR = /^:/;\nvar numberOfHoverTemplateWarnings = 0;\nvar maximumNumberOfHoverTemplateWarnings = 10;\n/**\n * Substitute values from an object into a string and optionally formats them using d3-format,\n * or fallback to associated labels.\n *\n * Examples:\n *  Lib.templateString('name: %{trace}', {trace: 'asdf'}) --> 'name: asdf'\n *  Lib.templateString('name: %{trace[0].name}', {trace: [{name: 'asdf'}]}) --> 'name: asdf'\n *  Lib.templateString('price: %{y:$.2f}', {y: 1}) --> 'price: $1.00'\n *\n * @param {string}  input string containing %{...:...} template strings\n * @param {obj}     data object containing fallback text when no formatting is specified, ex.: {yLabel: 'formattedYValue'}\n * @param {obj}     data objects containing substitution values\n *\n * @return {string} templated string\n */\nlib.hovertemplateString = function(string, labels) {\n    var args = arguments;\n    // Not all that useful, but cache nestedProperty instantiation\n    // just in case it speeds things up *slightly*:\n    var getterCache = {};\n\n    return string.replace(TEMPLATE_STRING_REGEX, function(match, key, format) {\n        var obj, value, i;\n        for(i = 2; i < args.length; i++) {\n            obj = args[i];\n            if(obj.hasOwnProperty(key)) {\n                value = obj[key];\n                break;\n            }\n\n            if(!SIMPLE_PROPERTY_REGEX.test(key)) {\n                value = getterCache[key] || lib.nestedProperty(obj, key).get();\n                if(value) getterCache[key] = value;\n            }\n            if(value !== undefined) break;\n        }\n\n        if(value === undefined) {\n            if(numberOfHoverTemplateWarnings < maximumNumberOfHoverTemplateWarnings) {\n                lib.warn('Variable \\'' + key + '\\' in hovertemplate could not be found!');\n                value = match;\n            }\n\n            if(numberOfHoverTemplateWarnings === maximumNumberOfHoverTemplateWarnings) {\n                lib.warn('Too many hovertemplate warnings - additional warnings will be suppressed');\n            }\n            numberOfHoverTemplateWarnings++;\n        }\n\n        if(format) {\n            value = d3.format(format.replace(TEMPLATE_STRING_FORMAT_SEPARATOR, ''))(value);\n        } else {\n            if(labels.hasOwnProperty(key + 'Label')) value = labels[key + 'Label'];\n        }\n        return value;\n    });\n};\n\n/*\n * alphanumeric string sort, tailored for subplot IDs like scene2, scene10, x10y13 etc\n */\nvar char0 = 48;\nvar char9 = 57;\nlib.subplotSort = function(a, b) {\n    var l = Math.min(a.length, b.length) + 1;\n    var numA = 0;\n    var numB = 0;\n    for(var i = 0; i < l; i++) {\n        var charA = a.charCodeAt(i) || 0;\n        var charB = b.charCodeAt(i) || 0;\n        var isNumA = charA >= char0 && charA <= char9;\n        var isNumB = charB >= char0 && charB <= char9;\n\n        if(isNumA) numA = 10 * numA + charA - char0;\n        if(isNumB) numB = 10 * numB + charB - char0;\n\n        if(!isNumA || !isNumB) {\n            if(numA !== numB) return numA - numB;\n            if(charA !== charB) return charA - charB;\n        }\n    }\n    return numB - numA;\n};\n\n// repeatable pseudorandom generator\nvar randSeed = 2000000000;\n\nlib.seedPseudoRandom = function() {\n    randSeed = 2000000000;\n};\n\nlib.pseudoRandom = function() {\n    var lastVal = randSeed;\n    randSeed = (69069 * randSeed + 1) % 4294967296;\n    // don't let consecutive vals be too close together\n    // gets away from really trying to be random, in favor of better local uniformity\n    if(Math.abs(randSeed - lastVal) < 429496729) return lib.pseudoRandom();\n    return randSeed / 4294967296;\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACtB,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAEzC,IAAIE,YAAY,GAAGF,OAAO,CAAC,wBAAwB,CAAC;AACpD,IAAIG,OAAO,GAAGD,YAAY,CAACC,OAAO;AAClC,IAAIC,MAAM,GAAGF,YAAY,CAACE,MAAM;AAEhC,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAO,GAAG,CAAC,CAAC;AAE7BF,GAAG,CAACG,cAAc,GAAGR,OAAO,CAAC,mBAAmB,CAAC;AACjDK,GAAG,CAACI,cAAc,GAAGT,OAAO,CAAC,mBAAmB,CAAC;AACjDK,GAAG,CAACK,YAAY,GAAGV,OAAO,CAAC,iBAAiB,CAAC;AAC7CK,GAAG,CAACM,aAAa,GAAGX,OAAO,CAAC,mBAAmB,CAAC;AAChDK,GAAG,CAACO,UAAU,GAAGZ,OAAO,CAAC,gBAAgB,CAAC;AAC1CK,GAAG,CAACQ,iBAAiB,GAAGb,OAAO,CAAC,kBAAkB,CAAC;AAEnD,IAAIc,WAAW,GAAGd,OAAO,CAAC,SAAS,CAAC;AACpCK,GAAG,CAACU,YAAY,GAAGD,WAAW,CAACC,YAAY;AAC3CV,GAAG,CAACW,mBAAmB,GAAGF,WAAW,CAACE,mBAAmB;AACzDX,GAAG,CAACY,SAAS,GAAGH,WAAW,CAACG,SAAS;AACrCZ,GAAG,CAACa,WAAW,GAAGJ,WAAW,CAACI,WAAW;AACzCb,GAAG,CAACc,MAAM,GAAGL,WAAW,CAACK,MAAM;AAC/Bd,GAAG,CAACe,YAAY,GAAGN,WAAW,CAACM,YAAY;AAC3Cf,GAAG,CAACgB,YAAY,GAAGP,WAAW,CAACO,YAAY;AAE3C,IAAIC,SAAS,GAAGtB,OAAO,CAAC,OAAO,CAAC;AAChCK,GAAG,CAACkB,GAAG,GAAGD,SAAS,CAACC,GAAG;AACvBlB,GAAG,CAACmB,OAAO,GAAGF,SAAS,CAACE,OAAO;AAE/B,IAAIC,YAAY,GAAGzB,OAAO,CAAC,UAAU,CAAC;AACtCK,GAAG,CAACqB,aAAa,GAAGD,YAAY,CAACC,aAAa;AAC9CrB,GAAG,CAACsB,MAAM,GAAGF,YAAY,CAACE,MAAM;AAChCtB,GAAG,CAACuB,OAAO,GAAGH,YAAY,CAACG,OAAO;AAClCvB,GAAG,CAACwB,UAAU,GAAGJ,YAAY,CAACI,UAAU;AACxCxB,GAAG,CAACyB,eAAe,GAAGL,YAAY,CAACK,eAAe;AAClDzB,GAAG,CAAC0B,4BAA4B,GAAGN,YAAY,CAACM,4BAA4B;AAC5E1B,GAAG,CAAC2B,QAAQ,GAAGP,YAAY,CAACO,QAAQ;AAEpC,IAAIC,WAAW,GAAGjC,OAAO,CAAC,SAAS,CAAC;AACpCK,GAAG,CAAC6B,WAAW,GAAGD,WAAW,CAACC,WAAW;AACzC7B,GAAG,CAAC8B,UAAU,GAAGF,WAAW,CAACE,UAAU;AACvC9B,GAAG,CAAC+B,WAAW,GAAGH,WAAW,CAACG,WAAW;AACzC/B,GAAG,CAACgC,gBAAgB,GAAGJ,WAAW,CAACI,gBAAgB;AACnDhC,GAAG,CAACiC,SAAS,GAAGL,WAAW,CAACK,SAAS;AACrCjC,GAAG,CAACkC,QAAQ,GAAGN,WAAW,CAACM,QAAQ;AACnClC,GAAG,CAACmC,UAAU,GAAGP,WAAW,CAACO,UAAU;AACvCnC,GAAG,CAACoC,cAAc,GAAGR,WAAW,CAACQ,cAAc;AAC/CpC,GAAG,CAACqC,SAAS,GAAGT,WAAW,CAACS,SAAS;AACrCrC,GAAG,CAACsC,SAAS,GAAGV,WAAW,CAACU,SAAS;AACrCtC,GAAG,CAACuC,cAAc,GAAGX,WAAW,CAACW,cAAc;AAC/CvC,GAAG,CAACwC,MAAM,GAAGZ,WAAW,CAACY,MAAM;AAC/BxC,GAAG,CAACyC,MAAM,GAAGb,WAAW,CAACa,MAAM;AAE/B,IAAIC,YAAY,GAAG/C,OAAO,CAAC,UAAU,CAAC;AACtCK,GAAG,CAAC2C,OAAO,GAAGD,YAAY,CAACC,OAAO;AAClC3C,GAAG,CAAC4C,SAAS,GAAGF,YAAY,CAACE,SAAS;AACtC5C,GAAG,CAAC6C,SAAS,GAAGH,YAAY,CAACG,SAAS;AACtC7C,GAAG,CAAC8C,YAAY,GAAGJ,YAAY,CAACI,YAAY;AAC5C9C,GAAG,CAAC+C,OAAO,GAAGL,YAAY,CAACK,OAAO;AAClC/C,GAAG,CAACgD,IAAI,GAAGN,YAAY,CAACM,IAAI;AAC5BhD,GAAG,CAACiD,cAAc,GAAGP,YAAY,CAACO,cAAc;AAEhD,IAAIC,WAAW,GAAGvD,OAAO,CAAC,SAAS,CAAC;AACpCK,GAAG,CAACmD,OAAO,GAAGD,WAAW,CAACC,OAAO;AACjCnD,GAAG,CAACoD,GAAG,GAAGF,WAAW,CAACE,GAAG;AACzBpD,GAAG,CAACqD,IAAI,GAAGH,WAAW,CAACG,IAAI;AAC3BrD,GAAG,CAACsD,QAAQ,GAAGJ,WAAW,CAACI,QAAQ;AACnCtD,GAAG,CAACuD,QAAQ,GAAGL,WAAW,CAACK,QAAQ;AACnCvD,GAAG,CAACwD,KAAK,GAAGN,WAAW,CAACM,KAAK;AAC7BxD,GAAG,CAACyD,MAAM,GAAGP,WAAW,CAACO,MAAM;AAE/B,IAAIC,YAAY,GAAG/D,OAAO,CAAC,UAAU,CAAC;AACtCK,GAAG,CAAC2D,WAAW,GAAGD,YAAY,CAACC,WAAW;AAC1C3D,GAAG,CAAC4D,eAAe,GAAGF,YAAY,CAACE,eAAe;AAClD5D,GAAG,CAAC6D,GAAG,GAAGH,YAAY,CAACG,GAAG;AAC1B7D,GAAG,CAAC8D,iBAAiB,GAAGJ,YAAY,CAACI,iBAAiB;AACtD9D,GAAG,CAAC+D,cAAc,GAAGL,YAAY,CAACK,cAAc;AAChD/D,GAAG,CAACgE,gBAAgB,GAAGN,YAAY,CAACM,gBAAgB;AACpDhE,GAAG,CAACiE,gBAAgB,GAAGP,YAAY,CAACO,gBAAgB;AACpDjE,GAAG,CAACkE,iBAAiB,GAAGR,YAAY,CAACQ,iBAAiB;AAEtD,IAAIC,YAAY,GAAGxE,OAAO,CAAC,UAAU,CAAC;AACtCK,GAAG,CAACoE,OAAO,GAAGD,YAAY,CAACC,OAAO;AAClCpE,GAAG,CAACqE,OAAO,GAAGF,YAAY,CAACE,OAAO;AAClCrE,GAAG,CAACsE,UAAU,GAAGH,YAAY,CAACG,UAAU;AACxCtE,GAAG,CAACuE,SAAS,GAAGJ,YAAY,CAACI,SAAS;AACtCvE,GAAG,CAACwE,YAAY,GAAGL,YAAY,CAACK,YAAY;AAC5CxE,GAAG,CAACyE,mBAAmB,GAAGN,YAAY,CAACM,mBAAmB;AAC1DzE,GAAG,CAAC0E,gBAAgB,GAAGP,YAAY,CAACO,gBAAgB;AACpD1E,GAAG,CAAC2E,OAAO,GAAGR,YAAY,CAACQ,OAAO;AAClC3E,GAAG,CAAC4E,UAAU,GAAGT,YAAY,CAACS,UAAU;AACxC5E,GAAG,CAAC6E,WAAW,GAAGV,YAAY,CAACU,WAAW;AAE1C,IAAIC,WAAW,GAAGnF,OAAO,CAAC,gBAAgB,CAAC;AAC3CK,GAAG,CAAC+E,YAAY,GAAGD,WAAW,CAACC,YAAY;AAC3C/E,GAAG,CAACgF,cAAc,GAAGF,WAAW,CAACE,cAAc;AAC/ChF,GAAG,CAACiF,aAAa,GAAGH,WAAW,CAACG,aAAa;AAC7CjF,GAAG,CAACkF,WAAW,GAAGJ,WAAW,CAACI,WAAW;AACzClF,GAAG,CAACmF,cAAc,GAAGL,WAAW,CAACK,cAAc;AAC/CnF,GAAG,CAACoF,cAAc,GAAGN,WAAW,CAACM,cAAc;AAE/C,IAAIC,YAAY,GAAG1F,OAAO,CAAC,cAAc,CAAC;AAC1CK,GAAG,CAACsF,iBAAiB,GAAGD,YAAY,CAACC,iBAAiB;AACtDtF,GAAG,CAACuF,eAAe,GAAGF,YAAY,CAACE,eAAe;AAClDvF,GAAG,CAACwF,eAAe,GAAGH,YAAY,CAACG,eAAe;AAClDxF,GAAG,CAACyF,kBAAkB,GAAGJ,YAAY,CAACI,kBAAkB;AACxDzF,GAAG,CAAC0F,iBAAiB,GAAGL,YAAY,CAACK,iBAAiB;AACtD1F,GAAG,CAAC2F,eAAe,GAAGN,YAAY,CAACM,eAAe;AAElD,IAAIC,YAAY,GAAGjG,OAAO,CAAC,UAAU,CAAC;AACtCK,GAAG,CAAC6F,UAAU,GAAGD,YAAY,CAACC,UAAU;AACxC7F,GAAG,CAAC8F,UAAU,GAAGF,YAAY,CAACE,UAAU;AACxC9F,GAAG,CAAC+F,aAAa,GAAGH,YAAY,CAACG,aAAa;AAC9C/F,GAAG,CAACgG,kBAAkB,GAAGJ,YAAY,CAACI,kBAAkB;AAExD,IAAIC,aAAa,GAAGtG,OAAO,CAAC,WAAW,CAAC;AACxCK,GAAG,CAACkG,GAAG,GAAGD,aAAa,CAACC,GAAG;AAC3BlG,GAAG,CAACmG,IAAI,GAAGF,aAAa,CAACE,IAAI;AAC7BnG,GAAG,CAACoG,KAAK,GAAGH,aAAa,CAACG,KAAK;AAE/B,IAAIC,WAAW,GAAG1G,OAAO,CAAC,SAAS,CAAC;AACpCK,GAAG,CAACsG,YAAY,GAAGD,WAAW,CAACE,OAAO;AAEtC,IAAIC,cAAc,GAAG7G,OAAO,CAAC,YAAY,CAAC;AAC1CK,GAAG,CAACyG,QAAQ,GAAGD,cAAc,CAACC,QAAQ;AACtCzG,GAAG,CAAC0G,YAAY,GAAGF,cAAc,CAACG,IAAI;AACtC3G,GAAG,CAAC4G,aAAa,GAAGJ,cAAc,CAACK,KAAK;AAExC7G,GAAG,CAAC8G,WAAW,GAAGnH,OAAO,CAAC,iBAAiB,CAAC;AAE5CK,GAAG,CAAC+G,eAAe,GAAGpH,OAAO,CAAC,oBAAoB,CAAC;AAEnDK,GAAG,CAACgH,eAAe,GAAGrH,OAAO,CAAC,qBAAqB,CAAC;AAEpDK,GAAG,CAACiH,CAAC,GAAGtH,OAAO,CAAC,YAAY,CAAC;AAE7BK,GAAG,CAACkH,QAAQ,GAAGvH,OAAO,CAAC,YAAY,CAAC;AAEpCK,GAAG,CAACmH,YAAY,GAAGxH,OAAO,CAAC,iBAAiB,CAAC;AAC7CK,GAAG,CAACoH,aAAa,GAAGzH,OAAO,CAAC,kBAAkB,CAAC;AAC/CK,GAAG,CAACqH,UAAU,GAAG1H,OAAO,CAAC,eAAe,CAAC;AAEzCK,GAAG,CAACsH,WAAW,GAAG3H,OAAO,CAAC,gBAAgB,CAAC;AAE3CK,GAAG,CAACuH,YAAY,GAAG,SAASC,GAAG,CAACC,CAAC,EAAE;EAC/B,IAAG,CAAC7H,SAAS,CAAC6H,CAAC,CAAC,EAAE,OAAO1H,MAAM;EAC/B0H,CAAC,GAAGC,MAAM,CAACD,CAAC,CAAC;EACb,IAAGA,CAAC,GAAG,CAAC3H,OAAO,IAAI2H,CAAC,GAAG3H,OAAO,EAAE,OAAOC,MAAM;EAC7C,OAAOH,SAAS,CAAC6H,CAAC,CAAC,GAAGC,MAAM,CAACD,CAAC,CAAC,GAAG1H,MAAM;AAC5C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,GAAG,CAAC2H,OAAO,GAAG,UAASF,CAAC,EAAErE,GAAG,EAAE;EAC3B,IAAGA,GAAG,KAAKwE,SAAS,IAAIH,CAAC,IAAIrE,GAAG,EAAE,OAAO,KAAK;EAC9C,OAAOxD,SAAS,CAAC6H,CAAC,CAAC,IAAKA,CAAC,IAAI,CAAE,IAAKA,CAAC,GAAG,CAAC,KAAK,CAAE;AACpD,CAAC;AAEDzH,GAAG,CAAC6H,IAAI,GAAGlI,OAAO,CAAC,QAAQ,CAAC;AAC5BK,GAAG,CAAC8H,QAAQ,GAAGnI,OAAO,CAAC,YAAY,CAAC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACAK,GAAG,CAAC+H,MAAM,GAAG,UAASN,CAAC,EAAEO,GAAG,EAAE;EAC1B,IAAIC,GAAG,GAAG,IAAIC,KAAK,CAACF,GAAG,CAAC;EACxB,KAAI,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,GAAG,EAAEG,CAAC,EAAE,EAAE;IACzBF,GAAG,CAACE,CAAC,CAAC,GAAGV,CAAC;EACd;EACA,OAAOQ,GAAG;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjI,GAAG,CAACoI,SAAS,GAAG,UAASC,IAAI,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,KAAK,EAAE;EACnD,IAAG,CAACD,KAAK,EAAEA,KAAK,GAAG,GAAG;EACtB,IAAG,CAACC,KAAK,EAAEA,KAAK,GAAG,GAAG;EACtB,KAAI,IAAIL,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,QAAQ,CAACG,MAAM,EAAEN,CAAC,EAAE,EAAE;IACrC,IAAIO,IAAI,GAAGJ,QAAQ,CAACH,CAAC,CAAC;IACtB,IAAIQ,EAAE,GAAG3I,GAAG,CAACG,cAAc,CAACkI,IAAI,EAAEK,IAAI,CAACE,OAAO,CAAC,GAAG,EAAEL,KAAK,CAAC,CAAC;IAC3D,IAAIM,EAAE,GAAG7I,GAAG,CAACG,cAAc,CAACkI,IAAI,EAAEK,IAAI,CAACE,OAAO,CAAC,GAAG,EAAEJ,KAAK,CAAC,CAAC;IAC3D,IAAIM,IAAI,GAAGH,EAAE,CAACI,GAAG,EAAE;IACnBJ,EAAE,CAACK,GAAG,CAACH,EAAE,CAACE,GAAG,EAAE,CAAC;IAChBF,EAAE,CAACG,GAAG,CAACF,IAAI,CAAC;EAChB;AACJ,CAAC;;AAED;AACA;AACA;AACA9I,GAAG,CAACiJ,UAAU,GAAG,SAASA,UAAU,CAACC,IAAI,EAAE;EACvCA,IAAI,CAACC,UAAU,CAACC,WAAW,CAACF,IAAI,CAAC;AACrC,CAAC;;AAED;AACA;AACA;AACAlJ,GAAG,CAACqJ,gBAAgB,GAAG,UAASC,SAAS,EAAE;EACvC,OAAOA,SAAS,CAACC,UAAU,EAAE,CAACC,QAAQ,CAAC,CAAC,CAAC;AAC7C,CAAC;;AAED;AACAxJ,GAAG,CAACyJ,SAAS,GAAG,UAAShC,CAAC,EAAEiC,EAAE,EAAEC,EAAE,EAAE;EAChC,IAAGD,EAAE,GAAGC,EAAE,EAAE,OAAOC,IAAI,CAACC,GAAG,CAACF,EAAE,EAAEC,IAAI,CAACE,GAAG,CAACJ,EAAE,EAAEjC,CAAC,CAAC,CAAC;EAChD,OAAOmC,IAAI,CAACC,GAAG,CAACH,EAAE,EAAEE,IAAI,CAACE,GAAG,CAACH,EAAE,EAAElC,CAAC,CAAC,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAzH,GAAG,CAAC+J,aAAa,GAAG,UAASC,CAAC,EAAEC,CAAC,EAAEC,GAAG,EAAE;EACpCA,GAAG,GAAGA,GAAG,IAAI,CAAC;EACd,OAAQF,CAAC,CAACG,IAAI,IAAIF,CAAC,CAACG,KAAK,GAAGF,GAAG,IACvBD,CAAC,CAACE,IAAI,IAAIH,CAAC,CAACI,KAAK,GAAGF,GAAG,IACvBF,CAAC,CAACK,GAAG,IAAIJ,CAAC,CAACK,MAAM,GAAGJ,GAAG,IACvBD,CAAC,CAACI,GAAG,IAAIL,CAAC,CAACM,MAAM,GAAGJ,GAAG;AACnC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlK,GAAG,CAACuK,SAAS,GAAG,UAASC,KAAK,EAAEC,IAAI,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC1C,IAAIvH,GAAG,GAAGoH,KAAK,CAAC/B,MAAM;EACtB,IAAIR,GAAG,GAAG,IAAIC,KAAK,CAAC9E,GAAG,CAAC;EACxB,KAAI,IAAI+E,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG/E,GAAG,EAAE+E,CAAC,EAAE;IAAEF,GAAG,CAACE,CAAC,CAAC,GAAGsC,IAAI,CAACD,KAAK,CAACrC,CAAC,CAAC,EAAEuC,EAAE,EAAEC,EAAE,CAAC;EAAC;EAC7D,OAAO1C,GAAG;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjI,GAAG,CAAC4K,OAAO,GAAG,SAASA,OAAO,CAACC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAEC,UAAU,EAAE;EAC7D,IAAG,CAACD,IAAI,EAAEA,IAAI,GAAG,EAAE;EACnB,IAAGD,IAAI,KAAKlD,SAAS,EAAEkD,IAAI,GAAG,EAAE;EAChC,IAAGA,IAAI,IAAI,CAAC,EAAE,OAAO,GAAG;EAExB,IAAIG,MAAM,GAAGrB,IAAI,CAAC1D,GAAG,CAAC0D,IAAI,CAACsB,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAAC,CAAC,GAAGlB,IAAI,CAAC1D,GAAG,CAAC6E,IAAI,CAAC;EACzD,IAAII,GAAG,GAAG,EAAE;EACZ,IAAIhD,CAAC,EAAE8B,CAAC,EAAEmB,CAAC;EAEX,KAAIjD,CAAC,GAAG,CAAC,EAAE8C,MAAM,KAAKI,QAAQ,EAAElD,CAAC,IAAI,CAAC,EAAE;IACpC8C,MAAM,GAAGrB,IAAI,CAAC1D,GAAG,CAAC0D,IAAI,CAACsB,GAAG,CAAC,CAAC,EAAEJ,IAAI,GAAG3C,CAAC,CAAC,CAAC,GAAGyB,IAAI,CAAC1D,GAAG,CAAC6E,IAAI,CAAC,GAAG5C,CAAC;EACjE;EAEA,IAAImD,GAAG,GAAGL,MAAM,GAAGrB,IAAI,CAAC2B,KAAK,CAACN,MAAM,CAAC;EAErC,KAAI9C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyB,IAAI,CAAC2B,KAAK,CAACN,MAAM,CAAC,EAAE9C,CAAC,EAAE,EAAE;IACpCiD,CAAC,GAAGxB,IAAI,CAAC2B,KAAK,CAAC3B,IAAI,CAAC4B,MAAM,EAAE,GAAGT,IAAI,CAAC,CAACU,QAAQ,CAACV,IAAI,CAAC;IACnDI,GAAG,GAAGC,CAAC,GAAGD,GAAG;EACjB;EAEA,IAAGG,GAAG,EAAE;IACJrB,CAAC,GAAGL,IAAI,CAACsB,GAAG,CAACH,IAAI,EAAEO,GAAG,CAAC;IACvBF,CAAC,GAAGxB,IAAI,CAAC2B,KAAK,CAAC3B,IAAI,CAAC4B,MAAM,EAAE,GAAGvB,CAAC,CAAC,CAACwB,QAAQ,CAACV,IAAI,CAAC;IAChDI,GAAG,GAAGC,CAAC,GAAGD,GAAG;EACjB;EAEA,IAAIO,MAAM,GAAGC,QAAQ,CAACR,GAAG,EAAEJ,IAAI,CAAC;EAChC,IAAIF,QAAQ,IAAIA,QAAQ,CAACM,GAAG,CAAC,IACvBO,MAAM,KAAKL,QAAQ,IAAIK,MAAM,IAAI9B,IAAI,CAACsB,GAAG,CAAC,CAAC,EAAEJ,IAAI,CAAE,EAAE;IACvD,IAAGE,UAAU,GAAG,EAAE,EAAE;MAChBhL,GAAG,CAACmG,IAAI,CAAC,2BAA2B,CAAC;MACrC,OAAOgF,GAAG;IACd;IACA,OAAOP,OAAO,CAACC,QAAQ,EAAEC,IAAI,EAAEC,IAAI,EAAE,CAACC,UAAU,IAAI,CAAC,IAAI,CAAC,CAAC;EAC/D,CAAC,MACI,OAAOG,GAAG;AACnB,CAAC;AAEDnL,GAAG,CAAC4L,aAAa,GAAG,UAASC,GAAG,EAAEC,OAAO,EAAE;EACvC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAG,CAACD,GAAG,EAAEA,GAAG,GAAG,CAAC,CAAC;EACjB,IAAG,CAACC,OAAO,EAAEA,OAAO,GAAG,KAAK;EAE5B,IAAIC,IAAI,GAAG,CAAC,CAAC;EACbA,IAAI,CAACC,UAAU,GAAG,EAAE;EAEpBD,IAAI,CAACE,UAAU,GAAG,UAASC,MAAM,EAAE;IAC/BA,MAAM,CAACJ,OAAO,CAAC,GAAGD,GAAG;IACrBE,IAAI,CAACG,MAAM,CAACC,IAAI,CAAC,GAAGD,MAAM;IAC1BH,IAAI,CAACC,UAAU,CAACI,IAAI,CAACF,MAAM,CAAC;EAChC,CAAC;EAEDH,IAAI,CAAC,GAAG,GAAGD,OAAO,CAAC,GAAGD,GAAG;EACzB,OAAOE,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA/L,GAAG,CAACqM,MAAM,GAAG,UAASC,OAAO,EAAEC,IAAI,EAAE;EACjCA,IAAI,GAAG3C,IAAI,CAAC4C,KAAK,CAACD,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;EAC9B,IAAGA,IAAI,GAAG,CAAC,EAAE,OAAOD,OAAO;EAE3B,IAAIG,IAAI,GAAGH,OAAO,CAAC7D,MAAM;EACzB,IAAIiE,KAAK,GAAG,CAAC,GAAGD,IAAI;EACpB,IAAIE,IAAI,GAAG,CAAC,GAAGJ,IAAI,GAAG,CAAC;EACvB,IAAIK,CAAC,GAAG,IAAI1E,KAAK,CAACyE,IAAI,CAAC;EACvB,IAAIE,QAAQ,GAAG,IAAI3E,KAAK,CAACuE,IAAI,CAAC;EAC9B,IAAItE,CAAC;EACL,IAAI2E,CAAC;EACL,IAAIC,CAAC;EACL,IAAItF,CAAC;;EAEL;EACA,KAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,IAAI,EAAExE,CAAC,EAAE,EAAE;IACtByE,CAAC,CAACzE,CAAC,CAAC,GAAG,CAAC,CAAC,GAAGyB,IAAI,CAACoD,GAAG,CAACpD,IAAI,CAACqD,EAAE,IAAI9E,CAAC,GAAG,CAAC,CAAC,GAAGoE,IAAI,CAAC,KAAK,CAAC,GAAGA,IAAI,CAAC;EAChE;;EAEA;EACA,KAAIpE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsE,IAAI,EAAEtE,CAAC,EAAE,EAAE;IACtBV,CAAC,GAAG,CAAC;IACL,KAAIqF,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,IAAI,EAAEG,CAAC,EAAE,EAAE;MACtBC,CAAC,GAAG5E,CAAC,GAAG2E,CAAC,GAAG,CAAC,GAAGP,IAAI;;MAEpB;MACA,IAAGQ,CAAC,GAAG,CAACN,IAAI,EAAEM,CAAC,IAAIL,KAAK,GAAG9C,IAAI,CAAC4C,KAAK,CAACO,CAAC,GAAGL,KAAK,CAAC,CAAC,KAC5C,IAAGK,CAAC,IAAIL,KAAK,EAAEK,CAAC,IAAIL,KAAK,GAAG9C,IAAI,CAAC2B,KAAK,CAACwB,CAAC,GAAGL,KAAK,CAAC;;MAEtD;MACA,IAAGK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,CAAE,CAAC,GAAGA,CAAC,CAAC,KACjB,IAAGA,CAAC,IAAIN,IAAI,EAAEM,CAAC,GAAGL,KAAK,GAAG,CAAC,GAAGK,CAAC;MAEpCtF,CAAC,IAAI6E,OAAO,CAACS,CAAC,CAAC,GAAGH,CAAC,CAACE,CAAC,CAAC;IAC1B;IACAD,QAAQ,CAAC1E,CAAC,CAAC,GAAGV,CAAC;EACnB;EAEA,OAAOoF,QAAQ;AACnB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7M,GAAG,CAACkN,WAAW,GAAG,UAASC,QAAQ,EAAEC,GAAG,EAAEC,SAAS,EAAE;EACjD,IAAIC,GAAG,EAAEC,GAAG;EAEZ,SAASC,aAAa,GAAG;IACrB,OAAOxN,GAAG,CAACkN,WAAW,CAACC,QAAQ,EAAEC,GAAG,EAAEC,SAAS,CAAC;EACpD;EAEA,OAAMF,QAAQ,CAAC1E,MAAM,EAAE;IACnB8E,GAAG,GAAGJ,QAAQ,CAACM,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9BH,GAAG,GAAGC,GAAG,CAACH,GAAG,CAAC;IAEd,IAAGE,GAAG,IAAIA,GAAG,CAACI,IAAI,EAAE;MAChB,OAAOJ,GAAG,CAACI,IAAI,CAACF,aAAa,CAAC,CACzBE,IAAI,CAAC9F,SAAS,EAAE5H,GAAG,CAAC2N,YAAY,CAAC;IAC1C;EACJ;EAEA,OAAON,SAAS,IAAIA,SAAS,CAACD,GAAG,CAAC;AACtC,CAAC;;AAGD;AACA;AACA;AACA;AACApN,GAAG,CAAC4N,kBAAkB,GAAG,UAASC,GAAG,EAAE;EACnC,IAAGA,GAAG,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,OAAOD,GAAG,CAACC,MAAM,CAAC,CAAC,EAAED,GAAG,CAACpF,MAAM,GAAG,CAAC,CAAC;EAC/D,OAAOoF,GAAG;AACd,CAAC;AAED7N,GAAG,CAAC+N,SAAS,GAAG,UAASC,WAAW,EAAEC,YAAY,EAAE3F,QAAQ,EAAE;EAC1D;AACJ;AACA;AACA;AACA;EACI,IAAG,CAAC0F,WAAW,EAAE;EAEjB,IAAIE,MAAM,GAAG,KAAK;EAClB,IAAIC,MAAM,GAAG,IAAI;EACjB,IAAIhG,CAAC;EACL,IAAIiG,GAAG;EAEP,KAAIjG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,QAAQ,CAACG,MAAM,EAAEN,CAAC,EAAE,EAAE;IACjCiG,GAAG,GAAGJ,WAAW,CAAC1F,QAAQ,CAACH,CAAC,CAAC,CAAC;IAC9B,IAAGiG,GAAG,KAAKxG,SAAS,IAAIwG,GAAG,KAAK,IAAI,EAAEF,MAAM,GAAG,IAAI,CAAC,KAC/CC,MAAM,GAAG,KAAK;EACvB;EAEA,IAAGD,MAAM,IAAI,CAACC,MAAM,EAAE;IAClB,KAAIhG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGG,QAAQ,CAACG,MAAM,EAAEN,CAAC,EAAE,EAAE;MACjC6F,WAAW,CAAC1F,QAAQ,CAACH,CAAC,CAAC,CAAC,GAAG8F,YAAY,CAAC3F,QAAQ,CAACH,CAAC,CAAC,CAAC;IACxD;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnI,GAAG,CAACqO,UAAU,GAAG,UAASC,SAAS,EAAEC,EAAE,EAAEC,MAAM,EAAE;EAC7C,IAAGxO,GAAG,CAACW,mBAAmB,CAAC2N,SAAS,CAAC,EAAE;IACnC,IAAIG,IAAI,GAAG7E,IAAI,CAACE,GAAG,CAACwE,SAAS,CAAC7F,MAAM,EAAE8F,EAAE,CAAC9F,MAAM,CAAC;IAChD,KAAI,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsG,IAAI,EAAEtG,CAAC,EAAE;MAAEoG,EAAE,CAACpG,CAAC,CAAC,CAACqG,MAAM,CAAC,GAAGF,SAAS,CAACnG,CAAC,CAAC;IAAC;EAC/D;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnI,GAAG,CAAC0O,SAAS,GAAG,UAASJ,SAAS,EAAEC,EAAE,EAAEC,MAAM,EAAEG,EAAE,EAAE;EAChDA,EAAE,GAAGA,EAAE,IAAI3O,GAAG,CAAC8H,QAAQ;EAEvB,IAAG9H,GAAG,CAACW,mBAAmB,CAAC2N,SAAS,CAAC,EAAE;IACnC,KAAI,IAAInG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoG,EAAE,CAAC9F,MAAM,EAAEN,CAAC,EAAE,EAAE;MAC/BoG,EAAE,CAACpG,CAAC,CAAC,CAACqG,MAAM,CAAC,GAAGG,EAAE,CAACL,SAAS,CAACnG,CAAC,CAAC,CAAC;IACpC;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAnI,GAAG,CAAC4O,UAAU,GAAG,UAASC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAEJ,EAAE,EAAE;EACjDA,EAAE,GAAGA,EAAE,IAAI3O,GAAG,CAAC8H,QAAQ;EAEvB,IAAIsG,GAAG,GAAGpO,GAAG,CAACG,cAAc,CAAC0O,KAAK,EAAEE,IAAI,CAAC,CAAChG,GAAG,EAAE;EAE/C,IAAG/I,GAAG,CAACW,mBAAmB,CAACyN,GAAG,CAAC,EAAE;IAC7B,IAAGlG,KAAK,CAAC8G,OAAO,CAACF,QAAQ,CAAC,IAAI9O,GAAG,CAACW,mBAAmB,CAACyN,GAAG,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;MACrE,OAAOH,EAAE,CAACP,GAAG,CAACU,QAAQ,CAAC,CAAC,CAAC,CAAC,CAACA,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;IAC5C,CAAC,MAAM;MACH,OAAOH,EAAE,CAACP,GAAG,CAACU,QAAQ,CAAC,CAAC;IAC5B;EACJ,CAAC,MAAM;IACH,OAAOV,GAAG;EACd;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACApO,GAAG,CAACiP,aAAa,GAAG,UAASC,MAAM,EAAEL,KAAK,EAAEM,OAAO,EAAEC,QAAQ,EAAE;EAC3D,IAAGD,OAAO,IAAID,MAAM,EAAE,OAAOA,MAAM,CAACC,OAAO,CAAC;;EAE5C;EACA;EACA;EACA;EACA,IAAIE,QAAQ,GAAGrP,GAAG,CAACG,cAAc,CAAC0O,KAAK,EAAEO,QAAQ,CAAC,CAACrG,GAAG,EAAE;EACxD,IAAG,CAACb,KAAK,CAAC8G,OAAO,CAACK,QAAQ,CAAC,EAAE,OAAOA,QAAQ;AAChD,CAAC;AAED,SAASC,oBAAoB,CAACC,aAAa,EAAE;EACzC,IAAIC,gBAAgB,GAAG,CAAC,CAAC;EACzB,KAAI,IAAIzC,CAAC,IAAIwC,aAAa,EAAE;IACxB,IAAIE,GAAG,GAAGF,aAAa,CAACxC,CAAC,CAAC;IAC1B,KAAI,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG2C,GAAG,CAAChH,MAAM,EAAEqE,CAAC,EAAE,EAAE;MAChC0C,gBAAgB,CAACC,GAAG,CAAC3C,CAAC,CAAC,CAAC,GAAG,CAACC,CAAC;IACjC;EACJ;EACA,OAAOyC,gBAAgB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAxP,GAAG,CAAC0P,WAAW,GAAG,UAASC,SAAS,EAAEd,KAAK,EAAEe,gBAAgB,EAAE;EAC3D,IAAIC,cAAc,GAAGhB,KAAK,CAACgB,cAAc;EACzC,IAAIN,aAAa,GAAGV,KAAK,CAACiB,cAAc;EACxC,IAAIN,gBAAgB;;EAEpB;EACA,IAAGD,aAAa,EAAE;IACdC,gBAAgB,GAAGF,oBAAoB,CAACC,aAAa,CAAC;EAC1D;EAEA,SAASQ,cAAc,CAACtI,CAAC,EAAE;IACvB,OAAOA,CAAC,KAAKG,SAAS,IAAIH,CAAC,GAAGkI,SAAS,CAAClH,MAAM;EAClD;EAEA,KAAI,IAAIN,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0H,cAAc,CAACpH,MAAM,EAAEN,CAAC,EAAE,EAAE;IAC3C,IAAI6H,OAAO,GAAGH,cAAc,CAAC1H,CAAC,CAAC;IAE/B,IAAGnI,GAAG,CAAC2H,OAAO,CAACqI,OAAO,CAAC,EAAE;MACrB,IAAIlB,QAAQ,GAAGU,gBAAgB,GAAGA,gBAAgB,CAACQ,OAAO,CAAC,GAAGA,OAAO;MACrE,IAAIC,OAAO,GAAGL,gBAAgB,GAAGA,gBAAgB,CAACd,QAAQ,CAAC,GAAGA,QAAQ;MAEtE,IAAGiB,cAAc,CAACE,OAAO,CAAC,EAAE;QACxBN,SAAS,CAACM,OAAO,CAAC,CAACC,QAAQ,GAAG,CAAC;MACnC;IACJ;EACJ;AACJ,CAAC;AAEDlQ,GAAG,CAACmQ,oBAAoB,GAAG,UAAStB,KAAK,EAAE;EACvC,IAAIgB,cAAc,GAAGhB,KAAK,CAACgB,cAAc;EACzC,IAAIN,aAAa,GAAGV,KAAK,CAACiB,cAAc;EAExC,IAAGP,aAAa,EAAE;IACd,IAAIC,gBAAgB,GAAGF,oBAAoB,CAACC,aAAa,CAAC;IAC1D,IAAItH,GAAG,GAAG,EAAE;IAEZ,KAAI,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG0H,cAAc,CAACpH,MAAM,EAAEN,CAAC,EAAE,EAAE;MAC3C,IAAI6H,OAAO,GAAGH,cAAc,CAAC1H,CAAC,CAAC;MAC/B,IAAGnI,GAAG,CAAC2H,OAAO,CAACqI,OAAO,CAAC,EAAE;QACrB,IAAIlB,QAAQ,GAAGU,gBAAgB,CAACQ,OAAO,CAAC;QACxC,IAAGhQ,GAAG,CAAC2H,OAAO,CAACmH,QAAQ,CAAC,EAAE;UACtB7G,GAAG,CAACmE,IAAI,CAAC0C,QAAQ,CAAC;QACtB;MACJ;IACJ;IAEA,OAAO7G,GAAG;EACd,CAAC,MAAM;IACH,OAAO4H,cAAc;EACzB;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7P,GAAG,CAACoQ,cAAc,GAAG,UAASvB,KAAK,EAAEwB,aAAa,EAAE;EAChD,IAAIC,MAAM,GAAGD,aAAa,CAACC,MAAM;EAEjC,IAAG,OAAOA,MAAM,KAAK,QAAQ,IAAIA,MAAM,EAAE;IACrC,IAAI9F,KAAK,GAAGxK,GAAG,CAACG,cAAc,CAAC0O,KAAK,EAAEyB,MAAM,CAAC,CAACvH,GAAG,EAAE;IACnD,OAAOb,KAAK,CAAC8G,OAAO,CAACxE,KAAK,CAAC,GAAGA,KAAK,GAAG,KAAK;EAC/C,CAAC,MAAM,IAAGtC,KAAK,CAAC8G,OAAO,CAACsB,MAAM,CAAC,EAAE;IAC7B,OAAOA,MAAM;EACjB;EAEA,OAAO,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAtQ,GAAG,CAACuQ,SAAS,GAAG,UAASC,IAAI,EAAEC,IAAI,EAAE;EACjC,IAAIC,MAAM,GAAG,CAAC,CAAC;EACf,IAAG,OAAOD,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAG,CAAC,CAAC;EACtC,IAAIE,QAAQ,GAAG,CAAC;EAChB,IAAIC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACJ,IAAI,CAAC;EAC5B,IAAIrI,CAAC,EAAE4E,CAAC,EAAEtF,CAAC;EAEX,KAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,IAAI,CAACnI,MAAM,EAAEN,CAAC,EAAE,EAAE;IAC7B4E,CAAC,GAAG6D,IAAI,CAACzI,CAAC,CAAC;IACXV,CAAC,GAAG+I,IAAI,CAACzD,CAAC,CAAC;IACX,IAAGA,CAAC,CAAC+D,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,IAAI,OAAOrJ,CAAC,KAAK,UAAU,EAAE,SAAS,KACvD,IAAGsF,CAAC,KAAK,QAAQ,EAAE2D,MAAM,CAAC3D,CAAC,CAAC,GAAGtF,CAAC,CAAC,KACjC,IAAGS,KAAK,CAAC8G,OAAO,CAACvH,CAAC,CAAC,EAAE;MACtB,IAAGsF,CAAC,KAAK,YAAY,EAAE;QACnB2D,MAAM,CAAC3D,CAAC,CAAC,GAAGtF,CAAC,CAACsJ,KAAK,EAAE;MACzB,CAAC,MAAM;QACHL,MAAM,CAAC3D,CAAC,CAAC,GAAGtF,CAAC,CAACsJ,KAAK,CAAC,CAAC,EAAEJ,QAAQ,CAAC;MACpC;IACJ,CAAC,MACI,IAAGlJ,CAAC,IAAK,OAAOA,CAAC,KAAK,QAAS,EAAEiJ,MAAM,CAAC3D,CAAC,CAAC,GAAG/M,GAAG,CAACuQ,SAAS,CAACC,IAAI,CAACzD,CAAC,CAAC,EAAE0D,IAAI,CAAC1D,CAAC,CAAC,CAAC,CAAC,KAC7E2D,MAAM,CAAC3D,CAAC,CAAC,GAAGtF,CAAC;EACtB;EAEAmJ,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACH,IAAI,CAAC;EACxB,KAAItI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,IAAI,CAACnI,MAAM,EAAEN,CAAC,EAAE,EAAE;IAC7B4E,CAAC,GAAG6D,IAAI,CAACzI,CAAC,CAAC;IACXV,CAAC,GAAGgJ,IAAI,CAAC1D,CAAC,CAAC;IACX,IAAG,OAAOtF,CAAC,KAAK,QAAQ,IAAI,EAAEsF,CAAC,IAAI2D,MAAM,CAAC,IAAI,OAAOA,MAAM,CAAC3D,CAAC,CAAC,KAAK,QAAQ,EAAE;MACzE2D,MAAM,CAAC3D,CAAC,CAAC,GAAGtF,CAAC;IACjB;EACJ;EAEA,OAAOiJ,MAAM;AACjB,CAAC;AAED1Q,GAAG,CAACgR,SAAS,GAAG,UAASC,CAAC,EAAE;EACxB,OAAOA,CAAC,CAACH,MAAM,CAAC,CAAC,CAAC,CAACI,WAAW,EAAE,GAAGD,CAAC,CAACnD,MAAM,CAAC,CAAC,CAAC;AAClD,CAAC;AAED9N,GAAG,CAACmR,WAAW,GAAG,UAASF,CAAC,EAAEG,SAAS,EAAE;EACrC,KAAI,IAAIjJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiJ,SAAS,CAAC3I,MAAM,EAAEN,CAAC,EAAE,EAAE;IACtC,IAAG8I,CAAC,CAACI,OAAO,CAACD,SAAS,CAACjJ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE,OAAO,IAAI;EAClD;EACA,OAAO,KAAK;AAChB,CAAC;AAEDnI,GAAG,CAACsR,SAAS,GAAG,UAASC,EAAE,EAAE;EACzB,IAAIC,GAAG,GAAG9R,EAAE,CAAC+R,MAAM,CAACF,EAAE,CAAC;EACvB,OAAOC,GAAG,CAACE,IAAI,EAAE,YAAYC,WAAW,IACpCH,GAAG,CAACI,IAAI,EAAE,IACVJ,GAAG,CAACK,OAAO,CAAC,gBAAgB,CAAC;AACrC,CAAC;AAED7R,GAAG,CAAC8R,aAAa,GAAG,UAASP,EAAE,EAAE;EAC7B,IAAIQ,QAAQ,GAAGR,EAAE,IAAIA,EAAE,CAACpI,UAAU;EAClC,IAAG4I,QAAQ,EAAEA,QAAQ,CAACC,WAAW,CAACT,EAAE,CAAC;AACzC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAvR,GAAG,CAACiS,YAAY,GAAG,UAASC,QAAQ,EAAEC,WAAW,EAAE;EAC/CnS,GAAG,CAACoS,mBAAmB,CAAC,QAAQ,EAAEF,QAAQ,EAAEC,WAAW,CAAC;AAC5D,CAAC;;AAED;AACA;AACA;AACA;AACAnS,GAAG,CAACoS,mBAAmB,GAAG,UAASC,GAAG,EAAEH,QAAQ,EAAEC,WAAW,EAAE;EAC3D,IAAIG,EAAE,GAAG,kBAAkB,GAAGD,GAAG;EACjC,IAAIE,KAAK,GAAGC,QAAQ,CAACC,cAAc,CAACH,EAAE,CAAC;EACvC,IAAG,CAACC,KAAK,EAAE;IACPA,KAAK,GAAGC,QAAQ,CAACE,aAAa,CAAC,OAAO,CAAC;IACvCH,KAAK,CAACI,YAAY,CAAC,IAAI,EAAEL,EAAE,CAAC;IAC5B;IACAC,KAAK,CAACnJ,WAAW,CAACoJ,QAAQ,CAACI,cAAc,CAAC,EAAE,CAAC,CAAC;IAC9CJ,QAAQ,CAACK,IAAI,CAACzJ,WAAW,CAACmJ,KAAK,CAAC;EACpC;EACA,IAAIO,UAAU,GAAGP,KAAK,CAACQ,KAAK;EAE5B,IAAGD,UAAU,CAACE,UAAU,EAAE;IACtBF,UAAU,CAACE,UAAU,CAACd,QAAQ,GAAG,GAAG,GAAGC,WAAW,GAAG,GAAG,EAAE,CAAC,CAAC;EAChE,CAAC,MACI,IAAGW,UAAU,CAACG,OAAO,EAAE;IACxBH,UAAU,CAACG,OAAO,CAACf,QAAQ,EAAEC,WAAW,EAAE,CAAC,CAAC;EAChD,CAAC,MACInS,GAAG,CAACmG,IAAI,CAAC,qBAAqB,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACAnG,GAAG,CAACkT,sBAAsB,GAAG,UAASb,GAAG,EAAE;EACvC,IAAIC,EAAE,GAAG,kBAAkB,GAAGD,GAAG;EACjC,IAAIE,KAAK,GAAGC,QAAQ,CAACC,cAAc,CAACH,EAAE,CAAC;EACvC,IAAGC,KAAK,EAAEvS,GAAG,CAAC8R,aAAa,CAACS,KAAK,CAAC;AACtC,CAAC;AAEDvS,GAAG,CAACmT,IAAI,GAAG,YAAW;EAClB,OAAO,OAAOC,MAAM,CAACC,SAAS,CAACC,UAAU,KAAK,WAAW;AAC7D,CAAC;;AAED;AACA;AACA;AACA;AACAtT,GAAG,CAACuT,aAAa,GAAG,UAASC,GAAG,EAAE;EAC9B,OAAOA,GAAG,IAAK,OAAOA,GAAG,CAAC3B,OAAO,KAAK,UAAW;AACrD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA7R,GAAG,CAACyT,YAAY,GAAG,UAASC,MAAM,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC9D,IAAIC,GAAG,GAAGJ,MAAM,CAACjC,MAAM,CAACkC,QAAQ,IAAIC,SAAS,GAAG,GAAG,GAAGA,SAAS,GAAG,EAAE,CAAC,CAAC;EACtE,IAAGE,GAAG,CAAClC,IAAI,EAAE,EAAE,OAAOkC,GAAG;EAEzB,IAAIC,KAAK,GAAGL,MAAM,CAACM,MAAM,CAACL,QAAQ,CAAC;EACnC,IAAGC,SAAS,EAAEG,KAAK,CAAClC,OAAO,CAAC+B,SAAS,EAAE,IAAI,CAAC;EAC5C,IAAGC,OAAO,EAAEE,KAAK,CAACE,IAAI,CAACJ,OAAO,CAAC;EAE/B,OAAOE,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/T,GAAG,CAACkU,gBAAgB,GAAG,UAASR,MAAM,EAAEC,QAAQ,EAAErB,EAAE,EAAEuB,OAAO,EAAE;EAC3D,IAAIC,GAAG,GAAGJ,MAAM,CAACjC,MAAM,CAACkC,QAAQ,GAAG,GAAG,GAAGrB,EAAE,CAAC;EAC5C,IAAGwB,GAAG,CAAClC,IAAI,EAAE,EAAE,OAAOkC,GAAG;EAEzB,IAAIC,KAAK,GAAGL,MAAM,CAACM,MAAM,CAACL,QAAQ,CAAC,CAACjL,IAAI,CAAC,IAAI,EAAE4J,EAAE,CAAC;EAClD,IAAGuB,OAAO,EAAEE,KAAK,CAACE,IAAI,CAACJ,OAAO,CAAC;EAE/B,OAAOE,KAAK;AAChB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/T,GAAG,CAACmU,cAAc,GAAG,UAASC,IAAI,EAAEC,KAAK,EAAE;EACvC,IAAIzD,IAAI,GAAGwD,IAAI,CAACE,KAAK,CAAC,GAAG,CAAC;EAC1B,IAAIC,MAAM;EACV,IAAIf,GAAG,GAAGe,MAAM,GAAG,CAAC,CAAC;EAErB,KAAI,IAAIpM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGyI,IAAI,CAACnI,MAAM,EAAEN,CAAC,EAAE,EAAE;IACjC,IAAIqM,GAAG,GAAG5D,IAAI,CAACzI,CAAC,CAAC;IACjB,IAAIoJ,EAAE,GAAG,IAAI;IAEb,IAAIkD,KAAK,GAAG7D,IAAI,CAACzI,CAAC,CAAC,CAACuM,KAAK,CAAC,kBAAkB,CAAC;IAE7C,IAAGD,KAAK,EAAE;MACND,GAAG,GAAGC,KAAK,CAAC,CAAC,CAAC;MACdlD,EAAE,GAAGkD,KAAK,CAAC,CAAC,CAAC;MAEbF,MAAM,GAAGA,MAAM,CAACC,GAAG,CAAC,GAAG,EAAE;MAEzB,IAAGrM,CAAC,KAAKyI,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE;QACtB8L,MAAM,CAAChD,EAAE,CAAC,GAAG8C,KAAK;MACtB,CAAC,MAAM;QACHE,MAAM,CAAChD,EAAE,CAAC,GAAG,CAAC,CAAC;MACnB;MAEAgD,MAAM,GAAGA,MAAM,CAAChD,EAAE,CAAC;IACvB,CAAC,MAAM;MAEH,IAAGpJ,CAAC,KAAKyI,IAAI,CAACnI,MAAM,GAAG,CAAC,EAAE;QACtB8L,MAAM,CAACC,GAAG,CAAC,GAAGH,KAAK;MACvB,CAAC,MAAM;QACHE,MAAM,CAACC,GAAG,CAAC,GAAG,CAAC,CAAC;MACpB;MAEAD,MAAM,GAAGA,MAAM,CAACC,GAAG,CAAC;IACxB;EACJ;EAEA,OAAOhB,GAAG;AACd,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAImB,mBAAmB,GAAG,oBAAoB;AAC9C,IAAIC,oBAAoB,GAAG,iCAAiC;AAE5D5U,GAAG,CAAC6U,iBAAiB,GAAG,UAASC,IAAI,EAAE;EACnC,IAAIJ,KAAK,EAAEF,GAAG,EAAEO,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,IAAI,EAAEC,YAAY;EACpD,IAAG,OAAOL,IAAI,KAAK,QAAQ,IAAI,CAAC5M,KAAK,CAAC8G,OAAO,CAAC8F,IAAI,CAAC,EAAE;IACjD,KAAIN,GAAG,IAAIM,IAAI,EAAE;MACb,IAAGA,IAAI,CAACM,cAAc,CAACZ,GAAG,CAAC,EAAE;QACzB,IAAIE,KAAK,GAAGF,GAAG,CAACE,KAAK,CAACC,mBAAmB,CAAC,EAAG;UACzCK,KAAK,GAAGF,IAAI,CAACN,GAAG,CAAC;UACjBO,IAAI,GAAGL,KAAK,CAAC,CAAC,CAAC;UAEf,OAAOI,IAAI,CAACN,GAAG,CAAC;UAEhBM,IAAI,CAACC,IAAI,CAAC,GAAG/U,GAAG,CAACgG,kBAAkB,CAAC8O,IAAI,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,EAAE/U,GAAG,CAACmU,cAAc,CAACK,GAAG,EAAExU,GAAG,CAAC6U,iBAAiB,CAACG,KAAK,CAAC,CAAC,CAACD,IAAI,CAAC,CAAC;QACtH,CAAC,MAAM,IAAIL,KAAK,GAAGF,GAAG,CAACE,KAAK,CAACE,oBAAoB,CAAC,EAAG;UACjDI,KAAK,GAAGF,IAAI,CAACN,GAAG,CAAC;UAEjBO,IAAI,GAAGL,KAAK,CAAC,CAAC,CAAC;UACfO,GAAG,GAAGtJ,QAAQ,CAAC+I,KAAK,CAAC,CAAC,CAAC,CAAC;UAExB,OAAOI,IAAI,CAACN,GAAG,CAAC;UAEhBM,IAAI,CAACC,IAAI,CAAC,GAAGD,IAAI,CAACC,IAAI,CAAC,IAAI,EAAE;UAE7B,IAAGL,KAAK,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;YACjB;YACA;YACAS,YAAY,GAAGT,KAAK,CAAC,CAAC,CAAC;YACvBQ,IAAI,GAAGJ,IAAI,CAACC,IAAI,CAAC,CAACE,GAAG,CAAC,GAAGH,IAAI,CAACC,IAAI,CAAC,CAACE,GAAG,CAAC,IAAI,CAAC,CAAC;;YAE9C;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACAjV,GAAG,CAACgG,kBAAkB,CAACkP,IAAI,EAAElV,GAAG,CAACmU,cAAc,CAACgB,YAAY,EAAEnV,GAAG,CAAC6U,iBAAiB,CAACG,KAAK,CAAC,CAAC,CAAC;UAChG,CAAC,MAAM;YACH;YACA;YACAF,IAAI,CAACC,IAAI,CAAC,CAACE,GAAG,CAAC,GAAGjV,GAAG,CAAC6U,iBAAiB,CAACG,KAAK,CAAC;UAClD;QACJ,CAAC,MAAM;UACHF,IAAI,CAACN,GAAG,CAAC,GAAGxU,GAAG,CAAC6U,iBAAiB,CAACC,IAAI,CAACN,GAAG,CAAC,CAAC;QAChD;MACJ;IACJ;EACJ;EAEA,OAAOM,IAAI;AACf,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA9U,GAAG,CAACqV,WAAW,GAAG,UAAShB,KAAK,EAAEiB,UAAU,EAAEC,iBAAiB,EAAE;EAC7D,IAAG,CAACA,iBAAiB,EAAEA,iBAAiB,GAAG,KAAK;EAEhD,IAAG,OAAOD,UAAU,KAAK,QAAQ,IAAIA,UAAU,CAAC7M,MAAM,KAAK,CAAC,EAAE;IAC1D,MAAM,IAAI+M,KAAK,CAAC,2CAA2C,CAAC;EAChE;EAEA,IAAG,OAAOnB,KAAK,KAAK,QAAQ,EAAE;IAC1BA,KAAK,GAAGoB,MAAM,CAACpB,KAAK,CAAC;EACzB;EAEA,IAAIqB,WAAW,GAAG,cAAc;EAChC,IAAIC,UAAU,GAAGL,UAAU,CAACxE,MAAM,CAAC,CAAC,CAAC;EACrC,IAAI8E,OAAO,GAAGN,UAAU,CAACxE,MAAM,CAAC,CAAC,CAAC;EAElC,IAAI1F,CAAC,GAAGiJ,KAAK,CAACC,KAAK,CAAC,GAAG,CAAC;EACxB,IAAI5J,EAAE,GAAGU,CAAC,CAAC,CAAC,CAAC;EACb,IAAIT,EAAE,GAAGS,CAAC,CAAC3C,MAAM,GAAG,CAAC,GAAGkN,UAAU,GAAGvK,CAAC,CAAC,CAAC,CAAC,GAAG,EAAE;;EAE9C;EACA,IAAGwK,OAAO,KAAKxK,CAAC,CAAC3C,MAAM,GAAG,CAAC,IAAIiC,EAAE,CAACjC,MAAM,GAAG,CAAC,IAAI8M,iBAAiB,CAAC,EAAE;IAChE,OAAMG,WAAW,CAACG,IAAI,CAACnL,EAAE,CAAC,EAAE;MACxBA,EAAE,GAAGA,EAAE,CAAC9B,OAAO,CAAC8M,WAAW,EAAE,IAAI,GAAGE,OAAO,GAAG,IAAI,CAAC;IACvD;EACJ;EAEA,OAAOlL,EAAE,GAAGC,EAAE;AAClB,CAAC;AAED,IAAImL,qBAAqB,GAAG,2BAA2B;AACvD,IAAIC,qBAAqB,GAAG,OAAO;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA/V,GAAG,CAACgW,cAAc,GAAG,UAASC,MAAM,EAAEzC,GAAG,EAAE;EACvC;EACA;EACA,IAAI0C,WAAW,GAAG,CAAC,CAAC;EAEpB,OAAOD,MAAM,CAACrN,OAAO,CAACkN,qBAAqB,EAAE,UAASK,KAAK,EAAE3B,GAAG,EAAE;IAC9D,IAAGuB,qBAAqB,CAACF,IAAI,CAACrB,GAAG,CAAC,EAAE;MAChC,OAAOhB,GAAG,CAACgB,GAAG,CAAC,IAAI,EAAE;IACzB;IACA0B,WAAW,CAAC1B,GAAG,CAAC,GAAG0B,WAAW,CAAC1B,GAAG,CAAC,IAAIxU,GAAG,CAACG,cAAc,CAACqT,GAAG,EAAEgB,GAAG,CAAC,CAACzL,GAAG;IACvE,OAAOmN,WAAW,CAAC1B,GAAG,CAAC,EAAE,IAAI,EAAE;EACnC,CAAC,CAAC;AACN,CAAC;AAED,IAAI4B,gCAAgC,GAAG,IAAI;AAC3C,IAAIC,6BAA6B,GAAG,CAAC;AACrC,IAAIC,oCAAoC,GAAG,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAtW,GAAG,CAACuW,mBAAmB,GAAG,UAASN,MAAM,EAAEO,MAAM,EAAE;EAC/C,IAAIC,IAAI,GAAGC,SAAS;EACpB;EACA;EACA,IAAIR,WAAW,GAAG,CAAC,CAAC;EAEpB,OAAOD,MAAM,CAACrN,OAAO,CAACkN,qBAAqB,EAAE,UAASpB,KAAK,EAAEF,GAAG,EAAEmC,MAAM,EAAE;IACtE,IAAInD,GAAG,EAAEa,KAAK,EAAElM,CAAC;IACjB,KAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsO,IAAI,CAAChO,MAAM,EAAEN,CAAC,EAAE,EAAE;MAC7BqL,GAAG,GAAGiD,IAAI,CAACtO,CAAC,CAAC;MACb,IAAGqL,GAAG,CAAC4B,cAAc,CAACZ,GAAG,CAAC,EAAE;QACxBH,KAAK,GAAGb,GAAG,CAACgB,GAAG,CAAC;QAChB;MACJ;MAEA,IAAG,CAACuB,qBAAqB,CAACF,IAAI,CAACrB,GAAG,CAAC,EAAE;QACjCH,KAAK,GAAG6B,WAAW,CAAC1B,GAAG,CAAC,IAAIxU,GAAG,CAACG,cAAc,CAACqT,GAAG,EAAEgB,GAAG,CAAC,CAACzL,GAAG,EAAE;QAC9D,IAAGsL,KAAK,EAAE6B,WAAW,CAAC1B,GAAG,CAAC,GAAGH,KAAK;MACtC;MACA,IAAGA,KAAK,KAAKzM,SAAS,EAAE;IAC5B;IAEA,IAAGyM,KAAK,KAAKzM,SAAS,EAAE;MACpB,IAAGyO,6BAA6B,GAAGC,oCAAoC,EAAE;QACrEtW,GAAG,CAACmG,IAAI,CAAC,aAAa,GAAGqO,GAAG,GAAG,yCAAyC,CAAC;QACzEH,KAAK,GAAGK,KAAK;MACjB;MAEA,IAAG2B,6BAA6B,KAAKC,oCAAoC,EAAE;QACvEtW,GAAG,CAACmG,IAAI,CAAC,0EAA0E,CAAC;MACxF;MACAkQ,6BAA6B,EAAE;IACnC;IAEA,IAAGM,MAAM,EAAE;MACPtC,KAAK,GAAG3U,EAAE,CAACiX,MAAM,CAACA,MAAM,CAAC/N,OAAO,CAACwN,gCAAgC,EAAE,EAAE,CAAC,CAAC,CAAC/B,KAAK,CAAC;IAClF,CAAC,MAAM;MACH,IAAGmC,MAAM,CAACpB,cAAc,CAACZ,GAAG,GAAG,OAAO,CAAC,EAAEH,KAAK,GAAGmC,MAAM,CAAChC,GAAG,GAAG,OAAO,CAAC;IAC1E;IACA,OAAOH,KAAK;EAChB,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA,IAAIuC,KAAK,GAAG,EAAE;AACd,IAAIC,KAAK,GAAG,EAAE;AACd7W,GAAG,CAAC8W,WAAW,GAAG,UAAS9M,CAAC,EAAEC,CAAC,EAAE;EAC7B,IAAI8M,CAAC,GAAGnN,IAAI,CAACE,GAAG,CAACE,CAAC,CAACvB,MAAM,EAAEwB,CAAC,CAACxB,MAAM,CAAC,GAAG,CAAC;EACxC,IAAIuO,IAAI,GAAG,CAAC;EACZ,IAAIC,IAAI,GAAG,CAAC;EACZ,KAAI,IAAI9O,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4O,CAAC,EAAE5O,CAAC,EAAE,EAAE;IACvB,IAAI+O,KAAK,GAAGlN,CAAC,CAACmN,UAAU,CAAChP,CAAC,CAAC,IAAI,CAAC;IAChC,IAAIiP,KAAK,GAAGnN,CAAC,CAACkN,UAAU,CAAChP,CAAC,CAAC,IAAI,CAAC;IAChC,IAAIkP,MAAM,GAAGH,KAAK,IAAIN,KAAK,IAAIM,KAAK,IAAIL,KAAK;IAC7C,IAAIS,MAAM,GAAGF,KAAK,IAAIR,KAAK,IAAIQ,KAAK,IAAIP,KAAK;IAE7C,IAAGQ,MAAM,EAAEL,IAAI,GAAG,EAAE,GAAGA,IAAI,GAAGE,KAAK,GAAGN,KAAK;IAC3C,IAAGU,MAAM,EAAEL,IAAI,GAAG,EAAE,GAAGA,IAAI,GAAGG,KAAK,GAAGR,KAAK;IAE3C,IAAG,CAACS,MAAM,IAAI,CAACC,MAAM,EAAE;MACnB,IAAGN,IAAI,KAAKC,IAAI,EAAE,OAAOD,IAAI,GAAGC,IAAI;MACpC,IAAGC,KAAK,KAAKE,KAAK,EAAE,OAAOF,KAAK,GAAGE,KAAK;IAC5C;EACJ;EACA,OAAOH,IAAI,GAAGD,IAAI;AACtB,CAAC;;AAED;AACA,IAAIO,QAAQ,GAAG,UAAU;AAEzBvX,GAAG,CAACwX,gBAAgB,GAAG,YAAW;EAC9BD,QAAQ,GAAG,UAAU;AACzB,CAAC;AAEDvX,GAAG,CAACyX,YAAY,GAAG,YAAW;EAC1B,IAAIC,OAAO,GAAGH,QAAQ;EACtBA,QAAQ,GAAG,CAAC,KAAK,GAAGA,QAAQ,GAAG,CAAC,IAAI,UAAU;EAC9C;EACA;EACA,IAAG3N,IAAI,CAAC+N,GAAG,CAACJ,QAAQ,GAAGG,OAAO,CAAC,GAAG,SAAS,EAAE,OAAO1X,GAAG,CAACyX,YAAY,EAAE;EACtE,OAAOF,QAAQ,GAAG,UAAU;AAChC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}