{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar timerCache = {};\n\n/**\n * Throttle a callback. `callback` executes synchronously only if\n * more than `minInterval` milliseconds have already elapsed since the latest\n * call (if any). Otherwise we wait until `minInterval` is over and execute the\n * last callback received while waiting.\n * So the first and last events in a train are always executed (eventually)\n * but some of the events in the middle can be dropped.\n *\n * @param {string} id: an identifier to mark events to throttle together\n * @param {number} minInterval: minimum time, in milliseconds, between\n *   invocations of `callback`\n * @param {function} callback: the function to throttle. `callback` itself\n *   should be a purely synchronous function.\n */\nexports.throttle = function throttle(id, minInterval, callback) {\n  var cache = timerCache[id];\n  var now = Date.now();\n  if (!cache) {\n    /*\n     * Throw out old items before making a new one, to prevent the cache\n     * getting overgrown, for example from old plots that have been replaced.\n     * 1 minute age is arbitrary.\n     */\n    for (var idi in timerCache) {\n      if (timerCache[idi].ts < now - 60000) {\n        delete timerCache[idi];\n      }\n    }\n    cache = timerCache[id] = {\n      ts: 0,\n      timer: null\n    };\n  }\n  _clearTimeout(cache);\n  function exec() {\n    callback();\n    cache.ts = Date.now();\n    if (cache.onDone) {\n      cache.onDone();\n      cache.onDone = null;\n    }\n  }\n  if (now > cache.ts + minInterval) {\n    exec();\n    return;\n  }\n  cache.timer = setTimeout(function () {\n    exec();\n    cache.timer = null;\n  }, minInterval);\n};\nexports.done = function (id) {\n  var cache = timerCache[id];\n  if (!cache || !cache.timer) return Promise.resolve();\n  return new Promise(function (resolve) {\n    var previousOnDone = cache.onDone;\n    cache.onDone = function onDone() {\n      if (previousOnDone) previousOnDone();\n      resolve();\n      cache.onDone = null;\n    };\n  });\n};\n\n/**\n * Clear the throttle cache for one or all timers\n * @param {optional string} id:\n *   if provided, clear just this timer\n *   if omitted, clear all timers (mainly useful for testing)\n */\nexports.clear = function (id) {\n  if (id) {\n    _clearTimeout(timerCache[id]);\n    delete timerCache[id];\n  } else {\n    for (var idi in timerCache) {\n      exports.clear(idi);\n    }\n  }\n};\nfunction _clearTimeout(cache) {\n  if (cache && cache.timer !== null) {\n    clearTimeout(cache.timer);\n    cache.timer = null;\n  }\n}","map":{"version":3,"names":["timerCache","exports","throttle","id","minInterval","callback","cache","now","Date","idi","ts","timer","_clearTimeout","exec","onDone","setTimeout","done","Promise","resolve","previousOnDone","clear","clearTimeout"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/lib/throttle.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar timerCache = {};\n\n/**\n * Throttle a callback. `callback` executes synchronously only if\n * more than `minInterval` milliseconds have already elapsed since the latest\n * call (if any). Otherwise we wait until `minInterval` is over and execute the\n * last callback received while waiting.\n * So the first and last events in a train are always executed (eventually)\n * but some of the events in the middle can be dropped.\n *\n * @param {string} id: an identifier to mark events to throttle together\n * @param {number} minInterval: minimum time, in milliseconds, between\n *   invocations of `callback`\n * @param {function} callback: the function to throttle. `callback` itself\n *   should be a purely synchronous function.\n */\nexports.throttle = function throttle(id, minInterval, callback) {\n    var cache = timerCache[id];\n    var now = Date.now();\n\n    if(!cache) {\n        /*\n         * Throw out old items before making a new one, to prevent the cache\n         * getting overgrown, for example from old plots that have been replaced.\n         * 1 minute age is arbitrary.\n         */\n        for(var idi in timerCache) {\n            if(timerCache[idi].ts < now - 60000) {\n                delete timerCache[idi];\n            }\n        }\n        cache = timerCache[id] = {ts: 0, timer: null};\n    }\n\n    _clearTimeout(cache);\n\n    function exec() {\n        callback();\n        cache.ts = Date.now();\n        if(cache.onDone) {\n            cache.onDone();\n            cache.onDone = null;\n        }\n    }\n\n    if(now > cache.ts + minInterval) {\n        exec();\n        return;\n    }\n\n    cache.timer = setTimeout(function() {\n        exec();\n        cache.timer = null;\n    }, minInterval);\n};\n\nexports.done = function(id) {\n    var cache = timerCache[id];\n    if(!cache || !cache.timer) return Promise.resolve();\n\n    return new Promise(function(resolve) {\n        var previousOnDone = cache.onDone;\n        cache.onDone = function onDone() {\n            if(previousOnDone) previousOnDone();\n            resolve();\n            cache.onDone = null;\n        };\n    });\n};\n\n/**\n * Clear the throttle cache for one or all timers\n * @param {optional string} id:\n *   if provided, clear just this timer\n *   if omitted, clear all timers (mainly useful for testing)\n */\nexports.clear = function(id) {\n    if(id) {\n        _clearTimeout(timerCache[id]);\n        delete timerCache[id];\n    }\n    else {\n        for(var idi in timerCache) exports.clear(idi);\n    }\n};\n\nfunction _clearTimeout(cache) {\n    if(cache && cache.timer !== null) {\n        clearTimeout(cache.timer);\n        cache.timer = null;\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,UAAU,GAAG,CAAC,CAAC;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,OAAO,CAACC,QAAQ,GAAG,SAASA,QAAQ,CAACC,EAAE,EAAEC,WAAW,EAAEC,QAAQ,EAAE;EAC5D,IAAIC,KAAK,GAAGN,UAAU,CAACG,EAAE,CAAC;EAC1B,IAAII,GAAG,GAAGC,IAAI,CAACD,GAAG,EAAE;EAEpB,IAAG,CAACD,KAAK,EAAE;IACP;AACR;AACA;AACA;AACA;IACQ,KAAI,IAAIG,GAAG,IAAIT,UAAU,EAAE;MACvB,IAAGA,UAAU,CAACS,GAAG,CAAC,CAACC,EAAE,GAAGH,GAAG,GAAG,KAAK,EAAE;QACjC,OAAOP,UAAU,CAACS,GAAG,CAAC;MAC1B;IACJ;IACAH,KAAK,GAAGN,UAAU,CAACG,EAAE,CAAC,GAAG;MAACO,EAAE,EAAE,CAAC;MAAEC,KAAK,EAAE;IAAI,CAAC;EACjD;EAEAC,aAAa,CAACN,KAAK,CAAC;EAEpB,SAASO,IAAI,GAAG;IACZR,QAAQ,EAAE;IACVC,KAAK,CAACI,EAAE,GAAGF,IAAI,CAACD,GAAG,EAAE;IACrB,IAAGD,KAAK,CAACQ,MAAM,EAAE;MACbR,KAAK,CAACQ,MAAM,EAAE;MACdR,KAAK,CAACQ,MAAM,GAAG,IAAI;IACvB;EACJ;EAEA,IAAGP,GAAG,GAAGD,KAAK,CAACI,EAAE,GAAGN,WAAW,EAAE;IAC7BS,IAAI,EAAE;IACN;EACJ;EAEAP,KAAK,CAACK,KAAK,GAAGI,UAAU,CAAC,YAAW;IAChCF,IAAI,EAAE;IACNP,KAAK,CAACK,KAAK,GAAG,IAAI;EACtB,CAAC,EAAEP,WAAW,CAAC;AACnB,CAAC;AAEDH,OAAO,CAACe,IAAI,GAAG,UAASb,EAAE,EAAE;EACxB,IAAIG,KAAK,GAAGN,UAAU,CAACG,EAAE,CAAC;EAC1B,IAAG,CAACG,KAAK,IAAI,CAACA,KAAK,CAACK,KAAK,EAAE,OAAOM,OAAO,CAACC,OAAO,EAAE;EAEnD,OAAO,IAAID,OAAO,CAAC,UAASC,OAAO,EAAE;IACjC,IAAIC,cAAc,GAAGb,KAAK,CAACQ,MAAM;IACjCR,KAAK,CAACQ,MAAM,GAAG,SAASA,MAAM,GAAG;MAC7B,IAAGK,cAAc,EAAEA,cAAc,EAAE;MACnCD,OAAO,EAAE;MACTZ,KAAK,CAACQ,MAAM,GAAG,IAAI;IACvB,CAAC;EACL,CAAC,CAAC;AACN,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAb,OAAO,CAACmB,KAAK,GAAG,UAASjB,EAAE,EAAE;EACzB,IAAGA,EAAE,EAAE;IACHS,aAAa,CAACZ,UAAU,CAACG,EAAE,CAAC,CAAC;IAC7B,OAAOH,UAAU,CAACG,EAAE,CAAC;EACzB,CAAC,MACI;IACD,KAAI,IAAIM,GAAG,IAAIT,UAAU;MAAEC,OAAO,CAACmB,KAAK,CAACX,GAAG,CAAC;IAAC;EAClD;AACJ,CAAC;AAED,SAASG,aAAa,CAACN,KAAK,EAAE;EAC1B,IAAGA,KAAK,IAAIA,KAAK,CAACK,KAAK,KAAK,IAAI,EAAE;IAC9BU,YAAY,CAACf,KAAK,CAACK,KAAK,CAAC;IACzBL,KAAK,CAACK,KAAK,GAAG,IAAI;EACtB;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}