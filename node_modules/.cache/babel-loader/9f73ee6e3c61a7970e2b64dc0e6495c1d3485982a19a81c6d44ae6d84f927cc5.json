{"ast":null,"code":"'use strict';\n\nmodule.exports = cleanPSLG;\nvar UnionFind = require('union-find');\nvar boxIntersect = require('box-intersect');\nvar segseg = require('robust-segment-intersect');\nvar rat = require('big-rat');\nvar ratCmp = require('big-rat/cmp');\nvar ratToFloat = require('big-rat/to-float');\nvar ratVec = require('rat-vec');\nvar nextafter = require('nextafter');\nvar solveIntersection = require('./lib/rat-seg-intersect');\n\n// Bounds on a rational number when rounded to a float\nfunction boundRat(r) {\n  var f = ratToFloat(r);\n  return [nextafter(f, -Infinity), nextafter(f, Infinity)];\n}\n\n// Convert a list of edges in a pslg to bounding boxes\nfunction boundEdges(points, edges) {\n  var bounds = new Array(edges.length);\n  for (var i = 0; i < edges.length; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n    bounds[i] = [nextafter(Math.min(a[0], b[0]), -Infinity), nextafter(Math.min(a[1], b[1]), -Infinity), nextafter(Math.max(a[0], b[0]), Infinity), nextafter(Math.max(a[1], b[1]), Infinity)];\n  }\n  return bounds;\n}\n\n// Convert a list of points into bounding boxes by duplicating coords\nfunction boundPoints(points) {\n  var bounds = new Array(points.length);\n  for (var i = 0; i < points.length; ++i) {\n    var p = points[i];\n    bounds[i] = [nextafter(p[0], -Infinity), nextafter(p[1], -Infinity), nextafter(p[0], Infinity), nextafter(p[1], Infinity)];\n  }\n  return bounds;\n}\n\n// Find all pairs of crossing edges in a pslg (given edge bounds)\nfunction getCrossings(points, edges, edgeBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, function (i, j) {\n    var e = edges[i];\n    var f = edges[j];\n    if (e[0] === f[0] || e[0] === f[1] || e[1] === f[0] || e[1] === f[1]) {\n      return;\n    }\n    var a = points[e[0]];\n    var b = points[e[1]];\n    var c = points[f[0]];\n    var d = points[f[1]];\n    if (segseg(a, b, c, d)) {\n      result.push([i, j]);\n    }\n  });\n  return result;\n}\n\n// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\nfunction getTJunctions(points, edges, edgeBounds, vertBounds) {\n  var result = [];\n  boxIntersect(edgeBounds, vertBounds, function (i, v) {\n    var e = edges[i];\n    if (e[0] === v || e[1] === v) {\n      return;\n    }\n    var p = points[v];\n    var a = points[e[0]];\n    var b = points[e[1]];\n    if (segseg(a, b, p, p)) {\n      result.push([i, v]);\n    }\n  });\n  return result;\n}\n\n// Cut edges along crossings/tjunctions\nfunction cutEdges(floatPoints, edges, crossings, junctions, useColor) {\n  var i, e;\n\n  // Convert crossings into tjunctions by constructing rational points\n  var ratPoints = floatPoints.map(function (p) {\n    return [rat(p[0]), rat(p[1])];\n  });\n  for (i = 0; i < crossings.length; ++i) {\n    var crossing = crossings[i];\n    e = crossing[0];\n    var f = crossing[1];\n    var ee = edges[e];\n    var ef = edges[f];\n    var x = solveIntersection(ratVec(floatPoints[ee[0]]), ratVec(floatPoints[ee[1]]), ratVec(floatPoints[ef[0]]), ratVec(floatPoints[ef[1]]));\n    if (!x) {\n      // Segments are parallel, should already be handled by t-junctions\n      continue;\n    }\n    var idx = floatPoints.length;\n    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])]);\n    ratPoints.push(x);\n    junctions.push([e, idx], [f, idx]);\n  }\n\n  // Sort tjunctions\n  junctions.sort(function (a, b) {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0];\n    }\n    var u = ratPoints[a[1]];\n    var v = ratPoints[b[1]];\n    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1]);\n  });\n\n  // Split edges along junctions\n  for (i = junctions.length - 1; i >= 0; --i) {\n    var junction = junctions[i];\n    e = junction[0];\n    var edge = edges[e];\n    var s = edge[0];\n    var t = edge[1];\n\n    // Check if edge is not lexicographically sorted\n    var a = floatPoints[s];\n    var b = floatPoints[t];\n    if ((a[0] - b[0] || a[1] - b[1]) < 0) {\n      var tmp = s;\n      s = t;\n      t = tmp;\n    }\n\n    // Split leading edge\n    edge[0] = s;\n    var last = edge[1] = junction[1];\n\n    // If we are grouping edges by color, remember to track data\n    var color;\n    if (useColor) {\n      color = edge[2];\n    }\n\n    // Split other edges\n    while (i > 0 && junctions[i - 1][0] === e) {\n      var junction = junctions[--i];\n      var next = junction[1];\n      if (useColor) {\n        edges.push([last, next, color]);\n      } else {\n        edges.push([last, next]);\n      }\n      last = next;\n    }\n\n    // Add final edge\n    if (useColor) {\n      edges.push([last, t, color]);\n    } else {\n      edges.push([last, t]);\n    }\n  }\n\n  // Return constructed rational points\n  return ratPoints;\n}\n\n// Merge overlapping points\nfunction dedupPoints(floatPoints, ratPoints, floatBounds) {\n  var numPoints = ratPoints.length;\n  var uf = new UnionFind(numPoints);\n\n  // Compute rational bounds\n  var bounds = [];\n  for (var i = 0; i < ratPoints.length; ++i) {\n    var p = ratPoints[i];\n    var xb = boundRat(p[0]);\n    var yb = boundRat(p[1]);\n    bounds.push([nextafter(xb[0], -Infinity), nextafter(yb[0], -Infinity), nextafter(xb[1], Infinity), nextafter(yb[1], Infinity)]);\n  }\n\n  // Link all points with over lapping boxes\n  boxIntersect(bounds, function (i, j) {\n    uf.link(i, j);\n  });\n\n  // Do 1 pass over points to combine points in label sets\n  var noDupes = true;\n  var labels = new Array(numPoints);\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n    if (j !== i) {\n      // Clear no-dupes flag, zero out label\n      noDupes = false;\n      // Make each point the top-left point from its cell\n      floatPoints[j] = [Math.min(floatPoints[i][0], floatPoints[j][0]), Math.min(floatPoints[i][1], floatPoints[j][1])];\n    }\n  }\n\n  // If no duplicates, return null to signal termination\n  if (noDupes) {\n    return null;\n  }\n  var ptr = 0;\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i);\n    if (j === i) {\n      labels[i] = ptr;\n      floatPoints[ptr++] = floatPoints[i];\n    } else {\n      labels[i] = -1;\n    }\n  }\n  floatPoints.length = ptr;\n\n  // Do a second pass to fix up missing labels\n  for (var i = 0; i < numPoints; ++i) {\n    if (labels[i] < 0) {\n      labels[i] = labels[uf.find(i)];\n    }\n  }\n\n  // Return resulting union-find data structure\n  return labels;\n}\nfunction compareLex2(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\nfunction compareLex3(a, b) {\n  var d = a[0] - b[0] || a[1] - b[1];\n  if (d) {\n    return d;\n  }\n  if (a[2] < b[2]) {\n    return -1;\n  } else if (a[2] > b[2]) {\n    return 1;\n  }\n  return 0;\n}\n\n// Remove duplicate edge labels\nfunction dedupEdges(edges, labels, useColor) {\n  if (edges.length === 0) {\n    return;\n  }\n  if (labels) {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = labels[e[0]];\n      var b = labels[e[1]];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  } else {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      var a = e[0];\n      var b = e[1];\n      e[0] = Math.min(a, b);\n      e[1] = Math.max(a, b);\n    }\n  }\n  if (useColor) {\n    edges.sort(compareLex3);\n  } else {\n    edges.sort(compareLex2);\n  }\n  var ptr = 1;\n  for (var i = 1; i < edges.length; ++i) {\n    var prev = edges[i - 1];\n    var next = edges[i];\n    if (next[0] === prev[0] && next[1] === prev[1] && (!useColor || next[2] === prev[2])) {\n      continue;\n    }\n    edges[ptr++] = next;\n  }\n  edges.length = ptr;\n}\nfunction preRound(points, edges, useColor) {\n  var labels = dedupPoints(points, [], boundPoints(points));\n  dedupEdges(edges, labels, useColor);\n  return !!labels;\n}\n\n// Repeat until convergence\nfunction snapRound(points, edges, useColor) {\n  // 1. find edge crossings\n  var edgeBounds = boundEdges(points, edges);\n  var crossings = getCrossings(points, edges, edgeBounds);\n\n  // 2. find t-junctions\n  var vertBounds = boundPoints(points);\n  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds);\n\n  // 3. cut edges, construct rational points\n  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor);\n\n  // 4. dedupe verts\n  var labels = dedupPoints(points, ratPoints, vertBounds);\n\n  // 5. dedupe edges\n  dedupEdges(edges, labels, useColor);\n\n  // 6. check termination\n  if (!labels) {\n    return crossings.length > 0 || tjunctions.length > 0;\n  }\n\n  // More iterations necessary\n  return true;\n}\n\n// Main loop, runs PSLG clean up until completion\nfunction cleanPSLG(points, edges, colors) {\n  // If using colors, augment edges with color data\n  var prevEdges;\n  if (colors) {\n    prevEdges = edges;\n    var augEdges = new Array(edges.length);\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      augEdges[i] = [e[0], e[1], colors[i]];\n    }\n    edges = augEdges;\n  }\n\n  // First round: remove duplicate edges and points\n  var modified = preRound(points, edges, !!colors);\n\n  // Run snap rounding until convergence\n  while (snapRound(points, edges, !!colors)) {\n    modified = true;\n  }\n\n  // Strip color tags\n  if (!!colors && modified) {\n    prevEdges.length = 0;\n    colors.length = 0;\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      prevEdges.push([e[0], e[1]]);\n      colors.push(e[2]);\n    }\n  }\n  return modified;\n}","map":{"version":3,"names":["module","exports","cleanPSLG","UnionFind","require","boxIntersect","segseg","rat","ratCmp","ratToFloat","ratVec","nextafter","solveIntersection","boundRat","r","f","Infinity","boundEdges","points","edges","bounds","Array","length","i","e","a","b","Math","min","max","boundPoints","p","getCrossings","edgeBounds","result","j","c","d","push","getTJunctions","vertBounds","v","cutEdges","floatPoints","crossings","junctions","useColor","ratPoints","map","crossing","ee","ef","x","idx","sort","u","junction","edge","s","t","tmp","last","color","next","dedupPoints","floatBounds","numPoints","uf","xb","yb","link","noDupes","labels","find","ptr","compareLex2","compareLex3","dedupEdges","prev","preRound","snapRound","tjunctions","colors","prevEdges","augEdges","modified"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/clean-pslg/clean-pslg.js"],"sourcesContent":["'use strict'\n\nmodule.exports = cleanPSLG\n\nvar UnionFind = require('union-find')\nvar boxIntersect = require('box-intersect')\nvar segseg = require('robust-segment-intersect')\nvar rat = require('big-rat')\nvar ratCmp = require('big-rat/cmp')\nvar ratToFloat = require('big-rat/to-float')\nvar ratVec = require('rat-vec')\nvar nextafter = require('nextafter')\n\nvar solveIntersection = require('./lib/rat-seg-intersect')\n\n// Bounds on a rational number when rounded to a float\nfunction boundRat (r) {\n  var f = ratToFloat(r)\n  return [\n    nextafter(f, -Infinity),\n    nextafter(f, Infinity)\n  ]\n}\n\n// Convert a list of edges in a pslg to bounding boxes\nfunction boundEdges (points, edges) {\n  var bounds = new Array(edges.length)\n  for (var i = 0; i < edges.length; ++i) {\n    var e = edges[i]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    bounds[i] = [\n      nextafter(Math.min(a[0], b[0]), -Infinity),\n      nextafter(Math.min(a[1], b[1]), -Infinity),\n      nextafter(Math.max(a[0], b[0]), Infinity),\n      nextafter(Math.max(a[1], b[1]), Infinity)\n    ]\n  }\n  return bounds\n}\n\n// Convert a list of points into bounding boxes by duplicating coords\nfunction boundPoints (points) {\n  var bounds = new Array(points.length)\n  for (var i = 0; i < points.length; ++i) {\n    var p = points[i]\n    bounds[i] = [\n      nextafter(p[0], -Infinity),\n      nextafter(p[1], -Infinity),\n      nextafter(p[0], Infinity),\n      nextafter(p[1], Infinity)\n    ]\n  }\n  return bounds\n}\n\n// Find all pairs of crossing edges in a pslg (given edge bounds)\nfunction getCrossings (points, edges, edgeBounds) {\n  var result = []\n  boxIntersect(edgeBounds, function (i, j) {\n    var e = edges[i]\n    var f = edges[j]\n    if (e[0] === f[0] || e[0] === f[1] ||\n      e[1] === f[0] || e[1] === f[1]) {\n      return\n    }\n    var a = points[e[0]]\n    var b = points[e[1]]\n    var c = points[f[0]]\n    var d = points[f[1]]\n    if (segseg(a, b, c, d)) {\n      result.push([i, j])\n    }\n  })\n  return result\n}\n\n// Find all pairs of crossing vertices in a pslg (given edge/vert bounds)\nfunction getTJunctions (points, edges, edgeBounds, vertBounds) {\n  var result = []\n  boxIntersect(edgeBounds, vertBounds, function (i, v) {\n    var e = edges[i]\n    if (e[0] === v || e[1] === v) {\n      return\n    }\n    var p = points[v]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    if (segseg(a, b, p, p)) {\n      result.push([i, v])\n    }\n  })\n  return result\n}\n\n// Cut edges along crossings/tjunctions\nfunction cutEdges (floatPoints, edges, crossings, junctions, useColor) {\n  var i, e\n\n  // Convert crossings into tjunctions by constructing rational points\n  var ratPoints = floatPoints.map(function(p) {\n      return [\n          rat(p[0]),\n          rat(p[1])\n      ]\n  })\n  for (i = 0; i < crossings.length; ++i) {\n    var crossing = crossings[i]\n    e = crossing[0]\n    var f = crossing[1]\n    var ee = edges[e]\n    var ef = edges[f]\n    var x = solveIntersection(\n      ratVec(floatPoints[ee[0]]),\n      ratVec(floatPoints[ee[1]]),\n      ratVec(floatPoints[ef[0]]),\n      ratVec(floatPoints[ef[1]]))\n    if (!x) {\n      // Segments are parallel, should already be handled by t-junctions\n      continue\n    }\n    var idx = floatPoints.length\n    floatPoints.push([ratToFloat(x[0]), ratToFloat(x[1])])\n    ratPoints.push(x)\n    junctions.push([e, idx], [f, idx])\n  }\n\n  // Sort tjunctions\n  junctions.sort(function (a, b) {\n    if (a[0] !== b[0]) {\n      return a[0] - b[0]\n    }\n    var u = ratPoints[a[1]]\n    var v = ratPoints[b[1]]\n    return ratCmp(u[0], v[0]) || ratCmp(u[1], v[1])\n  })\n\n  // Split edges along junctions\n  for (i = junctions.length - 1; i >= 0; --i) {\n    var junction = junctions[i]\n    e = junction[0]\n\n    var edge = edges[e]\n    var s = edge[0]\n    var t = edge[1]\n\n    // Check if edge is not lexicographically sorted\n    var a = floatPoints[s]\n    var b = floatPoints[t]\n    if (((a[0] - b[0]) || (a[1] - b[1])) < 0) {\n      var tmp = s\n      s = t\n      t = tmp\n    }\n\n    // Split leading edge\n    edge[0] = s\n    var last = edge[1] = junction[1]\n\n    // If we are grouping edges by color, remember to track data\n    var color\n    if (useColor) {\n      color = edge[2]\n    }\n\n    // Split other edges\n    while (i > 0 && junctions[i - 1][0] === e) {\n      var junction = junctions[--i]\n      var next = junction[1]\n      if (useColor) {\n        edges.push([last, next, color])\n      } else {\n        edges.push([last, next])\n      }\n      last = next\n    }\n\n    // Add final edge\n    if (useColor) {\n      edges.push([last, t, color])\n    } else {\n      edges.push([last, t])\n    }\n  }\n\n  // Return constructed rational points\n  return ratPoints\n}\n\n// Merge overlapping points\nfunction dedupPoints (floatPoints, ratPoints, floatBounds) {\n  var numPoints = ratPoints.length\n  var uf = new UnionFind(numPoints)\n\n  // Compute rational bounds\n  var bounds = []\n  for (var i = 0; i < ratPoints.length; ++i) {\n    var p = ratPoints[i]\n    var xb = boundRat(p[0])\n    var yb = boundRat(p[1])\n    bounds.push([\n      nextafter(xb[0], -Infinity),\n      nextafter(yb[0], -Infinity),\n      nextafter(xb[1], Infinity),\n      nextafter(yb[1], Infinity)\n    ])\n  }\n\n  // Link all points with over lapping boxes\n  boxIntersect(bounds, function (i, j) {\n    uf.link(i, j)\n  })\n\n  // Do 1 pass over points to combine points in label sets\n  var noDupes = true\n  var labels = new Array(numPoints)\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i)\n    if (j !== i) {\n      // Clear no-dupes flag, zero out label\n      noDupes = false\n      // Make each point the top-left point from its cell\n      floatPoints[j] = [\n        Math.min(floatPoints[i][0], floatPoints[j][0]),\n        Math.min(floatPoints[i][1], floatPoints[j][1])\n      ]\n    }\n  }\n\n  // If no duplicates, return null to signal termination\n  if (noDupes) {\n    return null\n  }\n\n  var ptr = 0\n  for (var i = 0; i < numPoints; ++i) {\n    var j = uf.find(i)\n    if (j === i) {\n      labels[i] = ptr\n      floatPoints[ptr++] = floatPoints[i]\n    } else {\n      labels[i] = -1\n    }\n  }\n\n  floatPoints.length = ptr\n\n  // Do a second pass to fix up missing labels\n  for (var i = 0; i < numPoints; ++i) {\n    if (labels[i] < 0) {\n      labels[i] = labels[uf.find(i)]\n    }\n  }\n\n  // Return resulting union-find data structure\n  return labels\n}\n\nfunction compareLex2 (a, b) { return (a[0] - b[0]) || (a[1] - b[1]) }\nfunction compareLex3 (a, b) {\n  var d = (a[0] - b[0]) || (a[1] - b[1])\n  if (d) {\n    return d\n  }\n  if (a[2] < b[2]) {\n    return -1\n  } else if (a[2] > b[2]) {\n    return 1\n  }\n  return 0\n}\n\n// Remove duplicate edge labels\nfunction dedupEdges (edges, labels, useColor) {\n  if (edges.length === 0) {\n    return\n  }\n  if (labels) {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      var a = labels[e[0]]\n      var b = labels[e[1]]\n      e[0] = Math.min(a, b)\n      e[1] = Math.max(a, b)\n    }\n  } else {\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      var a = e[0]\n      var b = e[1]\n      e[0] = Math.min(a, b)\n      e[1] = Math.max(a, b)\n    }\n  }\n  if (useColor) {\n    edges.sort(compareLex3)\n  } else {\n    edges.sort(compareLex2)\n  }\n  var ptr = 1\n  for (var i = 1; i < edges.length; ++i) {\n    var prev = edges[i - 1]\n    var next = edges[i]\n    if (next[0] === prev[0] && next[1] === prev[1] &&\n      (!useColor || next[2] === prev[2])) {\n      continue\n    }\n    edges[ptr++] = next\n  }\n  edges.length = ptr\n}\n\nfunction preRound (points, edges, useColor) {\n  var labels = dedupPoints(points, [], boundPoints(points))\n  dedupEdges(edges, labels, useColor)\n  return !!labels\n}\n\n// Repeat until convergence\nfunction snapRound (points, edges, useColor) {\n  // 1. find edge crossings\n  var edgeBounds = boundEdges(points, edges)\n  var crossings = getCrossings(points, edges, edgeBounds)\n\n  // 2. find t-junctions\n  var vertBounds = boundPoints(points)\n  var tjunctions = getTJunctions(points, edges, edgeBounds, vertBounds)\n\n  // 3. cut edges, construct rational points\n  var ratPoints = cutEdges(points, edges, crossings, tjunctions, useColor)\n\n  // 4. dedupe verts\n  var labels = dedupPoints(points, ratPoints, vertBounds)\n\n  // 5. dedupe edges\n  dedupEdges(edges, labels, useColor)\n\n  // 6. check termination\n  if (!labels) {\n    return (crossings.length > 0 || tjunctions.length > 0)\n  }\n\n  // More iterations necessary\n  return true\n}\n\n// Main loop, runs PSLG clean up until completion\nfunction cleanPSLG (points, edges, colors) {\n  // If using colors, augment edges with color data\n  var prevEdges\n  if (colors) {\n    prevEdges = edges\n    var augEdges = new Array(edges.length)\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      augEdges[i] = [e[0], e[1], colors[i]]\n    }\n    edges = augEdges\n  }\n\n  // First round: remove duplicate edges and points\n  var modified = preRound(points, edges, !!colors)\n\n  // Run snap rounding until convergence\n  while (snapRound(points, edges, !!colors)) {\n    modified = true\n  }\n\n  // Strip color tags\n  if (!!colors && modified) {\n    prevEdges.length = 0\n    colors.length = 0\n    for (var i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      prevEdges.push([e[0], e[1]])\n      colors.push(e[2])\n    }\n  }\n\n  return modified\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}