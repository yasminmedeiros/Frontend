{"ast":null,"code":"module.exports = preprocessPolygon;\nvar orient = require('robust-orientation')[3];\nvar makeSlabs = require('slab-decomposition');\nvar makeIntervalTree = require('interval-tree-1d');\nvar bsearch = require('binary-search-bounds');\nfunction visitInterval() {\n  return true;\n}\nfunction intervalSearch(table) {\n  return function (x, y) {\n    var tree = table[x];\n    if (tree) {\n      return !!tree.queryPoint(y, visitInterval);\n    }\n    return false;\n  };\n}\nfunction buildVerticalIndex(segments) {\n  var table = {};\n  for (var i = 0; i < segments.length; ++i) {\n    var s = segments[i];\n    var x = s[0][0];\n    var y0 = s[0][1];\n    var y1 = s[1][1];\n    var p = [Math.min(y0, y1), Math.max(y0, y1)];\n    if (x in table) {\n      table[x].push(p);\n    } else {\n      table[x] = [p];\n    }\n  }\n  var intervalTable = {};\n  var keys = Object.keys(table);\n  for (var i = 0; i < keys.length; ++i) {\n    var segs = table[keys[i]];\n    intervalTable[keys[i]] = makeIntervalTree(segs);\n  }\n  return intervalSearch(intervalTable);\n}\nfunction buildSlabSearch(slabs, coordinates) {\n  return function (p) {\n    var bucket = bsearch.le(coordinates, p[0]);\n    if (bucket < 0) {\n      return 1;\n    }\n    var root = slabs[bucket];\n    if (!root) {\n      if (bucket > 0 && coordinates[bucket] === p[0]) {\n        root = slabs[bucket - 1];\n      } else {\n        return 1;\n      }\n    }\n    var lastOrientation = 1;\n    while (root) {\n      var s = root.key;\n      var o = orient(p, s[0], s[1]);\n      if (s[0][0] < s[1][0]) {\n        if (o < 0) {\n          root = root.left;\n        } else if (o > 0) {\n          lastOrientation = -1;\n          root = root.right;\n        } else {\n          return 0;\n        }\n      } else {\n        if (o > 0) {\n          root = root.left;\n        } else if (o < 0) {\n          lastOrientation = 1;\n          root = root.right;\n        } else {\n          return 0;\n        }\n      }\n    }\n    return lastOrientation;\n  };\n}\nfunction classifyEmpty(p) {\n  return 1;\n}\nfunction createClassifyVertical(testVertical) {\n  return function classify(p) {\n    if (testVertical(p[0], p[1])) {\n      return 0;\n    }\n    return 1;\n  };\n}\nfunction createClassifyPointDegen(testVertical, testNormal) {\n  return function classify(p) {\n    if (testVertical(p[0], p[1])) {\n      return 0;\n    }\n    return testNormal(p);\n  };\n}\nfunction preprocessPolygon(loops) {\n  //Compute number of loops\n  var numLoops = loops.length;\n\n  //Unpack segments\n  var segments = [];\n  var vsegments = [];\n  var ptr = 0;\n  for (var i = 0; i < numLoops; ++i) {\n    var loop = loops[i];\n    var numVertices = loop.length;\n    for (var s = numVertices - 1, t = 0; t < numVertices; s = t++) {\n      var a = loop[s];\n      var b = loop[t];\n      if (a[0] === b[0]) {\n        vsegments.push([a, b]);\n      } else {\n        segments.push([a, b]);\n      }\n    }\n  }\n\n  //Degenerate case: All loops are empty\n  if (segments.length === 0) {\n    if (vsegments.length === 0) {\n      return classifyEmpty;\n    } else {\n      return createClassifyVertical(buildVerticalIndex(vsegments));\n    }\n  }\n\n  //Build slab decomposition\n  var slabs = makeSlabs(segments);\n  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates);\n  if (vsegments.length === 0) {\n    return testSlab;\n  } else {\n    return createClassifyPointDegen(buildVerticalIndex(vsegments), testSlab);\n  }\n}","map":{"version":3,"names":["module","exports","preprocessPolygon","orient","require","makeSlabs","makeIntervalTree","bsearch","visitInterval","intervalSearch","table","x","y","tree","queryPoint","buildVerticalIndex","segments","i","length","s","y0","y1","p","Math","min","max","push","intervalTable","keys","Object","segs","buildSlabSearch","slabs","coordinates","bucket","le","root","lastOrientation","key","o","left","right","classifyEmpty","createClassifyVertical","testVertical","classify","createClassifyPointDegen","testNormal","loops","numLoops","vsegments","ptr","loop","numVertices","t","a","b","testSlab"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/point-in-big-polygon/pnp-big.js"],"sourcesContent":["module.exports = preprocessPolygon\n\nvar orient = require('robust-orientation')[3]\nvar makeSlabs = require('slab-decomposition')\nvar makeIntervalTree = require('interval-tree-1d')\nvar bsearch = require('binary-search-bounds')\n\nfunction visitInterval() {\n  return true\n}\n\nfunction intervalSearch(table) {\n  return function(x, y) {\n    var tree = table[x]\n    if(tree) {\n      return !!tree.queryPoint(y, visitInterval)\n    }\n    return false\n  }\n}\n\nfunction buildVerticalIndex(segments) {\n  var table = {}\n  for(var i=0; i<segments.length; ++i) {\n    var s = segments[i]\n    var x = s[0][0]\n    var y0 = s[0][1]\n    var y1 = s[1][1]\n    var p = [ Math.min(y0, y1), Math.max(y0, y1) ]\n    if(x in table) {\n      table[x].push(p)\n    } else {\n      table[x] = [ p ]\n    }\n  }\n  var intervalTable = {}\n  var keys = Object.keys(table)\n  for(var i=0; i<keys.length; ++i) {\n    var segs = table[keys[i]]\n    intervalTable[keys[i]] = makeIntervalTree(segs)\n  }\n  return intervalSearch(intervalTable)\n}\n\nfunction buildSlabSearch(slabs, coordinates) {\n  return function(p) {\n    var bucket = bsearch.le(coordinates, p[0])\n    if(bucket < 0) {\n      return 1\n    }\n    var root = slabs[bucket]\n    if(!root) {\n      if(bucket > 0 && coordinates[bucket] === p[0]) {\n        root = slabs[bucket-1]\n      } else {\n        return 1\n      }\n    }\n    var lastOrientation = 1\n    while(root) {\n      var s = root.key\n      var o = orient(p, s[0], s[1])\n      if(s[0][0] < s[1][0]) {\n        if(o < 0) {\n          root = root.left\n        } else if(o > 0) {\n          lastOrientation = -1\n          root = root.right\n        } else {\n          return 0\n        }\n      } else {\n        if(o > 0) {\n          root = root.left\n        } else if(o < 0) {\n          lastOrientation = 1\n          root = root.right\n        } else {\n          return 0\n        }\n      }\n    }\n    return lastOrientation\n  }\n}\n\nfunction classifyEmpty(p) {\n  return 1\n}\n\nfunction createClassifyVertical(testVertical) {\n  return function classify(p) {\n    if(testVertical(p[0], p[1])) {\n      return 0\n    }\n    return 1\n  }\n}\n\nfunction createClassifyPointDegen(testVertical, testNormal) {\n  return function classify(p) {\n    if(testVertical(p[0], p[1])) {\n      return 0\n    }\n    return testNormal(p)\n  }\n}\n\nfunction preprocessPolygon(loops) {\n  //Compute number of loops\n  var numLoops = loops.length\n\n  //Unpack segments\n  var segments = []\n  var vsegments = []\n  var ptr = 0\n  for(var i=0; i<numLoops; ++i) {\n    var loop = loops[i]\n    var numVertices = loop.length\n    for(var s=numVertices-1,t=0; t<numVertices; s=(t++)) {\n      var a = loop[s]\n      var b = loop[t]\n      if(a[0] === b[0]) {\n        vsegments.push([a,b])\n      } else {\n        segments.push([a,b])\n      }\n    }\n  }\n\n  //Degenerate case: All loops are empty\n  if(segments.length === 0) {\n    if(vsegments.length === 0) {\n      return classifyEmpty\n    } else {\n      return createClassifyVertical(buildVerticalIndex(vsegments))\n    }\n  }\n\n  //Build slab decomposition\n  var slabs = makeSlabs(segments)\n  var testSlab = buildSlabSearch(slabs.slabs, slabs.coordinates)\n\n  if(vsegments.length === 0) {\n    return testSlab\n  } else {\n    return createClassifyPointDegen(\n      buildVerticalIndex(vsegments),\n      testSlab)\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}