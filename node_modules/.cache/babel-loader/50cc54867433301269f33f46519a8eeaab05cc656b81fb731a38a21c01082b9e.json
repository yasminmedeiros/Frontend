{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\nmodule.exports = function (vectorfield, bounds) {\n  var positions = vectorfield.positions;\n  var vectors = vectorfield.vectors;\n  var geo = {\n    positions: [],\n    vertexIntensity: [],\n    vertexIntensityBounds: vectorfield.vertexIntensityBounds,\n    vectors: [],\n    cells: [],\n    coneOffset: vectorfield.coneOffset,\n    colormap: vectorfield.colormap\n  };\n  if (vectorfield.positions.length === 0) {\n    if (bounds) {\n      bounds[0] = [0, 0, 0];\n      bounds[1] = [0, 0, 0];\n    }\n    return geo;\n  }\n\n  // Compute bounding box for the dataset.\n  // Compute maximum velocity for the dataset to use for scaling the cones.\n  var maxNorm = 0;\n  var minX = Infinity,\n    maxX = -Infinity;\n  var minY = Infinity,\n    maxY = -Infinity;\n  var minZ = Infinity,\n    maxZ = -Infinity;\n  var p2 = null;\n  var u2 = null;\n  var positionVectors = [];\n  var vectorScale = Infinity;\n  var skipIt = false;\n  for (var i = 0; i < positions.length; i++) {\n    var p = positions[i];\n    minX = Math.min(p[0], minX);\n    maxX = Math.max(p[0], maxX);\n    minY = Math.min(p[1], minY);\n    maxY = Math.max(p[1], maxY);\n    minZ = Math.min(p[2], minZ);\n    maxZ = Math.max(p[2], maxZ);\n    var u = vectors[i];\n    if (vec3.length(u) > maxNorm) {\n      maxNorm = vec3.length(u);\n    }\n    if (i) {\n      // Find vector scale [w/ units of time] using \"successive\" positions\n      // (not \"adjacent\" with would be O(n^2)),\n      //\n      // The vector scale corresponds to the minimum \"time\" to travel across two\n      // two adjacent positions at the average velocity of those two adjacent positions\n\n      var q = 2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u));\n      if (q) {\n        vectorScale = Math.min(vectorScale, q);\n        skipIt = false;\n      } else {\n        skipIt = true;\n      }\n    }\n    if (!skipIt) {\n      p2 = p;\n      u2 = u;\n    }\n    positionVectors.push(u);\n  }\n  var minV = [minX, minY, minZ];\n  var maxV = [maxX, maxY, maxZ];\n  if (bounds) {\n    bounds[0] = minV;\n    bounds[1] = maxV;\n  }\n  if (maxNorm === 0) {\n    maxNorm = 1;\n  }\n\n  // Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n  var invertedMaxNorm = 1 / maxNorm;\n  if (!isFinite(vectorScale)) {\n    vectorScale = 1.0;\n  }\n  geo.vectorScale = vectorScale;\n  var coneScale = vectorfield.coneSize || 0.5;\n  if (vectorfield.absoluteConeSize) {\n    coneScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n  }\n  geo.coneScale = coneScale;\n\n  // Build the cone model.\n  for (var i = 0, j = 0; i < positions.length; i++) {\n    var p = positions[i];\n    var x = p[0],\n      y = p[1],\n      z = p[2];\n    var d = positionVectors[i];\n    var intensity = vec3.length(d) * invertedMaxNorm;\n    for (var k = 0, l = 8; k < l; k++) {\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.positions.push([x, y, z, j++]);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vectors.push(d);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      geo.vertexIntensity.push(intensity, intensity, intensity);\n      var m = geo.positions.length;\n      geo.cells.push([m - 6, m - 5, m - 4], [m - 3, m - 2, m - 1]);\n    }\n  }\n  return geo;\n};\nvar shaders = require('./lib/shaders');\nmodule.exports.createMesh = require('./create_mesh');\nmodule.exports.createConeMesh = function (gl, params) {\n  return module.exports.createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'cone'\n  });\n};","map":{"version":3,"names":["vec3","require","module","exports","vectorfield","bounds","positions","vectors","geo","vertexIntensity","vertexIntensityBounds","cells","coneOffset","colormap","length","maxNorm","minX","Infinity","maxX","minY","maxY","minZ","maxZ","p2","u2","positionVectors","vectorScale","skipIt","i","p","Math","min","max","u","q","distance","push","minV","maxV","invertedMaxNorm","isFinite","coneScale","coneSize","absoluteConeSize","j","x","y","z","d","intensity","k","l","m","shaders","createMesh","createConeMesh","gl","params","traceType"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/gl-cone3d/cone.js"],"sourcesContent":["\"use strict\";\n\nvar vec3 = require('gl-vec3');\n\nmodule.exports = function(vectorfield, bounds) {\n\tvar positions = vectorfield.positions;\n\tvar vectors = vectorfield.vectors;\n\tvar geo = {\n\t\tpositions: [],\n\t\tvertexIntensity: [],\n\t\tvertexIntensityBounds: vectorfield.vertexIntensityBounds,\n\t\tvectors: [],\n\t\tcells: [],\n\t\tconeOffset: vectorfield.coneOffset,\n\t\tcolormap: vectorfield.colormap\n\t};\n\n\tif (vectorfield.positions.length === 0) {\n\t\tif (bounds) {\n\t\t\tbounds[0] = [0,0,0];\n\t\t\tbounds[1] = [0,0,0];\n\t\t}\n\t\treturn geo;\n\t}\n\n\t// Compute bounding box for the dataset.\n\t// Compute maximum velocity for the dataset to use for scaling the cones.\n\tvar maxNorm = 0;\n\tvar minX = Infinity, maxX = -Infinity;\n\tvar minY = Infinity, maxY = -Infinity;\n\tvar minZ = Infinity, maxZ = -Infinity;\n\tvar p2 = null;\n\tvar u2 = null;\n\tvar positionVectors = [];\n\tvar vectorScale = Infinity;\n\tvar skipIt = false;\n\tfor (var i = 0; i < positions.length; i++) {\n\t\tvar p = positions[i];\n\t\tminX = Math.min(p[0], minX);\n\t\tmaxX = Math.max(p[0], maxX);\n\t\tminY = Math.min(p[1], minY);\n\t\tmaxY = Math.max(p[1], maxY);\n\t\tminZ = Math.min(p[2], minZ);\n\t\tmaxZ = Math.max(p[2], maxZ);\n\t\tvar u = vectors[i];\n\n\t\tif (vec3.length(u) > maxNorm) {\n\t\t\tmaxNorm = vec3.length(u);\n\t\t}\n\t\tif (i) {\n\t\t\t// Find vector scale [w/ units of time] using \"successive\" positions\n\t\t\t// (not \"adjacent\" with would be O(n^2)),\n\t\t\t//\n\t\t\t// The vector scale corresponds to the minimum \"time\" to travel across two\n\t\t\t// two adjacent positions at the average velocity of those two adjacent positions\n\n\t\t\tvar q = (2 * vec3.distance(p2, p) / (vec3.length(u2) + vec3.length(u)));\n\t\t\tif(q) {\n\t\t\t\tvectorScale = Math.min(vectorScale, q);\n\t\t\t\tskipIt = false;\n\t\t\t} else {\n\t\t\t\tskipIt = true;\n\t\t\t}\n\t\t}\n\t\tif(!skipIt) {\n\t\t\tp2 = p;\n\t\t\tu2 = u;\n\t\t}\n\t\tpositionVectors.push(u);\n\t}\n\tvar minV = [minX, minY, minZ];\n\tvar maxV = [maxX, maxY, maxZ];\n\tif (bounds) {\n\t\tbounds[0] = minV;\n\t\tbounds[1] = maxV;\n\t}\n\tif (maxNorm === 0) {\n\t\tmaxNorm = 1;\n\t}\n\n\t// Inverted max norm would map vector with norm maxNorm to 1 coord space units in length\n\tvar invertedMaxNorm = 1 / maxNorm;\n\n\tif (!isFinite(vectorScale)) {\n\t\tvectorScale = 1.0;\n\t}\n\tgeo.vectorScale = vectorScale;\n\n\tvar coneScale = vectorfield.coneSize || 0.5;\n\n\tif (vectorfield.absoluteConeSize) {\n\t\tconeScale = vectorfield.absoluteConeSize * invertedMaxNorm;\n\t}\n\n\tgeo.coneScale = coneScale;\n\n\t// Build the cone model.\n\tfor (var i = 0, j = 0; i < positions.length; i++) {\n\t\tvar p = positions[i];\n\t\tvar x = p[0], y = p[1], z = p[2];\n\t\tvar d = positionVectors[i];\n\t\tvar intensity = vec3.length(d) * invertedMaxNorm;\n\t\tfor (var k = 0, l = 8; k < l; k++) {\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\t\t\tgeo.positions.push([x, y, z, j++]);\n\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\t\t\tgeo.vectors.push(d);\n\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\t\t\tgeo.vertexIntensity.push(intensity, intensity, intensity);\n\n\t\t\tvar m = geo.positions.length;\n\t\t\tgeo.cells.push([m-6, m-5, m-4], [m-3, m-2, m-1]);\n\t\t}\n\t}\n\n\treturn geo;\n};\n\nvar shaders = require('./lib/shaders');\nmodule.exports.createMesh = require('./create_mesh');\nmodule.exports.createConeMesh = function(gl, params) {\n\treturn module.exports.createMesh(gl, params, {\n\t\tshaders: shaders,\n\t\ttraceType: 'cone'\n\t});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}