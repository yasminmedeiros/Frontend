{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar Polar = require('../plots/polar/legacy');\nvar Axes = require('../plots/cartesian/axes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar connectColorbar = require('../components/colorbar/connect');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar svgTextUtils = require('../lib/svg_text_utils');\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nexports.plot = function (gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd);\n\n  // Events.init is idempotent and bails early if gd has already been init'd\n  Events.init(gd);\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject();\n\n  // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling Plotly.plot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  }\n\n  // transfer configuration options to gd until we move over to\n  // a more OO like model\n  setPlotContext(gd, config);\n  if (!layout) layout = {};\n\n  // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n  d3.select(gd).classed('js-plotly-plot', true);\n\n  // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n  Drawing.makeTester();\n\n  // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data);\n\n  // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data);\n\n    // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n    gd.empty = false;\n  }\n  if (!gd.layout || graphWasEmpty) gd.layout = helpers.cleanLayout(layout);\n\n  // if the user is trying to drag the axes, allow new data and layout\n  // to come in but don't allow a replot.\n  if (gd._dragging && !gd._transitioning) {\n    // signal to drag handler that after everything else is done\n    // we need to replot, because something has changed\n    gd._replotPending = true;\n    return Promise.reject();\n  } else {\n    // we're going ahead with a replot now\n    gd._replotPending = false;\n  }\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n  var hasCartesian = fullLayout._has('cartesian');\n\n  // Legacy polar plots\n  if (!fullLayout._has('polar') && data && data[0] && data[0].r) {\n    Lib.log('Legacy polar charts are deprecated!');\n    return plotLegacyPolar(gd, data, layout);\n  }\n\n  // so we don't try to re-call Plotly.plot from inside\n  // legend and colorbar, if margins changed\n  fullLayout._replotting = true;\n\n  // make or remake the framework if we need to\n  if (graphWasEmpty) makePlotFramework(gd);\n\n  // polar need a different framework\n  if (gd.framework !== makePlotFramework) {\n    gd.framework = makePlotFramework;\n    makePlotFramework(gd);\n  }\n\n  // clear gradient defs on each .plot call, because we know we'll loop through all traces\n  Drawing.initGradients(gd);\n\n  // save initial show spikes once per graph\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n  // prepare the data and find the autorange\n\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling Plotly.plot\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd);\n\n  // in case it has changed, attach fullData traces to calcdata\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  }\n\n  // make the figure responsive\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        Plots.resize(gd);\n      };\n\n      // Listen to window resize\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n\n  /*\n   * start async-friendly code - now we're actually drawing things\n   */\n\n  var oldmargins = JSON.stringify(fullLayout._size);\n\n  // draw framework first so that margin-pushing\n  // components can position themselves correctly\n  var drawFrameworkCalls = 0;\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        'position': 'absolute',\n        'top': 0,\n        'left': 0,\n        'width': '100%',\n        'height': '100%',\n        'overflow': 'visible',\n        'pointer-events': 'none'\n      });\n    }\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width).attr('height', fullLayout.height);\n      var regl = fullLayout._glcanvas.data()[0].regl;\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n    return Plots.previousPromises(gd);\n  }\n\n  // draw anything that can affect margins.\n  function marginPushers() {\n    var calcdata = gd.calcdata;\n    var i, cd, trace;\n\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd);\n    for (i = 0; i < calcdata.length; i++) {\n      cd = calcdata[i];\n      trace = cd[0].trace;\n      var colorbarOpts = trace._module.colorbar;\n      if (trace.visible !== true || !colorbarOpts) {\n        Plots.autoMargin(gd, 'cb' + trace.uid);\n      } else connectColorbar(gd, cd, colorbarOpts);\n    }\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  }\n\n  // in case the margins changed, draw margin pushers again\n  function marginPushersAgain() {\n    if (JSON.stringify(fullLayout._size) === oldmargins) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    }\n\n    // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd);\n\n    // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n    if (graphWasEmpty) Axes.saveRangeInitial(gd);\n\n    // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  }\n\n  // draw ticks, titles, and calculate axis scaling (._b, ._m)\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n  if (hasCartesian) seq.push(drawAxes);\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover,\n  // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, Plots.previousPromises);\n\n  // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n};\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\nexports.setPlotConfig = function setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n};\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig);\n\n    // stash <base> href, used to make robust clipPath URLs\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n  var context = gd._context;\n  var i, keys, key;\n  if (config) {\n    keys = Object.keys(config);\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    }\n\n    // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    }\n\n    // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n    var editable = config.editable;\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    }\n\n    // not part of the user-facing config options\n    context._exportedPlot = config._exportedPlot;\n  }\n\n  // staticPlot forces a bunch of others:\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  }\n\n  // make sure hover-only devices have mode bar visible\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  }\n\n  // default and fallback for setBackground\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  }\n\n  // Check if gd has a specified widht/height to begin with\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n  // fill context._scrollZoom helper to help manage scrollZoom flaglist\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  }\n}\nfunction plotLegacyPolar(gd, data, layout) {\n  // build or reuse the container skeleton\n  var plotContainer = d3.select(gd).selectAll('.plot-container').data([0]);\n  plotContainer.enter().insert('div', ':first-child').classed('plot-container plotly', true);\n  var paperDiv = plotContainer.selectAll('.svg-container').data([0]);\n  paperDiv.enter().append('div').classed('svg-container', true).style('position', 'relative');\n\n  // empty it everytime for now\n  paperDiv.html('');\n\n  // fulfill gd requirements\n  if (data) gd.data = data;\n  if (layout) gd.layout = layout;\n  Polar.manager.fillLayout(gd);\n\n  // resize canvas\n  paperDiv.style({\n    width: gd._fullLayout.width + 'px',\n    height: gd._fullLayout.height + 'px'\n  });\n\n  // instantiate framework\n  gd.framework = Polar.manager.framework(gd);\n\n  // plot\n  gd.framework({\n    data: gd.data,\n    layout: gd.layout\n  }, paperDiv.node());\n\n  // set undo point\n  gd.framework.setUndoPoint();\n\n  // get the resulting svg for extending it\n  var polarPlotSVG = gd.framework.svg();\n\n  // editable title\n  var opacity = 1;\n  var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n  if (txt === '' || !txt) opacity = 0;\n  var titleLayout = function titleLayout() {\n    this.call(svgTextUtils.convertToTspans, gd);\n    // TODO: html/mathjax\n    // TODO: center title\n  };\n\n  var title = polarPlotSVG.select('.title-group text').call(titleLayout);\n  if (gd._context.edits.titleText) {\n    var placeholderText = Lib._(gd, 'Click to enter Plot title');\n    if (!txt || txt === placeholderText) {\n      opacity = 0.2;\n      // placeholder is not going through convertToTspans\n      // so needs explicit data-unformatted\n      title.attr({\n        'data-unformatted': placeholderText\n      }).text(placeholderText).style({\n        opacity: opacity\n      }).on('mouseover.opacity', function () {\n        d3.select(this).transition().duration(100).style('opacity', 1);\n      }).on('mouseout.opacity', function () {\n        d3.select(this).transition().duration(1000).style('opacity', 0);\n      });\n    }\n    var setContenteditable = function setContenteditable() {\n      this.call(svgTextUtils.makeEditable, {\n        gd: gd\n      }).on('edit', function (text) {\n        gd.framework({\n          layout: {\n            title: {\n              text: text\n            }\n          }\n        });\n        this.text(text).call(titleLayout);\n        this.call(setContenteditable);\n      }).on('cancel', function () {\n        var txt = this.attr('data-unformatted');\n        this.text(txt).call(titleLayout);\n      });\n    };\n    title.call(setContenteditable);\n  }\n  gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n  Plots.addLinks(gd);\n  return Promise.resolve();\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nexports.redraw = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports.plot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n};\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nexports.newPlot = function (gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd);\n\n  // remove gl contexts\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports.plot(gd, data, layout, config);\n};\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n  return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    // validate that indices are indeed integers\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    }\n\n    // check that all indices are in bounds for given gd.data array length\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    }\n\n    // check that indices aren't repeated\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  }\n\n  // validate currentIndices array\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n  assertIndexArray(gd, currentIndices, 'currentIndices');\n\n  // validate newIndices array if it exists\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  }\n\n  // check currentIndices and newIndices are the same length if newIdices exists\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value;\n\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  }\n\n  // make sure traces exists\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  }\n\n  // make sure traces is an array\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  }\n\n  // make sure each value in traces is an object\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  }\n\n  // make sure we have an index for each trace\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n  assertIndexArray(gd, indices, 'indices');\n  for (var key in update) {\n    /*\n     * Verify that the attribute to be updated contains as many trace updates\n     * as indices. Failure must result in throw and no-op\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n\n    /*\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n     */\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp;\n\n  // allow scalar index to represent a single trace position\n  if (!Array.isArray(indices)) indices = [indices];\n\n  // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n  indices = positivifyIndices(indices, gd.data.length - 1);\n\n  // loop through all update keys and traces and harvest validated data.\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\n       * instance that references the key and value for this particular trace.\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n\n      /*\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n       * Target must exist as an Array to allow the extend operation to be performed.\n       */\n      target = prop.get();\n      insert = update[key][j];\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n\n      /*\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\n       * Use the scalar maxPoints for all key and trace combinations.\n       */\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n      // could have chosen null here, -1 just tells us to not take a window\n      if (!isNumeric(maxp)) maxp = -1;\n\n      /*\n       * Wrap the nestedProperty in an object containing required data\n       * for lengthening and windowing this particular trace - key combination.\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n       */\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  }\n\n  // all target and insertion data now validated\n  return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp;\n\n    // return new array and remainder\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]);\n\n    // build the inverse update object for the undo operation\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]);\n\n    // build the matching maxPoints undo object containing original trace lengths\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nexports.extendTraces = function extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n    return [newArray, remainder];\n  }\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n};\nexports.prependTraces = function prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n    return [newArray, remainder];\n  }\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n};\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nexports.addTraces = function addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n  var i;\n  var promise;\n\n  // all validation is done elsewhere to remove clutter here\n  checkAddTracesArgs(gd, traces, newIndices);\n\n  // make sure traces is an array\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  }\n\n  // make sure traces do not repeat existing ones\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces);\n\n  // add the traces to gd.data (no redrawing yet!)\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  }\n\n  // to continue, we need to call moveTraces which requires currentIndices\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  }\n\n  // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  }\n\n  // make sure indices is property defined\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  }\n\n  // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n};\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nexports.deleteTraces = function deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace;\n\n  // make sure indices are defined\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n  assertIndexArray(gd, indices, 'indices');\n\n  // convert negative indices to positive indices\n  indices = positivifyIndices(indices, gd.data.length - 1);\n\n  // we want descending here so that splicing later doesn't affect indexing\n  indices.sort(Lib.sorterDes);\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n};\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nexports.moveTraces = function moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i;\n\n  // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n  checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n  // make sure currentIndices is an array\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n  // if undefined, define newIndices to point to the end of gd.data array\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  }\n\n  // make sure newIndices is an array if it's user-defined\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n  // convert negative indices to positive indices (they're the same length)\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n  // at this point, we've coerced the index arrays into predictable forms\n\n  // get the traces that aren't being moved around\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  }\n\n  // get a mapping of indices to moving traces\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  }\n\n  // reorder this mapping by newIndex, ascending\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  });\n\n  // now, add the moving traces back in, in order!\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n};\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n  var specs = _restyle(gd, aobj, traces);\n  var flags = specs.flags;\n\n  // clear calcdata and/or axis types if required so they get regenerated\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n  // fill in redraw sequence\n  var seq = [];\n  if (flags.fullReplot) {\n    seq.push(exports.plot);\n  } else {\n    seq.push(Plots.previousPromises);\n\n    // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n    Plots.supplyDefaults(gd);\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq);\n\n      // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n}\nexports.restyle = restyle;\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n    return np;\n  };\n}\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nexports._storeDirectGUIEdit = function (container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n};\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj);\n\n  // initialize flags\n  var flags = editTypes.traceFlags();\n\n  // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n  var redoit = {};\n  var undoit = {};\n  var axlist;\n\n  // make a new empty vals array for undoit\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  }\n\n  // for autoranging multiple axes\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    }\n    // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n  }\n\n  // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    }\n    // quit if explicitly setting this elsewhere\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  }\n\n  // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n    }\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject;\n\n    // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n    redoit[ai] = vi;\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())];\n      // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n      param.set(Array.isArray(vi) ? vi[0] : vi);\n      // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n      flags.calc = true;\n      continue;\n    }\n\n    // set attribute in gd.data\n    undoit[ai] = a0();\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      }\n\n      // changing colorbar size modes,\n      // make the resulting size not change\n      // note that colorbar fractional sizing is based on the\n      // original plot size, before anything (like a colorbar)\n      // increases the margins\n      else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && newVal === 'pie' !== (oldVal === 'pie')) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n        if (oldVal === 'pie') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get());\n\n          // super kludgy - but if all pies are gone we won't remove them otherwise\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n      undoit[ai][i] = undefinedToNull(oldVal);\n      // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal);\n          // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        }\n        // orientationaxes has no value,\n        // it flips everything and the axes\n        else if (ai === 'orientationaxes') {\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\n           * if we couldn't find valObject,  assume a full recalc.\n           * This can happen if you're changing type and making\n           * some other edits too, so the modules we're\n           * looking at don't have these attributes in them.\n           */\n          flags.calc = true;\n        }\n\n        // all the other ones, just modify that one attribute\n        param.set(newVal);\n      }\n    }\n\n    // swap the data attributes of the relevant x and y axes?\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    }\n\n    // swap hovermode if set to \"compare x/y data\"\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n      if (hovermode.get() === 'x') {\n        hovermode.set('y');\n      } else if (hovermode.get() === 'y') {\n        hovermode.set('x');\n      }\n    }\n\n    // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n  var aobj = {};\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var specs = _relayout(gd, aobj);\n  var flags = specs.flags;\n\n  // clear calcdata if required\n  if (flags.calc) gd.calcdata = undefined;\n\n  // fill in redraw sequence\n\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n  var seq = [Plots.previousPromises];\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n}\nexports.relayout = relayout;\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var k;\n  if (!flags.axrange) return false;\n  for (k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n  for (k in specs.rangesAltered) {\n    var axName = Axes.id2name(k);\n    var axIn = gd.layout[axName];\n    var axOut = gd._fullLayout[axName];\n    axOut.autorange = axIn.autorange;\n    axOut.range = axIn.range.slice();\n    axOut.cleanRange();\n  }\n  return true;\n}\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var opts = {\n      skipTitle: true\n    };\n    for (var id in rangesAltered) {\n      if (Axes.getFromId(gd, id).automargin) {\n        opts = {};\n        break;\n      }\n    }\n    return Axes.draw(gd, Object.keys(rangesAltered), opts);\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj);\n\n  // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n      delete aobj[keys[i]];\n    }\n  }\n\n  // initialize flags\n  var flags = editTypes.layoutFlags();\n\n  // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n  var redoit = {};\n  var undoit = {};\n\n  // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    }\n\n    // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n    if (val !== undefined) p.set(val);\n  }\n\n  // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n  var rangesAltered = {};\n  var axId;\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  }\n\n  // alter gd.layout\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n    }\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length;\n    // p.parts may end with an index integer if the property is an array\n    var pend = plen - 1;\n    while (pend > 0 && typeof p.parts[pend] !== 'string') {\n      pend--;\n    }\n    // last property in chain (leaf node)\n    var pleaf = p.parts[pend];\n    // leaf plus immediate parent\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n    // trunk nodes (everything except the leaf)\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi;\n\n    // axis reverse is special - it is its own inverse\n    // op and has no flag.\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    }\n\n    // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null);\n        // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    }\n    // check autorange vs range\n    else if (pleafPlus.match(AX_RANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    }\n\n    // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n    if (pleaf === 'type') {\n      var ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            }\n            // if one is negative, set it 6 orders below the other.\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6;\n            // now set the range values as appropriate\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        }\n\n        // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        }\n\n        // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type;\n\n      // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    }\n\n    // alter gd.layout\n\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n      editTypes.update(flags, updateValObject);\n\n      // prepare the edits object we'll send to applyContainerArrayChanges\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    }\n    // handle axis reversal explicitly, as there's no 'reverse' attribute\n    else if (pleaf === 'reverse') {\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n      p.set(vi);\n    }\n  }\n\n  // now we've collected component edits - execute them all together\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  }\n\n  // figure out if we need to recalculate axis constraints\n  var constraints = fullLayout._axisConstraintGroups || [];\n  for (axId in rangesAltered) {\n    for (i = 0; i < constraints.length; i++) {\n      var group = constraints[i];\n      if (group[axId]) {\n        // Always recalc if we're changing constrained ranges.\n        // Otherwise it's possible to violate the constraints by\n        // specifying arbitrary ranges for all axes in the group.\n        // this way some ranges may expand beyond what's specified,\n        // as they do at first draw, to satisfy the constraints.\n        flags.calc = true;\n        for (var groupAxId in group) {\n          if (!rangesAltered[groupAxId]) {\n            Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n          }\n        }\n      }\n    }\n  }\n\n  // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height;\n\n  // calculate autosizing\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  if (gd.framework && gd.framework.isPolar) {\n    return Promise.resolve(gd);\n  }\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n  var restyleFlags = restyleSpecs.flags;\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n  var relayoutFlags = relayoutSpecs.flags;\n\n  // clear calcdata and/or axis types if required\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n  // fill in redraw sequence\n  var seq = [];\n  if (restyleFlags.fullReplot && relayoutFlags.layoutReplot) {\n    var data = gd.data;\n    var layout = gd.layout;\n\n    // clear existing data/layout on gd\n    // so that Plotly.plot doesn't try to extend them\n    gd.data = undefined;\n    gd.layout = undefined;\n    seq.push(function () {\n      return exports.plot(gd, data, layout);\n    });\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports.plot);\n  } else if (relayoutFlags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n  seq.push(Plots.rehover);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\nexports.update = update;\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n}\nexports._guiRestyle = guiEdit(restyle);\nexports._guiRelayout = guiEdit(relayout);\nexports._guiUpdate = guiEdit(update);\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n},\n// showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n},\n// \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n},\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n},\n// including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n    if (match) {\n      return {\n        head: match[1],\n        attr: spec.attr\n      };\n    }\n  }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n  return container.uirevision;\n}\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n  return -1;\n}\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  }\n  // fall back on trace order, but only if user didn't provide a uid for that trace\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n  return v1 === v2;\n}\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n  var bothInheritAutorange = [];\n  var newRangeAccepted = {};\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n    if (match) {\n      revAttr = match.attr || match.head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n            bothInheritAutorange.push(key.substr(0, key.length - 10));\n          }\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    }\n    // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n    delete layoutPreGUI[key];\n    if (key.substr(key.length - 8, 6) === 'range[') {\n      newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n    }\n  }\n\n  // Special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  }\n\n  // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n        newTrace = data[newTracei];\n      }\n      match = findUIPattern(key, traceUIControlPatterns);\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision;\n          // inheritance for trace.uirevision is simple, just layout.uirevision\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n      delete tracePreGUI[key];\n    }\n  }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nexports.react = function (gd, data, layout, config) {\n  var frames, plotDone;\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n  gd = Lib.getGraphDiv(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout;\n\n  // you can use this as the initial draw as well as to update\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n    var configChanged = false;\n    // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n    // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n    // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n    // clear calcdata if required\n    if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n    // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n    else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n\n    // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n\n    // fill in redraw sequence\n    var seq = [];\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    }\n\n    // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports.plot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n            draw(gd);\n          }\n        }\n      }\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n    seq.push(Plots.rehover);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n};\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n  function getTraceValObject(parts) {\n    return PlotSchema.getTraceValObject(trace, parts);\n  }\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n  return flags;\n}\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n  return flags;\n}\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n  function changed() {\n    var editType = valObject.editType;\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n    editTypes.update(flags, valObject);\n    if (editType !== 'none') {\n      flags.nChanges++;\n    }\n\n    // track animatable changes\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    }\n\n    // track cartesian axes with altered ranges\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    }\n\n    // clear _inputDomain on cartesian axes with altered domains\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    }\n\n    // track datarevision changes\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n    // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    }\n    // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts);\n\n    // in case type changed, we may not even *have* a valObject.\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal);\n\n    // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n        // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      }\n\n      // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        }\n\n        // look for animatable attributes when the data changed\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nexports.animate = function (gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n  var trans = gd._transitionData;\n\n  // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame;\n\n  // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  }\n\n  // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resovled *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n      gd.emit('plotly_animationinterrupted', []);\n    }\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i);\n\n        // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n        trans._frameQueue.push(nextFrame);\n      }\n\n      // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      }\n\n      // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated');\n\n      // Be sure to unset also since it's how we know whether a loop is already running:\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration;\n\n        // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating');\n\n      // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n      var doFrame = function doFrame() {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n        // Check if we're ready for a new frame:\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n      doFrame();\n    }\n\n    // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n    var configCounter = 0;\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n      configCounter++;\n      return frame;\n    }\n\n    // Disambiguate what's sort of frames have been received\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName);\n          // In this case, there's an array and this frame is a string name:\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    }\n\n    // Verify that all of these frames actually exist; return and reject if not:\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    }\n\n    // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n    var currentFrame = gd._fullLayout._currentFrame;\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n        frameList = filteredFrameList;\n      }\n    }\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n};\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nexports.addFrames = function (gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plot.ly/javascript/animations/');\n  }\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  }\n\n  // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue;\n\n    // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  }\n\n  // Sort this, taking note that undefined insertions end up at the end:\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]) {\n        ;\n      }\n    }\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nexports.deleteFrames = function (gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n  if (!frameList) {\n    frameList = [];\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n  frameList = frameList.slice(0);\n  frameList.sort();\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nexports.purge = function purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || [];\n\n  // remove gl contexts\n  Plots.cleanPlot([], {}, fullData, fullLayout);\n\n  // purge properties\n  Plots.purge(gd);\n\n  // purge event emitter methods\n  Events.purge(gd);\n\n  // remove plot container\n  if (fullLayout._container) fullLayout._container.remove();\n\n  // in contrast to Plotly.Plots.purge which does NOT clear _context!\n  delete gd._context;\n  return gd;\n};\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout;\n\n  // Plot container\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true);\n\n  // Make the svg container\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n  fullLayout._paperdiv.enter().append('div').classed('svg-container', true).style('position', 'relative');\n\n  // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true);\n\n  // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true);\n\n  // single cartesian layer for the whole plot\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n  // single polar layer for the whole plot\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n  // single ternary layer for the whole plot\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n  // single geo layer for the whole plot\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n  // single pie layer for the whole plot\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n  // fill in image server scrape-svg\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n  // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._toppaper.append('g').classed('hoverlayer', true);\n  gd.emit('plotly_framework');\n}","map":{"version":3,"names":["d3","require","isNumeric","hasHover","Lib","nestedProperty","Events","Queue","Registry","PlotSchema","Plots","Polar","Axes","Drawing","Color","connectColorbar","initInteractions","xmlnsNamespaces","svgTextUtils","dfltConfig","manageArrays","helpers","subroutines","editTypes","AX_NAME_PATTERN","numericNameWarningCount","numericNameWarningCountLimit","exports","plot","gd","data","layout","config","frames","getGraphDiv","init","isPlainObject","obj","okToPlot","triggerHandler","Promise","reject","isPlotDiv","warn","addFrames","setPlotContext","select","classed","makeTester","Array","isArray","_promises","graphWasEmpty","length","cleanData","push","apply","empty","cleanLayout","_dragging","_transitioning","_replotPending","supplyDefaults","fullLayout","_fullLayout","hasCartesian","_has","r","log","plotLegacyPolar","_replotting","makePlotFramework","framework","initGradients","saveShowSpikeInitial","recalc","calcdata","_fullData","doCalcdata","i","trace","_context","responsive","_responsiveChartHandler","resize","window","addEventListener","clearResponsive","oldmargins","JSON","stringify","_size","drawFrameworkCalls","drawFramework","basePlotModules","_basePlotModules","_glcanvas","_glcontainer","selectAll","key","context","pick","d","enter","append","attr","replace","style","width","height","regl","Math","floor","_gl","drawingBufferWidth","drawingBufferHeight","msg","error","cleanPlot","previousPromises","marginPushers","cd","clearAutoMarginIds","drawMarginPushers","allowAutoMargin","colorbarOpts","_module","colorbar","visible","autoMargin","uid","doAutoMargin","marginPushersAgain","syncOrAsync","layoutStyles","positionAndAutorange","doAutoRangeAndConstraints","getComponentMethod","saveRangeInitial","drawAxes","draw","seq","drawData","finalDraw","addLinks","rehover","plotDone","then","resolve","emitAfterPlot","_redrawFromAutoMarginCount","emit","setPlotConfig","extendFlat","setBackground","bgColor","_paper","e","opaqueSetBackground","blend","combine","extendDeep","base","_baseUrl","size","location","href","split","keys","Object","plot3dPixelRatio","plotGlPixelRatio","editable","undefined","edits","_exportedPlot","staticPlot","autosizable","scrollZoom","doubleClick","showTips","showLink","displayModeBar","_hasZeroHeight","clientHeight","_hasZeroWidth","clientWidth","szIn","szOut","_scrollZoom","cartesian","gl3d","geo","mapbox","parts","plotContainer","insert","paperDiv","html","manager","fillLayout","node","setUndoPoint","polarPlotSVG","svg","opacity","txt","title","text","titleLayout","call","convertToTspans","titleText","placeholderText","_","on","transition","duration","setContenteditable","makeEditable","paper_bgcolor","redraw","Error","newPlot","purge","positivifyIndices","indices","maxIndex","parentLength","positiveIndices","index","assertIndexArray","arrayName","parseInt","indexOf","checkMoveTracesArgs","currentIndices","newIndices","checkAddTracesArgs","traces","value","assertExtendTracesArgs","update","maxPoints","maxPointsIsObject","getExtendProperties","updateProps","target","prop","maxp","j","get","isArrayOrTypedArray","constructor","spliceTraces","updateArray","undoUpdate","undoPoints","out","set","astr","concatTypedArray","arr0","arr1","arr2","extendTraces","newArray","remainder","isTypedArray","none","both","numberOfItemsFromInsert","subarray","numberOfItemsFromTarget","targetBegin","concat","splice","undo","promise","undoArgs","add","prependTraces","arguments","addTraces","undoFunc","deleteTraces","redoFunc","redoArgs","map","startSequence","moveTraces","stopSequence","deletedTrace","sort","sorterDes","newData","movingTraceMap","newIndex","a","b","restyle","val","_traces","clearPromiseQueue","aobj","changed","coerceTraceIndices","specs","_restyle","flags","calc","clearAxisTypes","fullReplot","markerSize","addAxRangeSequence","doTraceStyle","colorbars","doColorBars","undoit","redoit","eventData","undefinedToNull","makeNP","preGUI","guiEditFlag","container","prefix","np","npSet","fullAttr","storeCurrent","newVal","arrayVal","arrayNew","maxLen","max","objVal","objNew","objBoth","_storeDirectGUIEdit","fullData","_guiEditing","layoutNP","_preGUI","extendDeepAll","cleanDeprecatedAttributeKeys","traceFlags","axlist","a0","addToAxlist","axid","axName","id2name","autorangeAttr","rangeAttr","getFullTrace","traceIndex","_input","doextra","forEach","hasParent","extraparam","substr","tracei","_tracePreGUI","_fullInput","allBins","binAttr","arrayBins","vij","ai","vi","cont","contFull","param","oldVal","valObject","charAt","finalPart","prefixDot","innerContFull","getTraceValObject","impliedEdits","impliedKey","relativeAttr","gs","orient","topOrBottom","thicknorm","h","w","thickness","lennorm","len","labelsTo","valuesTo","orientation","swapAttrs","_pielayer","remove","traceIs","defaultOrientation","x","y","v","swapXYData","dataArrayContainers","manageArrayContainers","arrayOk","swap","hovermode","xaxis","yaxis","extendDeepNoArrays","oldAxisTitleRegex","counterRegex","colorbarRegex","test","oldAttrStr","newAttrStr","relayout","isPolar","_relayout","layoutReplot","axRangeSupplyDefaultsByPass","legend","doLegend","layoutstyle","axrange","rangesAltered","ticks","doTicksRelayout","modebar","doModeBar","camera","doCamera","k","axIn","axOut","autorange","range","slice","cleanRange","opts","skipTitle","id","getFromId","automargin","AX_RANGE_RE","AX_AUTORANGE_RE","AX_DOMAIN_RE","axes","list","arrayEdits","arrayStr","scene","_id","axisAttr","newkey","_name","layoutFlags","p","axId","recordAlteredAxis","pleafPlus","name2id","plen","pend","pleaf","ptrunk","join","parentIn","parentFull","vOld","getLayoutValObject","oppositeAttr","_initialAutoSize","match","axFull","_inputDomain","domain","ax","toLog","type","fromLog","r0","r1","LN10","pow","_subplots","polar","_subplot","viewInitial","fullProp","newType","containerArrayMatch","array","propStr","property","updateValObject","editType","isAddVal","isRemoveVal","objEdits","reverse","finished","applyContainerArrayChanges","constraints","_axisConstraintGroups","group","groupAxId","_constraintShrinkable","updateAutosize","oldWidth","oldHeight","autosize","plotAutoSize","traceUpdate","layoutUpdate","restyleSpecs","restyleFlags","relayoutSpecs","relayoutFlags","guiEdit","func","wrappedEdit","_guiRestyle","_guiRelayout","_guiUpdate","layoutUIControlPatterns","pattern","traceUIControlPatterns","findUIPattern","patternSpecs","spec","head","getNewRev","revAttr","newRev","pop","uirevision","getFullTraceIndexFromUid","getTraceIndexFromUid","valsMatch","v1","v2","v1IsObj","v1IsArray","applyUIRevisions","oldFullData","oldFullLayout","layoutPreGUI","oldRev","preGUIVal","newNP","bothInheritAutorange","newRangeAccepted","axAttr","newAx","allTracePreGUI","tracePreGUI","newTrace","fullInput","fulli","fullTrace","newTracei","react","configChanged","oldConfig","diffConfig","skipUpdateCalc","newFullData","newFullLayout","immutable","datarevision","diffLayout","newDataRevision","diffData","supplyDefaultsUpdateCalc","_transitionData","createTransitionData","anim","transitionFromReact","_skipDefaults","componentType","arrays","drawOne","noop","sameTraceLength","nChanges","nChangesAnim","diffOpts","getValObject","seenUIDs","hasMakesDataTransform","getDiffFlags","oldContainer","newContainer","outerparts","inArray","arrayIndex","pushUnique","valObjectCanBeDataArray","valType","tickMode","tickmode","_compareAsJSON","canBeDataArray","wasArray","nowArray","inputKey","oldValIn","newValIn","_isLinkedToArray","arrayEditIndices","extraIndices","minLen","min","String","newConfig","animate","frameOrGroupNameOrFrameList","animationOpts","trans","_frameQueue","supplyAnimationDefaults","transitionOpts","frameOpts","frame","_frameWaitingCnt","getTransitionOpts","getFrameOpts","callbackOnNthTime","cb","n","cnt","discardExistingFrames","next","onInterrupt","queueFrames","frameList","computedFrame","computeFrame","name","nextFrame","onComplete","mode","_lastFrameAt","Infinity","_animationRaf","beginAnimationLoop","stopAnimationLoop","cancelAnimationFrame","_currentFrame","newFrame","shift","stringName","toString","Date","now","_timeToNext","animation","_runningTransitions","doFrame","requestAnimationFrame","configCounter","setTransitionConfig","allFrames","isFrameArray","isSingleFrame","_frames","frameOrName","_frameHash","direction","currentFrame","fromcurrent","idx","filteredFrameList","bigIndex","insertions","_frameHashLocal","lookupName","newName","collisionPresent","supplyFrameDefaults","ops","revops","frameCount","_counter","unshift","modifyFrames","deleteFrames","_container","gd3","_paperdiv","_toppaper","_uid","otherUids","each","randstr","svgAttrs","_defs","_clips","_topdefs","_topclips","_bgLayer","_draggers","layerBelow","_imageLowerLayer","_shapeLowerLayer","_cartesianlayer","_polarlayer","_ternarylayer","_geolayer","_glimages","layerAbove","_imageUpperLayer","_shapeUpperLayer","_infolayer","_menulayer","_zoomlayer","_hoverlayer"],"sources":["/home/yasmin/rea de Trabalho/Frontend/node_modules/plotly.js/src/plot_api/plot_api.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar Polar = require('../plots/polar/legacy');\n\nvar Axes = require('../plots/cartesian/axes');\nvar Drawing = require('../components/drawing');\nvar Color = require('../components/color');\nvar connectColorbar = require('../components/colorbar/connect');\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\nvar svgTextUtils = require('../lib/svg_text_utils');\n\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar manageArrays = require('./manage_arrays');\nvar helpers = require('./helpers');\nvar subroutines = require('./subroutines');\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n\n/**\n * Main plot-creation function\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nexports.plot = function(gd, data, layout, config) {\n    var frames;\n\n    gd = Lib.getGraphDiv(gd);\n\n    // Events.init is idempotent and bails early if gd has already been init'd\n    Events.init(gd);\n\n    if(Lib.isPlainObject(data)) {\n        var obj = data;\n        data = obj.data;\n        layout = obj.layout;\n        config = obj.config;\n        frames = obj.frames;\n    }\n\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n    if(okToPlot === false) return Promise.reject();\n\n    // if there's no data or layout, and this isn't yet a plotly plot\n    // container, log a warning to help plotly.js users debug\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\n        Lib.warn('Calling Plotly.plot as if redrawing ' +\n            'but this container doesn\\'t yet have a plot.', gd);\n    }\n\n    function addFrames() {\n        if(frames) {\n            return exports.addFrames(gd, frames);\n        }\n    }\n\n    // transfer configuration options to gd until we move over to\n    // a more OO like model\n    setPlotContext(gd, config);\n\n    if(!layout) layout = {};\n\n    // hook class for plots main container (in case of plotly.js\n    // this won't be #embedded-graph or .js-tab-contents)\n    d3.select(gd).classed('js-plotly-plot', true);\n\n    // off-screen getBoundingClientRect testing space,\n    // in #js-plotly-tester (and stored as Drawing.tester)\n    // so we can share cached text across tabs\n    Drawing.makeTester();\n\n    // collect promises for any async actions during plotting\n    // any part of the plotting code can push to gd._promises, then\n    // before we move to the next step, we check that they're all\n    // complete, and empty out the promise list again.\n    if(!Array.isArray(gd._promises)) gd._promises = [];\n\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\n\n    // if there is already data on the graph, append the new data\n    // if you only want to redraw, pass a non-array for data\n    if(Array.isArray(data)) {\n        helpers.cleanData(data);\n\n        if(graphWasEmpty) gd.data = data;\n        else gd.data.push.apply(gd.data, data);\n\n        // for routines outside graph_obj that want a clean tab\n        // (rather than appending to an existing one) gd.empty\n        // is used to determine whether to make a new tab\n        gd.empty = false;\n    }\n\n    if(!gd.layout || graphWasEmpty) gd.layout = helpers.cleanLayout(layout);\n\n    // if the user is trying to drag the axes, allow new data and layout\n    // to come in but don't allow a replot.\n    if(gd._dragging && !gd._transitioning) {\n        // signal to drag handler that after everything else is done\n        // we need to replot, because something has changed\n        gd._replotPending = true;\n        return Promise.reject();\n    } else {\n        // we're going ahead with a replot now\n        gd._replotPending = false;\n    }\n\n    Plots.supplyDefaults(gd);\n\n    var fullLayout = gd._fullLayout;\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // Legacy polar plots\n    if(!fullLayout._has('polar') && data && data[0] && data[0].r) {\n        Lib.log('Legacy polar charts are deprecated!');\n        return plotLegacyPolar(gd, data, layout);\n    }\n\n    // so we don't try to re-call Plotly.plot from inside\n    // legend and colorbar, if margins changed\n    fullLayout._replotting = true;\n\n    // make or remake the framework if we need to\n    if(graphWasEmpty) makePlotFramework(gd);\n\n    // polar need a different framework\n    if(gd.framework !== makePlotFramework) {\n        gd.framework = makePlotFramework;\n        makePlotFramework(gd);\n    }\n\n    // clear gradient defs on each .plot call, because we know we'll loop through all traces\n    Drawing.initGradients(gd);\n\n    // save initial show spikes once per graph\n    if(graphWasEmpty) Axes.saveShowSpikeInitial(gd);\n\n    // prepare the data and find the autorange\n\n    // generate calcdata, if we need to\n    // to force redoing calcdata, just delete it before calling Plotly.plot\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n    if(recalc) Plots.doCalcdata(gd);\n\n    // in case it has changed, attach fullData traces to calcdata\n    for(var i = 0; i < gd.calcdata.length; i++) {\n        gd.calcdata[i][0].trace = gd._fullData[i];\n    }\n\n    // make the figure responsive\n    if(gd._context.responsive) {\n        if(!gd._responsiveChartHandler) {\n            // Keep a reference to the resize handler to purge it down the road\n            gd._responsiveChartHandler = function() {Plots.resize(gd);};\n\n            // Listen to window resize\n            window.addEventListener('resize', gd._responsiveChartHandler);\n        }\n    } else {\n        Lib.clearResponsive(gd);\n    }\n\n    /*\n     * start async-friendly code - now we're actually drawing things\n     */\n\n    var oldmargins = JSON.stringify(fullLayout._size);\n\n    // draw framework first so that margin-pushing\n    // components can position themselves correctly\n    var drawFrameworkCalls = 0;\n    function drawFramework() {\n        var basePlotModules = fullLayout._basePlotModules;\n\n        for(var i = 0; i < basePlotModules.length; i++) {\n            if(basePlotModules[i].drawFramework) {\n                basePlotModules[i].drawFramework(gd);\n            }\n        }\n\n        if(!fullLayout._glcanvas && fullLayout._has('gl')) {\n            fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n                key: 'contextLayer',\n                context: true,\n                pick: false\n            }, {\n                key: 'focusLayer',\n                context: false,\n                pick: false\n            }, {\n                key: 'pickLayer',\n                context: false,\n                pick: true\n            }], function(d) { return d.key; });\n\n            fullLayout._glcanvas.enter().append('canvas')\n                .attr('class', function(d) {\n                    return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n                })\n                .style({\n                    'position': 'absolute',\n                    'top': 0,\n                    'left': 0,\n                    'width': '100%',\n                    'height': '100%',\n                    'overflow': 'visible',\n                    'pointer-events': 'none'\n                });\n        }\n\n        if(fullLayout._glcanvas) {\n            fullLayout._glcanvas\n                .attr('width', fullLayout.width)\n                .attr('height', fullLayout.height);\n\n            var regl = fullLayout._glcanvas.data()[0].regl;\n            if(regl) {\n                // Unfortunately, this can happen when relayouting to large\n                // width/height on some browsers.\n                if(Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth ||\n                    Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight\n                 ) {\n                    var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n                    if(drawFrameworkCalls) {\n                        Lib.error(msg);\n                    } else {\n                        Lib.log(msg + ' Clearing graph and plotting again.');\n                        Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n                        Plots.supplyDefaults(gd);\n                        fullLayout = gd._fullLayout;\n                        Plots.doCalcdata(gd);\n                        drawFrameworkCalls++;\n                        return drawFramework();\n                    }\n                }\n            }\n        }\n\n        return Plots.previousPromises(gd);\n    }\n\n    // draw anything that can affect margins.\n    function marginPushers() {\n        var calcdata = gd.calcdata;\n        var i, cd, trace;\n\n        // First reset the list of things that are allowed to change the margins\n        // So any deleted traces or components will be wiped out of the\n        // automargin calculation.\n        // This means *every* margin pusher must be listed here, even if it\n        // doesn't actually try to push the margins until later.\n        Plots.clearAutoMarginIds(gd);\n\n        subroutines.drawMarginPushers(gd);\n        Axes.allowAutoMargin(gd);\n\n        for(i = 0; i < calcdata.length; i++) {\n            cd = calcdata[i];\n            trace = cd[0].trace;\n            var colorbarOpts = trace._module.colorbar;\n            if(trace.visible !== true || !colorbarOpts) {\n                Plots.autoMargin(gd, 'cb' + trace.uid);\n            }\n            else connectColorbar(gd, cd, colorbarOpts);\n        }\n\n        Plots.doAutoMargin(gd);\n        return Plots.previousPromises(gd);\n    }\n\n    // in case the margins changed, draw margin pushers again\n    function marginPushersAgain() {\n        if(JSON.stringify(fullLayout._size) === oldmargins) return;\n\n        return Lib.syncOrAsync([\n            marginPushers,\n            subroutines.layoutStyles\n        ], gd);\n    }\n\n    function positionAndAutorange() {\n        if(!recalc) {\n            doAutoRangeAndConstraints();\n            return;\n        }\n\n        // TODO: autosize extra for text markers and images\n        // see https://github.com/plotly/plotly.js/issues/1111\n        return Lib.syncOrAsync([\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\n            doAutoRangeAndConstraints\n        ], gd);\n    }\n\n    function doAutoRangeAndConstraints() {\n        if(gd._transitioning) return;\n\n        subroutines.doAutoRangeAndConstraints(gd);\n\n        // store initial ranges *after* enforcing constraints, otherwise\n        // we will never look like we're at the initial ranges\n        if(graphWasEmpty) Axes.saveRangeInitial(gd);\n\n        // this one is different from shapes/annotations calcAutorange\n        // the others incorporate those components into ax._extremes,\n        // this one actually sets the ranges in rangesliders.\n        Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n    }\n\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\n    function drawAxes() {\n        return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n    }\n\n    var seq = [\n        Plots.previousPromises,\n        addFrames,\n        drawFramework,\n        marginPushers,\n        marginPushersAgain\n    ];\n\n    if(hasCartesian) seq.push(positionAndAutorange);\n\n    seq.push(subroutines.layoutStyles);\n    if(hasCartesian) seq.push(drawAxes);\n\n    seq.push(\n        subroutines.drawData,\n        subroutines.finalDraw,\n        initInteractions,\n        Plots.addLinks,\n        Plots.rehover,\n        // TODO: doAutoMargin is only needed here for axis automargin, which\n        // happens outside of marginPushers where all the other automargins are\n        // calculated. Would be much better to separate margin calculations from\n        // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n        Plots.doAutoMargin,\n        Plots.previousPromises\n    );\n\n    // even if everything we did was synchronous, return a promise\n    // so that the caller doesn't care which route we took\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        emitAfterPlot(gd);\n        return gd;\n    });\n};\n\nfunction emitAfterPlot(gd) {\n    var fullLayout = gd._fullLayout;\n\n    if(fullLayout._redrawFromAutoMarginCount) {\n        fullLayout._redrawFromAutoMarginCount--;\n    } else {\n        gd.emit('plotly_afterplot');\n    }\n}\n\nexports.setPlotConfig = function setPlotConfig(obj) {\n    return Lib.extendFlat(dfltConfig, obj);\n};\n\nfunction setBackground(gd, bgColor) {\n    try {\n        gd._fullLayout._paper.style('background', bgColor);\n    } catch(e) {\n        Lib.error(e);\n    }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n    var blend = Color.combine(bgColor, 'white');\n    setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n    if(!gd._context) {\n        gd._context = Lib.extendDeep({}, dfltConfig);\n\n        // stash <base> href, used to make robust clipPath URLs\n        var base = d3.select('base');\n        gd._context._baseUrl = base.size() && base.attr('href') ?\n            window.location.href.split('#')[0] :\n            '';\n    }\n\n    var context = gd._context;\n\n    var i, keys, key;\n\n    if(config) {\n        keys = Object.keys(config);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            if(key === 'editable' || key === 'edits') continue;\n            if(key in context) {\n                if(key === 'setBackground' && config[key] === 'opaque') {\n                    context[key] = opaqueSetBackground;\n                } else {\n                    context[key] = config[key];\n                }\n            }\n        }\n\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\n        }\n\n        // now deal with editable and edits - first editable overrides\n        // everything, then edits refines\n        var editable = config.editable;\n        if(editable !== undefined) {\n            // we're not going to *use* context.editable, we're only going to\n            // use context.edits... but keep it for the record\n            context.editable = editable;\n\n            keys = Object.keys(context.edits);\n            for(i = 0; i < keys.length; i++) {\n                context.edits[keys[i]] = editable;\n            }\n        }\n        if(config.edits) {\n            keys = Object.keys(config.edits);\n            for(i = 0; i < keys.length; i++) {\n                key = keys[i];\n                if(key in context.edits) {\n                    context.edits[key] = config.edits[key];\n                }\n            }\n        }\n\n        // not part of the user-facing config options\n        context._exportedPlot = config._exportedPlot;\n    }\n\n    // staticPlot forces a bunch of others:\n    if(context.staticPlot) {\n        context.editable = false;\n        context.edits = {};\n        context.autosizable = false;\n        context.scrollZoom = false;\n        context.doubleClick = false;\n        context.showTips = false;\n        context.showLink = false;\n        context.displayModeBar = false;\n    }\n\n    // make sure hover-only devices have mode bar visible\n    if(context.displayModeBar === 'hover' && !hasHover) {\n        context.displayModeBar = true;\n    }\n\n    // default and fallback for setBackground\n    if(context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n        context.setBackground = setBackground;\n    }\n\n    // Check if gd has a specified widht/height to begin with\n    context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n    context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\n\n    // fill context._scrollZoom helper to help manage scrollZoom flaglist\n    var szIn = context.scrollZoom;\n    var szOut = context._scrollZoom = {};\n    if(szIn === true) {\n        szOut.cartesian = 1;\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    } else if(typeof szIn === 'string') {\n        var parts = szIn.split('+');\n        for(i = 0; i < parts.length; i++) {\n            szOut[parts[i]] = 1;\n        }\n    } else if(szIn !== false) {\n        szOut.gl3d = 1;\n        szOut.geo = 1;\n        szOut.mapbox = 1;\n    }\n}\n\nfunction plotLegacyPolar(gd, data, layout) {\n    // build or reuse the container skeleton\n    var plotContainer = d3.select(gd).selectAll('.plot-container')\n        .data([0]);\n    plotContainer.enter()\n        .insert('div', ':first-child')\n        .classed('plot-container plotly', true);\n    var paperDiv = plotContainer.selectAll('.svg-container')\n        .data([0]);\n    paperDiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // empty it everytime for now\n    paperDiv.html('');\n\n    // fulfill gd requirements\n    if(data) gd.data = data;\n    if(layout) gd.layout = layout;\n    Polar.manager.fillLayout(gd);\n\n    // resize canvas\n    paperDiv.style({\n        width: gd._fullLayout.width + 'px',\n        height: gd._fullLayout.height + 'px'\n    });\n\n    // instantiate framework\n    gd.framework = Polar.manager.framework(gd);\n\n    // plot\n    gd.framework({data: gd.data, layout: gd.layout}, paperDiv.node());\n\n    // set undo point\n    gd.framework.setUndoPoint();\n\n    // get the resulting svg for extending it\n    var polarPlotSVG = gd.framework.svg();\n\n    // editable title\n    var opacity = 1;\n    var txt = gd._fullLayout.title ? gd._fullLayout.title.text : '';\n    if(txt === '' || !txt) opacity = 0;\n\n    var titleLayout = function() {\n        this.call(svgTextUtils.convertToTspans, gd);\n        // TODO: html/mathjax\n        // TODO: center title\n    };\n\n    var title = polarPlotSVG.select('.title-group text')\n        .call(titleLayout);\n\n    if(gd._context.edits.titleText) {\n        var placeholderText = Lib._(gd, 'Click to enter Plot title');\n        if(!txt || txt === placeholderText) {\n            opacity = 0.2;\n            // placeholder is not going through convertToTspans\n            // so needs explicit data-unformatted\n            title.attr({'data-unformatted': placeholderText})\n                .text(placeholderText)\n                .style({opacity: opacity})\n                .on('mouseover.opacity', function() {\n                    d3.select(this).transition().duration(100)\n                        .style('opacity', 1);\n                })\n                .on('mouseout.opacity', function() {\n                    d3.select(this).transition().duration(1000)\n                        .style('opacity', 0);\n                });\n        }\n\n        var setContenteditable = function() {\n            this.call(svgTextUtils.makeEditable, {gd: gd})\n                .on('edit', function(text) {\n                    gd.framework({layout: {title: {text: text}}});\n                    this.text(text)\n                        .call(titleLayout);\n                    this.call(setContenteditable);\n                })\n                .on('cancel', function() {\n                    var txt = this.attr('data-unformatted');\n                    this.text(txt).call(titleLayout);\n                });\n        };\n        title.call(setContenteditable);\n    }\n\n    gd._context.setBackground(gd, gd._fullLayout.paper_bgcolor);\n    Plots.addLinks(gd);\n\n    return Promise.resolve();\n}\n\n// convenience function to force a full redraw, mostly for use by plotly.js\nexports.redraw = function(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    helpers.cleanData(gd.data);\n    helpers.cleanLayout(gd.layout);\n\n    gd.calcdata = undefined;\n    return exports.plot(gd).then(function() {\n        gd.emit('plotly_redraw');\n        return gd;\n    });\n};\n\n/**\n * Convenience function to make idempotent plot option obvious to users.\n *\n * @param gd\n * @param {Object[]} data\n * @param {Object} layout\n * @param {Object} config\n */\nexports.newPlot = function(gd, data, layout, config) {\n    gd = Lib.getGraphDiv(gd);\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n\n    Plots.purge(gd);\n    return exports.plot(gd, data, layout, config);\n};\n\n/**\n * Wrap negative indicies to their positive counterparts.\n *\n * @param {Number[]} indices An array of indices\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\n */\nfunction positivifyIndices(indices, maxIndex) {\n    var parentLength = maxIndex + 1;\n    var positiveIndices = [];\n    var i;\n    var index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n        if(index < 0) {\n            positiveIndices.push(parentLength + index);\n        } else {\n            positiveIndices.push(index);\n        }\n    }\n    return positiveIndices;\n}\n\n/**\n * Ensures that an index array for manipulating gd.data is valid.\n *\n * Intended for use with addTraces, deleteTraces, and moveTraces.\n *\n * @param gd\n * @param indices\n * @param arrayName\n */\nfunction assertIndexArray(gd, indices, arrayName) {\n    var i,\n        index;\n\n    for(i = 0; i < indices.length; i++) {\n        index = indices[i];\n\n        // validate that indices are indeed integers\n        if(index !== parseInt(index, 10)) {\n            throw new Error('all values in ' + arrayName + ' must be integers');\n        }\n\n        // check that all indices are in bounds for given gd.data array length\n        if(index >= gd.data.length || index < -gd.data.length) {\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\n        }\n\n        // check that indices aren't repeated\n        if(indices.indexOf(index, i + 1) > -1 ||\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n            throw new Error('each index in ' + arrayName + ' must be unique.');\n        }\n    }\n}\n\n/**\n * Private function used by Plotly.moveTraces to check input args\n *\n * @param gd\n * @param currentIndices\n * @param newIndices\n */\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // validate currentIndices array\n    if(typeof currentIndices === 'undefined') {\n        throw new Error('currentIndices is a required argument.');\n    } else if(!Array.isArray(currentIndices)) {\n        currentIndices = [currentIndices];\n    }\n    assertIndexArray(gd, currentIndices, 'currentIndices');\n\n    // validate newIndices array if it exists\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined') {\n        assertIndexArray(gd, newIndices, 'newIndices');\n    }\n\n    // check currentIndices and newIndices are the same length if newIdices exists\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n        throw new Error('current and new indices must be of equal length.');\n    }\n\n}\n/**\n * A private function to reduce the type checking clutter in addTraces.\n *\n * @param gd\n * @param traces\n * @param newIndices\n */\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n    var i, value;\n\n    // check that gd has attribute 'data' and 'data' is array\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array.');\n    }\n\n    // make sure traces exists\n    if(typeof traces === 'undefined') {\n        throw new Error('traces must be defined.');\n    }\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure each value in traces is an object\n    for(i = 0; i < traces.length; i++) {\n        value = traces[i];\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\n            throw new Error('all values in traces array must be non-array objects');\n        }\n    }\n\n    // make sure we have an index for each trace\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n        throw new Error(\n            'if indices is specified, traces.length must equal indices.length'\n        );\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n * Get all update Properties from gd.data. Validate inputs and outputs.\n * Used by prependTrace and extendTraces\n *\n * @param gd\n * @param update\n * @param indices\n * @param maxPoints\n */\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n    if(!Array.isArray(gd.data)) {\n        throw new Error('gd.data must be an array');\n    }\n    if(!Lib.isPlainObject(update)) {\n        throw new Error('update must be a key:value object');\n    }\n\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers');\n    }\n\n    assertIndexArray(gd, indices, 'indices');\n\n    for(var key in update) {\n\n        /*\n         * Verify that the attribute to be updated contains as many trace updates\n         * as indices. Failure must result in throw and no-op\n         */\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n        }\n\n        /*\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\n         */\n        if(maxPointsIsObject &&\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\n            maxPoints[key].length !== update[key].length)) {\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\n                            'corrispondence with the keys and number of traces in the update object');\n        }\n    }\n}\n\n/**\n * A private function to reduce the type checking clutter in spliceTraces.\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @return {Object[]}\n */\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n    var updateProps = [];\n    var trace, target, prop, insert, maxp;\n\n    // allow scalar index to represent a single trace position\n    if(!Array.isArray(indices)) indices = [indices];\n\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // loop through all update keys and traces and harvest validated data.\n    for(var key in update) {\n\n        for(var j = 0; j < indices.length; j++) {\n\n            /*\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\n             * instance that references the key and value for this particular trace.\n             */\n            trace = gd.data[indices[j]];\n            prop = nestedProperty(trace, key);\n\n            /*\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\n             * Target must exist as an Array to allow the extend operation to be performed.\n             */\n            target = prop.get();\n            insert = update[key][j];\n\n            if(!Lib.isArrayOrTypedArray(insert)) {\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n            }\n            if(!Lib.isArrayOrTypedArray(target)) {\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\n            }\n            if(target.constructor !== insert.constructor) {\n                throw new Error('cannot extend array with an array of a different type: ' + key);\n            }\n\n            /*\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\n             * Use the scalar maxPoints for all key and trace combinations.\n             */\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\n\n            // could have chosen null here, -1 just tells us to not take a window\n            if(!isNumeric(maxp)) maxp = -1;\n\n            /*\n             * Wrap the nestedProperty in an object containing required data\n             * for lengthening and windowing this particular trace - key combination.\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\n             */\n            updateProps.push({\n                prop: prop,\n                target: target,\n                insert: insert,\n                maxp: Math.floor(maxp)\n            });\n        }\n    }\n\n    // all target and insertion data now validated\n    return updateProps;\n}\n\n/**\n * A private function to key Extend and Prepend traces DRY\n *\n * @param {Object|HTMLDivElement} gd\n * @param {Object} update\n * @param {Number[]} indices\n * @param {Number||Object} maxPoints\n * @param {Function} updateArray\n * @return {Object}\n */\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\n\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n    var undoUpdate = {};\n    var undoPoints = {};\n\n    for(var i = 0; i < updateProps.length; i++) {\n        var prop = updateProps[i].prop;\n        var maxp = updateProps[i].maxp;\n\n        // return new array and remainder\n        var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n        prop.set(out[0]);\n\n        // build the inverse update object for the undo operation\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n        undoUpdate[prop.astr].push(out[1]);\n\n         // build the matching maxPoints undo object containing original trace lengths\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n        undoPoints[prop.astr].push(updateProps[i].target.length);\n    }\n\n    return {update: undoUpdate, maxPoints: undoPoints};\n}\n\nfunction concatTypedArray(arr0, arr1) {\n    var arr2 = new arr0.constructor(arr0.length + arr1.length);\n    arr2.set(arr0);\n    arr2.set(arr1, arr0.length);\n    return arr2;\n}\n\n/**\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\n *\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\n * from the tail.\n *\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object} update The key:array map of target attributes to extend\n * @param {Number|Number[]} indices The locations of traces to be extended\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\n *\n */\nexports.extendTraces = function extendTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp < 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(target, insert);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target);\n                    remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n                    var targetBegin = target.length - numberOfItemsFromTarget;\n\n                    newArray.set(target.subarray(targetBegin));\n                    newArray.set(insert, numberOfItemsFromTarget);\n                    remainder.set(target.subarray(0, targetBegin));\n                }\n            }\n        } else {\n            newArray = target.concat(insert);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(0, newArray.length - maxp) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n\n    return promise;\n};\n\nexports.prependTraces = function prependTraces(gd, update, indices, maxPoints) {\n    gd = Lib.getGraphDiv(gd);\n\n    function updateArray(target, insert, maxp) {\n        var newArray, remainder;\n\n        if(Lib.isTypedArray(target)) {\n            if(maxp <= 0) {\n                var none = new target.constructor(0);\n                var both = concatTypedArray(insert, target);\n\n                if(maxp < 0) {\n                    newArray = both;\n                    remainder = none;\n                } else {\n                    newArray = none;\n                    remainder = both;\n                }\n            } else {\n                newArray = new target.constructor(maxp);\n                remainder = new target.constructor(target.length + insert.length - maxp);\n\n                if(maxp === insert.length) {\n                    newArray.set(insert);\n                    remainder.set(target);\n                } else if(maxp < insert.length) {\n                    var numberOfItemsFromInsert = insert.length - maxp;\n\n                    newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n                    remainder.set(insert.subarray(numberOfItemsFromInsert));\n                    remainder.set(target, numberOfItemsFromInsert);\n                } else {\n                    var numberOfItemsFromTarget = maxp - insert.length;\n\n                    newArray.set(insert);\n                    newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n                    remainder.set(target.subarray(numberOfItemsFromTarget));\n                }\n            }\n        } else {\n            newArray = insert.concat(target);\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\n                newArray.splice(maxp, newArray.length) :\n                [];\n        }\n\n        return [newArray, remainder];\n    }\n\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n    var promise = exports.redraw(gd);\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n    Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n\n    return promise;\n};\n\n/**\n * Add data traces to an existing graph div.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're adding to\n * @param {Object[]|Object} traces The object or array of objects to add\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\n *\n */\nexports.addTraces = function addTraces(gd, traces, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var currentIndices = [];\n    var undoFunc = exports.deleteTraces;\n    var redoFunc = addTraces;\n    var undoArgs = [gd, currentIndices];\n    var redoArgs = [gd, traces];  // no newIndices here\n    var i;\n    var promise;\n\n    // all validation is done elsewhere to remove clutter here\n    checkAddTracesArgs(gd, traces, newIndices);\n\n    // make sure traces is an array\n    if(!Array.isArray(traces)) {\n        traces = [traces];\n    }\n\n    // make sure traces do not repeat existing ones\n    traces = traces.map(function(trace) {\n        return Lib.extendFlat({}, trace);\n    });\n\n    helpers.cleanData(traces);\n\n    // add the traces to gd.data (no redrawing yet!)\n    for(i = 0; i < traces.length; i++) {\n        gd.data.push(traces[i]);\n    }\n\n    // to continue, we need to call moveTraces which requires currentIndices\n    for(i = 0; i < traces.length; i++) {\n        currentIndices.push(-traces.length + i);\n    }\n\n    // if the user didn't define newIndices, they just want the traces appended\n    // i.e., we can simply redraw and be done\n    if(typeof newIndices === 'undefined') {\n        promise = exports.redraw(gd);\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n        return promise;\n    }\n\n    // make sure indices is property defined\n    if(!Array.isArray(newIndices)) {\n        newIndices = [newIndices];\n    }\n\n    try {\n\n        // this is redundant, but necessary to not catch later possible errors!\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\n    }\n    catch(error) {\n\n        // something went wrong, reset gd to be safe and rethrow error\n        gd.data.splice(gd.data.length - traces.length, traces.length);\n        throw error;\n    }\n\n    // if we're here, the user has defined specific places to place the new traces\n    // this requires some extra work that moveTraces will do\n    Queue.startSequence(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    promise = exports.moveTraces(gd, currentIndices, newIndices);\n    Queue.stopSequence(gd);\n    return promise;\n};\n\n/**\n * Delete traces at `indices` from gd.data array.\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} indices The indices\n */\nexports.deleteTraces = function deleteTraces(gd, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var traces = [];\n    var undoFunc = exports.addTraces;\n    var redoFunc = deleteTraces;\n    var undoArgs = [gd, traces, indices];\n    var redoArgs = [gd, indices];\n    var i;\n    var deletedTrace;\n\n    // make sure indices are defined\n    if(typeof indices === 'undefined') {\n        throw new Error('indices must be an integer or array of integers.');\n    } else if(!Array.isArray(indices)) {\n        indices = [indices];\n    }\n    assertIndexArray(gd, indices, 'indices');\n\n    // convert negative indices to positive indices\n    indices = positivifyIndices(indices, gd.data.length - 1);\n\n    // we want descending here so that splicing later doesn't affect indexing\n    indices.sort(Lib.sorterDes);\n    for(i = 0; i < indices.length; i += 1) {\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\n        traces.push(deletedTrace);\n    }\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n};\n\n/**\n * Move traces at currentIndices array to locations in newIndices array.\n *\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\n * these are equivalent:\n *\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\n * Plotly.moveTraces(gd, [1, 2, 3])\n *\n * @param {Object|HTMLDivElement} gd The graph div\n * @param {Object[]} gd.data The array of traces we're removing from\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\n * @param {Number|Number[]} [newIndices] The locations to move traces to\n *\n * Example calls:\n *\n *      // move trace i to location x\n *      Plotly.moveTraces(gd, i, x)\n *\n *      // move trace i to end of array\n *      Plotly.moveTraces(gd, i)\n *\n *      // move traces i, j, k to end of array (i != j != k)\n *      Plotly.moveTraces(gd, [i, j, k])\n *\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\n *\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\n */\nexports.moveTraces = function moveTraces(gd, currentIndices, newIndices) {\n    gd = Lib.getGraphDiv(gd);\n\n    var newData = [];\n    var movingTraceMap = [];\n    var undoFunc = moveTraces;\n    var redoFunc = moveTraces;\n    var undoArgs = [gd, newIndices, currentIndices];\n    var redoArgs = [gd, currentIndices, newIndices];\n    var i;\n\n    // to reduce complexity here, check args elsewhere\n    // this throws errors where appropriate\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n\n    // make sure currentIndices is an array\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\n\n    // if undefined, define newIndices to point to the end of gd.data array\n    if(typeof newIndices === 'undefined') {\n        newIndices = [];\n        for(i = 0; i < currentIndices.length; i++) {\n            newIndices.push(-currentIndices.length + i);\n        }\n    }\n\n    // make sure newIndices is an array if it's user-defined\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\n\n    // convert negative indices to positive indices (they're the same length)\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\n\n    // at this point, we've coerced the index arrays into predictable forms\n\n    // get the traces that aren't being moved around\n    for(i = 0; i < gd.data.length; i++) {\n\n        // if index isn't in currentIndices, include it in ignored!\n        if(currentIndices.indexOf(i) === -1) {\n            newData.push(gd.data[i]);\n        }\n    }\n\n    // get a mapping of indices to moving traces\n    for(i = 0; i < currentIndices.length; i++) {\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\n    }\n\n    // reorder this mapping by newIndex, ascending\n    movingTraceMap.sort(function(a, b) {\n        return a.newIndex - b.newIndex;\n    });\n\n    // now, add the moving traces back in, in order!\n    for(i = 0; i < movingTraceMap.length; i += 1) {\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n    }\n\n    gd.data = newData;\n\n    var promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return promise;\n};\n\n/**\n * restyle: update trace attributes of an existing plot\n *\n * Can be called two ways.\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {String} astr\n *  attribute string (like `'marker.symbol'`) to update\n * @param {*} val\n *  value to give this attribute\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n * @param {Number[] | Number} [traces]\n *  (as in signature 1)\n *\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\n * to apply different values to each trace.\n *\n * If the array is too short, it will wrap around (useful for\n * style files that want to specify cyclical default values).\n */\nfunction restyle(gd, astr, val, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    var aobj = {};\n    if(typeof astr === 'string') aobj[astr] = val;\n    else if(Lib.isPlainObject(astr)) {\n        // the 3-arg form\n        aobj = Lib.extendFlat({}, astr);\n        if(_traces === undefined) _traces = val;\n    }\n    else {\n        Lib.warn('Restyle fail.', astr, val, _traces);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var specs = _restyle(gd, aobj, traces);\n    var flags = specs.flags;\n\n    // clear calcdata and/or axis types if required so they get regenerated\n    if(flags.calc) gd.calcdata = undefined;\n    if(flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(flags.fullReplot) {\n        seq.push(exports.plot);\n    } else {\n        seq.push(Plots.previousPromises);\n\n        // maybe only call Plots.supplyDataDefaults in the splom case,\n        // to skip over long and slow axes defaults\n        Plots.supplyDefaults(gd);\n\n        if(flags.markerSize) {\n            Plots.doCalcdata(gd);\n            addAxRangeSequence(seq);\n\n            // TODO\n            // if all axes have autorange:false, then\n            // proceed to subroutines.doTraceStyle(),\n            // otherwise we must go through addAxRangeSequence,\n            // which in general must redraws 'all' axes\n        }\n\n        if(flags.style) seq.push(subroutines.doTraceStyle);\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        restyle, [gd, specs.undoit, specs.traces],\n        restyle, [gd, specs.redoit, specs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\n\n    return plotDone.then(function() {\n        gd.emit('plotly_restyle', specs.eventData);\n        return gd;\n    });\n}\nexports.restyle = restyle;\n\n// for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\nfunction undefinedToNull(val) {\n    if(val === undefined) return null;\n    return val;\n}\n\n/**\n * Factory function to wrap nestedProperty with GUI edits if necessary\n * with GUI edits we add an optional prefix to the nestedProperty constructor\n * to prepend to the attribute string in the preGUI store.\n */\nfunction makeNP(preGUI, guiEditFlag) {\n    if(!guiEditFlag) return nestedProperty;\n\n    return function(container, attr, prefix) {\n        var np = nestedProperty(container, attr);\n        var npSet = np.set;\n        np.set = function(val) {\n            var fullAttr = (prefix || '') + attr;\n            storeCurrent(fullAttr, np.get(), val, preGUI);\n            npSet(val);\n        };\n        return np;\n    };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n    if(Array.isArray(val) || Array.isArray(newVal)) {\n        var arrayVal = Array.isArray(val) ? val : [];\n        var arrayNew = Array.isArray(newVal) ? newVal : [];\n        var maxLen = Math.max(arrayVal.length, arrayNew.length);\n        for(var i = 0; i < maxLen; i++) {\n            storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n        }\n    }\n    else if(Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n        var objVal = Lib.isPlainObject(val) ? val : {};\n        var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n        var objBoth = Lib.extendFlat({}, objVal, objNew);\n        for(var key in objBoth) {\n            storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n        }\n    }\n    else if(preGUI[attr] === undefined) {\n        preGUI[attr] = undefinedToNull(val);\n    }\n}\n\n/**\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\n * by emitting a plotly_restyle or plotly_relayout event, this routine\n * keeps track of the initial state in _preGUI for use by uirevision\n * Does *not* apply these changes to data/layout - that's the responsibility\n * of the calling routine.\n *\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\n * @param {object} preGUI: where original values should be stored, either\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\n */\nexports._storeDirectGUIEdit = function(container, preGUI, edits) {\n    for(var attr in edits) {\n        var np = nestedProperty(container, attr);\n        storeCurrent(attr, np.get(), edits[attr], preGUI);\n    }\n};\n\nfunction _restyle(gd, aobj, traces) {\n    var fullLayout = gd._fullLayout;\n    var fullData = gd._fullData;\n    var data = gd.data;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var i;\n\n    cleanDeprecatedAttributeKeys(aobj);\n\n    // initialize flags\n    var flags = editTypes.traceFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n    var axlist;\n\n    // make a new empty vals array for undoit\n    function a0() { return traces.map(function() { return undefined; }); }\n\n    // for autoranging multiple axes\n    function addToAxlist(axid) {\n        var axName = Axes.id2name(axid);\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\n    }\n\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\n\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\n\n    function getFullTrace(traceIndex) {\n        // usually fullData maps 1:1 onto data, but with groupby transforms\n        // the fullData index can be greater. Take the *first* matching trace.\n        for(var j = traceIndex; j < fullData.length; j++) {\n            if(fullData[j]._input === data[traceIndex]) return fullData[j];\n        }\n        // should never get here - and if we *do* it should cause an error\n        // later on undefined fullTrace is passed to nestedProperty.\n    }\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // val=null will delete the attribute\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val, i) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val, i); });\n            return;\n        }\n        // quit if explicitly setting this elsewhere\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var extraparam;\n        if(attr.substr(0, 6) === 'LAYOUT') {\n            extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n        } else {\n            var tracei = traces[i];\n            var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n            extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n        }\n\n        if(!(attr in undoit)) {\n            undoit[attr] = a0();\n        }\n        if(undoit[attr][i] === undefined) {\n            undoit[attr][i] = undefinedToNull(extraparam.get());\n        }\n        if(val !== undefined) {\n            extraparam.set(val);\n        }\n    }\n\n    function allBins(binAttr) {\n        return function(j) {\n            return fullData[j][binAttr];\n        };\n    }\n\n    function arrayBins(binAttr) {\n        return function(vij, j) {\n            return vij === false ? fullData[traces[j]][binAttr] : null;\n        };\n    }\n\n    // now make the changes to gd.data (and occasionally gd.layout)\n    // and figure out what kind of graphics update we need to do\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n        }\n\n        var vi = aobj[ai];\n        var cont;\n        var contFull;\n        var param;\n        var oldVal;\n        var newVal;\n        var valObject;\n\n        // Backward compatibility shim for turning histogram autobin on,\n        // or freezing previous autobinned values.\n        // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n        // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n        if(ai === 'autobinx' || ai === 'autobiny') {\n            ai = ai.charAt(ai.length - 1) + 'bins';\n            if(Array.isArray(vi)) vi = vi.map(arrayBins(ai));\n            else if(vi === false) vi = traces.map(allBins(ai));\n            else vi = null;\n        }\n\n        redoit[ai] = vi;\n\n        if(ai.substr(0, 6) === 'LAYOUT') {\n            param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n            undoit[ai] = [undefinedToNull(param.get())];\n            // since we're allowing val to be an array, allow it here too,\n            // even though that's meaningless\n            param.set(Array.isArray(vi) ? vi[0] : vi);\n            // ironically, the layout attrs in restyle only require replot,\n            // not relayout\n            flags.calc = true;\n            continue;\n        }\n\n        // set attribute in gd.data\n        undoit[ai] = a0();\n        for(i = 0; i < traces.length; i++) {\n            cont = data[traces[i]];\n            contFull = getFullTrace(traces[i]);\n            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n            param = makeNP(preGUI, guiEditFlag)(cont, ai);\n            oldVal = param.get();\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n\n            if(newVal === undefined) continue;\n\n            var finalPart = param.parts[param.parts.length - 1];\n            var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n            var prefixDot = prefix ? prefix + '.' : '';\n            var innerContFull = prefix ?\n                nestedProperty(contFull, prefix).get() : contFull;\n\n            valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n            if(valObject && valObject.impliedEdits && newVal !== null) {\n                for(var impliedKey in valObject.impliedEdits) {\n                    doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n                }\n            }\n\n            // changing colorbar size modes,\n            // make the resulting size not change\n            // note that colorbar fractional sizing is based on the\n            // original plot size, before anything (like a colorbar)\n            // increases the margins\n            else if((finalPart === 'thicknessmode' || finalPart === 'lenmode') &&\n                    oldVal !== newVal &&\n                    (newVal === 'fraction' || newVal === 'pixels') &&\n                    innerContFull\n            ) {\n                var gs = fullLayout._size;\n                var orient = innerContFull.orient;\n                var topOrBottom = (orient === 'top') || (orient === 'bottom');\n                if(finalPart === 'thicknessmode') {\n                    var thicknorm = topOrBottom ? gs.h : gs.w;\n                    doextra(prefixDot + 'thickness', innerContFull.thickness *\n                        (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n                }\n                else {\n                    var lennorm = topOrBottom ? gs.w : gs.h;\n                    doextra(prefixDot + 'len', innerContFull.len *\n                        (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n                }\n            }\n\n            else if(ai === 'type' && (newVal === 'pie') !== (oldVal === 'pie')) {\n                var labelsTo = 'x';\n                var valuesTo = 'y';\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n                    labelsTo = 'y';\n                    valuesTo = 'x';\n                }\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n                if(oldVal === 'pie') {\n                    nestedProperty(cont, 'marker.color')\n                        .set(nestedProperty(cont, 'marker.colors').get());\n\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\n                    fullLayout._pielayer.selectAll('g.trace').remove();\n                } else if(Registry.traceIs(cont, 'cartesian')) {\n                    nestedProperty(cont, 'marker.colors')\n                        .set(nestedProperty(cont, 'marker.color').get());\n                }\n            }\n\n            undoit[ai][i] = undefinedToNull(oldVal);\n            // set the new value - if val is an array, it's one el per trace\n            // first check for attributes that get more complex alterations\n            var swapAttrs = [\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\n            ];\n            if(swapAttrs.indexOf(ai) !== -1) {\n                // setting an orientation: make sure it's changing\n                // before we swap everything else\n                if(ai === 'orientation') {\n                    param.set(newVal);\n                    // obnoxious that we need this level of coupling... but in order to\n                    // properly handle setting orientation to `null` we need to mimic\n                    // the logic inside Bars.supplyDefaults for default orientation\n                    var defaultOrientation = (cont.x && !cont.y) ? 'h' : 'v';\n                    if((param.get() || defaultOrientation) === contFull.orientation) {\n                        continue;\n                    }\n                }\n                // orientationaxes has no value,\n                // it flips everything and the axes\n                else if(ai === 'orientationaxes') {\n                    cont.orientation =\n                        {v: 'h', h: 'v'}[contFull.orientation];\n                }\n                helpers.swapXYData(cont);\n                flags.calc = flags.clearAxisTypes = true;\n            }\n            else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n                // TODO: use manageArrays.applyContainerArrayChanges here too\n                helpers.manageArrayContainers(param, newVal, undoit);\n                flags.calc = true;\n            }\n            else {\n                if(valObject) {\n                    // must redo calcdata when restyling array values of arrayOk attributes\n                    // ... but no need to this for regl-based traces\n                    if(valObject.arrayOk &&\n                        !Registry.traceIs(contFull, 'regl') &&\n                        (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))\n                    ) {\n                        flags.calc = true;\n                    }\n                    else editTypes.update(flags, valObject);\n                }\n                else {\n                    /*\n                     * if we couldn't find valObject,  assume a full recalc.\n                     * This can happen if you're changing type and making\n                     * some other edits too, so the modules we're\n                     * looking at don't have these attributes in them.\n                     */\n                    flags.calc = true;\n                }\n\n                // all the other ones, just modify that one attribute\n                param.set(newVal);\n            }\n        }\n\n        // swap the data attributes of the relevant x and y axes?\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n            Axes.swap(gd, traces);\n        }\n\n        // swap hovermode if set to \"compare x/y data\"\n        if(ai === 'orientationaxes') {\n            var hovermode = nestedProperty(gd.layout, 'hovermode');\n            if(hovermode.get() === 'x') {\n                hovermode.set('y');\n            } else if(hovermode.get() === 'y') {\n                hovermode.set('x');\n            }\n        }\n\n        // Major enough changes deserve autoscale and\n        // non-reversed axes so people don't get confused\n        //\n        // Note: autobin (or its new analog bin clearing) is not included here\n        // since we're not pushing bins back to gd.data, so if we have bin\n        // info it was explicitly provided by the user.\n        if(['orientation', 'type'].indexOf(ai) !== -1) {\n            axlist = [];\n            for(i = 0; i < traces.length; i++) {\n                var trace = data[traces[i]];\n\n                if(Registry.traceIs(trace, 'cartesian')) {\n                    addToAxlist(trace.xaxis || 'x');\n                    addToAxlist(trace.yaxis || 'y');\n                }\n            }\n\n            doextra(axlist.map(autorangeAttr), true, 0);\n            doextra(axlist.map(rangeAttr), [0, 1], 0);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    return {\n        flags: flags,\n        undoit: undoit,\n        redoit: redoit,\n        traces: traces,\n        eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n    };\n}\n\n/**\n * Converts deprecated attribute keys to\n * the current API to ensure backwards compatibility.\n *\n * This is needed for the update mechanism to determine which\n * subroutines to run based on the actual attribute\n * definitions (that don't include the deprecated ones).\n *\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\n * and {titlefont: {...}} to {'title.font': {...}}.\n *\n * @param aobj\n */\nfunction cleanDeprecatedAttributeKeys(aobj) {\n    var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n    var colorbarRegex = /colorbar\\.title$/;\n    var keys = Object.keys(aobj);\n    var i, key, value;\n\n    for(i = 0; i < keys.length; i++) {\n        key = keys[i];\n        value = aobj[key];\n\n        if((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) &&\n          (typeof value === 'string' || typeof value === 'number')) {\n            replace(key, key.replace('title', 'title.text'));\n        } else if(key.indexOf('titlefont') > -1) {\n            replace(key, key.replace('titlefont', 'title.font'));\n        } else if(key.indexOf('titleposition') > -1) {\n            replace(key, key.replace('titleposition', 'title.position'));\n        } else if(key.indexOf('titleside') > -1) {\n            replace(key, key.replace('titleside', 'title.side'));\n        } else if(key.indexOf('titleoffset') > -1) {\n            replace(key, key.replace('titleoffset', 'title.offset'));\n        }\n    }\n\n    function replace(oldAttrStr, newAttrStr) {\n        aobj[newAttrStr] = aobj[oldAttrStr];\n        delete aobj[oldAttrStr];\n    }\n}\n\n/**\n * relayout: update layout attributes of an existing plot\n *\n * Can be called two ways:\n *\n * Signature 1:\n * @param {String | HTMLDivElement} gd\n *  the id or dom element of the graph container div\n * @param {String} astr\n *  attribute string (like `'xaxis.range[0]'`) to update\n * @param {*} val\n *  value to give this attribute\n *\n * Signature 2:\n * @param {String | HTMLDivElement} gd\n *  (as in signature 1)\n * @param {Object} aobj\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  allows setting multiple attributes simultaneously\n */\nfunction relayout(gd, astr, val) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    var aobj = {};\n    if(typeof astr === 'string') {\n        aobj[astr] = val;\n    } else if(Lib.isPlainObject(astr)) {\n        aobj = Lib.extendFlat({}, astr);\n    } else {\n        Lib.warn('Relayout fail.', astr, val);\n        return Promise.reject();\n    }\n\n    if(Object.keys(aobj).length) gd.changed = true;\n\n    var specs = _relayout(gd, aobj);\n    var flags = specs.flags;\n\n    // clear calcdata if required\n    if(flags.calc) gd.calcdata = undefined;\n\n    // fill in redraw sequence\n\n    // even if we don't have anything left in aobj,\n    // something may have happened within relayout that we\n    // need to wait for\n    var seq = [Plots.previousPromises];\n\n    if(flags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    }\n    else if(Object.keys(aobj).length) {\n        axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n\n        if(flags.legend) seq.push(subroutines.doLegend);\n        if(flags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n        if(flags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(flags.modebar) seq.push(subroutines.doModeBar);\n        if(flags.camera) seq.push(subroutines.doCamera);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        relayout, [gd, specs.undoit],\n        relayout, [gd, specs.redoit]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_relayout', specs.eventData);\n        return gd;\n    });\n}\nexports.relayout = relayout;\n\n// Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n    var k;\n\n    if(!flags.axrange) return false;\n\n    for(k in flags) {\n        if(k !== 'axrange' && flags[k]) return false;\n    }\n\n    for(k in specs.rangesAltered) {\n        var axName = Axes.id2name(k);\n        var axIn = gd.layout[axName];\n        var axOut = gd._fullLayout[axName];\n        axOut.autorange = axIn.autorange;\n        axOut.range = axIn.range.slice();\n        axOut.cleanRange();\n    }\n    return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n    // N.B. leave as sequence of subroutines (for now) instead of\n    // subroutine of its own so that finalDraw always gets\n    // executed after drawData\n    var drawAxes = rangesAltered ?\n        function(gd) {\n            var opts = {skipTitle: true};\n            for(var id in rangesAltered) {\n                if(Axes.getFromId(gd, id).automargin) {\n                    opts = {};\n                    break;\n                }\n            }\n            return Axes.draw(gd, Object.keys(rangesAltered), opts);\n        } :\n        function(gd) {\n            return Axes.draw(gd, 'redraw');\n        };\n\n    seq.push(\n        subroutines.doAutoRangeAndConstraints,\n        drawAxes,\n        subroutines.drawData,\n        subroutines.finalDraw\n    );\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n    var guiEditFlag = fullLayout._guiEditing;\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n    var keys = Object.keys(aobj);\n    var axes = Axes.list(gd);\n    var eventData = Lib.extendDeepAll({}, aobj);\n    var arrayEdits = {};\n\n    var arrayStr, i, j;\n\n    cleanDeprecatedAttributeKeys(aobj);\n    keys = Object.keys(aobj);\n\n    // look for 'allaxes', split out into all axes\n    // in case of 3D the axis are nested within a scene which is held in _id\n    for(i = 0; i < keys.length; i++) {\n        if(keys[i].indexOf('allaxes') === 0) {\n            for(j = 0; j < axes.length; j++) {\n                var scene = axes[j]._id.substr(1);\n                var axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';\n                var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n            }\n\n            delete aobj[keys[i]];\n        }\n    }\n\n    // initialize flags\n    var flags = editTypes.layoutFlags();\n\n    // copies of the change (and previous values of anything affected)\n    // for the undo / redo queue\n    var redoit = {};\n    var undoit = {};\n\n    // for attrs that interact (like scales & autoscales), save the\n    // old vals before making the change\n    // val=undefined will not set a value, just record what the value was.\n    // attr can be an array to set several at once (all to the same val)\n    function doextra(attr, val) {\n        if(Array.isArray(attr)) {\n            attr.forEach(function(a) { doextra(a, val); });\n            return;\n        }\n\n        // if we have another value for this attribute (explicitly or\n        // via a parent) do not override with this auto-generated extra\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\n\n        var p = layoutNP(layout, attr);\n        if(!(attr in undoit)) {\n            undoit[attr] = undefinedToNull(p.get());\n        }\n        if(val !== undefined) p.set(val);\n    }\n\n    // for constraint enforcement: keep track of all axes (as {id: name})\n    // we're editing the (auto)range of, so we can tell the others constrained\n    // to scale with them that it's OK for them to shrink\n    var rangesAltered = {};\n    var axId;\n\n    function recordAlteredAxis(pleafPlus) {\n        var axId = Axes.name2id(pleafPlus.split('.')[0]);\n        rangesAltered[axId] = 1;\n        return axId;\n    }\n\n    // alter gd.layout\n    for(var ai in aobj) {\n        if(helpers.hasParent(aobj, ai)) {\n            throw new Error('cannot set ' + ai + 'and a parent attribute simultaneously');\n        }\n\n        var p = layoutNP(layout, ai);\n        var vi = aobj[ai];\n        var plen = p.parts.length;\n        // p.parts may end with an index integer if the property is an array\n        var pend = plen - 1;\n        while(pend > 0 && typeof p.parts[pend] !== 'string') pend--;\n        // last property in chain (leaf node)\n        var pleaf = p.parts[pend];\n        // leaf plus immediate parent\n        var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\n        // trunk nodes (everything except the leaf)\n        var ptrunk = p.parts.slice(0, pend).join('.');\n        var parentIn = nestedProperty(gd.layout, ptrunk).get();\n        var parentFull = nestedProperty(fullLayout, ptrunk).get();\n        var vOld = p.get();\n\n        if(vi === undefined) continue;\n\n        redoit[ai] = vi;\n\n        // axis reverse is special - it is its own inverse\n        // op and has no flag.\n        undoit[ai] = (pleaf === 'reverse') ? vi : undefinedToNull(vOld);\n\n        var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n        if(valObject && valObject.impliedEdits && vi !== null) {\n            for(var impliedKey in valObject.impliedEdits) {\n                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n            }\n        }\n\n        // Setting width or height to null must reset the graph's width / height\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        //\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // can't use impliedEdits for this because behavior depends on vi\n        if(['width', 'height'].indexOf(ai) !== -1) {\n            if(vi) {\n                doextra('autosize', null);\n                // currently we don't support autosize one dim only - so\n                // explicitly set the other one. Note that doextra will\n                // ignore this if the same relayout call also provides oppositeAttr\n                var oppositeAttr = ai === 'height' ? 'width' : 'height';\n                doextra(oppositeAttr, fullLayout[oppositeAttr]);\n            }\n            else {\n                fullLayout[ai] = gd._initialAutoSize[ai];\n            }\n        }\n        else if(ai === 'autosize') {\n            // depends on vi here too, so again can't use impliedEdits\n            doextra('width', vi ? null : fullLayout.width);\n            doextra('height', vi ? null : fullLayout.height);\n        }\n        // check autorange vs range\n        else if(pleafPlus.match(AX_RANGE_RE)) {\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        }\n        else if(pleafPlus.match(AX_AUTORANGE_RE)) {\n            recordAlteredAxis(pleafPlus);\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n            var axFull = nestedProperty(fullLayout, ptrunk).get();\n            if(axFull._inputDomain) {\n                // if we're autoranging and this axis has a constrained domain,\n                // reset it so we don't get locked into a shrunken size\n                axFull._input.domain = axFull._inputDomain.slice();\n            }\n        }\n        else if(pleafPlus.match(AX_DOMAIN_RE)) {\n            nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n        }\n\n        // toggling axis type between log and linear: we need to convert\n        // positions for components that are still using linearized values,\n        // not data values like newer components.\n        // previously we did this for log <-> not-log, but now only do it\n        // for log <-> linear\n        if(pleaf === 'type') {\n            var ax = parentIn;\n            var toLog = parentFull.type === 'linear' && vi === 'log';\n            var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n            if(toLog || fromLog) {\n                if(!ax || !ax.range) {\n                    // 2D never gets here, but 3D does\n                    // I don't think this is needed, but left here in case there\n                    // are edge cases I'm not thinking of.\n                    doextra(ptrunk + '.autorange', true);\n                }\n                else if(!parentFull.autorange) {\n                    // toggling log without autorange: need to also recalculate ranges\n                    // because log axes use linearized values for range endpoints\n                    var r0 = ax.range[0];\n                    var r1 = ax.range[1];\n                    if(toLog) {\n                        // if both limits are negative, autorange\n                        if(r0 <= 0 && r1 <= 0) {\n                            doextra(ptrunk + '.autorange', true);\n                        }\n                        // if one is negative, set it 6 orders below the other.\n                        if(r0 <= 0) r0 = r1 / 1e6;\n                        else if(r1 <= 0) r1 = r0 / 1e6;\n                        // now set the range values as appropriate\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n                    }\n                    else {\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n                    }\n                }\n                else if(toLog) {\n                    // just make sure the range is positive and in the right\n                    // order, it'll get recalculated later\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\n                }\n\n                // clear polar view initial stash for radial range so that\n                // value get recomputed in correct units\n                if(Array.isArray(fullLayout._subplots.polar) &&\n                    fullLayout._subplots.polar.length &&\n                    fullLayout[p.parts[0]] &&\n                    p.parts[1] === 'radialaxis'\n                ) {\n                    delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n                }\n\n                // Annotations and images also need to convert to/from linearized coords\n                // Shapes do not need this :)\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n            }\n            else {\n                // any other type changes: the range from the previous type\n                // will not make sense, so autorange it.\n                doextra(ptrunk + '.autorange', true);\n                doextra(ptrunk + '.range', null);\n            }\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n        }\n        else if(pleaf.match(AX_NAME_PATTERN)) {\n            var fullProp = nestedProperty(fullLayout, ai).get();\n            var newType = (vi || {}).type;\n\n            // This can potentially cause strange behavior if the autotype is not\n            // numeric (linear, because we don't auto-log) but the previous type\n            // was log. That's a very strange edge case though\n            if(!newType || newType === '-') newType = 'linear';\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n        }\n\n        // alter gd.layout\n\n        // collect array component edits for execution all together\n        // so we can ensure consistent behavior adding/removing items\n        // and order-independence for add/remove/edit all together in\n        // one relayout call\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n        if(containerArrayMatch) {\n            arrayStr = containerArrayMatch.array;\n            i = containerArrayMatch.index;\n            var propStr = containerArrayMatch.property;\n            var updateValObject = valObject || {editType: 'calc'};\n\n            if(i !== '' && propStr === '') {\n                // special handling of undoit if we're adding or removing an element\n                // ie 'annotations[2]' which can be {...} (add) or null,\n                // does not work when replacing the entire array\n                if(manageArrays.isAddVal(vi)) {\n                    undoit[ai] = null;\n                } else if(manageArrays.isRemoveVal(vi)) {\n                    undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n                } else {\n                    Lib.warn('unrecognized full object value', aobj);\n                }\n            }\n            editTypes.update(flags, updateValObject);\n\n            // prepare the edits object we'll send to applyContainerArrayChanges\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n            var objEdits = arrayEdits[arrayStr][i];\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n            objEdits[propStr] = vi;\n\n            delete aobj[ai];\n        }\n        // handle axis reversal explicitly, as there's no 'reverse' attribute\n        else if(pleaf === 'reverse') {\n            if(parentIn.range) parentIn.range.reverse();\n            else {\n                doextra(ptrunk + '.autorange', true);\n                parentIn.range = [1, 0];\n            }\n\n            if(parentFull.autorange) flags.calc = true;\n            else flags.plot = true;\n        }\n        else {\n            if((fullLayout._has('scatter-like') && fullLayout._has('regl')) &&\n                (ai === 'dragmode' &&\n                (vi === 'lasso' || vi === 'select') &&\n                !(vOld === 'lasso' || vOld === 'select'))\n            ) {\n                flags.plot = true;\n            }\n            else if(valObject) editTypes.update(flags, valObject);\n            else flags.calc = true;\n\n            p.set(vi);\n        }\n    }\n\n    // now we've collected component edits - execute them all together\n    for(arrayStr in arrayEdits) {\n        var finished = manageArrays.applyContainerArrayChanges(gd,\n            layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n        if(!finished) flags.plot = true;\n    }\n\n    // figure out if we need to recalculate axis constraints\n    var constraints = fullLayout._axisConstraintGroups || [];\n    for(axId in rangesAltered) {\n        for(i = 0; i < constraints.length; i++) {\n            var group = constraints[i];\n            if(group[axId]) {\n                // Always recalc if we're changing constrained ranges.\n                // Otherwise it's possible to violate the constraints by\n                // specifying arbitrary ranges for all axes in the group.\n                // this way some ranges may expand beyond what's specified,\n                // as they do at first draw, to satisfy the constraints.\n                flags.calc = true;\n                for(var groupAxId in group) {\n                    if(!rangesAltered[groupAxId]) {\n                        Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n                    }\n                }\n            }\n        }\n    }\n\n    // If the autosize changed or height or width was explicitly specified,\n    // this triggers a redraw\n    // TODO: do we really need special aobj.height/width handling here?\n    // couldn't editType do this?\n    if(updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    // now all attribute mods are done, as are\n    // redo and undo so we can save them\n\n    return {\n        flags: flags,\n        rangesAltered: rangesAltered,\n        undoit: undoit,\n        redoit: redoit,\n        eventData: eventData\n    };\n}\n\n/*\n * updateAutosize: we made a change, does it change the autosize result?\n * puts the new size into fullLayout\n * returns true if either height or width changed\n */\nfunction updateAutosize(gd) {\n    var fullLayout = gd._fullLayout;\n    var oldWidth = fullLayout.width;\n    var oldHeight = fullLayout.height;\n\n    // calculate autosizing\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n\n    return (fullLayout.width !== oldWidth) || (fullLayout.height !== oldHeight);\n}\n\n/**\n * update: update trace and layout attributes of an existing plot\n *\n * @param {String | HTMLDivElement} gd\n *  the id or DOM element of the graph container div\n * @param {Object} traceUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's traces\n * @param {Object} layoutUpdate\n *  attribute object `{astr1: val1, astr2: val2 ...}`\n *  corresponding to updates in the plot's layout\n * @param {Number[] | Number} [traces]\n *  integer or array of integers for the traces to alter (all if omitted)\n *\n */\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n    gd = Lib.getGraphDiv(gd);\n    helpers.clearPromiseQueue(gd);\n\n    if(gd.framework && gd.framework.isPolar) {\n        return Promise.resolve(gd);\n    }\n\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n\n    if(Object.keys(traceUpdate).length) gd.changed = true;\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\n\n    var traces = helpers.coerceTraceIndices(gd, _traces);\n\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n    var restyleFlags = restyleSpecs.flags;\n\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n    var relayoutFlags = relayoutSpecs.flags;\n\n    // clear calcdata and/or axis types if required\n    if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n    if(restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\n\n    // fill in redraw sequence\n    var seq = [];\n\n    if(restyleFlags.fullReplot && relayoutFlags.layoutReplot) {\n        var data = gd.data;\n        var layout = gd.layout;\n\n        // clear existing data/layout on gd\n        // so that Plotly.plot doesn't try to extend them\n        gd.data = undefined;\n        gd.layout = undefined;\n\n        seq.push(function() { return exports.plot(gd, data, layout); });\n    }\n    else if(restyleFlags.fullReplot) {\n        seq.push(exports.plot);\n    }\n    else if(relayoutFlags.layoutReplot) {\n        seq.push(subroutines.layoutReplot);\n    }\n    else {\n        seq.push(Plots.previousPromises);\n        axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n\n        if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n        if(restyleFlags.colorbars) seq.push(subroutines.doColorBars);\n        if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n        if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n        if(relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n        if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n        if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n        if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n\n        seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover);\n\n    Queue.add(gd,\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\n    );\n\n    var plotDone = Lib.syncOrAsync(seq, gd);\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n\n    return plotDone.then(function() {\n        gd.emit('plotly_update', {\n            data: restyleSpecs.eventData,\n            layout: relayoutSpecs.eventData\n        });\n\n        return gd;\n    });\n}\nexports.update = update;\n\n/*\n * internal-use-only restyle/relayout/update variants that record the initial\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\n * Plotly.react data updates, dependent on uirevision attributes\n */\nfunction guiEdit(func) {\n    return function wrappedEdit(gd) {\n        gd._fullLayout._guiEditing = true;\n        var p = func.apply(null, arguments);\n        gd._fullLayout._guiEditing = false;\n        return p;\n    };\n}\nexports._guiRestyle = guiEdit(restyle);\nexports._guiRelayout = guiEdit(relayout);\nexports._guiUpdate = guiEdit(update);\n\n// For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\nvar layoutUIControlPatterns = [\n    {pattern: /^hiddenlabels/, attr: 'legend.uirevision'},\n    {pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},\n\n    // showspikes and modes include those nested inside scenes\n    {pattern: /axis\\d*\\.showspikes$/, attr: 'modebar.uirevision'},\n    {pattern: /(hover|drag)mode$/, attr: 'modebar.uirevision'},\n\n    {pattern: /^(scene\\d*)\\.camera/},\n    {pattern: /^(geo\\d*)\\.(projection|center)/},\n    {pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},\n    {pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},\n    {pattern: /^(polar\\d*\\.angularaxis)\\.rotation/},\n    {pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},\n\n    {pattern: /^legend\\.(x|y)$/, attr: 'editrevision'},\n    {pattern: /^(shapes|annotations)/, attr: 'editrevision'},\n    {pattern: /^title\\.text$/, attr: 'editrevision'}\n];\n\n// same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\nvar traceUIControlPatterns = [\n    {pattern: /^selectedpoints$/, attr: 'selectionrevision'},\n    // \"visible\" includes trace.transforms[i].styles[j].value.visible\n    {pattern: /(^|value\\.)visible$/, attr: 'legend.uirevision'},\n    {pattern: /^dimensions\\[\\d+\\]\\.constraintrange/},\n\n    // below this you must be in editable: true mode\n    // TODO: I still put name and title with `trace.uirevision`\n    // reasonable or should these be `editrevision`?\n    // Also applies to axis titles up in the layout section\n\n    // \"name\" also includes transform.styles\n    {pattern: /(^|value\\.)name$/},\n    // including nested colorbar attributes (ie marker.colorbar)\n    {pattern: /colorbar\\.title\\.text$/},\n    {pattern: /colorbar\\.(x|y)$/, attr: 'editrevision'}\n];\n\nfunction findUIPattern(key, patternSpecs) {\n    for(var i = 0; i < patternSpecs.length; i++) {\n        var spec = patternSpecs[i];\n        var match = key.match(spec.pattern);\n        if(match) {\n            return {head: match[1], attr: spec.attr};\n        }\n    }\n}\n\n// We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\nfunction getNewRev(revAttr, container) {\n    var newRev = nestedProperty(container, revAttr).get();\n    if(newRev !== undefined) return newRev;\n\n    var parts = revAttr.split('.');\n    parts.pop();\n    while(parts.length > 1) {\n        parts.pop();\n        newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n        if(newRev !== undefined) return newRev;\n    }\n\n    return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n    for(var i = 0; i < fullData.length; i++) {\n        if(fullData[i]._fullInput.uid === uid) return i;\n    }\n    return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n    for(var i = 0; i < data.length; i++) {\n        if(data[i].uid === uid) return i;\n    }\n    // fall back on trace order, but only if user didn't provide a uid for that trace\n    return (!data[tracei] || data[tracei].uid) ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n    var v1IsObj = Lib.isPlainObject(v1);\n    var v1IsArray = Array.isArray(v1);\n    if(v1IsObj || v1IsArray) {\n        return (\n            (v1IsObj && Lib.isPlainObject(v2)) ||\n            (v1IsArray && Array.isArray(v2))\n        ) && JSON.stringify(v1) === JSON.stringify(v2);\n    }\n    return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n    var layoutPreGUI = oldFullLayout._preGUI;\n    var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n    var bothInheritAutorange = [];\n    var newRangeAccepted = {};\n    for(key in layoutPreGUI) {\n        match = findUIPattern(key, layoutUIControlPatterns);\n        if(match) {\n            revAttr = match.attr || (match.head + '.uirevision');\n            oldRev = nestedProperty(oldFullLayout, revAttr).get();\n            newRev = oldRev && getNewRev(revAttr, layout);\n            if(newRev && (newRev === oldRev)) {\n                preGUIVal = layoutPreGUI[key];\n                if(preGUIVal === null) preGUIVal = undefined;\n                newNP = nestedProperty(layout, key);\n                newVal = newNP.get();\n                if(valsMatch(newVal, preGUIVal)) {\n                    if(newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n                        bothInheritAutorange.push(key.substr(0, key.length - 10));\n                    }\n                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n                    continue;\n                }\n            }\n        }\n        else {\n            Lib.warn('unrecognized GUI edit: ' + key);\n        }\n        // if we got this far, the new value was accepted as the new starting\n        // point (either because it changed or revision changed)\n        // so remove it from _preGUI for next time.\n        delete layoutPreGUI[key];\n\n        if(key.substr(key.length - 8, 6) === 'range[') {\n            newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n        }\n    }\n\n    // Special logic for `autorange`, since it interacts with `range`:\n    // If the new figure's matching `range` was kept, and `autorange`\n    // wasn't supplied explicitly in either the original or the new figure,\n    // we shouldn't alter that - but we may just have done that, so fix it.\n    for(var i = 0; i < bothInheritAutorange.length; i++) {\n        var axAttr = bothInheritAutorange[i];\n        if(newRangeAccepted[axAttr]) {\n            var newAx = nestedProperty(layout, axAttr).get();\n            if(newAx) delete newAx.autorange;\n        }\n    }\n\n    // Now traces - try to match them up by uid (in case we added/deleted in\n    // the middle), then fall back on index.\n    var allTracePreGUI = oldFullLayout._tracePreGUI;\n    for(var uid in allTracePreGUI) {\n        var tracePreGUI = allTracePreGUI[uid];\n        var newTrace = null;\n        var fullInput;\n        for(key in tracePreGUI) {\n            // wait until we know we have preGUI values to look for traces\n            // but if we don't find both, stop looking at this uid\n            if(!newTrace) {\n                var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n                if(fulli < 0) {\n                    // Somehow we didn't even have this trace in oldFullData...\n                    // I guess this could happen with `deleteTraces` or something\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                var fullTrace = oldFullData[fulli];\n                fullInput = fullTrace._fullInput;\n\n                var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n                if(newTracei < 0) {\n                    // No match in new data\n                    delete allTracePreGUI[uid];\n                    break;\n                }\n                newTrace = data[newTracei];\n            }\n\n            match = findUIPattern(key, traceUIControlPatterns);\n            if(match) {\n                if(match.attr) {\n                    oldRev = nestedProperty(oldFullLayout, match.attr).get();\n                    newRev = oldRev && getNewRev(match.attr, layout);\n                }\n                else {\n                    oldRev = fullInput.uirevision;\n                    // inheritance for trace.uirevision is simple, just layout.uirevision\n                    newRev = newTrace.uirevision;\n                    if(newRev === undefined) newRev = layout.uirevision;\n                }\n\n                if(newRev && newRev === oldRev) {\n                    preGUIVal = tracePreGUI[key];\n                    if(preGUIVal === null) preGUIVal = undefined;\n                    newNP = nestedProperty(newTrace, key);\n                    newVal = newNP.get();\n                    if(valsMatch(newVal, preGUIVal)) {\n                        newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n                        continue;\n                    }\n                }\n            }\n            else {\n                Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n            }\n            delete tracePreGUI[key];\n        }\n    }\n}\n\n/**\n * Plotly.react:\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\n * and diffs to determine the minimal update pathway\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {array of objects} data\n *      array of traces, containing the data and display information for each trace\n * @param {object} layout\n *      object describing the overall display of the plot,\n *      all the stuff that doesn't pertain to any individual trace\n * @param {object} config\n *      configuration options (see ./plot_config.js for more info)\n *\n * OR\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n * @param {object} figure\n *      object containing `data`, `layout`, `config`, and `frames` members\n *\n */\nexports.react = function(gd, data, layout, config) {\n    var frames, plotDone;\n\n    function addFrames() { return exports.addFrames(gd, frames); }\n\n    gd = Lib.getGraphDiv(gd);\n\n    var oldFullData = gd._fullData;\n    var oldFullLayout = gd._fullLayout;\n\n    // you can use this as the initial draw as well as to update\n    if(!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n        plotDone = exports.newPlot(gd, data, layout, config);\n    }\n    else {\n\n        if(Lib.isPlainObject(data)) {\n            var obj = data;\n            data = obj.data;\n            layout = obj.layout;\n            config = obj.config;\n            frames = obj.frames;\n        }\n\n        var configChanged = false;\n        // assume that if there's a config at all, we're reacting to it too,\n        // and completely replace the previous config\n        if(config) {\n            var oldConfig = Lib.extendDeep({}, gd._context);\n            gd._context = undefined;\n            setPlotContext(gd, config);\n            configChanged = diffConfig(oldConfig, gd._context);\n        }\n\n        gd.data = data || [];\n        helpers.cleanData(gd.data);\n        gd.layout = layout || {};\n        helpers.cleanLayout(gd.layout);\n\n        applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\n\n        // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n        // which supplyDefaults usually does at the end, but we may need to NOT do\n        // if the diff (which we haven't determined yet) says we'll recalc\n        Plots.supplyDefaults(gd, {skipUpdateCalc: true});\n\n        var newFullData = gd._fullData;\n        var newFullLayout = gd._fullLayout;\n        var immutable = newFullLayout.datarevision === undefined;\n        var transition = newFullLayout.transition;\n\n        var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n        var newDataRevision = relayoutFlags.newDataRevision;\n        var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\n\n        // TODO: how to translate this part of relayout to Plotly.react?\n        // // Setting width or height to null must reset the graph's width / height\n        // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n        // //\n        // // To do so, we must manually set them back here using the _initialAutoSize cache.\n        // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n        //     fullLayout[ai] = gd._initialAutoSize[ai];\n        // }\n\n        if(updateAutosize(gd)) relayoutFlags.layoutReplot = true;\n\n        // clear calcdata if required\n        if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n        // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n        else Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n\n        // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n        // must be handled by the user when using Plotly.react.\n\n        // fill in redraw sequence\n        var seq = [];\n\n        if(frames) {\n            gd._transitionData = {};\n            Plots.createTransitionData(gd);\n            seq.push(addFrames);\n        }\n\n        // Transition pathway,\n        // only used when 'transition' is set by user and\n        // when at least one animatable attribute has changed,\n        // N.B. config changed aren't animatable\n        if(newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n            Plots.doCalcdata(gd);\n            subroutines.doAutoRangeAndConstraints(gd);\n\n            seq.push(function() {\n                return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n            });\n        }\n        else if(restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n            gd._fullLayout._skipDefaults = true;\n            seq.push(exports.plot);\n        }\n        else {\n            for(var componentType in relayoutFlags.arrays) {\n                var indices = relayoutFlags.arrays[componentType];\n                if(indices.length) {\n                    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n                    if(drawOne !== Lib.noop) {\n                        for(var i = 0; i < indices.length; i++) {\n                            drawOne(gd, indices[i]);\n                        }\n                    }\n                    else {\n                        var draw = Registry.getComponentMethod(componentType, 'draw');\n                        if(draw === Lib.noop) {\n                            throw new Error('cannot draw components: ' + componentType);\n                        }\n                        draw(gd);\n                    }\n                }\n            }\n\n            seq.push(Plots.previousPromises);\n            if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\n            if(restyleFlags.colorbars) seq.push(subroutines.doColorBars);\n            if(relayoutFlags.legend) seq.push(subroutines.doLegend);\n            if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n            if(relayoutFlags.axrange) addAxRangeSequence(seq);\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n            if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n            if(relayoutFlags.camera) seq.push(subroutines.doCamera);\n            seq.push(emitAfterPlot);\n        }\n\n        seq.push(Plots.rehover);\n\n        plotDone = Lib.syncOrAsync(seq, gd);\n        if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n    }\n\n    return plotDone.then(function() {\n        gd.emit('plotly_react', {\n            data: data,\n            layout: layout\n        });\n\n        return gd;\n    });\n\n};\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n    var sameTraceLength = oldFullData.length === newFullData.length;\n\n    if(!transition && !sameTraceLength) {\n        return {\n            fullReplot: true,\n            calc: true\n        };\n    }\n\n    var flags = editTypes.traceFlags();\n    flags.arrays = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    var i, trace;\n\n    function getTraceValObject(parts) {\n        return PlotSchema.getTraceValObject(trace, parts);\n    }\n\n    var diffOpts = {\n        getValObject: getTraceValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        newDataRevision: newDataRevision,\n        gd: gd\n    };\n\n    var seenUIDs = {};\n\n    for(i = 0; i < oldFullData.length; i++) {\n        if(newFullData[i]) {\n            trace = newFullData[i]._fullInput;\n            if(Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n            if(seenUIDs[trace.uid]) continue;\n            seenUIDs[trace.uid] = 1;\n\n            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n        }\n    }\n\n    if(flags.calc || flags.plot) {\n        flags.fullReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = (flags.nChanges === flags.nChangesAnim) && sameTraceLength ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n    var flags = editTypes.layoutFlags();\n    flags.arrays = {};\n    flags.rangesAltered = {};\n    flags.nChanges = 0;\n    flags.nChangesAnim = 0;\n\n    function getLayoutValObject(parts) {\n        return PlotSchema.getLayoutValObject(newFullLayout, parts);\n    }\n\n    var diffOpts = {\n        getValObject: getLayoutValObject,\n        flags: flags,\n        immutable: immutable,\n        transition: transition,\n        gd: gd\n    };\n\n    getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n    if(flags.plot || flags.calc) {\n        flags.layoutReplot = true;\n    }\n\n    if(transition && flags.nChanges && flags.nChangesAnim) {\n        flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n    }\n\n    return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n    var valObject, key, astr;\n\n    var getValObject = opts.getValObject;\n    var flags = opts.flags;\n    var immutable = opts.immutable;\n    var inArray = opts.inArray;\n    var arrayIndex = opts.arrayIndex;\n\n    function changed() {\n        var editType = valObject.editType;\n        if(inArray && editType.indexOf('arraydraw') !== -1) {\n            Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n            return;\n        }\n        editTypes.update(flags, valObject);\n\n        if(editType !== 'none') {\n            flags.nChanges++;\n        }\n\n        // track animatable changes\n        if(opts.transition && valObject.anim) {\n            flags.nChangesAnim++;\n        }\n\n        // track cartesian axes with altered ranges\n        if(AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n            flags.rangesAltered[outerparts[0]] = 1;\n        }\n\n        // clear _inputDomain on cartesian axes with altered domains\n        if(AX_DOMAIN_RE.test(astr)) {\n            nestedProperty(newContainer, '_inputDomain').set(null);\n        }\n\n        // track datarevision changes\n        if(key === 'datarevision') {\n            flags.newDataRevision = 1;\n        }\n    }\n\n    function valObjectCanBeDataArray(valObject) {\n        return valObject.valType === 'data_array' || valObject.arrayOk;\n    }\n\n    for(key in oldContainer) {\n        // short-circuit based on previous calls or previous keys that already maximized the pathway\n        if(flags.calc && !opts.transition) return;\n\n        var oldVal = oldContainer[key];\n        var newVal = newContainer[key];\n        var parts = outerparts.concat(key);\n        astr = parts.join('.');\n\n        if(key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\n\n        // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n        // and unlike other auto values they don't make it back into the input,\n        // so newContainer won't have them.\n        if((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n            var tickMode = newContainer.tickmode;\n            if(tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n        }\n        // FIXME: Similarly for axis ranges for 3D\n        // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n        if(key === 'range' && newContainer.autorange) continue;\n        if((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n\n        valObject = getValObject(parts);\n\n        // in case type changed, we may not even *have* a valObject.\n        if(!valObject) continue;\n\n        if(valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n\n        var valType = valObject.valType;\n        var i;\n\n        var canBeDataArray = valObjectCanBeDataArray(valObject);\n        var wasArray = Array.isArray(oldVal);\n        var nowArray = Array.isArray(newVal);\n\n        // hack for traces that modify the data in supplyDefaults, like\n        // converting 1D to 2D arrays, which will always create new objects\n        if(wasArray && nowArray) {\n            var inputKey = '_input_' + key;\n            var oldValIn = oldContainer[inputKey];\n            var newValIn = newContainer[inputKey];\n            if(Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n        }\n\n        if(newVal === undefined) {\n            if(canBeDataArray && wasArray) flags.calc = true;\n            else changed();\n        }\n        else if(valObject._isLinkedToArray) {\n            var arrayEditIndices = [];\n            var extraIndices = false;\n            if(!inArray) flags.arrays[key] = arrayEditIndices;\n\n            var minLen = Math.min(oldVal.length, newVal.length);\n            var maxLen = Math.max(oldVal.length, newVal.length);\n            if(minLen !== maxLen) {\n                if(valObject.editType === 'arraydraw') {\n                    extraIndices = true;\n                }\n                else {\n                    changed();\n                    continue;\n                }\n            }\n\n            for(i = 0; i < minLen; i++) {\n                getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\n                    // add array indices, but not if we're already in an array\n                    Lib.extendFlat({inArray: key, arrayIndex: i}, opts));\n            }\n\n            // put this at the end so that we know our collected array indices are sorted\n            // but the check for length changes happens up front so we can short-circuit\n            // diffing if appropriate\n            if(extraIndices) {\n                for(i = minLen; i < maxLen; i++) {\n                    arrayEditIndices.push(i);\n                }\n            }\n        }\n        else if(!valType && Lib.isPlainObject(oldVal)) {\n            getDiffFlags(oldVal, newVal, parts, opts);\n        }\n        else if(canBeDataArray) {\n            if(wasArray && nowArray) {\n\n                // don't try to diff two data arrays. If immutable we know the data changed,\n                // if not, assume it didn't and let `layout.datarevision` tell us if it did\n                if(immutable) {\n                    flags.calc = true;\n                }\n\n                // look for animatable attributes when the data changed\n                if(immutable || opts.newDataRevision) {\n                    changed();\n                }\n            }\n            else if(wasArray !== nowArray) {\n                flags.calc = true;\n            }\n            else changed();\n        }\n        else if(wasArray && nowArray) {\n            // info array, colorscale, 'any' - these are short, just stringify.\n            // I don't *think* that covers up any real differences post-validation, does it?\n            // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n            // all elements.\n            if(oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n                changed();\n            }\n        }\n        else {\n            changed();\n        }\n    }\n\n    for(key in newContainer) {\n        if(!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n            valObject = getValObject(outerparts.concat(key));\n\n            if(valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n                flags.calc = true;\n                return;\n            }\n            else changed();\n        }\n    }\n}\n\n/*\n * simple diff for config - for now, just treat all changes as equivalent\n */\nfunction diffConfig(oldConfig, newConfig) {\n    var key;\n\n    for(key in oldConfig) {\n        if(key.charAt(0) === '_') continue;\n        var oldVal = oldConfig[key];\n        var newVal = newConfig[key];\n        if(oldVal !== newVal) {\n            if(Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n                if(diffConfig(oldVal, newVal)) {\n                    return true;\n                }\n            }\n            else if(Array.isArray(oldVal) && Array.isArray(newVal)) {\n                if(oldVal.length !== newVal.length) {\n                    return true;\n                }\n                for(var i = 0; i < oldVal.length; i++) {\n                    if(oldVal[i] !== newVal[i]) {\n                        if(Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n                            if(diffConfig(oldVal[i], newVal[i])) {\n                                return true;\n                            }\n                        }\n                        else {\n                            return true;\n                        }\n                    }\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    }\n}\n\n/**\n * Animate to a frame, sequence of frame, frame group, or frame definition\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\n *      a single frame, array of frames, or group to which to animate. The intent is\n *      inferred by the type of the input. Valid inputs are:\n *\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\n *            in which they are defined via `Plotly.addFrames`.\n *\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\n *            to animate in sequence\n *\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\n *            frame is used as provided and does not use the `baseframe` property.\n *\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\n *            each following the same rules as a single `object`.\n *\n * @param {object} animationOpts\n *      configuration for the animation\n */\nexports.animate = function(gd, frameOrGroupNameOrFrameList, animationOpts) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before animating it. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var trans = gd._transitionData;\n\n    // This is the queue of frames that will be animated as soon as possible. They\n    // are popped immediately upon the *start* of a transition:\n    if(!trans._frameQueue) {\n        trans._frameQueue = [];\n    }\n\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n    var transitionOpts = animationOpts.transition;\n    var frameOpts = animationOpts.frame;\n\n    // Since frames are popped immediately, an empty queue only means all frames have\n    // *started* to transition, not that the animation is complete. To solve that,\n    // track a separate counter that increments at the same time as frames are added\n    // to the queue, but decrements only when the transition is complete.\n    if(trans._frameWaitingCnt === undefined) {\n        trans._frameWaitingCnt = 0;\n    }\n\n    function getTransitionOpts(i) {\n        if(Array.isArray(transitionOpts)) {\n            if(i >= transitionOpts.length) {\n                return transitionOpts[0];\n            } else {\n                return transitionOpts[i];\n            }\n        } else {\n            return transitionOpts;\n        }\n    }\n\n    function getFrameOpts(i) {\n        if(Array.isArray(frameOpts)) {\n            if(i >= frameOpts.length) {\n                return frameOpts[0];\n            } else {\n                return frameOpts[i];\n            }\n        } else {\n            return frameOpts;\n        }\n    }\n\n    // Execute a callback after the wrapper function has been called n times.\n    // This is used to defer the resolution until a transition has resovled *and*\n    // the frame has completed. If it's not done this way, then we get a race\n    // condition in which the animation might resolve before a transition is complete\n    // or vice versa.\n    function callbackOnNthTime(cb, n) {\n        var cnt = 0;\n        return function() {\n            if(cb && ++cnt === n) {\n                return cb();\n            }\n        };\n    }\n\n    return new Promise(function(resolve, reject) {\n        function discardExistingFrames() {\n            if(trans._frameQueue.length === 0) {\n                return;\n            }\n\n            while(trans._frameQueue.length) {\n                var next = trans._frameQueue.pop();\n                if(next.onInterrupt) {\n                    next.onInterrupt();\n                }\n            }\n\n            gd.emit('plotly_animationinterrupted', []);\n        }\n\n        function queueFrames(frameList) {\n            if(frameList.length === 0) return;\n\n            for(var i = 0; i < frameList.length; i++) {\n                var computedFrame;\n\n                if(frameList[i].type === 'byname') {\n                    // If it's a named frame, compute it:\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\n                } else {\n                    // Otherwise we must have been given a simple object, so treat\n                    // the input itself as the computed frame.\n                    computedFrame = frameList[i].data;\n                }\n\n                var frameOpts = getFrameOpts(i);\n                var transitionOpts = getTransitionOpts(i);\n\n                // It doesn't make much sense for the transition duration to be greater than\n                // the frame duration, so limit it:\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n\n                var nextFrame = {\n                    frame: computedFrame,\n                    name: frameList[i].name,\n                    frameOpts: frameOpts,\n                    transitionOpts: transitionOpts,\n                };\n                if(i === frameList.length - 1) {\n                    // The last frame in this .animate call stores the promise resolve\n                    // and reject callbacks. This is how we ensure that the animation\n                    // loop (which may exist as a result of a *different* .animate call)\n                    // still resolves or rejecdts this .animate call's promise. once it's\n                    // complete.\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n                    nextFrame.onInterrupt = reject;\n                }\n\n                trans._frameQueue.push(nextFrame);\n            }\n\n            // Set it as never having transitioned to a frame. This will cause the animation\n            // loop to immediately transition to the next frame (which, for immediate mode,\n            // is the first frame in the list since all others would have been discarded\n            // below)\n            if(animationOpts.mode === 'immediate') {\n                trans._lastFrameAt = -Infinity;\n            }\n\n            // Only it's not already running, start a RAF loop. This could be avoided in the\n            // case that there's only one frame, but it significantly complicated the logic\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\n            // It would be a fine thing to implement, but the benefit of that optimization\n            // doesn't seem worth the extra complexity.\n            if(!trans._animationRaf) {\n                beginAnimationLoop();\n            }\n        }\n\n        function stopAnimationLoop() {\n            gd.emit('plotly_animated');\n\n            // Be sure to unset also since it's how we know whether a loop is already running:\n            window.cancelAnimationFrame(trans._animationRaf);\n            trans._animationRaf = null;\n        }\n\n        function nextFrame() {\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\n                // Execute the callback and unset it to ensure it doesn't\n                // accidentally get called twice\n                trans._currentFrame.onComplete();\n            }\n\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n            if(newFrame) {\n                // Since it's sometimes necessary to do deep digging into frame data,\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n                // so check when casting the name, just to be absolutely certain:\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\n                gd._fullLayout._currentFrame = stringName;\n\n                trans._lastFrameAt = Date.now();\n                trans._timeToNext = newFrame.frameOpts.duration;\n\n                // This is simply called and it's left to .transition to decide how to manage\n                // interrupting current transitions. That means we don't need to worry about\n                // how it resolves or what happens after this:\n                Plots.transition(gd,\n                    newFrame.frame.data,\n                    newFrame.frame.layout,\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\n                    newFrame.frameOpts,\n                    newFrame.transitionOpts\n                ).then(function() {\n                    if(newFrame.onComplete) {\n                        newFrame.onComplete();\n                    }\n\n                });\n\n                gd.emit('plotly_animatingframe', {\n                    name: stringName,\n                    frame: newFrame.frame,\n                    animation: {\n                        frame: newFrame.frameOpts,\n                        transition: newFrame.transitionOpts,\n                    }\n                });\n            } else {\n                // If there are no more frames, then stop the RAF loop:\n                stopAnimationLoop();\n            }\n        }\n\n        function beginAnimationLoop() {\n            gd.emit('plotly_animating');\n\n            // If no timer is running, then set last frame = long ago so that the next\n            // frame is immediately transitioned:\n            trans._lastFrameAt = -Infinity;\n            trans._timeToNext = 0;\n            trans._runningTransitions = 0;\n            trans._currentFrame = null;\n\n            var doFrame = function() {\n                // This *must* be requested before nextFrame since nextFrame may decide\n                // to cancel it if there's nothing more to animated:\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\n\n                // Check if we're ready for a new frame:\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\n                    nextFrame();\n                }\n            };\n\n            doFrame();\n        }\n\n        // This is an animate-local counter that helps match up option input list\n        // items with the particular frame.\n        var configCounter = 0;\n        function setTransitionConfig(frame) {\n            if(Array.isArray(transitionOpts)) {\n                if(configCounter >= transitionOpts.length) {\n                    frame.transitionOpts = transitionOpts[configCounter];\n                } else {\n                    frame.transitionOpts = transitionOpts[0];\n                }\n            } else {\n                frame.transitionOpts = transitionOpts;\n            }\n            configCounter++;\n            return frame;\n        }\n\n        // Disambiguate what's sort of frames have been received\n        var i, frame;\n        var frameList = [];\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n        if(isSingleFrame) {\n            // In this case, a simple object has been passed to animate.\n            frameList.push({\n                type: 'object',\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n            });\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n            // In this case, null or undefined has been passed so that we want to\n            // animate *all* currently defined frames\n            for(i = 0; i < trans._frames.length; i++) {\n                frame = trans._frames[i];\n\n                if(!frame) continue;\n\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n                    frameList.push({\n                        type: 'byname',\n                        name: String(frame.name),\n                        data: setTransitionConfig({name: frame.name})\n                    });\n                }\n            }\n        } else if(isFrameArray) {\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n                var frameOrName = frameOrGroupNameOrFrameList[i];\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n                    frameOrName = String(frameOrName);\n                    // In this case, there's an array and this frame is a string name:\n                    frameList.push({\n                        type: 'byname',\n                        name: frameOrName,\n                        data: setTransitionConfig({name: frameOrName})\n                    });\n                } else if(Lib.isPlainObject(frameOrName)) {\n                    frameList.push({\n                        type: 'object',\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n                    });\n                }\n            }\n        }\n\n        // Verify that all of these frames actually exist; return and reject if not:\n        for(i = 0; i < frameList.length; i++) {\n            frame = frameList[i];\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n                reject();\n                return;\n            }\n        }\n\n        // If the mode is either next or immediate, then all currently queued frames must\n        // be dumped and the corresponding .animate promises rejected.\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n            discardExistingFrames();\n        }\n\n        if(animationOpts.direction === 'reverse') {\n            frameList.reverse();\n        }\n\n        var currentFrame = gd._fullLayout._currentFrame;\n        if(currentFrame && animationOpts.fromcurrent) {\n            var idx = -1;\n            for(i = 0; i < frameList.length; i++) {\n                frame = frameList[i];\n                if(frame.type === 'byname' && frame.name === currentFrame) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            if(idx > 0 && idx < frameList.length - 1) {\n                var filteredFrameList = [];\n                for(i = 0; i < frameList.length; i++) {\n                    frame = frameList[i];\n                    if(frameList[i].type !== 'byname' || i > idx) {\n                        filteredFrameList.push(frame);\n                    }\n                }\n                frameList = filteredFrameList;\n            }\n        }\n\n        if(frameList.length > 0) {\n            queueFrames(frameList);\n        } else {\n            // This is the case where there were simply no frames. It's a little strange\n            // since there's not much to do:\n            gd.emit('plotly_animated');\n            resolve();\n        }\n    });\n};\n\n/**\n * Register new frames\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of objects} frameList\n *      list of frame definitions, in which each object includes any of:\n *      - name: {string} name of frame to add\n *      - data: {array of objects} trace data\n *      - layout {object} layout definition\n *      - traces {array} trace indices\n *      - baseframe {string} name of frame from which this frame gets defaults\n *\n *  @param {array of integers} indices\n *      an array of integer indices matching the respective frames in `frameList`. If not\n *      provided, an index will be provided in serial order. If already used, the frame\n *      will be overwritten.\n */\nexports.addFrames = function(gd, frameList, indices) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(frameList === null || frameList === undefined) {\n        return Promise.resolve();\n    }\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error(\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\n            'to create a plot before adding frames. For more details, see ' +\n            'https://plot.ly/javascript/animations/'\n        );\n    }\n\n    var i, frame, j, idx;\n    var _frames = gd._transitionData._frames;\n    var _frameHash = gd._transitionData._frameHash;\n\n\n    if(!Array.isArray(frameList)) {\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n    }\n\n    // Create a sorted list of insertions since we run into lots of problems if these\n    // aren't in ascending order of index:\n    //\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\n    // already-exisisting indices:\n    var bigIndex = _frames.length + frameList.length * 2;\n\n    var insertions = [];\n    var _frameHashLocal = {};\n    for(i = frameList.length - 1; i >= 0; i--) {\n        if(!Lib.isPlainObject(frameList[i])) continue;\n\n        // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n        // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n        var lookupName = frameList[i].name;\n        var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n        var newName = frameList[i].name;\n        var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n        if(name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n            numericNameWarningCount++;\n\n            Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name +\n                '\" with a frame whose name of type \"number\" also equates to \"' +\n                name + '\". This is valid but may potentially lead to unexpected ' +\n                'behavior since all plotly.js frame names are stored internally ' +\n                'as strings.');\n\n            if(numericNameWarningCount === numericNameWarningCountLimit) {\n                Lib.warn('addFrames: This API call has yielded too many of these warnings. ' +\n                    'For the rest of this call, further warnings about numeric frame ' +\n                    'names will be suppressed.');\n            }\n        }\n\n        _frameHashLocal[lookupName] = {name: lookupName};\n\n        insertions.push({\n            frame: Plots.supplyFrameDefaults(frameList[i]),\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\n        });\n    }\n\n    // Sort this, taking note that undefined insertions end up at the end:\n    insertions.sort(function(a, b) {\n        if(a.index > b.index) return -1;\n        if(a.index < b.index) return 1;\n        return 0;\n    });\n\n    var ops = [];\n    var revops = [];\n    var frameCount = _frames.length;\n\n    for(i = insertions.length - 1; i >= 0; i--) {\n        frame = insertions[i].frame;\n\n        if(typeof frame.name === 'number') {\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\n                'implicitly cast to strings');\n\n        }\n\n        if(!frame.name) {\n            // Repeatedly assign a default name, incrementing the counter each time until\n            // we get a name that's not in the hashed lookup table:\n            while(_frameHash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\n        }\n\n        if(_frameHash[frame.name]) {\n            // If frame is present, overwrite its definition:\n            for(j = 0; j < _frames.length; j++) {\n                if((_frames[j] || {}).name === frame.name) break;\n            }\n            ops.push({type: 'replace', index: j, value: frame});\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\n        } else {\n            // Otherwise insert it at the end of the list:\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n\n            ops.push({type: 'insert', index: idx, value: frame});\n            revops.unshift({type: 'delete', index: idx});\n            frameCount++;\n        }\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Delete frame\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n *\n * @param {array of integers} frameList\n *      list of integer indices of frames to be deleted\n */\nexports.deleteFrames = function(gd, frameList) {\n    gd = Lib.getGraphDiv(gd);\n\n    if(!Lib.isPlotDiv(gd)) {\n        throw new Error('This element is not a Plotly plot: ' + gd);\n    }\n\n    var i, idx;\n    var _frames = gd._transitionData._frames;\n    var ops = [];\n    var revops = [];\n\n    if(!frameList) {\n        frameList = [];\n        for(i = 0; i < _frames.length; i++) {\n            frameList.push(i);\n        }\n    }\n\n    frameList = frameList.slice(0);\n    frameList.sort();\n\n    for(i = frameList.length - 1; i >= 0; i--) {\n        idx = frameList[i];\n        ops.push({type: 'delete', index: idx});\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\n    }\n\n    var undoFunc = Plots.modifyFrames;\n    var redoFunc = Plots.modifyFrames;\n    var undoArgs = [gd, revops];\n    var redoArgs = [gd, ops];\n\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n\n    return Plots.modifyFrames(gd, ops);\n};\n\n/**\n * Purge a graph container div back to its initial pre-Plotly.plot state\n *\n * @param {string id or DOM element} gd\n *      the id or DOM element of the graph container div\n */\nexports.purge = function purge(gd) {\n    gd = Lib.getGraphDiv(gd);\n\n    var fullLayout = gd._fullLayout || {};\n    var fullData = gd._fullData || [];\n\n    // remove gl contexts\n    Plots.cleanPlot([], {}, fullData, fullLayout);\n\n    // purge properties\n    Plots.purge(gd);\n\n    // purge event emitter methods\n    Events.purge(gd);\n\n    // remove plot container\n    if(fullLayout._container) fullLayout._container.remove();\n\n    // in contrast to Plotly.Plots.purge which does NOT clear _context!\n    delete gd._context;\n\n    return gd;\n};\n\n// -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\nfunction makePlotFramework(gd) {\n    var gd3 = d3.select(gd);\n    var fullLayout = gd._fullLayout;\n\n    // Plot container\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n    fullLayout._container.enter().insert('div', ':first-child')\n        .classed('plot-container', true)\n        .classed('plotly', true);\n\n    // Make the svg container\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n    fullLayout._paperdiv.enter().append('div')\n        .classed('svg-container', true)\n        .style('position', 'relative');\n\n    // Make the graph containers\n    // start fresh each time we get here, so we know the order comes out\n    // right, rather than enter/exit which can muck up the order\n    // TODO: sort out all the ordering so we don't have to\n    // explicitly delete anything\n    // FIXME: parcoords reuses this object, not the best pattern\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\n        .data([{}]);\n\n    fullLayout._glcontainer.enter().append('div')\n        .classed('gl-container', true);\n\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\n        .classed('main-svg', true);\n\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\n        .classed('main-svg', true);\n\n    if(!fullLayout._uid) {\n        var otherUids = {};\n        d3.selectAll('defs').each(function() {\n            if(this.id) otherUids[this.id.split('-')[1]] = 1;\n        });\n        fullLayout._uid = Lib.randstr(otherUids);\n    }\n\n    fullLayout._paperdiv.selectAll('.main-svg')\n        .attr(xmlnsNamespaces.svgAttrs);\n\n    fullLayout._defs = fullLayout._paper.append('defs')\n        .attr('id', 'defs-' + fullLayout._uid);\n\n    fullLayout._clips = fullLayout._defs.append('g')\n        .classed('clips', true);\n\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\n        .attr('id', 'topdefs-' + fullLayout._uid);\n\n    fullLayout._topclips = fullLayout._topdefs.append('g')\n        .classed('clips', true);\n\n    fullLayout._bgLayer = fullLayout._paper.append('g')\n        .classed('bglayer', true);\n\n    fullLayout._draggers = fullLayout._paper.append('g')\n        .classed('draglayer', true);\n\n    // lower shape/image layer - note that this is behind\n    // all subplots data/grids but above the backgrounds\n    // except inset subplots, whose backgrounds are drawn\n    // inside their own group so that they appear above\n    // the data for the main subplot\n    // lower shapes and images which are fully referenced to\n    // a subplot still get drawn within the subplot's group\n    // so they will work correctly on insets\n    var layerBelow = fullLayout._paper.append('g')\n        .classed('layer-below', true);\n    fullLayout._imageLowerLayer = layerBelow.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\n        .classed('shapelayer', true);\n\n    // single cartesian layer for the whole plot\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\n\n    // single polar layer for the whole plot\n    fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\n\n    // single ternary layer for the whole plot\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\n\n    // single geo layer for the whole plot\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\n\n    // single pie layer for the whole plot\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\n\n    // fill in image server scrape-svg\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\n\n    // lastly upper shapes, info (legend, annotations) and hover layers go on top\n    // these are in a different svg element normally, but get collapsed into a single\n    // svg when exporting (after inserting 3D)\n    // upper shapes/images are only those drawn above the whole plot, including subplots\n    var layerAbove = fullLayout._toppaper.append('g')\n        .classed('layer-above', true);\n    fullLayout._imageUpperLayer = layerAbove.append('g')\n        .classed('imagelayer', true);\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\n        .classed('shapelayer', true);\n\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n    fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n    fullLayout._hoverlayer = fullLayout._toppaper.append('g').classed('hoverlayer', true);\n\n    gd.emit('plotly_framework');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}