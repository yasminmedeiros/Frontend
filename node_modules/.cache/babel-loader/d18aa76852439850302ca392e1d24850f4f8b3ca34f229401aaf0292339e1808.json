{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar isPlainObject = Lib.isPlainObject;\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar plotAttributes = require('../plots/attributes');\nvar Template = require('./plot_template');\nvar dfltConfig = require('./plot_config').dfltConfig;\n\n/**\n * Plotly.makeTemplate: create a template off an existing figure to reuse\n * style attributes on other figures.\n *\n * Note: separated from the rest of templates because otherwise we get circular\n * references due to PlotSchema.\n *\n * @param {object|DOM element|string} figure: The figure to base the template on\n *     should contain a trace array `figure.data`\n *     and a layout object `figure.layout`\n * @returns {object} template: the extracted template - can then be used as\n *     `layout.template` in another figure.\n */\nexports.makeTemplate = function (figure) {\n  figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);\n  figure = Lib.extendDeep({\n    _context: dfltConfig\n  }, {\n    data: figure.data,\n    layout: figure.layout\n  });\n  Plots.supplyDefaults(figure);\n  var data = figure.data || [];\n  var layout = figure.layout || {};\n  // copy over a few items to help follow the schema\n  layout._basePlotModules = figure._fullLayout._basePlotModules;\n  layout._modules = figure._fullLayout._modules;\n  var template = {\n    data: {},\n    layout: {}\n  };\n\n  /*\n   * Note: we do NOT validate template values, we just take what's in the\n   * user inputs data and layout, not the validated values in fullData and\n   * fullLayout. Even if we were to validate here, there's no guarantee that\n   * these values would still be valid when applied to a new figure, which\n   * may contain different trace modes, different axes, etc. So it's\n   * important that when applying a template we still validate the template\n   * values, rather than just using them as defaults.\n   */\n\n  data.forEach(function (trace) {\n    // TODO: What if no style info is extracted for this trace. We may\n    // not want an empty object as the null value.\n    // TODO: allow transforms to contribute to templates?\n    // as it stands they are ignored, which may be for the best...\n\n    var traceTemplate = {};\n    walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));\n    var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');\n    var typeTemplates = template.data[traceType];\n    if (!typeTemplates) typeTemplates = template.data[traceType] = [];\n    typeTemplates.push(traceTemplate);\n  });\n  walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));\n\n  /*\n   * Compose the new template with an existing one to the same effect\n   *\n   * NOTE: there's a possibility of slightly different behavior: if the plot\n   * has an invalid value and the old template has a valid value for the same\n   * attribute, the plot will use the old template value but this routine\n   * will pull the invalid value (resulting in the original default).\n   * In the general case it's not possible to solve this with a single value,\n   * since valid options can be context-dependent. It could be solved with\n   * a *list* of values, but that would be huge complexity for little gain.\n   */\n  delete template.layout.template;\n  var oldTemplate = layout.template;\n  if (isPlainObject(oldTemplate)) {\n    var oldLayoutTemplate = oldTemplate.layout;\n    var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;\n    if (isPlainObject(oldLayoutTemplate)) {\n      mergeTemplates(oldLayoutTemplate, template.layout);\n    }\n    var oldDataTemplate = oldTemplate.data;\n    if (isPlainObject(oldDataTemplate)) {\n      for (traceType in template.data) {\n        oldTypeTemplates = oldDataTemplate[traceType];\n        if (Array.isArray(oldTypeTemplates)) {\n          typeTemplates = template.data[traceType];\n          typeLen = typeTemplates.length;\n          oldTypeLen = oldTypeTemplates.length;\n          for (i = 0; i < typeLen; i++) {\n            mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);\n          }\n          for (i = typeLen; i < oldTypeLen; i++) {\n            typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));\n          }\n        }\n      }\n      for (traceType in oldDataTemplate) {\n        if (!(traceType in template.data)) {\n          template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);\n        }\n      }\n    }\n  }\n  return template;\n};\nfunction mergeTemplates(oldTemplate, newTemplate) {\n  // we don't care about speed here, just make sure we have a totally\n  // distinct object from the previous template\n  oldTemplate = Lib.extendDeep({}, oldTemplate);\n\n  // sort keys so we always get annotationdefaults before annotations etc\n  // so arrayTemplater will work right\n  var oldKeys = Object.keys(oldTemplate).sort();\n  var i, j;\n  function mergeOne(oldVal, newVal, key) {\n    if (isPlainObject(newVal) && isPlainObject(oldVal)) {\n      mergeTemplates(oldVal, newVal);\n    } else if (Array.isArray(newVal) && Array.isArray(oldVal)) {\n      // Note: omitted `inclusionAttr` from arrayTemplater here,\n      // it's irrelevant as we only want the resulting `_template`.\n      var templater = Template.arrayTemplater({\n        _template: oldTemplate\n      }, key);\n      for (j = 0; j < newVal.length; j++) {\n        var item = newVal[j];\n        var oldItem = templater.newItem(item)._template;\n        if (oldItem) mergeTemplates(oldItem, item);\n      }\n      var defaultItems = templater.defaultItems();\n      for (j = 0; j < defaultItems.length; j++) {\n        newVal.push(defaultItems[j]._template);\n      }\n\n      // templateitemname only applies to receiving plots\n      for (j = 0; j < newVal.length; j++) {\n        delete newVal[j].templateitemname;\n      }\n    }\n  }\n  for (i = 0; i < oldKeys.length; i++) {\n    var key = oldKeys[i];\n    var oldVal = oldTemplate[key];\n    if (key in newTemplate) {\n      mergeOne(oldVal, newTemplate[key], key);\n    } else newTemplate[key] = oldVal;\n\n    // if this is a base key from the old template (eg xaxis), look for\n    // extended keys (eg xaxis2) in the new template to merge into\n    if (getBaseKey(key) === key) {\n      for (var key2 in newTemplate) {\n        var baseKey2 = getBaseKey(key2);\n        if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {\n          mergeOne(oldVal, newTemplate[key2], key);\n        }\n      }\n    }\n  }\n}\nfunction getBaseKey(key) {\n  return key.replace(/[0-9]+$/, '');\n}\nfunction walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {\n  var pathAttr = basePath && getAttributeInfo(basePath);\n  for (var key in parent) {\n    var child = parent[key];\n    var nextPath = getNextPath(parent, key, path);\n    var nextBasePath = getNextPath(parent, key, basePath);\n    var attr = getAttributeInfo(nextBasePath);\n    if (!attr) {\n      var baseKey = getBaseKey(key);\n      if (baseKey !== key) {\n        nextBasePath = getNextPath(parent, baseKey, basePath);\n        attr = getAttributeInfo(nextBasePath);\n      }\n    }\n\n    // we'll get an attr if path starts with a valid part, then has an\n    // invalid ending. Make sure we got all the way to the end.\n    if (pathAttr && pathAttr === attr) continue;\n    if (!attr || attr._noTemplating || attr.valType === 'data_array' || attr.arrayOk && Array.isArray(child)) {\n      continue;\n    }\n    if (!attr.valType && isPlainObject(child)) {\n      walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);\n    } else if (attr._isLinkedToArray && Array.isArray(child)) {\n      var dfltDone = false;\n      var namedIndex = 0;\n      var usedNames = {};\n      for (var i = 0; i < child.length; i++) {\n        var item = child[i];\n        if (isPlainObject(item)) {\n          var name = item.name;\n          if (name) {\n            if (!usedNames[name]) {\n              // named array items: allow all attributes except data arrays\n              walkStyleKeys(item, templateOut, getAttributeInfo, getNextPath(child, namedIndex, nextPath), getNextPath(child, namedIndex, nextBasePath));\n              namedIndex++;\n              usedNames[name] = 1;\n            }\n          } else if (!dfltDone) {\n            var dfltKey = Template.arrayDefaultKey(key);\n            var dfltPath = getNextPath(parent, dfltKey, path);\n\n            // getAttributeInfo will fail if we try to use dfltKey directly.\n            // Instead put this item into the next array element, then\n            // pull it out and move it to dfltKey.\n            var pathInArray = getNextPath(child, namedIndex, nextPath);\n            walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray, getNextPath(child, namedIndex, nextBasePath));\n            var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);\n            var dfltProp = Lib.nestedProperty(templateOut, dfltPath);\n            dfltProp.set(itemPropInArray.get());\n            itemPropInArray.set(null);\n            dfltDone = true;\n          }\n        }\n      }\n    } else {\n      var templateProp = Lib.nestedProperty(templateOut, nextPath);\n      templateProp.set(child);\n    }\n  }\n}\nfunction getLayoutInfo(layout, path) {\n  return PlotSchema.getLayoutValObject(layout, Lib.nestedProperty({}, path).parts);\n}\nfunction getTraceInfo(trace, path) {\n  return PlotSchema.getTraceValObject(trace, Lib.nestedProperty({}, path).parts);\n}\nfunction getNextPath(parent, key, path) {\n  var nextPath;\n  if (!path) nextPath = key;else if (Array.isArray(parent)) nextPath = path + '[' + key + ']';else nextPath = path + '.' + key;\n  return nextPath;\n}\n\n/**\n * validateTemplate: Test for consistency between the given figure and\n * a template, either already included in the figure or given separately.\n * Note that not every issue we identify here is necessarily a problem,\n * it depends on what you're using the template for.\n *\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\n *     to test the template against\n * @param {Optional(object)} template: the template, with its own {data, layout},\n *     to test. If omitted, we will look for a template already attached as the\n *     plot's `layout.template` attribute.\n *\n * @returns {array} array of error objects each containing:\n *  - {string} code\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\n *  - {string} msg\n *      a full readable description of the issue.\n */\nexports.validateTemplate = function (figureIn, template) {\n  var figure = Lib.extendDeep({}, {\n    _context: dfltConfig,\n    data: figureIn.data,\n    layout: figureIn.layout\n  });\n  var layout = figure.layout || {};\n  if (!isPlainObject(template)) template = layout.template || {};\n  var layoutTemplate = template.layout;\n  var dataTemplate = template.data;\n  var errorList = [];\n  figure.layout = layout;\n  figure.layout.template = template;\n  Plots.supplyDefaults(figure);\n  var fullLayout = figure._fullLayout;\n  var fullData = figure._fullData;\n  var layoutPaths = {};\n  function crawlLayoutForContainers(obj, paths) {\n    for (var key in obj) {\n      if (key.charAt(0) !== '_' && isPlainObject(obj[key])) {\n        var baseKey = getBaseKey(key);\n        var nextPaths = [];\n        var i;\n        for (i = 0; i < paths.length; i++) {\n          nextPaths.push(getNextPath(obj, key, paths[i]));\n          if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));\n        }\n        for (i = 0; i < nextPaths.length; i++) {\n          layoutPaths[nextPaths[i]] = 1;\n        }\n        crawlLayoutForContainers(obj[key], nextPaths);\n      }\n    }\n  }\n  function crawlLayoutTemplateForContainers(obj, path) {\n    for (var key in obj) {\n      if (key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {\n        var nextPath = getNextPath(obj, key, path);\n        if (layoutPaths[nextPath]) {\n          crawlLayoutTemplateForContainers(obj[key], nextPath);\n        } else {\n          errorList.push({\n            code: 'unused',\n            path: nextPath\n          });\n        }\n      }\n    }\n  }\n  if (!isPlainObject(layoutTemplate)) {\n    errorList.push({\n      code: 'layout'\n    });\n  } else {\n    crawlLayoutForContainers(fullLayout, ['layout']);\n    crawlLayoutTemplateForContainers(layoutTemplate, 'layout');\n  }\n  if (!isPlainObject(dataTemplate)) {\n    errorList.push({\n      code: 'data'\n    });\n  } else {\n    var typeCount = {};\n    var traceType;\n    for (var i = 0; i < fullData.length; i++) {\n      var fullTrace = fullData[i];\n      traceType = fullTrace.type;\n      typeCount[traceType] = (typeCount[traceType] || 0) + 1;\n      if (!fullTrace._fullInput._template) {\n        // this takes care of the case of traceType in the data but not\n        // the template\n        errorList.push({\n          code: 'missing',\n          index: fullTrace._fullInput.index,\n          traceType: traceType\n        });\n      }\n    }\n    for (traceType in dataTemplate) {\n      var templateCount = dataTemplate[traceType].length;\n      var dataCount = typeCount[traceType] || 0;\n      if (templateCount > dataCount) {\n        errorList.push({\n          code: 'unused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      } else if (dataCount > templateCount) {\n        errorList.push({\n          code: 'reused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      }\n    }\n  }\n\n  // _template: false is when someone tried to modify an array item\n  // but there was no template with matching name\n  function crawlForMissingTemplates(obj, path) {\n    for (var key in obj) {\n      if (key.charAt(0) === '_') continue;\n      var val = obj[key];\n      var nextPath = getNextPath(obj, key, path);\n      if (isPlainObject(val)) {\n        if (Array.isArray(obj) && val._template === false && val.templateitemname) {\n          errorList.push({\n            code: 'missing',\n            path: nextPath,\n            templateitemname: val.templateitemname\n          });\n        }\n        crawlForMissingTemplates(val, nextPath);\n      } else if (Array.isArray(val) && hasPlainObject(val)) {\n        crawlForMissingTemplates(val, nextPath);\n      }\n    }\n  }\n  crawlForMissingTemplates({\n    data: fullData,\n    layout: fullLayout\n  }, '');\n  if (errorList.length) return errorList.map(format);\n};\nfunction hasPlainObject(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (isPlainObject(arr[i])) return true;\n  }\n}\nfunction format(opts) {\n  var msg;\n  switch (opts.code) {\n    case 'data':\n      msg = 'The template has no key data.';\n      break;\n    case 'layout':\n      msg = 'The template has no key layout.';\n      break;\n    case 'missing':\n      if (opts.path) {\n        msg = 'There are no templates for item ' + opts.path + ' with name ' + opts.templateitemname;\n      } else {\n        msg = 'There are no templates for trace ' + opts.index + ', of type ' + opts.traceType + '.';\n      }\n      break;\n    case 'unused':\n      if (opts.path) {\n        msg = 'The template item at ' + opts.path + ' was not used in constructing the plot.';\n      } else if (opts.dataCount) {\n        msg = 'Some of the templates of type ' + opts.traceType + ' were not used. The template has ' + opts.templateCount + ' traces, the data only has ' + opts.dataCount + ' of this type.';\n      } else {\n        msg = 'The template has ' + opts.templateCount + ' traces of type ' + opts.traceType + ' but there are none in the data.';\n      }\n      break;\n    case 'reused':\n      msg = 'Some of the templates of type ' + opts.traceType + ' were used more than once. The template has ' + opts.templateCount + ' traces, the data has ' + opts.dataCount + ' of this type.';\n      break;\n  }\n  opts.msg = msg;\n  return opts;\n}","map":{"version":3,"names":["Lib","require","isPlainObject","PlotSchema","Plots","plotAttributes","Template","dfltConfig","exports","makeTemplate","figure","getGraphDiv","extendDeep","_context","data","layout","supplyDefaults","_basePlotModules","_fullLayout","_modules","template","forEach","trace","traceTemplate","walkStyleKeys","getTraceInfo","bind","traceType","coerce","typeTemplates","push","getLayoutInfo","oldTemplate","oldLayoutTemplate","i","oldTypeTemplates","oldTypeLen","typeLen","mergeTemplates","oldDataTemplate","Array","isArray","length","newTemplate","oldKeys","Object","keys","sort","j","mergeOne","oldVal","newVal","key","templater","arrayTemplater","_template","item","oldItem","newItem","defaultItems","templateitemname","getBaseKey","key2","baseKey2","replace","parent","templateOut","getAttributeInfo","path","basePath","pathAttr","child","nextPath","getNextPath","nextBasePath","attr","baseKey","_noTemplating","valType","arrayOk","_isLinkedToArray","dfltDone","namedIndex","usedNames","name","dfltKey","arrayDefaultKey","dfltPath","pathInArray","itemPropInArray","nestedProperty","dfltProp","set","get","templateProp","getLayoutValObject","parts","getTraceValObject","validateTemplate","figureIn","layoutTemplate","dataTemplate","errorList","fullLayout","fullData","_fullData","layoutPaths","crawlLayoutForContainers","obj","paths","charAt","nextPaths","crawlLayoutTemplateForContainers","indexOf","code","typeCount","fullTrace","type","_fullInput","index","templateCount","dataCount","crawlForMissingTemplates","val","hasPlainObject","map","format","arr","opts","msg"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/plot_api/template_api.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../lib');\nvar isPlainObject = Lib.isPlainObject;\nvar PlotSchema = require('./plot_schema');\nvar Plots = require('../plots/plots');\nvar plotAttributes = require('../plots/attributes');\nvar Template = require('./plot_template');\nvar dfltConfig = require('./plot_config').dfltConfig;\n\n/**\n * Plotly.makeTemplate: create a template off an existing figure to reuse\n * style attributes on other figures.\n *\n * Note: separated from the rest of templates because otherwise we get circular\n * references due to PlotSchema.\n *\n * @param {object|DOM element|string} figure: The figure to base the template on\n *     should contain a trace array `figure.data`\n *     and a layout object `figure.layout`\n * @returns {object} template: the extracted template - can then be used as\n *     `layout.template` in another figure.\n */\nexports.makeTemplate = function(figure) {\n    figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);\n    figure = Lib.extendDeep({_context: dfltConfig}, {data: figure.data, layout: figure.layout});\n    Plots.supplyDefaults(figure);\n    var data = figure.data || [];\n    var layout = figure.layout || {};\n    // copy over a few items to help follow the schema\n    layout._basePlotModules = figure._fullLayout._basePlotModules;\n    layout._modules = figure._fullLayout._modules;\n\n    var template = {\n        data: {},\n        layout: {}\n    };\n\n    /*\n     * Note: we do NOT validate template values, we just take what's in the\n     * user inputs data and layout, not the validated values in fullData and\n     * fullLayout. Even if we were to validate here, there's no guarantee that\n     * these values would still be valid when applied to a new figure, which\n     * may contain different trace modes, different axes, etc. So it's\n     * important that when applying a template we still validate the template\n     * values, rather than just using them as defaults.\n     */\n\n    data.forEach(function(trace) {\n        // TODO: What if no style info is extracted for this trace. We may\n        // not want an empty object as the null value.\n        // TODO: allow transforms to contribute to templates?\n        // as it stands they are ignored, which may be for the best...\n\n        var traceTemplate = {};\n        walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));\n\n        var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');\n        var typeTemplates = template.data[traceType];\n        if(!typeTemplates) typeTemplates = template.data[traceType] = [];\n        typeTemplates.push(traceTemplate);\n    });\n\n    walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));\n\n    /*\n     * Compose the new template with an existing one to the same effect\n     *\n     * NOTE: there's a possibility of slightly different behavior: if the plot\n     * has an invalid value and the old template has a valid value for the same\n     * attribute, the plot will use the old template value but this routine\n     * will pull the invalid value (resulting in the original default).\n     * In the general case it's not possible to solve this with a single value,\n     * since valid options can be context-dependent. It could be solved with\n     * a *list* of values, but that would be huge complexity for little gain.\n     */\n    delete template.layout.template;\n    var oldTemplate = layout.template;\n    if(isPlainObject(oldTemplate)) {\n        var oldLayoutTemplate = oldTemplate.layout;\n\n        var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;\n\n        if(isPlainObject(oldLayoutTemplate)) {\n            mergeTemplates(oldLayoutTemplate, template.layout);\n        }\n        var oldDataTemplate = oldTemplate.data;\n        if(isPlainObject(oldDataTemplate)) {\n            for(traceType in template.data) {\n                oldTypeTemplates = oldDataTemplate[traceType];\n                if(Array.isArray(oldTypeTemplates)) {\n                    typeTemplates = template.data[traceType];\n                    typeLen = typeTemplates.length;\n                    oldTypeLen = oldTypeTemplates.length;\n                    for(i = 0; i < typeLen; i++) {\n                        mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);\n                    }\n                    for(i = typeLen; i < oldTypeLen; i++) {\n                        typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));\n                    }\n                }\n            }\n            for(traceType in oldDataTemplate) {\n                if(!(traceType in template.data)) {\n                    template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);\n                }\n            }\n        }\n    }\n\n    return template;\n};\n\nfunction mergeTemplates(oldTemplate, newTemplate) {\n    // we don't care about speed here, just make sure we have a totally\n    // distinct object from the previous template\n    oldTemplate = Lib.extendDeep({}, oldTemplate);\n\n    // sort keys so we always get annotationdefaults before annotations etc\n    // so arrayTemplater will work right\n    var oldKeys = Object.keys(oldTemplate).sort();\n    var i, j;\n\n    function mergeOne(oldVal, newVal, key) {\n        if(isPlainObject(newVal) && isPlainObject(oldVal)) {\n            mergeTemplates(oldVal, newVal);\n        }\n        else if(Array.isArray(newVal) && Array.isArray(oldVal)) {\n            // Note: omitted `inclusionAttr` from arrayTemplater here,\n            // it's irrelevant as we only want the resulting `_template`.\n            var templater = Template.arrayTemplater({_template: oldTemplate}, key);\n            for(j = 0; j < newVal.length; j++) {\n                var item = newVal[j];\n                var oldItem = templater.newItem(item)._template;\n                if(oldItem) mergeTemplates(oldItem, item);\n            }\n            var defaultItems = templater.defaultItems();\n            for(j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);\n\n            // templateitemname only applies to receiving plots\n            for(j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;\n        }\n    }\n\n    for(i = 0; i < oldKeys.length; i++) {\n        var key = oldKeys[i];\n        var oldVal = oldTemplate[key];\n        if(key in newTemplate) {\n            mergeOne(oldVal, newTemplate[key], key);\n        }\n        else newTemplate[key] = oldVal;\n\n        // if this is a base key from the old template (eg xaxis), look for\n        // extended keys (eg xaxis2) in the new template to merge into\n        if(getBaseKey(key) === key) {\n            for(var key2 in newTemplate) {\n                var baseKey2 = getBaseKey(key2);\n                if(key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {\n                    mergeOne(oldVal, newTemplate[key2], key);\n                }\n            }\n        }\n    }\n}\n\nfunction getBaseKey(key) {\n    return key.replace(/[0-9]+$/, '');\n}\n\nfunction walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {\n    var pathAttr = basePath && getAttributeInfo(basePath);\n    for(var key in parent) {\n        var child = parent[key];\n        var nextPath = getNextPath(parent, key, path);\n        var nextBasePath = getNextPath(parent, key, basePath);\n        var attr = getAttributeInfo(nextBasePath);\n        if(!attr) {\n            var baseKey = getBaseKey(key);\n            if(baseKey !== key) {\n                nextBasePath = getNextPath(parent, baseKey, basePath);\n                attr = getAttributeInfo(nextBasePath);\n            }\n        }\n\n        // we'll get an attr if path starts with a valid part, then has an\n        // invalid ending. Make sure we got all the way to the end.\n        if(pathAttr && (pathAttr === attr)) continue;\n\n        if(!attr || attr._noTemplating ||\n            attr.valType === 'data_array' ||\n            (attr.arrayOk && Array.isArray(child))\n        ) {\n            continue;\n        }\n\n        if(!attr.valType && isPlainObject(child)) {\n            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);\n        }\n        else if(attr._isLinkedToArray && Array.isArray(child)) {\n            var dfltDone = false;\n            var namedIndex = 0;\n            var usedNames = {};\n            for(var i = 0; i < child.length; i++) {\n                var item = child[i];\n                if(isPlainObject(item)) {\n                    var name = item.name;\n                    if(name) {\n                        if(!usedNames[name]) {\n                            // named array items: allow all attributes except data arrays\n                            walkStyleKeys(item, templateOut, getAttributeInfo,\n                                getNextPath(child, namedIndex, nextPath),\n                                getNextPath(child, namedIndex, nextBasePath));\n                            namedIndex++;\n                            usedNames[name] = 1;\n                        }\n                    }\n                    else if(!dfltDone) {\n                        var dfltKey = Template.arrayDefaultKey(key);\n                        var dfltPath = getNextPath(parent, dfltKey, path);\n\n                        // getAttributeInfo will fail if we try to use dfltKey directly.\n                        // Instead put this item into the next array element, then\n                        // pull it out and move it to dfltKey.\n                        var pathInArray = getNextPath(child, namedIndex, nextPath);\n                        walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray,\n                            getNextPath(child, namedIndex, nextBasePath));\n                        var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);\n                        var dfltProp = Lib.nestedProperty(templateOut, dfltPath);\n                        dfltProp.set(itemPropInArray.get());\n                        itemPropInArray.set(null);\n\n                        dfltDone = true;\n                    }\n                }\n            }\n        }\n        else {\n            var templateProp = Lib.nestedProperty(templateOut, nextPath);\n            templateProp.set(child);\n        }\n    }\n}\n\nfunction getLayoutInfo(layout, path) {\n    return PlotSchema.getLayoutValObject(\n        layout, Lib.nestedProperty({}, path).parts\n    );\n}\n\nfunction getTraceInfo(trace, path) {\n    return PlotSchema.getTraceValObject(\n        trace, Lib.nestedProperty({}, path).parts\n    );\n}\n\nfunction getNextPath(parent, key, path) {\n    var nextPath;\n    if(!path) nextPath = key;\n    else if(Array.isArray(parent)) nextPath = path + '[' + key + ']';\n    else nextPath = path + '.' + key;\n\n    return nextPath;\n}\n\n/**\n * validateTemplate: Test for consistency between the given figure and\n * a template, either already included in the figure or given separately.\n * Note that not every issue we identify here is necessarily a problem,\n * it depends on what you're using the template for.\n *\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\n *     to test the template against\n * @param {Optional(object)} template: the template, with its own {data, layout},\n *     to test. If omitted, we will look for a template already attached as the\n *     plot's `layout.template` attribute.\n *\n * @returns {array} array of error objects each containing:\n *  - {string} code\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\n *  - {string} msg\n *      a full readable description of the issue.\n */\nexports.validateTemplate = function(figureIn, template) {\n    var figure = Lib.extendDeep({}, {\n        _context: dfltConfig,\n        data: figureIn.data,\n        layout: figureIn.layout\n    });\n    var layout = figure.layout || {};\n    if(!isPlainObject(template)) template = layout.template || {};\n    var layoutTemplate = template.layout;\n    var dataTemplate = template.data;\n    var errorList = [];\n\n    figure.layout = layout;\n    figure.layout.template = template;\n    Plots.supplyDefaults(figure);\n\n    var fullLayout = figure._fullLayout;\n    var fullData = figure._fullData;\n\n    var layoutPaths = {};\n    function crawlLayoutForContainers(obj, paths) {\n        for(var key in obj) {\n            if(key.charAt(0) !== '_' && isPlainObject(obj[key])) {\n                var baseKey = getBaseKey(key);\n                var nextPaths = [];\n                var i;\n                for(i = 0; i < paths.length; i++) {\n                    nextPaths.push(getNextPath(obj, key, paths[i]));\n                    if(baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));\n                }\n                for(i = 0; i < nextPaths.length; i++) {\n                    layoutPaths[nextPaths[i]] = 1;\n                }\n                crawlLayoutForContainers(obj[key], nextPaths);\n            }\n        }\n    }\n\n    function crawlLayoutTemplateForContainers(obj, path) {\n        for(var key in obj) {\n            if(key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {\n                var nextPath = getNextPath(obj, key, path);\n                if(layoutPaths[nextPath]) {\n                    crawlLayoutTemplateForContainers(obj[key], nextPath);\n                }\n                else {\n                    errorList.push({code: 'unused', path: nextPath});\n                }\n            }\n        }\n    }\n\n    if(!isPlainObject(layoutTemplate)) {\n        errorList.push({code: 'layout'});\n    }\n    else {\n        crawlLayoutForContainers(fullLayout, ['layout']);\n        crawlLayoutTemplateForContainers(layoutTemplate, 'layout');\n    }\n\n    if(!isPlainObject(dataTemplate)) {\n        errorList.push({code: 'data'});\n    }\n    else {\n        var typeCount = {};\n        var traceType;\n        for(var i = 0; i < fullData.length; i++) {\n            var fullTrace = fullData[i];\n            traceType = fullTrace.type;\n            typeCount[traceType] = (typeCount[traceType] || 0) + 1;\n            if(!fullTrace._fullInput._template) {\n                // this takes care of the case of traceType in the data but not\n                // the template\n                errorList.push({\n                    code: 'missing',\n                    index: fullTrace._fullInput.index,\n                    traceType: traceType\n                });\n            }\n        }\n        for(traceType in dataTemplate) {\n            var templateCount = dataTemplate[traceType].length;\n            var dataCount = typeCount[traceType] || 0;\n            if(templateCount > dataCount) {\n                errorList.push({\n                    code: 'unused',\n                    traceType: traceType,\n                    templateCount: templateCount,\n                    dataCount: dataCount\n                });\n            }\n            else if(dataCount > templateCount) {\n                errorList.push({\n                    code: 'reused',\n                    traceType: traceType,\n                    templateCount: templateCount,\n                    dataCount: dataCount\n                });\n            }\n        }\n    }\n\n    // _template: false is when someone tried to modify an array item\n    // but there was no template with matching name\n    function crawlForMissingTemplates(obj, path) {\n        for(var key in obj) {\n            if(key.charAt(0) === '_') continue;\n            var val = obj[key];\n            var nextPath = getNextPath(obj, key, path);\n            if(isPlainObject(val)) {\n                if(Array.isArray(obj) && val._template === false && val.templateitemname) {\n                    errorList.push({\n                        code: 'missing',\n                        path: nextPath,\n                        templateitemname: val.templateitemname\n                    });\n                }\n                crawlForMissingTemplates(val, nextPath);\n            }\n            else if(Array.isArray(val) && hasPlainObject(val)) {\n                crawlForMissingTemplates(val, nextPath);\n            }\n        }\n    }\n    crawlForMissingTemplates({data: fullData, layout: fullLayout}, '');\n\n    if(errorList.length) return errorList.map(format);\n};\n\nfunction hasPlainObject(arr) {\n    for(var i = 0; i < arr.length; i++) {\n        if(isPlainObject(arr[i])) return true;\n    }\n}\n\nfunction format(opts) {\n    var msg;\n    switch(opts.code) {\n        case 'data':\n            msg = 'The template has no key data.';\n            break;\n        case 'layout':\n            msg = 'The template has no key layout.';\n            break;\n        case 'missing':\n            if(opts.path) {\n                msg = 'There are no templates for item ' + opts.path +\n                    ' with name ' + opts.templateitemname;\n            }\n            else {\n                msg = 'There are no templates for trace ' + opts.index +\n                    ', of type ' + opts.traceType + '.';\n            }\n            break;\n        case 'unused':\n            if(opts.path) {\n                msg = 'The template item at ' + opts.path +\n                    ' was not used in constructing the plot.';\n            }\n            else if(opts.dataCount) {\n                msg = 'Some of the templates of type ' + opts.traceType +\n                    ' were not used. The template has ' + opts.templateCount +\n                    ' traces, the data only has ' + opts.dataCount +\n                    ' of this type.';\n            }\n            else {\n                msg = 'The template has ' + opts.templateCount +\n                    ' traces of type ' + opts.traceType +\n                    ' but there are none in the data.';\n            }\n            break;\n        case 'reused':\n            msg = 'Some of the templates of type ' + opts.traceType +\n                ' were used more than once. The template has ' +\n                opts.templateCount + ' traces, the data has ' +\n                opts.dataCount + ' of this type.';\n            break;\n    }\n    opts.msg = msg;\n\n    return opts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}