{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar polygon = require('../../lib/polygon');\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\nvar style = require('./style').style;\nmodule.exports = function plot(gd, geo, calcData) {\n  for (var i = 0; i < calcData.length; i++) {\n    calcGeoJSON(calcData[i], geo.topojson);\n  }\n  var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');\n  Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function (calcTrace) {\n    var sel = calcTrace[0].node3 = d3.select(this);\n    var paths = sel.selectAll('path.choroplethlocation').data(Lib.identity);\n    paths.enter().append('path').classed('choroplethlocation', true);\n    paths.exit().remove();\n\n    // call style here within topojson request callback\n    style(gd, calcTrace);\n  });\n};\nfunction calcGeoJSON(calcTrace, topojson) {\n  var trace = calcTrace[0].trace;\n  var len = calcTrace.length;\n  var features = getTopojsonFeatures(trace, topojson);\n  for (var i = 0; i < len; i++) {\n    var calcPt = calcTrace[i];\n    var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n    if (!feature) {\n      calcPt.geojson = null;\n      continue;\n    }\n    calcPt.geojson = feature;\n    calcPt.ct = feature.properties.ct;\n    calcPt.index = i;\n    calcPt._polygons = feature2polygons(feature);\n  }\n}\nfunction feature2polygons(feature) {\n  var geometry = feature.geometry;\n  var coords = geometry.coordinates;\n  var loc = feature.id;\n  var polygons = [];\n  var appendPolygon, j, k, m;\n  function doesCrossAntiMerdian(pts) {\n    for (var l = 0; l < pts.length - 1; l++) {\n      if (pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n    }\n    return null;\n  }\n  if (loc === 'RUS' || loc === 'FJI') {\n    // Russia and Fiji have landmasses that cross the antimeridian,\n    // we need to add +360 to their longitude coordinates, so that\n    // polygon 'contains' doesn't get confused when crossing the antimeridian.\n    //\n    // Note that other countries have polygons on either side of the antimeridian\n    // (e.g. some Aleutian island for the USA), but those don't confuse\n    // the 'contains' method; these are skipped here.\n    appendPolygon = function appendPolygon(_pts) {\n      var pts;\n      if (doesCrossAntiMerdian(_pts) === null) {\n        pts = _pts;\n      } else {\n        pts = new Array(_pts.length);\n        for (m = 0; m < _pts.length; m++) {\n          // do nut mutate calcdata[i][j].geojson !!\n          pts[m] = [_pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0], _pts[m][1]];\n        }\n      }\n      polygons.push(polygon.tester(pts));\n    };\n  } else if (loc === 'ATA') {\n    // Antarctica has a landmass that wraps around every longitudes which\n    // confuses the 'contains' methods.\n    appendPolygon = function appendPolygon(pts) {\n      var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n      // polygon that do not cross anti-meridian need no special handling\n      if (crossAntiMeridianIndex === null) {\n        return polygons.push(polygon.tester(pts));\n      }\n\n      // stitch polygon by adding pt over South Pole,\n      // so that it covers the projected region covers all latitudes\n      //\n      // Note that the algorithm below only works for polygons that\n      // start and end on longitude -180 (like the ones built by\n      // https://github.com/etpinard/sane-topojson).\n      var stitch = new Array(pts.length + 1);\n      var si = 0;\n      for (m = 0; m < pts.length; m++) {\n        if (m > crossAntiMeridianIndex) {\n          stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n        } else if (m === crossAntiMeridianIndex) {\n          stitch[si++] = pts[m];\n          stitch[si++] = [pts[m][0], -90];\n        } else {\n          stitch[si++] = pts[m];\n        }\n      }\n\n      // polygon.tester by default appends pt[0] to the points list,\n      // we must remove it here, to avoid a jump in longitude from 180 to -180,\n      // that would confuse the 'contains' method\n      var tester = polygon.tester(stitch);\n      tester.pts.pop();\n      polygons.push(tester);\n    };\n  } else {\n    // otherwise using same array ref is fine\n    appendPolygon = function appendPolygon(pts) {\n      polygons.push(polygon.tester(pts));\n    };\n  }\n  switch (geometry.type) {\n    case 'MultiPolygon':\n      for (j = 0; j < coords.length; j++) {\n        for (k = 0; k < coords[j].length; k++) {\n          appendPolygon(coords[j][k]);\n        }\n      }\n      break;\n    case 'Polygon':\n      for (j = 0; j < coords.length; j++) {\n        appendPolygon(coords[j]);\n      }\n      break;\n  }\n  return polygons;\n}","map":{"version":3,"names":["d3","require","Lib","polygon","getTopojsonFeatures","locationToFeature","style","module","exports","plot","gd","geo","calcData","i","length","calcGeoJSON","topojson","choroplethLayer","layers","backplot","select","makeTraceGroups","each","calcTrace","sel","node3","paths","selectAll","data","identity","enter","append","classed","exit","remove","trace","len","features","calcPt","feature","locationmode","loc","geojson","ct","properties","index","_polygons","feature2polygons","geometry","coords","coordinates","id","polygons","appendPolygon","j","k","m","doesCrossAntiMerdian","pts","l","_pts","Array","push","tester","crossAntiMeridianIndex","stitch","si","pop","type"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/choropleth/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar polygon = require('../../lib/polygon');\n\nvar getTopojsonFeatures = require('../../lib/topojson_utils').getTopojsonFeatures;\nvar locationToFeature = require('../../lib/geo_location_utils').locationToFeature;\nvar style = require('./style').style;\n\nmodule.exports = function plot(gd, geo, calcData) {\n    for(var i = 0; i < calcData.length; i++) {\n        calcGeoJSON(calcData[i], geo.topojson);\n    }\n\n    var choroplethLayer = geo.layers.backplot.select('.choroplethlayer');\n    Lib.makeTraceGroups(choroplethLayer, calcData, 'trace choropleth').each(function(calcTrace) {\n        var sel = calcTrace[0].node3 = d3.select(this);\n\n        var paths = sel.selectAll('path.choroplethlocation')\n            .data(Lib.identity);\n\n        paths.enter().append('path')\n            .classed('choroplethlocation', true);\n\n        paths.exit().remove();\n\n        // call style here within topojson request callback\n        style(gd, calcTrace);\n    });\n};\n\nfunction calcGeoJSON(calcTrace, topojson) {\n    var trace = calcTrace[0].trace;\n    var len = calcTrace.length;\n    var features = getTopojsonFeatures(trace, topojson);\n\n    for(var i = 0; i < len; i++) {\n        var calcPt = calcTrace[i];\n        var feature = locationToFeature(trace.locationmode, calcPt.loc, features);\n\n        if(!feature) {\n            calcPt.geojson = null;\n            continue;\n        }\n\n\n        calcPt.geojson = feature;\n        calcPt.ct = feature.properties.ct;\n        calcPt.index = i;\n        calcPt._polygons = feature2polygons(feature);\n    }\n}\n\nfunction feature2polygons(feature) {\n    var geometry = feature.geometry;\n    var coords = geometry.coordinates;\n    var loc = feature.id;\n\n    var polygons = [];\n    var appendPolygon, j, k, m;\n\n    function doesCrossAntiMerdian(pts) {\n        for(var l = 0; l < pts.length - 1; l++) {\n            if(pts[l][0] > 0 && pts[l + 1][0] < 0) return l;\n        }\n        return null;\n    }\n\n    if(loc === 'RUS' || loc === 'FJI') {\n        // Russia and Fiji have landmasses that cross the antimeridian,\n        // we need to add +360 to their longitude coordinates, so that\n        // polygon 'contains' doesn't get confused when crossing the antimeridian.\n        //\n        // Note that other countries have polygons on either side of the antimeridian\n        // (e.g. some Aleutian island for the USA), but those don't confuse\n        // the 'contains' method; these are skipped here.\n        appendPolygon = function(_pts) {\n            var pts;\n\n            if(doesCrossAntiMerdian(_pts) === null) {\n                pts = _pts;\n            } else {\n                pts = new Array(_pts.length);\n                for(m = 0; m < _pts.length; m++) {\n                    // do nut mutate calcdata[i][j].geojson !!\n                    pts[m] = [\n                        _pts[m][0] < 0 ? _pts[m][0] + 360 : _pts[m][0],\n                        _pts[m][1]\n                    ];\n                }\n            }\n\n            polygons.push(polygon.tester(pts));\n        };\n    } else if(loc === 'ATA') {\n        // Antarctica has a landmass that wraps around every longitudes which\n        // confuses the 'contains' methods.\n        appendPolygon = function(pts) {\n            var crossAntiMeridianIndex = doesCrossAntiMerdian(pts);\n\n            // polygon that do not cross anti-meridian need no special handling\n            if(crossAntiMeridianIndex === null) {\n                return polygons.push(polygon.tester(pts));\n            }\n\n            // stitch polygon by adding pt over South Pole,\n            // so that it covers the projected region covers all latitudes\n            //\n            // Note that the algorithm below only works for polygons that\n            // start and end on longitude -180 (like the ones built by\n            // https://github.com/etpinard/sane-topojson).\n            var stitch = new Array(pts.length + 1);\n            var si = 0;\n\n            for(m = 0; m < pts.length; m++) {\n                if(m > crossAntiMeridianIndex) {\n                    stitch[si++] = [pts[m][0] + 360, pts[m][1]];\n                } else if(m === crossAntiMeridianIndex) {\n                    stitch[si++] = pts[m];\n                    stitch[si++] = [pts[m][0], -90];\n                } else {\n                    stitch[si++] = pts[m];\n                }\n            }\n\n            // polygon.tester by default appends pt[0] to the points list,\n            // we must remove it here, to avoid a jump in longitude from 180 to -180,\n            // that would confuse the 'contains' method\n            var tester = polygon.tester(stitch);\n            tester.pts.pop();\n            polygons.push(tester);\n        };\n    } else {\n        // otherwise using same array ref is fine\n        appendPolygon = function(pts) {\n            polygons.push(polygon.tester(pts));\n        };\n    }\n\n    switch(geometry.type) {\n        case 'MultiPolygon':\n            for(j = 0; j < coords.length; j++) {\n                for(k = 0; k < coords[j].length; k++) {\n                    appendPolygon(coords[j][k]);\n                }\n            }\n            break;\n        case 'Polygon':\n            for(j = 0; j < coords.length; j++) {\n                appendPolygon(coords[j]);\n            }\n            break;\n    }\n\n    return polygons;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}