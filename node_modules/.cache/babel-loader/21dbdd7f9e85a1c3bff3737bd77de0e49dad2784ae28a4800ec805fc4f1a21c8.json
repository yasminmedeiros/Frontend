{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../registry');\n\n/*\n * containerArrayMatch: does this attribute string point into a\n * layout container array?\n *\n * @param {String} astr: an attribute string, like *annotations[2].text*\n *\n * @returns {Object | false} Returns false if `astr` doesn't match a container\n *  array. If it does, returns:\n *     {array: {String}, index: {Number}, property: {String}}\n *  ie the attribute string for the array, the index within the array (or ''\n *  if the whole array) and the property within that (or '' if the whole array\n *  or the whole object)\n */\nmodule.exports = function containerArrayMatch(astr) {\n  var rootContainers = Registry.layoutArrayContainers;\n  var regexpContainers = Registry.layoutArrayRegexes;\n  var rootPart = astr.split('[')[0];\n  var arrayStr;\n  var match;\n\n  // look for regexp matches first, because they may be nested inside root matches\n  // eg updatemenus[i].buttons is nested inside updatemenus\n  for (var i = 0; i < regexpContainers.length; i++) {\n    match = astr.match(regexpContainers[i]);\n    if (match && match.index === 0) {\n      arrayStr = match[0];\n      break;\n    }\n  }\n\n  // now look for root matches\n  if (!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];\n  if (!arrayStr) return false;\n  var tail = astr.substr(arrayStr.length);\n  if (!tail) return {\n    array: arrayStr,\n    index: '',\n    property: ''\n  };\n  match = tail.match(/^\\[(0|[1-9][0-9]*)\\](\\.(.+))?$/);\n  if (!match) return false;\n  return {\n    array: arrayStr,\n    index: Number(match[1]),\n    property: match[3] || ''\n  };\n};","map":{"version":3,"names":["Registry","require","module","exports","containerArrayMatch","astr","rootContainers","layoutArrayContainers","regexpContainers","layoutArrayRegexes","rootPart","split","arrayStr","match","i","length","index","indexOf","tail","substr","array","property","Number"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plot_api/container_array_match.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../registry');\n\n/*\n * containerArrayMatch: does this attribute string point into a\n * layout container array?\n *\n * @param {String} astr: an attribute string, like *annotations[2].text*\n *\n * @returns {Object | false} Returns false if `astr` doesn't match a container\n *  array. If it does, returns:\n *     {array: {String}, index: {Number}, property: {String}}\n *  ie the attribute string for the array, the index within the array (or ''\n *  if the whole array) and the property within that (or '' if the whole array\n *  or the whole object)\n */\nmodule.exports = function containerArrayMatch(astr) {\n    var rootContainers = Registry.layoutArrayContainers;\n    var regexpContainers = Registry.layoutArrayRegexes;\n    var rootPart = astr.split('[')[0];\n    var arrayStr;\n    var match;\n\n    // look for regexp matches first, because they may be nested inside root matches\n    // eg updatemenus[i].buttons is nested inside updatemenus\n    for(var i = 0; i < regexpContainers.length; i++) {\n        match = astr.match(regexpContainers[i]);\n        if(match && match.index === 0) {\n            arrayStr = match[0];\n            break;\n        }\n    }\n\n    // now look for root matches\n    if(!arrayStr) arrayStr = rootContainers[rootContainers.indexOf(rootPart)];\n\n    if(!arrayStr) return false;\n\n    var tail = astr.substr(arrayStr.length);\n    if(!tail) return {array: arrayStr, index: '', property: ''};\n\n    match = tail.match(/^\\[(0|[1-9][0-9]*)\\](\\.(.+))?$/);\n    if(!match) return false;\n\n    return {array: arrayStr, index: Number(match[1]), property: match[3] || ''};\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,YAAY;;AAEZ,IAAIA,QAAQ,GAAGC,OAAO,CAAC,aAAa,CAAC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,SAASC,mBAAmB,CAACC,IAAI,EAAE;EAChD,IAAIC,cAAc,GAAGN,QAAQ,CAACO,qBAAqB;EACnD,IAAIC,gBAAgB,GAAGR,QAAQ,CAACS,kBAAkB;EAClD,IAAIC,QAAQ,GAAGL,IAAI,CAACM,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EACjC,IAAIC,QAAQ;EACZ,IAAIC,KAAK;;EAET;EACA;EACA,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,gBAAgB,CAACO,MAAM,EAAED,CAAC,EAAE,EAAE;IAC7CD,KAAK,GAAGR,IAAI,CAACQ,KAAK,CAACL,gBAAgB,CAACM,CAAC,CAAC,CAAC;IACvC,IAAGD,KAAK,IAAIA,KAAK,CAACG,KAAK,KAAK,CAAC,EAAE;MAC3BJ,QAAQ,GAAGC,KAAK,CAAC,CAAC,CAAC;MACnB;IACJ;EACJ;;EAEA;EACA,IAAG,CAACD,QAAQ,EAAEA,QAAQ,GAAGN,cAAc,CAACA,cAAc,CAACW,OAAO,CAACP,QAAQ,CAAC,CAAC;EAEzE,IAAG,CAACE,QAAQ,EAAE,OAAO,KAAK;EAE1B,IAAIM,IAAI,GAAGb,IAAI,CAACc,MAAM,CAACP,QAAQ,CAACG,MAAM,CAAC;EACvC,IAAG,CAACG,IAAI,EAAE,OAAO;IAACE,KAAK,EAAER,QAAQ;IAAEI,KAAK,EAAE,EAAE;IAAEK,QAAQ,EAAE;EAAE,CAAC;EAE3DR,KAAK,GAAGK,IAAI,CAACL,KAAK,CAAC,gCAAgC,CAAC;EACpD,IAAG,CAACA,KAAK,EAAE,OAAO,KAAK;EAEvB,OAAO;IAACO,KAAK,EAAER,QAAQ;IAAEI,KAAK,EAAEM,MAAM,CAACT,KAAK,CAAC,CAAC,CAAC,CAAC;IAAEQ,QAAQ,EAAER,KAAK,CAAC,CAAC,CAAC,IAAI;EAAE,CAAC;AAC/E,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}