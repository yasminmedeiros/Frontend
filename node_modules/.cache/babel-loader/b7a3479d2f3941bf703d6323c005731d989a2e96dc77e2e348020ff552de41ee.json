{"ast":null,"code":"\"use strict\";\n\nvar esprima = require(\"esprima\");\nvar uniq = require(\"uniq\");\nvar PREFIX_COUNTER = 0;\nfunction CompiledArgument(name, lvalue, rvalue) {\n  this.name = name;\n  this.lvalue = lvalue;\n  this.rvalue = rvalue;\n  this.count = 0;\n}\nfunction CompiledRoutine(body, args, thisVars, localVars) {\n  this.body = body;\n  this.args = args;\n  this.thisVars = thisVars;\n  this.localVars = localVars;\n}\nfunction isGlobal(identifier) {\n  if (identifier === \"eval\") {\n    throw new Error(\"cwise-parser: eval() not allowed\");\n  }\n  if (typeof window !== \"undefined\") {\n    return identifier in window;\n  } else if (typeof global !== \"undefined\") {\n    return identifier in global;\n  } else if (typeof self !== \"undefined\") {\n    return identifier in self;\n  } else {\n    return false;\n  }\n}\nfunction getArgNames(ast) {\n  var params = ast.body[0].expression.callee.params;\n  var names = new Array(params.length);\n  for (var i = 0; i < params.length; ++i) {\n    names[i] = params[i].name;\n  }\n  return names;\n}\nfunction preprocess(func) {\n  var src = [\"(\", func, \")()\"].join(\"\");\n  var ast = esprima.parse(src, {\n    range: true\n  });\n\n  //Compute new prefix\n  var prefix = \"_inline_\" + PREFIX_COUNTER++ + \"_\";\n\n  //Parse out arguments\n  var argNames = getArgNames(ast);\n  var compiledArgs = new Array(argNames.length);\n  for (var i = 0; i < argNames.length; ++i) {\n    compiledArgs[i] = new CompiledArgument([prefix, \"arg\", i, \"_\"].join(\"\"), false, false);\n  }\n\n  //Create temporary data structure for source rewriting\n  var exploded = new Array(src.length);\n  for (var i = 0, n = src.length; i < n; ++i) {\n    exploded[i] = src.charAt(i);\n  }\n\n  //Local variables\n  var localVars = [];\n  var thisVars = [];\n  var computedThis = false;\n\n  //Retrieves a local variable\n  function createLocal(id) {\n    var nstr = prefix + id.replace(/\\_/g, \"__\");\n    localVars.push(nstr);\n    return nstr;\n  }\n\n  //Creates a this variable\n  function createThisVar(id) {\n    var nstr = \"this_\" + id.replace(/\\_/g, \"__\");\n    thisVars.push(nstr);\n    return nstr;\n  }\n\n  //Rewrites an ast node\n  function rewrite(node, nstr) {\n    var lo = node.range[0],\n      hi = node.range[1];\n    for (var i = lo + 1; i < hi; ++i) {\n      exploded[i] = \"\";\n    }\n    exploded[lo] = nstr;\n  }\n\n  //Remove any underscores\n  function escapeString(str) {\n    return \"'\" + str.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"\\'\") + \"'\";\n  }\n\n  //Returns the source of an identifier\n  function source(node) {\n    return exploded.slice(node.range[0], node.range[1]).join(\"\");\n  }\n\n  //Computes the usage of a node\n  var LVALUE = 1;\n  var RVALUE = 2;\n  function getUsage(node) {\n    if (node.parent.type === \"AssignmentExpression\") {\n      if (node.parent.left === node) {\n        if (node.parent.operator === \"=\") {\n          return LVALUE;\n        }\n        return LVALUE | RVALUE;\n      }\n    }\n    if (node.parent.type === \"UpdateExpression\") {\n      return LVALUE | RVALUE;\n    }\n    return RVALUE;\n  }\n\n  //Handle visiting a node\n  (function visit(node, parent) {\n    node.parent = parent;\n    if (node.type === \"MemberExpression\") {\n      //Handle member expression\n      if (node.computed) {\n        visit(node.object, node);\n        visit(node.property, node);\n      } else if (node.object.type === \"ThisExpression\") {\n        rewrite(node, createThisVar(node.property.name));\n      } else {\n        visit(node.object, node);\n      }\n    } else if (node.type === \"ThisExpression\") {\n      throw new Error(\"cwise-parser: Computed this is not allowed\");\n    } else if (node.type === \"Identifier\") {\n      //Handle identifier\n      var name = node.name;\n      var argNo = argNames.indexOf(name);\n      if (argNo >= 0) {\n        var carg = compiledArgs[argNo];\n        var usage = getUsage(node);\n        if (usage & LVALUE) {\n          carg.lvalue = true;\n        }\n        if (usage & RVALUE) {\n          carg.rvalue = true;\n        }\n        ++carg.count;\n        rewrite(node, carg.name);\n      } else if (isGlobal(name)) {\n        //Don't rewrite globals\n      } else {\n        rewrite(node, createLocal(name));\n      }\n    } else if (node.type === \"Literal\") {\n      if (typeof node.value === \"string\") {\n        rewrite(node, escapeString(node.value));\n      }\n    } else if (node.type === \"WithStatement\") {\n      throw new Error(\"cwise-parser: with() statements not allowed\");\n    } else {\n      //Visit all children\n      var keys = Object.keys(node);\n      for (var i = 0, n = keys.length; i < n; ++i) {\n        if (keys[i] === \"parent\") {\n          continue;\n        }\n        var value = node[keys[i]];\n        if (value) {\n          if (value instanceof Array) {\n            for (var j = 0; j < value.length; ++j) {\n              if (value[j] && typeof value[j].type === \"string\") {\n                visit(value[j], node);\n              }\n            }\n          } else if (typeof value.type === \"string\") {\n            visit(value, node);\n          }\n        }\n      }\n    }\n  })(ast.body[0].expression.callee.body, undefined);\n\n  //Remove duplicate variables\n  uniq(localVars);\n  uniq(thisVars);\n\n  //Return body\n  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars);\n  return routine;\n}\nmodule.exports = preprocess;","map":{"version":3,"names":["esprima","require","uniq","PREFIX_COUNTER","CompiledArgument","name","lvalue","rvalue","count","CompiledRoutine","body","args","thisVars","localVars","isGlobal","identifier","Error","window","global","self","getArgNames","ast","params","expression","callee","names","Array","length","i","preprocess","func","src","join","parse","range","prefix","argNames","compiledArgs","exploded","n","charAt","computedThis","createLocal","id","nstr","replace","push","createThisVar","rewrite","node","lo","hi","escapeString","str","source","slice","LVALUE","RVALUE","getUsage","parent","type","left","operator","visit","computed","object","property","argNo","indexOf","carg","usage","value","keys","Object","j","undefined","routine","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/cwise-parser/index.js"],"sourcesContent":["\"use strict\"\n\nvar esprima = require(\"esprima\")\nvar uniq = require(\"uniq\")\n\nvar PREFIX_COUNTER = 0\n\nfunction CompiledArgument(name, lvalue, rvalue) {\n  this.name = name\n  this.lvalue = lvalue\n  this.rvalue = rvalue\n  this.count = 0\n}\n\nfunction CompiledRoutine(body, args, thisVars, localVars) {\n  this.body = body\n  this.args = args\n  this.thisVars = thisVars\n  this.localVars = localVars\n}\n\nfunction isGlobal(identifier) {\n  if(identifier === \"eval\") {\n    throw new Error(\"cwise-parser: eval() not allowed\")\n  }\n  if(typeof window !== \"undefined\") {\n    return identifier in window\n  } else if(typeof global !== \"undefined\") {\n    return identifier in global\n  } else if(typeof self !== \"undefined\") {\n    return identifier in self\n  } else {\n    return false\n  }\n}\n\nfunction getArgNames(ast) {\n  var params = ast.body[0].expression.callee.params\n  var names = new Array(params.length)\n  for(var i=0; i<params.length; ++i) {\n    names[i] = params[i].name\n  }\n  return names\n}\n\nfunction preprocess(func) {\n  var src = [\"(\", func, \")()\"].join(\"\")\n  var ast = esprima.parse(src, { range: true })\n  \n  //Compute new prefix\n  var prefix = \"_inline_\" + (PREFIX_COUNTER++) + \"_\"\n  \n  //Parse out arguments\n  var argNames = getArgNames(ast)\n  var compiledArgs = new Array(argNames.length)\n  for(var i=0; i<argNames.length; ++i) {\n    compiledArgs[i] = new CompiledArgument([prefix, \"arg\", i, \"_\"].join(\"\"), false, false)\n  }\n  \n  //Create temporary data structure for source rewriting\n  var exploded = new Array(src.length)\n  for(var i=0, n=src.length; i<n; ++i) {\n    exploded[i] = src.charAt(i)\n  }\n  \n  //Local variables\n  var localVars = []\n  var thisVars = []\n  var computedThis = false\n  \n  //Retrieves a local variable\n  function createLocal(id) {\n    var nstr = prefix + id.replace(/\\_/g, \"__\")\n    localVars.push(nstr)\n    return nstr\n  }\n  \n  //Creates a this variable\n  function createThisVar(id) {\n    var nstr = \"this_\" + id.replace(/\\_/g, \"__\")\n    thisVars.push(nstr)\n    return nstr\n  }\n  \n  //Rewrites an ast node\n  function rewrite(node, nstr) {\n    var lo = node.range[0], hi = node.range[1]\n    for(var i=lo+1; i<hi; ++i) {\n      exploded[i] = \"\"\n    }\n    exploded[lo] = nstr\n  }\n  \n  //Remove any underscores\n  function escapeString(str) {\n    return \"'\"+(str.replace(/\\_/g, \"\\\\_\").replace(/\\'/g, \"\\'\"))+\"'\"\n  }\n  \n  //Returns the source of an identifier\n  function source(node) {\n    return exploded.slice(node.range[0], node.range[1]).join(\"\")\n  }\n  \n  //Computes the usage of a node\n  var LVALUE = 1\n  var RVALUE = 2\n  function getUsage(node) {\n    if(node.parent.type === \"AssignmentExpression\") {\n      if(node.parent.left === node) {\n        if(node.parent.operator === \"=\") {\n          return LVALUE\n        }\n        return LVALUE|RVALUE\n      }\n    }\n    if(node.parent.type === \"UpdateExpression\") {\n      return LVALUE|RVALUE\n    }\n    return RVALUE\n  }\n  \n  //Handle visiting a node\n  (function visit(node, parent) {\n    node.parent = parent\n    if(node.type === \"MemberExpression\") {\n      //Handle member expression\n      if(node.computed) {\n        visit(node.object, node)\n        visit(node.property, node)\n      } else if(node.object.type === \"ThisExpression\") {\n        rewrite(node, createThisVar(node.property.name))\n      } else {\n        visit(node.object, node)\n      }\n    } else if(node.type === \"ThisExpression\") {\n      throw new Error(\"cwise-parser: Computed this is not allowed\")\n    } else if(node.type === \"Identifier\") {\n      //Handle identifier\n      var name = node.name\n      var argNo = argNames.indexOf(name)\n      if(argNo >= 0) {\n        var carg = compiledArgs[argNo]\n        var usage = getUsage(node)\n        if(usage & LVALUE) {\n          carg.lvalue = true\n        }\n        if(usage & RVALUE) {\n          carg.rvalue = true\n        }\n        ++carg.count\n        rewrite(node, carg.name)\n      } else if(isGlobal(name)) {\n        //Don't rewrite globals\n      } else {\n        rewrite(node, createLocal(name))\n      }\n    } else if(node.type === \"Literal\") {\n      if(typeof node.value === \"string\") {\n        rewrite(node, escapeString(node.value))\n      }\n    } else if(node.type === \"WithStatement\") {\n      throw new Error(\"cwise-parser: with() statements not allowed\")\n    } else {\n      //Visit all children\n      var keys = Object.keys(node)\n      for(var i=0, n=keys.length; i<n; ++i) {\n        if(keys[i] === \"parent\") {\n          continue\n        }\n        var value = node[keys[i]]\n        if(value) {\n          if(value instanceof Array) {\n            for(var j=0; j<value.length; ++j) {\n              if(value[j] && typeof value[j].type === \"string\") {\n                visit(value[j], node)\n              }\n            }\n          } else if(typeof value.type === \"string\") {\n            visit(value, node)\n          }\n        }\n      }\n    }\n  })(ast.body[0].expression.callee.body, undefined)\n  \n  //Remove duplicate variables\n  uniq(localVars)\n  uniq(thisVars)\n  \n  //Return body\n  var routine = new CompiledRoutine(source(ast.body[0].expression.callee.body), compiledArgs, thisVars, localVars)\n  return routine\n}\n\nmodule.exports = preprocess"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}