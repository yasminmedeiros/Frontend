{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar id2name = require('./axis_ids').id2name;\nmodule.exports = function handleConstraintDefaults(containerIn, containerOut, coerce, allAxisIds, layoutOut) {\n  var constraintGroups = layoutOut._axisConstraintGroups;\n  var thisID = containerOut._id;\n  var letter = thisID.charAt(0);\n  if (containerOut.fixedrange) return;\n\n  // coerce the constraint mechanics even if this axis has no scaleanchor\n  // because it may be the anchor of another axis.\n  coerce('constrain');\n  Lib.coerce(containerIn, containerOut, {\n    constraintoward: {\n      valType: 'enumerated',\n      values: letter === 'x' ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n      dflt: letter === 'x' ? 'center' : 'middle'\n    }\n  }, 'constraintoward');\n  if (!containerIn.scaleanchor) return;\n  var constraintOpts = getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut);\n  var scaleanchor = Lib.coerce(containerIn, containerOut, {\n    scaleanchor: {\n      valType: 'enumerated',\n      values: constraintOpts.linkableAxes\n    }\n  }, 'scaleanchor');\n  if (scaleanchor) {\n    var scaleratio = coerce('scaleratio');\n    // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n    // but that seems hacky. Better way to say \"must be a positive number\"?\n    // Of course if you use several super-tiny values you could eventually\n    // force a product of these to zero and all hell would break loose...\n    // Likewise with super-huge values.\n    if (!scaleratio) scaleratio = containerOut.scaleratio = 1;\n    updateConstraintGroups(constraintGroups, constraintOpts.thisGroup, thisID, scaleanchor, scaleratio);\n  } else if (allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n    Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' + containerIn.scaleanchor + '\" to avoid either an infinite loop ' + 'and possibly inconsistent scaleratios, or because the target' + 'axis has fixed range.');\n  }\n};\nfunction getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut) {\n  // If this axis is already part of a constraint group, we can't\n  // scaleanchor any other axis in that group, or we'd make a loop.\n  // Filter allAxisIds to enforce this, also matching axis types.\n\n  var thisType = layoutOut[id2name(thisID)].type;\n  var i, j, idj, axj;\n  var linkableAxes = [];\n  for (j = 0; j < allAxisIds.length; j++) {\n    idj = allAxisIds[j];\n    if (idj === thisID) continue;\n    axj = layoutOut[id2name(idj)];\n    if (axj.type === thisType && !axj.fixedrange) linkableAxes.push(idj);\n  }\n  for (i = 0; i < constraintGroups.length; i++) {\n    if (constraintGroups[i][thisID]) {\n      var thisGroup = constraintGroups[i];\n      var linkableAxesNoLoops = [];\n      for (j = 0; j < linkableAxes.length; j++) {\n        idj = linkableAxes[j];\n        if (!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n      }\n      return {\n        linkableAxes: linkableAxesNoLoops,\n        thisGroup: thisGroup\n      };\n    }\n  }\n  return {\n    linkableAxes: linkableAxes,\n    thisGroup: null\n  };\n}\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n  var i, j, groupi, keyj, thisGroupIndex;\n  if (thisGroup === null) {\n    thisGroup = {};\n    thisGroup[thisID] = 1;\n    thisGroupIndex = constraintGroups.length;\n    constraintGroups.push(thisGroup);\n  } else {\n    thisGroupIndex = constraintGroups.indexOf(thisGroup);\n  }\n  var thisGroupKeys = Object.keys(thisGroup);\n\n  // we know that this axis isn't in any other groups, but we don't know\n  // about the scaleanchor axis. If it is, we need to merge the groups.\n  for (i = 0; i < constraintGroups.length; i++) {\n    groupi = constraintGroups[i];\n    if (i !== thisGroupIndex && groupi[scaleanchor]) {\n      var baseScale = groupi[scaleanchor];\n      for (j = 0; j < thisGroupKeys.length; j++) {\n        keyj = thisGroupKeys[j];\n        groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n      }\n      constraintGroups.splice(thisGroupIndex, 1);\n      return;\n    }\n  }\n\n  // otherwise, we insert the new scaleanchor axis as the base scale (1)\n  // in its group, and scale the rest of the group to it\n  if (scaleratio !== 1) {\n    for (j = 0; j < thisGroupKeys.length; j++) {\n      thisGroup[thisGroupKeys[j]] *= scaleratio;\n    }\n  }\n  thisGroup[scaleanchor] = 1;\n}","map":{"version":3,"names":["Lib","require","id2name","module","exports","handleConstraintDefaults","containerIn","containerOut","coerce","allAxisIds","layoutOut","constraintGroups","_axisConstraintGroups","thisID","_id","letter","charAt","fixedrange","constraintoward","valType","values","dflt","scaleanchor","constraintOpts","getConstraintOpts","linkableAxes","scaleratio","updateConstraintGroups","thisGroup","indexOf","warn","_name","thisType","type","i","j","idj","axj","length","push","linkableAxesNoLoops","groupi","keyj","thisGroupIndex","thisGroupKeys","Object","keys","baseScale","splice"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/plots/cartesian/constraint_defaults.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar id2name = require('./axis_ids').id2name;\n\n\nmodule.exports = function handleConstraintDefaults(containerIn, containerOut, coerce, allAxisIds, layoutOut) {\n    var constraintGroups = layoutOut._axisConstraintGroups;\n    var thisID = containerOut._id;\n    var letter = thisID.charAt(0);\n\n    if(containerOut.fixedrange) return;\n\n    // coerce the constraint mechanics even if this axis has no scaleanchor\n    // because it may be the anchor of another axis.\n    coerce('constrain');\n    Lib.coerce(containerIn, containerOut, {\n        constraintoward: {\n            valType: 'enumerated',\n            values: letter === 'x' ? ['left', 'center', 'right'] : ['bottom', 'middle', 'top'],\n            dflt: letter === 'x' ? 'center' : 'middle'\n        }\n    }, 'constraintoward');\n\n    if(!containerIn.scaleanchor) return;\n\n    var constraintOpts = getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut);\n\n    var scaleanchor = Lib.coerce(containerIn, containerOut, {\n        scaleanchor: {\n            valType: 'enumerated',\n            values: constraintOpts.linkableAxes\n        }\n    }, 'scaleanchor');\n\n    if(scaleanchor) {\n        var scaleratio = coerce('scaleratio');\n        // TODO: I suppose I could do attribute.min: Number.MIN_VALUE to avoid zero,\n        // but that seems hacky. Better way to say \"must be a positive number\"?\n        // Of course if you use several super-tiny values you could eventually\n        // force a product of these to zero and all hell would break loose...\n        // Likewise with super-huge values.\n        if(!scaleratio) scaleratio = containerOut.scaleratio = 1;\n\n        updateConstraintGroups(constraintGroups, constraintOpts.thisGroup,\n            thisID, scaleanchor, scaleratio);\n    }\n    else if(allAxisIds.indexOf(containerIn.scaleanchor) !== -1) {\n        Lib.warn('ignored ' + containerOut._name + '.scaleanchor: \"' +\n            containerIn.scaleanchor + '\" to avoid either an infinite loop ' +\n            'and possibly inconsistent scaleratios, or because the target' +\n            'axis has fixed range.');\n    }\n};\n\nfunction getConstraintOpts(constraintGroups, thisID, allAxisIds, layoutOut) {\n    // If this axis is already part of a constraint group, we can't\n    // scaleanchor any other axis in that group, or we'd make a loop.\n    // Filter allAxisIds to enforce this, also matching axis types.\n\n    var thisType = layoutOut[id2name(thisID)].type;\n\n    var i, j, idj, axj;\n\n    var linkableAxes = [];\n    for(j = 0; j < allAxisIds.length; j++) {\n        idj = allAxisIds[j];\n        if(idj === thisID) continue;\n\n        axj = layoutOut[id2name(idj)];\n        if(axj.type === thisType && !axj.fixedrange) linkableAxes.push(idj);\n    }\n\n    for(i = 0; i < constraintGroups.length; i++) {\n        if(constraintGroups[i][thisID]) {\n            var thisGroup = constraintGroups[i];\n\n            var linkableAxesNoLoops = [];\n            for(j = 0; j < linkableAxes.length; j++) {\n                idj = linkableAxes[j];\n                if(!thisGroup[idj]) linkableAxesNoLoops.push(idj);\n            }\n            return {linkableAxes: linkableAxesNoLoops, thisGroup: thisGroup};\n        }\n    }\n\n    return {linkableAxes: linkableAxes, thisGroup: null};\n}\n\n\n/*\n * Add this axis to the axis constraint groups, which is the collection\n * of axes that are all constrained together on scale.\n *\n * constraintGroups: a list of objects. each object is\n * {axis_id: scale_within_group}, where scale_within_group is\n * only important relative to the rest of the group, and defines\n * the relative scales between all axes in the group\n *\n * thisGroup: the group the current axis is already in\n * thisID: the id if the current axis\n * scaleanchor: the id of the axis to scale it with\n * scaleratio: the ratio of this axis to the scaleanchor axis\n */\nfunction updateConstraintGroups(constraintGroups, thisGroup, thisID, scaleanchor, scaleratio) {\n    var i, j, groupi, keyj, thisGroupIndex;\n\n    if(thisGroup === null) {\n        thisGroup = {};\n        thisGroup[thisID] = 1;\n        thisGroupIndex = constraintGroups.length;\n        constraintGroups.push(thisGroup);\n    }\n    else {\n        thisGroupIndex = constraintGroups.indexOf(thisGroup);\n    }\n\n    var thisGroupKeys = Object.keys(thisGroup);\n\n    // we know that this axis isn't in any other groups, but we don't know\n    // about the scaleanchor axis. If it is, we need to merge the groups.\n    for(i = 0; i < constraintGroups.length; i++) {\n        groupi = constraintGroups[i];\n        if(i !== thisGroupIndex && groupi[scaleanchor]) {\n            var baseScale = groupi[scaleanchor];\n            for(j = 0; j < thisGroupKeys.length; j++) {\n                keyj = thisGroupKeys[j];\n                groupi[keyj] = baseScale * scaleratio * thisGroup[keyj];\n            }\n            constraintGroups.splice(thisGroupIndex, 1);\n            return;\n        }\n    }\n\n    // otherwise, we insert the new scaleanchor axis as the base scale (1)\n    // in its group, and scale the rest of the group to it\n    if(scaleratio !== 1) {\n        for(j = 0; j < thisGroupKeys.length; j++) {\n            thisGroup[thisGroupKeys[j]] *= scaleratio;\n        }\n    }\n    thisGroup[scaleanchor] = 1;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}