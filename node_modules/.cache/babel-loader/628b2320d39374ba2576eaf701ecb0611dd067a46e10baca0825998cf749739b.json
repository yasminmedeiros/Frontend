{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar polygonTester = require('../../lib/polygon').tester;\nvar findIndexOfMin = Lib.findIndexOfMin;\nvar isAngleInsideSector = Lib.isAngleInsideSector;\nvar angleDelta = Lib.angleDelta;\nvar angleDist = Lib.angleDist;\n\n/**\n * is pt (r,a) inside polygon made up vertices at angles 'vangles'\n * inside a given polar sector\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {boolean}\n */\nfunction isPtInsidePolygon(r, a, rBnds, aBnds, vangles) {\n  if (!isAngleInsideSector(a, aBnds)) return false;\n  var r0, r1;\n  if (rBnds[0] < rBnds[1]) {\n    r0 = rBnds[0];\n    r1 = rBnds[1];\n  } else {\n    r0 = rBnds[1];\n    r1 = rBnds[0];\n  }\n  var polygonIn = polygonTester(makePolygon(r0, aBnds[0], aBnds[1], vangles));\n  var polygonOut = polygonTester(makePolygon(r1, aBnds[0], aBnds[1], vangles));\n  var xy = [r * Math.cos(a), r * Math.sin(a)];\n  return polygonOut.contains(xy) && !polygonIn.contains(xy);\n}\n\n// find intersection of 'v0' <-> 'v1' edge with a ray at angle 'a'\n// (i.e. a line that starts from the origin at angle 'a')\n// given an (xp,yp) pair on the 'v0' <-> 'v1' line\n// (N.B. 'v0' and 'v1' are angles in radians)\nfunction findIntersectionXY(v0, v1, a, xpyp) {\n  var xstar, ystar;\n  var xp = xpyp[0];\n  var yp = xpyp[1];\n  var dsin = clampTiny(Math.sin(v1) - Math.sin(v0));\n  var dcos = clampTiny(Math.cos(v1) - Math.cos(v0));\n  var tanA = Math.tan(a);\n  var cotanA = clampTiny(1 / tanA);\n  var m = dsin / dcos;\n  var b = yp - m * xp;\n  if (cotanA) {\n    if (dsin && dcos) {\n      // given\n      //  g(x) := v0 -> v1 line = m*x + b\n      //  h(x) := ray at angle 'a' = m*x = tanA*x\n      // solve g(xstar) = h(xstar)\n      xstar = b / (tanA - m);\n      ystar = tanA * xstar;\n    } else if (dcos) {\n      // horizontal v0 -> v1\n      xstar = yp * cotanA;\n      ystar = yp;\n    } else {\n      // vertical v0 -> v1\n      xstar = xp;\n      ystar = xp * tanA;\n    }\n  } else {\n    // vertical ray\n    if (dsin && dcos) {\n      xstar = 0;\n      ystar = b;\n    } else if (dcos) {\n      xstar = 0;\n      ystar = yp;\n    } else {\n      // does this case exists?\n      xstar = ystar = NaN;\n    }\n  }\n  return [xstar, ystar];\n}\n\n// solves l^2 = (f(x)^2 - yp)^2 + (x - xp)^2\n// rearranged into 0 = a*x^2 + b * x + c\n//\n// where f(x) = m*x + t + yp\n// and   (x0, x1) = (-b +/- del) / (2*a)\nfunction findXYatLength(l, m, xp, yp) {\n  var t = -m * xp;\n  var a = m * m + 1;\n  var b = 2 * (m * t - xp);\n  var c = t * t + xp * xp - l * l;\n  var del = Math.sqrt(b * b - 4 * a * c);\n  var x0 = (-b + del) / (2 * a);\n  var x1 = (-b - del) / (2 * a);\n  return [[x0, m * x0 + t + yp], [x1, m * x1 + t + yp]];\n}\nfunction makeRegularPolygon(r, vangles) {\n  var len = vangles.length;\n  var vertices = new Array(len + 1);\n  var i;\n  for (i = 0; i < len; i++) {\n    var va = vangles[i];\n    vertices[i] = [r * Math.cos(va), r * Math.sin(va)];\n  }\n  vertices[i] = vertices[0].slice();\n  return vertices;\n}\nfunction makeClippedPolygon(r, a0, a1, vangles) {\n  var len = vangles.length;\n  var vertices = [];\n  var i, j;\n  function a2xy(a) {\n    return [r * Math.cos(a), r * Math.sin(a)];\n  }\n  function findXY(va0, va1, s) {\n    return findIntersectionXY(va0, va1, s, a2xy(va0));\n  }\n  function cycleIndex(ind) {\n    return Lib.mod(ind, len);\n  }\n  function isInside(v) {\n    return isAngleInsideSector(v, [a0, a1]);\n  }\n\n  // find index in sector closest to a0\n  // use it to find intersection of v[i0] <-> v[i0-1] edge with sector radius\n  var i0 = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a0) : Infinity;\n  });\n  var xy0 = findXY(vangles[i0], vangles[cycleIndex(i0 - 1)], a0);\n  vertices.push(xy0);\n\n  // fill in in-sector vertices\n  for (i = i0, j = 0; j < len; i++, j++) {\n    var va = vangles[cycleIndex(i)];\n    if (!isInside(va)) break;\n    vertices.push(a2xy(va));\n  }\n\n  // find index in sector closest to a1,\n  // use it to find intersection of v[iN] <-> v[iN+1] edge with sector radius\n  var iN = findIndexOfMin(vangles, function (v) {\n    return isInside(v) ? angleDist(v, a1) : Infinity;\n  });\n  var xyN = findXY(vangles[iN], vangles[cycleIndex(iN + 1)], a1);\n  vertices.push(xyN);\n  vertices.push([0, 0]);\n  vertices.push(vertices[0].slice());\n  return vertices;\n}\nfunction makePolygon(r, a0, a1, vangles) {\n  return Lib.isFullCircle([a0, a1]) ? makeRegularPolygon(r, vangles) : makeClippedPolygon(r, a0, a1, vangles);\n}\nfunction findPolygonOffset(r, a0, a1, vangles) {\n  var minX = Infinity;\n  var minY = Infinity;\n  var vertices = makePolygon(r, a0, a1, vangles);\n  for (var i = 0; i < vertices.length; i++) {\n    var v = vertices[i];\n    minX = Math.min(minX, v[0]);\n    minY = Math.min(minY, -v[1]);\n  }\n  return [minX, minY];\n}\n\n/**\n * find vertex angles (in 'vangles') the enclose angle 'a'\n *\n * @param {number} a : angle in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {2-item array}\n */\nfunction findEnclosingVertexAngles(a, vangles) {\n  var minFn = function minFn(v) {\n    var adelta = angleDelta(v, a);\n    return adelta > 0 ? adelta : Infinity;\n  };\n  var i0 = findIndexOfMin(vangles, minFn);\n  var i1 = Lib.mod(i0 + 1, vangles.length);\n  return [vangles[i0], vangles[i1]];\n}\n\n// to more easily catch 'almost zero' numbers in if-else blocks\nfunction clampTiny(v) {\n  return Math.abs(v) > 1e-10 ? v : 0;\n}\nfunction transformForSVG(pts0, cx, cy) {\n  cx = cx || 0;\n  cy = cy || 0;\n  var len = pts0.length;\n  var pts1 = new Array(len);\n  for (var i = 0; i < len; i++) {\n    var pt = pts0[i];\n    pts1[i] = [cx + pt[0], cy - pt[1]];\n  }\n  return pts1;\n}\n\n/**\n * path polygon\n *\n * @param {number} r : polygon 'radius'\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygon(r, a0, a1, vangles, cx, cy) {\n  var poly = makePolygon(r, a0, a1, vangles);\n  return 'M' + transformForSVG(poly, cx, cy).join('L');\n}\n\n/**\n * path a polygon 'annulus'\n * i.e. a polygon with a concentric hole\n *\n * N.B. this routine uses the evenodd SVG rule\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygonAnnulus(r0, r1, a0, a1, vangles, cx, cy) {\n  var rStart, rEnd;\n  if (r0 < r1) {\n    rStart = r0;\n    rEnd = r1;\n  } else {\n    rStart = r1;\n    rEnd = r0;\n  }\n  var inner = transformForSVG(makePolygon(rStart, a0, a1, vangles), cx, cy);\n  var outer = transformForSVG(makePolygon(rEnd, a0, a1, vangles), cx, cy);\n  return 'M' + outer.reverse().join('L') + 'M' + inner.join('L');\n}\nmodule.exports = {\n  isPtInsidePolygon: isPtInsidePolygon,\n  findPolygonOffset: findPolygonOffset,\n  findEnclosingVertexAngles: findEnclosingVertexAngles,\n  findIntersectionXY: findIntersectionXY,\n  findXYatLength: findXYatLength,\n  clampTiny: clampTiny,\n  pathPolygon: pathPolygon,\n  pathPolygonAnnulus: pathPolygonAnnulus\n};","map":{"version":3,"names":["Lib","require","polygonTester","tester","findIndexOfMin","isAngleInsideSector","angleDelta","angleDist","isPtInsidePolygon","r","a","rBnds","aBnds","vangles","r0","r1","polygonIn","makePolygon","polygonOut","xy","Math","cos","sin","contains","findIntersectionXY","v0","v1","xpyp","xstar","ystar","xp","yp","dsin","clampTiny","dcos","tanA","tan","cotanA","m","b","NaN","findXYatLength","l","t","c","del","sqrt","x0","x1","makeRegularPolygon","len","length","vertices","Array","i","va","slice","makeClippedPolygon","a0","a1","j","a2xy","findXY","va0","va1","s","cycleIndex","ind","mod","isInside","v","i0","Infinity","xy0","push","iN","xyN","isFullCircle","findPolygonOffset","minX","minY","min","findEnclosingVertexAngles","minFn","adelta","i1","abs","transformForSVG","pts0","cx","cy","pts1","pt","pathPolygon","poly","join","pathPolygonAnnulus","rStart","rEnd","inner","outer","reverse","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plots/polar/helpers.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar polygonTester = require('../../lib/polygon').tester;\n\nvar findIndexOfMin = Lib.findIndexOfMin;\nvar isAngleInsideSector = Lib.isAngleInsideSector;\nvar angleDelta = Lib.angleDelta;\nvar angleDist = Lib.angleDist;\n\n/**\n * is pt (r,a) inside polygon made up vertices at angles 'vangles'\n * inside a given polar sector\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {boolean}\n */\nfunction isPtInsidePolygon(r, a, rBnds, aBnds, vangles) {\n    if(!isAngleInsideSector(a, aBnds)) return false;\n\n    var r0, r1;\n\n    if(rBnds[0] < rBnds[1]) {\n        r0 = rBnds[0];\n        r1 = rBnds[1];\n    } else {\n        r0 = rBnds[1];\n        r1 = rBnds[0];\n    }\n\n    var polygonIn = polygonTester(makePolygon(r0, aBnds[0], aBnds[1], vangles));\n    var polygonOut = polygonTester(makePolygon(r1, aBnds[0], aBnds[1], vangles));\n    var xy = [r * Math.cos(a), r * Math.sin(a)];\n    return polygonOut.contains(xy) && !polygonIn.contains(xy);\n}\n\n// find intersection of 'v0' <-> 'v1' edge with a ray at angle 'a'\n// (i.e. a line that starts from the origin at angle 'a')\n// given an (xp,yp) pair on the 'v0' <-> 'v1' line\n// (N.B. 'v0' and 'v1' are angles in radians)\nfunction findIntersectionXY(v0, v1, a, xpyp) {\n    var xstar, ystar;\n\n    var xp = xpyp[0];\n    var yp = xpyp[1];\n    var dsin = clampTiny(Math.sin(v1) - Math.sin(v0));\n    var dcos = clampTiny(Math.cos(v1) - Math.cos(v0));\n    var tanA = Math.tan(a);\n    var cotanA = clampTiny(1 / tanA);\n    var m = dsin / dcos;\n    var b = yp - m * xp;\n\n    if(cotanA) {\n        if(dsin && dcos) {\n            // given\n            //  g(x) := v0 -> v1 line = m*x + b\n            //  h(x) := ray at angle 'a' = m*x = tanA*x\n            // solve g(xstar) = h(xstar)\n            xstar = b / (tanA - m);\n            ystar = tanA * xstar;\n        } else if(dcos) {\n            // horizontal v0 -> v1\n            xstar = yp * cotanA;\n            ystar = yp;\n        } else {\n            // vertical v0 -> v1\n            xstar = xp;\n            ystar = xp * tanA;\n        }\n    } else {\n        // vertical ray\n        if(dsin && dcos) {\n            xstar = 0;\n            ystar = b;\n        } else if(dcos) {\n            xstar = 0;\n            ystar = yp;\n        } else {\n            // does this case exists?\n            xstar = ystar = NaN;\n        }\n    }\n\n    return [xstar, ystar];\n}\n\n// solves l^2 = (f(x)^2 - yp)^2 + (x - xp)^2\n// rearranged into 0 = a*x^2 + b * x + c\n//\n// where f(x) = m*x + t + yp\n// and   (x0, x1) = (-b +/- del) / (2*a)\nfunction findXYatLength(l, m, xp, yp) {\n    var t = -m * xp;\n    var a = m * m + 1;\n    var b = 2 * (m * t - xp);\n    var c = t * t + xp * xp - l * l;\n    var del = Math.sqrt(b * b - 4 * a * c);\n    var x0 = (-b + del) / (2 * a);\n    var x1 = (-b - del) / (2 * a);\n    return [\n        [x0, m * x0 + t + yp],\n        [x1, m * x1 + t + yp]\n    ];\n}\n\nfunction makeRegularPolygon(r, vangles) {\n    var len = vangles.length;\n    var vertices = new Array(len + 1);\n    var i;\n    for(i = 0; i < len; i++) {\n        var va = vangles[i];\n        vertices[i] = [r * Math.cos(va), r * Math.sin(va)];\n    }\n    vertices[i] = vertices[0].slice();\n    return vertices;\n}\n\nfunction makeClippedPolygon(r, a0, a1, vangles) {\n    var len = vangles.length;\n    var vertices = [];\n    var i, j;\n\n    function a2xy(a) {\n        return [r * Math.cos(a), r * Math.sin(a)];\n    }\n\n    function findXY(va0, va1, s) {\n        return findIntersectionXY(va0, va1, s, a2xy(va0));\n    }\n\n    function cycleIndex(ind) {\n        return Lib.mod(ind, len);\n    }\n\n    function isInside(v) {\n        return isAngleInsideSector(v, [a0, a1]);\n    }\n\n    // find index in sector closest to a0\n    // use it to find intersection of v[i0] <-> v[i0-1] edge with sector radius\n    var i0 = findIndexOfMin(vangles, function(v) {\n        return isInside(v) ? angleDist(v, a0) : Infinity;\n    });\n    var xy0 = findXY(vangles[i0], vangles[cycleIndex(i0 - 1)], a0);\n    vertices.push(xy0);\n\n    // fill in in-sector vertices\n    for(i = i0, j = 0; j < len; i++, j++) {\n        var va = vangles[cycleIndex(i)];\n        if(!isInside(va)) break;\n        vertices.push(a2xy(va));\n    }\n\n    // find index in sector closest to a1,\n    // use it to find intersection of v[iN] <-> v[iN+1] edge with sector radius\n    var iN = findIndexOfMin(vangles, function(v) {\n        return isInside(v) ? angleDist(v, a1) : Infinity;\n    });\n    var xyN = findXY(vangles[iN], vangles[cycleIndex(iN + 1)], a1);\n    vertices.push(xyN);\n\n    vertices.push([0, 0]);\n    vertices.push(vertices[0].slice());\n\n    return vertices;\n}\n\nfunction makePolygon(r, a0, a1, vangles) {\n    return Lib.isFullCircle([a0, a1]) ?\n        makeRegularPolygon(r, vangles) :\n        makeClippedPolygon(r, a0, a1, vangles);\n}\n\nfunction findPolygonOffset(r, a0, a1, vangles) {\n    var minX = Infinity;\n    var minY = Infinity;\n    var vertices = makePolygon(r, a0, a1, vangles);\n\n    for(var i = 0; i < vertices.length; i++) {\n        var v = vertices[i];\n        minX = Math.min(minX, v[0]);\n        minY = Math.min(minY, -v[1]);\n    }\n    return [minX, minY];\n}\n\n/**\n * find vertex angles (in 'vangles') the enclose angle 'a'\n *\n * @param {number} a : angle in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @return {2-item array}\n */\nfunction findEnclosingVertexAngles(a, vangles) {\n    var minFn = function(v) {\n        var adelta = angleDelta(v, a);\n        return adelta > 0 ? adelta : Infinity;\n    };\n    var i0 = findIndexOfMin(vangles, minFn);\n    var i1 = Lib.mod(i0 + 1, vangles.length);\n    return [vangles[i0], vangles[i1]];\n}\n\n// to more easily catch 'almost zero' numbers in if-else blocks\nfunction clampTiny(v) {\n    return Math.abs(v) > 1e-10 ? v : 0;\n}\n\nfunction transformForSVG(pts0, cx, cy) {\n    cx = cx || 0;\n    cy = cy || 0;\n\n    var len = pts0.length;\n    var pts1 = new Array(len);\n\n    for(var i = 0; i < len; i++) {\n        var pt = pts0[i];\n        pts1[i] = [cx + pt[0], cy - pt[1]];\n    }\n    return pts1;\n}\n\n/**\n * path polygon\n *\n * @param {number} r : polygon 'radius'\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygon(r, a0, a1, vangles, cx, cy) {\n    var poly = makePolygon(r, a0, a1, vangles);\n    return 'M' + transformForSVG(poly, cx, cy).join('L');\n}\n\n/**\n * path a polygon 'annulus'\n * i.e. a polygon with a concentric hole\n *\n * N.B. this routine uses the evenodd SVG rule\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {array} vangles : angles of polygon vertices in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n *\n */\nfunction pathPolygonAnnulus(r0, r1, a0, a1, vangles, cx, cy) {\n    var rStart, rEnd;\n\n    if(r0 < r1) {\n        rStart = r0;\n        rEnd = r1;\n    } else {\n        rStart = r1;\n        rEnd = r0;\n    }\n\n    var inner = transformForSVG(makePolygon(rStart, a0, a1, vangles), cx, cy);\n    var outer = transformForSVG(makePolygon(rEnd, a0, a1, vangles), cx, cy);\n    return 'M' + outer.reverse().join('L') + 'M' + inner.join('L');\n}\n\nmodule.exports = {\n    isPtInsidePolygon: isPtInsidePolygon,\n    findPolygonOffset: findPolygonOffset,\n    findEnclosingVertexAngles: findEnclosingVertexAngles,\n    findIntersectionXY: findIntersectionXY,\n    findXYatLength: findXYatLength,\n    clampTiny: clampTiny,\n    pathPolygon: pathPolygon,\n    pathPolygonAnnulus: pathPolygonAnnulus\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}