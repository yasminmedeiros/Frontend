{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\n  var stackOpts = layout._scatterStackOpts;\n  var stackGroup = coerce('stackgroup');\n  if (stackGroup) {\n    // use independent stacking options per subplot\n    var subplot = traceOut.xaxis + traceOut.yaxis;\n    var subplotStackOpts = stackOpts[subplot];\n    if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\n    var groupOpts = subplotStackOpts[stackGroup];\n    var firstTrace = false;\n    if (groupOpts) {\n      groupOpts.traces.push(traceOut);\n    } else {\n      groupOpts = subplotStackOpts[stackGroup] = {\n        // keep track of trace indices for use during stacking calculations\n        // this will be filled in during `calc` and used during `crossTraceCalc`\n        // so it's OK if we don't recreate it during a non-calc edit\n        traceIndices: [],\n        // Hold on to the whole set of prior traces\n        // First one is most important, so we can clear defaults\n        // there if we find explicit values only in later traces.\n        // We're only going to *use* the values stored in groupOpts,\n        // but for the editor and validate we want things self-consistent\n        // The full set of traces is used only to fix `fill` default if\n        // we find `orientation: 'h'` beyond the first trace\n        traces: [traceOut]\n      };\n      firstTrace = true;\n    }\n    // TODO: how is this going to work with groupby transforms?\n    // in principle it should be OK I guess, as long as explicit group styles\n    // don't override explicit base-trace styles?\n\n    var dflts = {\n      orientation: traceOut.x && !traceOut.y ? 'h' : 'v'\n    };\n    for (var i = 0; i < perStackAttrs.length; i++) {\n      var attr = perStackAttrs[i];\n      var attrFound = attr + 'Found';\n      if (!groupOpts[attrFound]) {\n        var traceHasAttr = traceIn[attr] !== undefined;\n        var isOrientation = attr === 'orientation';\n        if (traceHasAttr || firstTrace) {\n          groupOpts[attr] = coerce(attr, dflts[attr]);\n          if (isOrientation) {\n            groupOpts.fillDflt = groupOpts[attr] === 'h' ? 'tonextx' : 'tonexty';\n          }\n          if (traceHasAttr) {\n            // Note: this will show a value here even if it's invalid\n            // in which case it will revert to default.\n            groupOpts[attrFound] = true;\n\n            // Note: only one trace in the stack will get a _fullData\n            // entry for a given stack-wide attribute. If no traces\n            // (or the first trace) specify that attribute, the\n            // first trace will get it. If the first trace does NOT\n            // specify it but some later trace does, then it gets\n            // removed from the first trace and only included in the\n            // one that specified it. This is mostly important for\n            // editors (that want to see the full values to know\n            // what settings are available) and Plotly.react diffing.\n            // Editors may want to use fullLayout._scatterStackOpts\n            // directly and make these settings available from all\n            // traces in the stack... then set the new value into\n            // the first trace, and clear all later traces.\n            if (!firstTrace) {\n              delete groupOpts.traces[0][attr];\n\n              // orientation can affect default fill of previous traces\n              if (isOrientation) {\n                for (var j = 0; j < groupOpts.traces.length - 1; j++) {\n                  var trace2 = groupOpts.traces[j];\n                  if (trace2._input.fill !== trace2.fill) {\n                    trace2.fill = groupOpts.fillDflt;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return groupOpts;\n  }\n};","map":{"version":3,"names":["perStackAttrs","module","exports","handleStackDefaults","traceIn","traceOut","layout","coerce","stackOpts","_scatterStackOpts","stackGroup","subplot","xaxis","yaxis","subplotStackOpts","groupOpts","firstTrace","traces","push","traceIndices","dflts","orientation","x","y","i","length","attr","attrFound","traceHasAttr","undefined","isOrientation","fillDflt","j","trace2","_input","fill"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/scatter/stack_defaults.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\n\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\n    var stackOpts = layout._scatterStackOpts;\n\n    var stackGroup = coerce('stackgroup');\n    if(stackGroup) {\n        // use independent stacking options per subplot\n        var subplot = traceOut.xaxis + traceOut.yaxis;\n        var subplotStackOpts = stackOpts[subplot];\n        if(!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\n\n        var groupOpts = subplotStackOpts[stackGroup];\n        var firstTrace = false;\n        if(groupOpts) {\n            groupOpts.traces.push(traceOut);\n        }\n        else {\n            groupOpts = subplotStackOpts[stackGroup] = {\n                // keep track of trace indices for use during stacking calculations\n                // this will be filled in during `calc` and used during `crossTraceCalc`\n                // so it's OK if we don't recreate it during a non-calc edit\n                traceIndices: [],\n                // Hold on to the whole set of prior traces\n                // First one is most important, so we can clear defaults\n                // there if we find explicit values only in later traces.\n                // We're only going to *use* the values stored in groupOpts,\n                // but for the editor and validate we want things self-consistent\n                // The full set of traces is used only to fix `fill` default if\n                // we find `orientation: 'h'` beyond the first trace\n                traces: [traceOut]\n            };\n            firstTrace = true;\n        }\n        // TODO: how is this going to work with groupby transforms?\n        // in principle it should be OK I guess, as long as explicit group styles\n        // don't override explicit base-trace styles?\n\n        var dflts = {\n            orientation: (traceOut.x && !traceOut.y) ? 'h' : 'v'\n        };\n\n        for(var i = 0; i < perStackAttrs.length; i++) {\n            var attr = perStackAttrs[i];\n            var attrFound = attr + 'Found';\n            if(!groupOpts[attrFound]) {\n                var traceHasAttr = traceIn[attr] !== undefined;\n                var isOrientation = attr === 'orientation';\n                if(traceHasAttr || firstTrace) {\n                    groupOpts[attr] = coerce(attr, dflts[attr]);\n\n                    if(isOrientation) {\n                        groupOpts.fillDflt = groupOpts[attr] === 'h' ?\n                            'tonextx' : 'tonexty';\n                    }\n\n                    if(traceHasAttr) {\n                        // Note: this will show a value here even if it's invalid\n                        // in which case it will revert to default.\n                        groupOpts[attrFound] = true;\n\n                        // Note: only one trace in the stack will get a _fullData\n                        // entry for a given stack-wide attribute. If no traces\n                        // (or the first trace) specify that attribute, the\n                        // first trace will get it. If the first trace does NOT\n                        // specify it but some later trace does, then it gets\n                        // removed from the first trace and only included in the\n                        // one that specified it. This is mostly important for\n                        // editors (that want to see the full values to know\n                        // what settings are available) and Plotly.react diffing.\n                        // Editors may want to use fullLayout._scatterStackOpts\n                        // directly and make these settings available from all\n                        // traces in the stack... then set the new value into\n                        // the first trace, and clear all later traces.\n                        if(!firstTrace) {\n                            delete groupOpts.traces[0][attr];\n\n                            // orientation can affect default fill of previous traces\n                            if(isOrientation) {\n                                for(var j = 0; j < groupOpts.traces.length - 1; j++) {\n                                    var trace2 = groupOpts.traces[j];\n                                    if(trace2._input.fill !== trace2.fill) {\n                                        trace2.fill = groupOpts.fillDflt;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return groupOpts;\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}