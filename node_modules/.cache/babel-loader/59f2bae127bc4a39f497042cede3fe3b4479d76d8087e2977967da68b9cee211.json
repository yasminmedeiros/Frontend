{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar glslify = require('glslify');\nvar vertexShaderSource = glslify('./shaders/vertex.glsl');\nvar contextShaderSource = glslify('./shaders/context_vertex.glsl');\nvar pickVertexShaderSource = glslify('./shaders/pick_vertex.glsl');\nvar fragmentShaderSource = glslify('./shaders/fragment.glsl');\nvar Lib = require('../../lib');\n\n// don't change; otherwise near/far plane lines are lost\nvar depthLimitEpsilon = 1e-6;\n// just enough buffer for an extra bit at single-precision floating point\n// which on [0, 1] is 6e-8 (1/2^24)\nvar filterEpsilon = 1e-7;\n\n// precision of multiselect is the full range divided into this many parts\nvar maskHeight = 2048;\nvar gpuDimensionCount = 64;\nvar sectionVertexCount = 2;\nvar vec4NumberCount = 4;\nvar bitsPerByte = 8;\nvar channelCount = gpuDimensionCount / bitsPerByte; // == 8 bytes needed to have 64 bits\n\nvar contextColor = [119, 119, 119]; // middle gray to not drawn the focus; looks good on a black or white background\n\nvar dummyPixel = new Uint8Array(4);\nvar pickPixel = new Uint8Array(4);\nvar paletteTextureConfig = {\n  shape: [256, 1],\n  format: 'rgba',\n  type: 'uint8',\n  mag: 'nearest',\n  min: 'nearest'\n};\nfunction ensureDraw(regl) {\n  regl.read({\n    x: 0,\n    y: 0,\n    width: 1,\n    height: 1,\n    data: dummyPixel\n  });\n}\nfunction clear(regl, x, y, width, height) {\n  var gl = regl._gl;\n  gl.enable(gl.SCISSOR_TEST);\n  gl.scissor(x, y, width, height);\n  regl.clear({\n    color: [0, 0, 0, 0],\n    depth: 1\n  }); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n  var rafKey = item.key;\n  function render(blockNumber) {\n    var count;\n    count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n    item.offset = sectionVertexCount * blockNumber * blockLineCount;\n    item.count = sectionVertexCount * count;\n    if (blockNumber === 0) {\n      // stop drawing possibly stale glyphs before clearing\n      window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n      delete renderState.currentRafs[rafKey];\n      clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n    }\n    if (renderState.clearOnly) {\n      return;\n    }\n    glAes(item);\n    if (blockNumber * blockLineCount + count < sampleCount) {\n      renderState.currentRafs[rafKey] = window.requestAnimationFrame(function () {\n        render(blockNumber + 1);\n      });\n    }\n    renderState.drawCompleted = false;\n  }\n  if (!renderState.drawCompleted) {\n    ensureDraw(regl);\n    renderState.drawCompleted = true;\n  }\n\n  // start with rendering item 0; recursion handles the rest\n  render(0);\n}\nfunction adjustDepth(d) {\n  // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n  // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n  // near or the far plane.\n  return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\nfunction palette(unitToColor, context, opacity) {\n  var result = [];\n  for (var j = 0; j < 256; j++) {\n    var c = unitToColor(j / 255);\n    result.push((context ? contextColor : c).concat(opacity));\n  }\n  return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(j, rgbIndex) {\n  return (j >>> 8 * rgbIndex) % 256 / 255;\n}\nfunction makePoints(sampleCount, dimensions, color) {\n  var dimensionCount = dimensions.length;\n  var points = [];\n  for (var j = 0; j < sampleCount; j++) {\n    for (var i = 0; i < gpuDimensionCount; i++) {\n      points.push(i < dimensionCount ? dimensions[i].paddedUnitValues[j] : i === gpuDimensionCount - 1 ? adjustDepth(color[j]) : i >= gpuDimensionCount - 4 ? calcPickColor(j, gpuDimensionCount - 2 - i) : 0.5);\n    }\n  }\n  return points;\n}\nfunction makeVecAttr(sampleCount, points, vecIndex) {\n  var i, j, k;\n  var pointPairs = [];\n  for (j = 0; j < sampleCount; j++) {\n    for (k = 0; k < sectionVertexCount; k++) {\n      for (i = 0; i < vec4NumberCount; i++) {\n        pointPairs.push(points[j * gpuDimensionCount + vecIndex * vec4NumberCount + i]);\n        if (vecIndex * vec4NumberCount + i === gpuDimensionCount - 1 && k % 2 === 0) {\n          pointPairs[pointPairs.length - 1] *= -1;\n        }\n      }\n    }\n  }\n  return pointPairs;\n}\nfunction setAttributes(attributes, sampleCount, points) {\n  for (var i = 0; i < 16; i++) {\n    attributes['p' + i.toString(16)](makeVecAttr(sampleCount, points, i));\n  }\n}\nfunction emptyAttributes(regl) {\n  var attributes = {};\n  for (var i = 0; i < 16; i++) {\n    attributes['p' + i.toString(16)] = regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array(0)\n    });\n  }\n  return attributes;\n}\nmodule.exports = function (canvasGL, d) {\n  // context & pick describe which canvas we're talking about - won't change with new data\n  var context = d.context;\n  var pick = d.pick;\n  var regl = d.regl;\n  var renderState = {\n    currentRafs: {},\n    drawCompleted: true,\n    clearOnly: false\n  };\n\n  // state to be set by update and used later\n  var model;\n  var vm;\n  var initialDims;\n  var sampleCount;\n  var attributes = emptyAttributes(regl);\n  var maskTexture;\n  var paletteTexture = regl.texture(paletteTextureConfig);\n  update(d);\n  var glAes = regl({\n    profile: false,\n    blend: {\n      enable: context,\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 1,\n        dstAlpha: 1 // 'one minus src alpha'\n      },\n\n      equation: {\n        rgb: 'add',\n        alpha: 'add'\n      },\n      color: [0, 0, 0, 0]\n    },\n    depth: {\n      enable: !context,\n      mask: true,\n      func: 'less',\n      range: [0, 1]\n    },\n    // for polygons\n    cull: {\n      enable: true,\n      face: 'back'\n    },\n    scissor: {\n      enable: true,\n      box: {\n        x: regl.prop('scissorX'),\n        y: regl.prop('scissorY'),\n        width: regl.prop('scissorWidth'),\n        height: regl.prop('scissorHeight')\n      }\n    },\n    viewport: {\n      x: regl.prop('viewportX'),\n      y: regl.prop('viewportY'),\n      width: regl.prop('viewportWidth'),\n      height: regl.prop('viewportHeight')\n    },\n    dither: false,\n    vert: pick ? pickVertexShaderSource : context ? contextShaderSource : vertexShaderSource,\n    frag: fragmentShaderSource,\n    primitive: 'lines',\n    lineWidth: 1,\n    attributes: attributes,\n    uniforms: {\n      resolution: regl.prop('resolution'),\n      viewBoxPosition: regl.prop('viewBoxPosition'),\n      viewBoxSize: regl.prop('viewBoxSize'),\n      dim1A: regl.prop('dim1A'),\n      dim2A: regl.prop('dim2A'),\n      dim1B: regl.prop('dim1B'),\n      dim2B: regl.prop('dim2B'),\n      dim1C: regl.prop('dim1C'),\n      dim2C: regl.prop('dim2C'),\n      dim1D: regl.prop('dim1D'),\n      dim2D: regl.prop('dim2D'),\n      loA: regl.prop('loA'),\n      hiA: regl.prop('hiA'),\n      loB: regl.prop('loB'),\n      hiB: regl.prop('hiB'),\n      loC: regl.prop('loC'),\n      hiC: regl.prop('hiC'),\n      loD: regl.prop('loD'),\n      hiD: regl.prop('hiD'),\n      palette: paletteTexture,\n      mask: regl.prop('maskTexture'),\n      maskHeight: regl.prop('maskHeight'),\n      colorClamp: regl.prop('colorClamp')\n    },\n    offset: regl.prop('offset'),\n    count: regl.prop('count')\n  });\n  function update(dNew) {\n    model = dNew.model;\n    vm = dNew.viewModel;\n    initialDims = vm.dimensions.slice();\n    sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n    var lines = model.lines;\n    var color = pick ? lines.color.map(function (_, i) {\n      return i / lines.color.length;\n    }) : lines.color;\n    var contextOpacity = Math.max(1 / 255, Math.pow(1 / color.length, 1 / 3));\n    var points = makePoints(sampleCount, initialDims, color);\n    setAttributes(attributes, sampleCount, points);\n    paletteTexture = regl.texture(Lib.extendFlat({\n      data: palette(model.unitToColor, context, Math.round((context ? contextOpacity : 1) * 255))\n    }, paletteTextureConfig));\n  }\n  var colorClamp = [0, 1];\n  function setColorDomain(unitDomain) {\n    colorClamp[0] = unitDomain[0];\n    colorClamp[1] = unitDomain[1];\n  }\n  var previousAxisOrder = [];\n  function makeItem(i, ii, x, y, panelSizeX, canvasPanelSizeY, crossfilterDimensionIndex, I, leftmost, rightmost, constraints) {\n    var loHi, abcd, d, index;\n    var leftRight = [i, ii];\n    var dims = [0, 1].map(function () {\n      return [0, 1, 2, 3].map(function () {\n        return new Float32Array(16);\n      });\n    });\n    for (loHi = 0; loHi < 2; loHi++) {\n      index = leftRight[loHi];\n      for (abcd = 0; abcd < 4; abcd++) {\n        for (d = 0; d < 16; d++) {\n          dims[loHi][abcd][d] = d + 16 * abcd === index ? 1 : 0;\n        }\n      }\n    }\n    var overdrag = model.lines.canvasOverdrag;\n    var domain = model.domain;\n    var canvasWidth = model.canvasWidth;\n    var canvasHeight = model.canvasHeight;\n    var itemModel = Lib.extendFlat({\n      key: crossfilterDimensionIndex,\n      resolution: [canvasWidth, canvasHeight],\n      viewBoxPosition: [x + overdrag, y],\n      viewBoxSize: [panelSizeX, canvasPanelSizeY],\n      i: i,\n      ii: ii,\n      dim1A: dims[0][0],\n      dim1B: dims[0][1],\n      dim1C: dims[0][2],\n      dim1D: dims[0][3],\n      dim2A: dims[1][0],\n      dim2B: dims[1][1],\n      dim2C: dims[1][2],\n      dim2D: dims[1][3],\n      colorClamp: colorClamp,\n      scissorX: (I === leftmost ? 0 : x + overdrag) + (model.pad.l - overdrag) + model.layoutWidth * domain.x[0],\n      scissorWidth: (I === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (I === leftmost ? x + overdrag : 0),\n      scissorY: y + model.pad.b + model.layoutHeight * domain.y[0],\n      scissorHeight: canvasPanelSizeY,\n      viewportX: model.pad.l - overdrag + model.layoutWidth * domain.x[0],\n      viewportY: model.pad.b + model.layoutHeight * domain.y[0],\n      viewportWidth: canvasWidth,\n      viewportHeight: canvasHeight\n    }, constraints);\n    return itemModel;\n  }\n  function makeConstraints() {\n    var loHi, abcd, d;\n    var lims = [0, 1].map(function () {\n      return [0, 1, 2, 3].map(function () {\n        return new Float32Array(16);\n      });\n    });\n    for (loHi = 0; loHi < 2; loHi++) {\n      for (abcd = 0; abcd < 4; abcd++) {\n        for (d = 0; d < 16; d++) {\n          var dimP = d + 16 * abcd;\n          var lim;\n          if (dimP < initialDims.length) {\n            lim = initialDims[dimP].brush.filter.getBounds()[loHi];\n          } else lim = loHi;\n          lims[loHi][abcd][d] = lim + (2 * loHi - 1) * filterEpsilon;\n        }\n      }\n    }\n    function expandedPixelRange(dim, bounds) {\n      var maskHMinus = maskHeight - 1;\n      return [Math.max(0, Math.floor(bounds[0] * maskHMinus)), Math.min(maskHMinus, Math.ceil(bounds[1] * maskHMinus))];\n    }\n    var mask = Array.apply(null, new Array(maskHeight * channelCount)).map(function () {\n      return 255;\n    });\n    for (var dimIndex = 0; dimIndex < initialDims.length; dimIndex++) {\n      var bitIndex = dimIndex % bitsPerByte;\n      var byteIndex = (dimIndex - bitIndex) / bitsPerByte;\n      var bitMask = Math.pow(2, bitIndex);\n      var dim = initialDims[dimIndex];\n      var ranges = dim.brush.filter.get();\n      if (ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n      var prevEnd = expandedPixelRange(dim, ranges[0])[1];\n      for (var ri = 1; ri < ranges.length; ri++) {\n        var nextRange = expandedPixelRange(dim, ranges[ri]);\n        for (var pi = prevEnd + 1; pi < nextRange[0]; pi++) {\n          mask[pi * channelCount + byteIndex] &= ~bitMask;\n        }\n        prevEnd = Math.max(prevEnd, nextRange[1]);\n      }\n    }\n    var textureData = {\n      // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n      shape: [channelCount, maskHeight],\n      format: 'alpha',\n      type: 'uint8',\n      mag: 'nearest',\n      min: 'nearest',\n      data: mask\n    };\n    if (maskTexture) maskTexture(textureData);else maskTexture = regl.texture(textureData);\n    return {\n      maskTexture: maskTexture,\n      maskHeight: maskHeight,\n      loA: lims[0][0],\n      loB: lims[0][1],\n      loC: lims[0][2],\n      loD: lims[0][3],\n      hiA: lims[1][0],\n      hiB: lims[1][1],\n      hiC: lims[1][2],\n      hiD: lims[1][3]\n    };\n  }\n  function renderGLParcoords(panels, setChanged, clearOnly) {\n    var panelCount = panels.length;\n    var I;\n    var leftmost;\n    var rightmost;\n    var lowestX = Infinity;\n    var highestX = -Infinity;\n    for (I = 0; I < panelCount; I++) {\n      if (panels[I].dim2.canvasX > highestX) {\n        highestX = panels[I].dim2.canvasX;\n        rightmost = I;\n      }\n      if (panels[I].dim1.canvasX < lowestX) {\n        lowestX = panels[I].dim1.canvasX;\n        leftmost = I;\n      }\n    }\n    if (panelCount === 0) {\n      // clear canvas here, as the panel iteration below will not enter the loop body\n      clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n    }\n    var constraints = context ? {} : makeConstraints();\n    for (I = 0; I < panelCount; I++) {\n      var panel = panels[I];\n      var dim1 = panel.dim1;\n      var i = dim1.crossfilterDimensionIndex;\n      var x = panel.canvasX;\n      var y = panel.canvasY;\n      var dim2 = panel.dim2;\n      var ii = dim2.crossfilterDimensionIndex;\n      var panelSizeX = panel.panelSizeX;\n      var panelSizeY = panel.panelSizeY;\n      var xTo = x + panelSizeX;\n      if (setChanged || !previousAxisOrder[i] || previousAxisOrder[i][0] !== x || previousAxisOrder[i][1] !== xTo) {\n        previousAxisOrder[i] = [x, xTo];\n        var item = makeItem(i, ii, x, y, panelSizeX, panelSizeY, dim1.crossfilterDimensionIndex, I, leftmost, rightmost, constraints);\n        renderState.clearOnly = clearOnly;\n        renderBlock(regl, glAes, renderState, setChanged ? model.lines.blockLineCount : sampleCount, sampleCount, item);\n      }\n    }\n  }\n  function readPixel(canvasX, canvasY) {\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: 1,\n      height: 1,\n      data: pickPixel\n    });\n    return pickPixel;\n  }\n  function readPixels(canvasX, canvasY, width, height) {\n    var pixelArray = new Uint8Array(4 * width * height);\n    regl.read({\n      x: canvasX,\n      y: canvasY,\n      width: width,\n      height: height,\n      data: pixelArray\n    });\n    return pixelArray;\n  }\n  function destroy() {\n    canvasGL.style['pointer-events'] = 'none';\n    paletteTexture.destroy();\n    if (maskTexture) maskTexture.destroy();\n    for (var k in attributes) {\n      attributes[k].destroy();\n    }\n  }\n  return {\n    setColorDomain: setColorDomain,\n    render: renderGLParcoords,\n    readPixel: readPixel,\n    readPixels: readPixels,\n    destroy: destroy,\n    update: update\n  };\n};","map":{"version":3,"names":["glslify","require","vertexShaderSource","contextShaderSource","pickVertexShaderSource","fragmentShaderSource","Lib","depthLimitEpsilon","filterEpsilon","maskHeight","gpuDimensionCount","sectionVertexCount","vec4NumberCount","bitsPerByte","channelCount","contextColor","dummyPixel","Uint8Array","pickPixel","paletteTextureConfig","shape","format","type","mag","min","ensureDraw","regl","read","x","y","width","height","data","clear","gl","_gl","enable","SCISSOR_TEST","scissor","color","depth","renderBlock","glAes","renderState","blockLineCount","sampleCount","item","rafKey","key","render","blockNumber","count","Math","offset","window","cancelAnimationFrame","currentRafs","scissorX","scissorY","scissorWidth","viewBoxSize","clearOnly","requestAnimationFrame","drawCompleted","adjustDepth","d","max","palette","unitToColor","context","opacity","result","j","c","push","concat","calcPickColor","rgbIndex","makePoints","dimensions","dimensionCount","length","points","i","paddedUnitValues","makeVecAttr","vecIndex","k","pointPairs","setAttributes","attributes","toString","emptyAttributes","buffer","usage","module","exports","canvasGL","pick","model","vm","initialDims","maskTexture","paletteTexture","texture","update","profile","blend","func","srcRGB","dstRGB","srcAlpha","dstAlpha","equation","rgb","alpha","mask","range","cull","face","box","prop","viewport","dither","vert","frag","primitive","lineWidth","uniforms","resolution","viewBoxPosition","dim1A","dim2A","dim1B","dim2B","dim1C","dim2C","dim1D","dim2D","loA","hiA","loB","hiB","loC","hiC","loD","hiD","colorClamp","dNew","viewModel","slice","values","lines","map","_","contextOpacity","pow","extendFlat","round","setColorDomain","unitDomain","previousAxisOrder","makeItem","ii","panelSizeX","canvasPanelSizeY","crossfilterDimensionIndex","I","leftmost","rightmost","constraints","loHi","abcd","index","leftRight","dims","Float32Array","overdrag","canvasOverdrag","domain","canvasWidth","canvasHeight","itemModel","pad","l","layoutWidth","b","layoutHeight","scissorHeight","viewportX","viewportY","viewportWidth","viewportHeight","makeConstraints","lims","dimP","lim","brush","filter","getBounds","expandedPixelRange","dim","bounds","maskHMinus","floor","ceil","Array","apply","dimIndex","bitIndex","byteIndex","bitMask","ranges","get","prevEnd","ri","nextRange","pi","textureData","renderGLParcoords","panels","setChanged","panelCount","lowestX","Infinity","highestX","dim2","canvasX","dim1","panel","canvasY","panelSizeY","xTo","readPixel","readPixels","pixelArray","destroy","style"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/parcoords/lines.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar glslify = require('glslify');\nvar vertexShaderSource = glslify('./shaders/vertex.glsl');\nvar contextShaderSource = glslify('./shaders/context_vertex.glsl');\nvar pickVertexShaderSource = glslify('./shaders/pick_vertex.glsl');\nvar fragmentShaderSource = glslify('./shaders/fragment.glsl');\n\nvar Lib = require('../../lib');\n\n// don't change; otherwise near/far plane lines are lost\nvar depthLimitEpsilon = 1e-6;\n// just enough buffer for an extra bit at single-precision floating point\n// which on [0, 1] is 6e-8 (1/2^24)\nvar filterEpsilon = 1e-7;\n\n// precision of multiselect is the full range divided into this many parts\nvar maskHeight = 2048;\n\nvar gpuDimensionCount = 64;\nvar sectionVertexCount = 2;\nvar vec4NumberCount = 4;\nvar bitsPerByte = 8;\nvar channelCount = gpuDimensionCount / bitsPerByte; // == 8 bytes needed to have 64 bits\n\nvar contextColor = [119, 119, 119]; // middle gray to not drawn the focus; looks good on a black or white background\n\nvar dummyPixel = new Uint8Array(4);\nvar pickPixel = new Uint8Array(4);\n\nvar paletteTextureConfig = {\n    shape: [256, 1],\n    format: 'rgba',\n    type: 'uint8',\n    mag: 'nearest',\n    min: 'nearest'\n};\n\nfunction ensureDraw(regl) {\n    regl.read({\n        x: 0,\n        y: 0,\n        width: 1,\n        height: 1,\n        data: dummyPixel\n    });\n}\n\nfunction clear(regl, x, y, width, height) {\n    var gl = regl._gl;\n    gl.enable(gl.SCISSOR_TEST);\n    gl.scissor(x, y, width, height);\n    regl.clear({color: [0, 0, 0, 0], depth: 1}); // clearing is done in scissored panel only\n}\n\nfunction renderBlock(regl, glAes, renderState, blockLineCount, sampleCount, item) {\n\n    var rafKey = item.key;\n\n    function render(blockNumber) {\n\n        var count;\n\n        count = Math.min(blockLineCount, sampleCount - blockNumber * blockLineCount);\n\n        item.offset = sectionVertexCount * blockNumber * blockLineCount;\n        item.count = sectionVertexCount * count;\n        if(blockNumber === 0) {\n            // stop drawing possibly stale glyphs before clearing\n            window.cancelAnimationFrame(renderState.currentRafs[rafKey]);\n            delete renderState.currentRafs[rafKey];\n            clear(regl, item.scissorX, item.scissorY, item.scissorWidth, item.viewBoxSize[1]);\n        }\n\n        if(renderState.clearOnly) {\n            return;\n        }\n\n        glAes(item);\n\n        if(blockNumber * blockLineCount + count < sampleCount) {\n            renderState.currentRafs[rafKey] = window.requestAnimationFrame(function() {\n                render(blockNumber + 1);\n            });\n        }\n\n        renderState.drawCompleted = false;\n    }\n\n    if(!renderState.drawCompleted) {\n        ensureDraw(regl);\n        renderState.drawCompleted = true;\n    }\n\n    // start with rendering item 0; recursion handles the rest\n    render(0);\n}\n\nfunction adjustDepth(d) {\n    // WebGL matrix operations use floats with limited precision, potentially causing a number near a border of [0, 1]\n    // to end up slightly outside the border. With an epsilon, we reduce the chance that a line gets clipped by the\n    // near or the far plane.\n    return Math.max(depthLimitEpsilon, Math.min(1 - depthLimitEpsilon, d));\n}\n\nfunction palette(unitToColor, context, opacity) {\n    var result = [];\n    for(var j = 0; j < 256; j++) {\n        var c = unitToColor(j / 255);\n        result.push((context ? contextColor : c).concat(opacity));\n    }\n\n    return result;\n}\n\n// Maps the sample index [0...sampleCount - 1] to a range of [0, 1] as the shader expects colors in the [0, 1] range.\n// but first it shifts the sample index by 0, 8 or 16 bits depending on rgbIndex [0..2]\n// with the end result that each line will be of a unique color, making it possible for the pick handler\n// to uniquely identify which line is hovered over (bijective mapping).\n// The inverse, i.e. readPixel is invoked from 'parcoords.js'\nfunction calcPickColor(j, rgbIndex) {\n    return (j >>> 8 * rgbIndex) % 256 / 255;\n}\n\nfunction makePoints(sampleCount, dimensions, color) {\n    var dimensionCount = dimensions.length;\n\n    var points = [];\n    for(var j = 0; j < sampleCount; j++) {\n        for(var i = 0; i < gpuDimensionCount; i++) {\n            points.push(i < dimensionCount ?\n                dimensions[i].paddedUnitValues[j] :\n                i === (gpuDimensionCount - 1) ?\n                    adjustDepth(color[j]) :\n                    i >= gpuDimensionCount - 4 ?\n                        calcPickColor(j, gpuDimensionCount - 2 - i) :\n                        0.5);\n        }\n    }\n\n    return points;\n}\n\nfunction makeVecAttr(sampleCount, points, vecIndex) {\n    var i, j, k;\n    var pointPairs = [];\n\n    for(j = 0; j < sampleCount; j++) {\n        for(k = 0; k < sectionVertexCount; k++) {\n            for(i = 0; i < vec4NumberCount; i++) {\n                pointPairs.push(points[j * gpuDimensionCount + vecIndex * vec4NumberCount + i]);\n                if(vecIndex * vec4NumberCount + i === gpuDimensionCount - 1 && k % 2 === 0) {\n                    pointPairs[pointPairs.length - 1] *= -1;\n                }\n            }\n        }\n    }\n\n    return pointPairs;\n}\n\nfunction setAttributes(attributes, sampleCount, points) {\n    for(var i = 0; i < 16; i++) {\n        attributes['p' + i.toString(16)](makeVecAttr(sampleCount, points, i));\n    }\n}\n\nfunction emptyAttributes(regl) {\n    var attributes = {};\n    for(var i = 0; i < 16; i++) {\n        attributes['p' + i.toString(16)] = regl.buffer({usage: 'dynamic', type: 'float', data: new Uint8Array(0)});\n    }\n    return attributes;\n}\n\nmodule.exports = function(canvasGL, d) {\n    // context & pick describe which canvas we're talking about - won't change with new data\n    var context = d.context;\n    var pick = d.pick;\n\n    var regl = d.regl;\n\n    var renderState = {\n        currentRafs: {},\n        drawCompleted: true,\n        clearOnly: false\n    };\n\n    // state to be set by update and used later\n    var model;\n    var vm;\n    var initialDims;\n    var sampleCount;\n    var attributes = emptyAttributes(regl);\n    var maskTexture;\n    var paletteTexture = regl.texture(paletteTextureConfig);\n\n    update(d);\n\n    var glAes = regl({\n\n        profile: false,\n\n        blend: {\n            enable: context,\n            func: {\n                srcRGB: 'src alpha',\n                dstRGB: 'one minus src alpha',\n                srcAlpha: 1,\n                dstAlpha: 1 // 'one minus src alpha'\n            },\n            equation: {\n                rgb: 'add',\n                alpha: 'add'\n            },\n            color: [0, 0, 0, 0]\n        },\n\n        depth: {\n            enable: !context,\n            mask: true,\n            func: 'less',\n            range: [0, 1]\n        },\n\n        // for polygons\n        cull: {\n            enable: true,\n            face: 'back'\n        },\n\n        scissor: {\n            enable: true,\n            box: {\n                x: regl.prop('scissorX'),\n                y: regl.prop('scissorY'),\n                width: regl.prop('scissorWidth'),\n                height: regl.prop('scissorHeight')\n            }\n        },\n\n        viewport: {\n            x: regl.prop('viewportX'),\n            y: regl.prop('viewportY'),\n            width: regl.prop('viewportWidth'),\n            height: regl.prop('viewportHeight')\n        },\n\n        dither: false,\n\n        vert: pick ? pickVertexShaderSource : context ? contextShaderSource : vertexShaderSource,\n\n        frag: fragmentShaderSource,\n\n        primitive: 'lines',\n        lineWidth: 1,\n        attributes: attributes,\n        uniforms: {\n            resolution: regl.prop('resolution'),\n            viewBoxPosition: regl.prop('viewBoxPosition'),\n            viewBoxSize: regl.prop('viewBoxSize'),\n            dim1A: regl.prop('dim1A'),\n            dim2A: regl.prop('dim2A'),\n            dim1B: regl.prop('dim1B'),\n            dim2B: regl.prop('dim2B'),\n            dim1C: regl.prop('dim1C'),\n            dim2C: regl.prop('dim2C'),\n            dim1D: regl.prop('dim1D'),\n            dim2D: regl.prop('dim2D'),\n            loA: regl.prop('loA'),\n            hiA: regl.prop('hiA'),\n            loB: regl.prop('loB'),\n            hiB: regl.prop('hiB'),\n            loC: regl.prop('loC'),\n            hiC: regl.prop('hiC'),\n            loD: regl.prop('loD'),\n            hiD: regl.prop('hiD'),\n            palette: paletteTexture,\n            mask: regl.prop('maskTexture'),\n            maskHeight: regl.prop('maskHeight'),\n            colorClamp: regl.prop('colorClamp')\n        },\n        offset: regl.prop('offset'),\n        count: regl.prop('count')\n    });\n\n    function update(dNew) {\n        model = dNew.model;\n        vm = dNew.viewModel;\n        initialDims = vm.dimensions.slice();\n        sampleCount = initialDims[0] ? initialDims[0].values.length : 0;\n\n        var lines = model.lines;\n        var color = pick ? lines.color.map(function(_, i) {return i / lines.color.length;}) : lines.color;\n        var contextOpacity = Math.max(1 / 255, Math.pow(1 / color.length, 1 / 3));\n\n        var points = makePoints(sampleCount, initialDims, color);\n        setAttributes(attributes, sampleCount, points);\n\n        paletteTexture = regl.texture(Lib.extendFlat({\n            data: palette(model.unitToColor, context, Math.round((context ? contextOpacity : 1) * 255))\n        }, paletteTextureConfig));\n    }\n\n    var colorClamp = [0, 1];\n\n    function setColorDomain(unitDomain) {\n        colorClamp[0] = unitDomain[0];\n        colorClamp[1] = unitDomain[1];\n    }\n\n    var previousAxisOrder = [];\n\n    function makeItem(i, ii, x, y, panelSizeX, canvasPanelSizeY, crossfilterDimensionIndex, I, leftmost, rightmost, constraints) {\n        var loHi, abcd, d, index;\n        var leftRight = [i, ii];\n\n        var dims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n\n        for(loHi = 0; loHi < 2; loHi++) {\n            index = leftRight[loHi];\n            for(abcd = 0; abcd < 4; abcd++) {\n                for(d = 0; d < 16; d++) {\n                    dims[loHi][abcd][d] = d + 16 * abcd === index ? 1 : 0;\n                }\n            }\n        }\n\n        var overdrag = model.lines.canvasOverdrag;\n        var domain = model.domain;\n        var canvasWidth = model.canvasWidth;\n        var canvasHeight = model.canvasHeight;\n\n        var itemModel = Lib.extendFlat({\n            key: crossfilterDimensionIndex,\n            resolution: [canvasWidth, canvasHeight],\n            viewBoxPosition: [x + overdrag, y],\n            viewBoxSize: [panelSizeX, canvasPanelSizeY],\n            i: i,\n            ii: ii,\n\n            dim1A: dims[0][0],\n            dim1B: dims[0][1],\n            dim1C: dims[0][2],\n            dim1D: dims[0][3],\n            dim2A: dims[1][0],\n            dim2B: dims[1][1],\n            dim2C: dims[1][2],\n            dim2D: dims[1][3],\n\n            colorClamp: colorClamp,\n\n            scissorX: (I === leftmost ? 0 : x + overdrag) + (model.pad.l - overdrag) + model.layoutWidth * domain.x[0],\n            scissorWidth: (I === rightmost ? canvasWidth - x + overdrag : panelSizeX + 0.5) + (I === leftmost ? x + overdrag : 0),\n            scissorY: y + model.pad.b + model.layoutHeight * domain.y[0],\n            scissorHeight: canvasPanelSizeY,\n\n            viewportX: model.pad.l - overdrag + model.layoutWidth * domain.x[0],\n            viewportY: model.pad.b + model.layoutHeight * domain.y[0],\n            viewportWidth: canvasWidth,\n            viewportHeight: canvasHeight\n        }, constraints);\n\n        return itemModel;\n    }\n\n    function makeConstraints() {\n        var loHi, abcd, d;\n\n        var lims = [0, 1].map(function() {return [0, 1, 2, 3].map(function() {return new Float32Array(16);});});\n\n        for(loHi = 0; loHi < 2; loHi++) {\n            for(abcd = 0; abcd < 4; abcd++) {\n                for(d = 0; d < 16; d++) {\n                    var dimP = d + 16 * abcd;\n                    var lim;\n                    if(dimP < initialDims.length) {\n                        lim = initialDims[dimP].brush.filter.getBounds()[loHi];\n                    }\n                    else lim = loHi;\n                    lims[loHi][abcd][d] = lim + (2 * loHi - 1) * filterEpsilon;\n                }\n            }\n        }\n\n        function expandedPixelRange(dim, bounds) {\n            var maskHMinus = maskHeight - 1;\n            return [\n                Math.max(0, Math.floor(bounds[0] * maskHMinus)),\n                Math.min(maskHMinus, Math.ceil(bounds[1] * maskHMinus))\n            ];\n        }\n\n        var mask = Array.apply(null, new Array(maskHeight * channelCount)).map(function() {\n            return 255;\n        });\n        for(var dimIndex = 0; dimIndex < initialDims.length; dimIndex++) {\n            var bitIndex = dimIndex % bitsPerByte;\n            var byteIndex = (dimIndex - bitIndex) / bitsPerByte;\n            var bitMask = Math.pow(2, bitIndex);\n            var dim = initialDims[dimIndex];\n            var ranges = dim.brush.filter.get();\n            if(ranges.length < 2) continue; // bail if the bounding box based filter is sufficient\n\n            var prevEnd = expandedPixelRange(dim, ranges[0])[1];\n            for(var ri = 1; ri < ranges.length; ri++) {\n                var nextRange = expandedPixelRange(dim, ranges[ri]);\n                for(var pi = prevEnd + 1; pi < nextRange[0]; pi++) {\n                    mask[pi * channelCount + byteIndex] &= ~bitMask;\n                }\n                prevEnd = Math.max(prevEnd, nextRange[1]);\n            }\n        }\n\n        var textureData = {\n            // 8 units x 8 bits = 64 bits, just sufficient for the almost 64 dimensions we support\n            shape: [channelCount, maskHeight],\n            format: 'alpha',\n            type: 'uint8',\n            mag: 'nearest',\n            min: 'nearest',\n            data: mask\n        };\n        if(maskTexture) maskTexture(textureData);\n        else maskTexture = regl.texture(textureData);\n\n        return {\n            maskTexture: maskTexture,\n            maskHeight: maskHeight,\n            loA: lims[0][0],\n            loB: lims[0][1],\n            loC: lims[0][2],\n            loD: lims[0][3],\n            hiA: lims[1][0],\n            hiB: lims[1][1],\n            hiC: lims[1][2],\n            hiD: lims[1][3]\n        };\n    }\n\n    function renderGLParcoords(panels, setChanged, clearOnly) {\n        var panelCount = panels.length;\n        var I;\n\n        var leftmost;\n        var rightmost;\n        var lowestX = Infinity;\n        var highestX = -Infinity;\n\n        for(I = 0; I < panelCount; I++) {\n            if(panels[I].dim2.canvasX > highestX) {\n                highestX = panels[I].dim2.canvasX;\n                rightmost = I;\n            }\n            if(panels[I].dim1.canvasX < lowestX) {\n                lowestX = panels[I].dim1.canvasX;\n                leftmost = I;\n            }\n        }\n\n        if(panelCount === 0) {\n            // clear canvas here, as the panel iteration below will not enter the loop body\n            clear(regl, 0, 0, model.canvasWidth, model.canvasHeight);\n        }\n        var constraints = context ? {} : makeConstraints();\n\n        for(I = 0; I < panelCount; I++) {\n            var panel = panels[I];\n            var dim1 = panel.dim1;\n            var i = dim1.crossfilterDimensionIndex;\n            var x = panel.canvasX;\n            var y = panel.canvasY;\n            var dim2 = panel.dim2;\n            var ii = dim2.crossfilterDimensionIndex;\n            var panelSizeX = panel.panelSizeX;\n            var panelSizeY = panel.panelSizeY;\n            var xTo = x + panelSizeX;\n            if(setChanged || !previousAxisOrder[i] || previousAxisOrder[i][0] !== x || previousAxisOrder[i][1] !== xTo) {\n                previousAxisOrder[i] = [x, xTo];\n                var item = makeItem(i, ii, x, y, panelSizeX, panelSizeY, dim1.crossfilterDimensionIndex, I, leftmost, rightmost, constraints);\n                renderState.clearOnly = clearOnly;\n                renderBlock(regl, glAes, renderState, setChanged ? model.lines.blockLineCount : sampleCount, sampleCount, item);\n            }\n        }\n    }\n\n    function readPixel(canvasX, canvasY) {\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: 1,\n            height: 1,\n            data: pickPixel\n        });\n        return pickPixel;\n    }\n\n    function readPixels(canvasX, canvasY, width, height) {\n        var pixelArray = new Uint8Array(4 * width * height);\n        regl.read({\n            x: canvasX,\n            y: canvasY,\n            width: width,\n            height: height,\n            data: pixelArray\n        });\n        return pixelArray;\n    }\n\n    function destroy() {\n        canvasGL.style['pointer-events'] = 'none';\n        paletteTexture.destroy();\n        if(maskTexture) maskTexture.destroy();\n        for(var k in attributes) attributes[k].destroy();\n    }\n\n    return {\n        setColorDomain: setColorDomain,\n        render: renderGLParcoords,\n        readPixel: readPixel,\n        readPixels: readPixels,\n        destroy: destroy,\n        update: update\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}