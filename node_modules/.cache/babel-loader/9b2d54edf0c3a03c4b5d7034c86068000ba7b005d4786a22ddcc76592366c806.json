{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isPlainObject = require('./is_plain_object.js');\nvar isArray = Array.isArray;\nfunction primitivesLoopSplice(source, target) {\n  var i, value;\n  for (i = 0; i < source.length; i++) {\n    value = source[i];\n    if (value !== null && typeof value === 'object') {\n      return false;\n    }\n    if (value !== void 0) {\n      target[i] = value;\n    }\n  }\n  return true;\n}\nexports.extendFlat = function () {\n  return _extend(arguments, false, false, false);\n};\nexports.extendDeep = function () {\n  return _extend(arguments, true, false, false);\n};\nexports.extendDeepAll = function () {\n  return _extend(arguments, true, true, false);\n};\nexports.extendDeepNoArrays = function () {\n  return _extend(arguments, true, false, true);\n};\n\n/*\n * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js\n * All credit to the jQuery authors for perfecting this amazing utility.\n *\n * API difference with jQuery version:\n * - No optional boolean (true -> deep extend) first argument,\n *   use `extendFlat` for first-level only extend and\n *   use `extendDeep` for a deep extend.\n *\n * Other differences with jQuery version:\n * - Uses a modern (and faster) isPlainObject routine.\n * - Expected to work with object {} and array [] arguments only.\n * - Does not check for circular structure.\n *   FYI: jQuery only does a check across one level.\n *   Warning: this might result in infinite loops.\n *\n */\nfunction _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {\n  var target = inputs[0];\n  var length = inputs.length;\n  var input, key, src, copy, copyIsArray, clone, allPrimitives;\n\n  // TODO does this do the right thing for typed arrays?\n\n  if (length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {\n    allPrimitives = primitivesLoopSplice(inputs[1], target);\n    if (allPrimitives) {\n      return target;\n    } else {\n      target.splice(0, target.length); // reset target and continue to next block\n    }\n  }\n\n  for (var i = 1; i < length; i++) {\n    input = inputs[i];\n    for (key in input) {\n      src = target[key];\n      copy = input[key];\n\n      // Stop early and just transfer the array if array copies are disallowed:\n      if (noArrayCopies && isArray(copy)) {\n        target[key] = copy;\n      }\n\n      // recurse if we're merging plain objects or arrays\n      else if (isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n        if (copyIsArray) {\n          copyIsArray = false;\n          clone = src && isArray(src) ? src : [];\n        } else {\n          clone = src && isPlainObject(src) ? src : {};\n        }\n\n        // never move original objects, clone them\n        target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);\n      }\n\n      // don't bring in undefined values, except for extendDeepAll\n      else if (typeof copy !== 'undefined' || keepAllKeys) {\n        target[key] = copy;\n      }\n    }\n  }\n  return target;\n}","map":{"version":3,"names":["isPlainObject","require","isArray","Array","primitivesLoopSplice","source","target","i","value","length","exports","extendFlat","_extend","arguments","extendDeep","extendDeepAll","extendDeepNoArrays","inputs","isDeep","keepAllKeys","noArrayCopies","input","key","src","copy","copyIsArray","clone","allPrimitives","splice"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/lib/extend.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isPlainObject = require('./is_plain_object.js');\nvar isArray = Array.isArray;\n\nfunction primitivesLoopSplice(source, target) {\n    var i, value;\n    for(i = 0; i < source.length; i++) {\n        value = source[i];\n        if(value !== null && typeof(value) === 'object') {\n            return false;\n        }\n        if(value !== void(0)) {\n            target[i] = value;\n        }\n    }\n    return true;\n}\n\nexports.extendFlat = function() {\n    return _extend(arguments, false, false, false);\n};\n\nexports.extendDeep = function() {\n    return _extend(arguments, true, false, false);\n};\n\nexports.extendDeepAll = function() {\n    return _extend(arguments, true, true, false);\n};\n\nexports.extendDeepNoArrays = function() {\n    return _extend(arguments, true, false, true);\n};\n\n/*\n * Inspired by https://github.com/justmoon/node-extend/blob/master/index.js\n * All credit to the jQuery authors for perfecting this amazing utility.\n *\n * API difference with jQuery version:\n * - No optional boolean (true -> deep extend) first argument,\n *   use `extendFlat` for first-level only extend and\n *   use `extendDeep` for a deep extend.\n *\n * Other differences with jQuery version:\n * - Uses a modern (and faster) isPlainObject routine.\n * - Expected to work with object {} and array [] arguments only.\n * - Does not check for circular structure.\n *   FYI: jQuery only does a check across one level.\n *   Warning: this might result in infinite loops.\n *\n */\nfunction _extend(inputs, isDeep, keepAllKeys, noArrayCopies) {\n    var target = inputs[0];\n    var length = inputs.length;\n\n    var input, key, src, copy, copyIsArray, clone, allPrimitives;\n\n    // TODO does this do the right thing for typed arrays?\n\n    if(length === 2 && isArray(target) && isArray(inputs[1]) && target.length === 0) {\n\n        allPrimitives = primitivesLoopSplice(inputs[1], target);\n\n        if(allPrimitives) {\n            return target;\n        } else {\n            target.splice(0, target.length); // reset target and continue to next block\n        }\n    }\n\n    for(var i = 1; i < length; i++) {\n        input = inputs[i];\n\n        for(key in input) {\n            src = target[key];\n            copy = input[key];\n\n            // Stop early and just transfer the array if array copies are disallowed:\n            if(noArrayCopies && isArray(copy)) {\n                target[key] = copy;\n            }\n\n            // recurse if we're merging plain objects or arrays\n            else if(isDeep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {\n                if(copyIsArray) {\n                    copyIsArray = false;\n                    clone = src && isArray(src) ? src : [];\n                } else {\n                    clone = src && isPlainObject(src) ? src : {};\n                }\n\n                // never move original objects, clone them\n                target[key] = _extend([clone, copy], isDeep, keepAllKeys, noArrayCopies);\n            }\n\n            // don't bring in undefined values, except for extendDeepAll\n            else if(typeof copy !== 'undefined' || keepAllKeys) {\n                target[key] = copy;\n            }\n        }\n    }\n\n    return target;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}