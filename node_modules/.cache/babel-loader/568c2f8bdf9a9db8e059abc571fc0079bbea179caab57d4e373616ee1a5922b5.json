{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n  var visibleDims = Lib.filterVisible(trace.dimensions);\n  if (visibleDims.length === 0) return [];\n  var uniqueInfoDims = visibleDims.map(function (dim) {\n    var categoryValues;\n    if (dim.categoryorder === 'trace') {\n      // Use order of first occurrence in trace\n      categoryValues = null;\n    } else if (dim.categoryorder === 'array') {\n      // Use categories specified in `categoryarray` first,\n      // then add extra to the end in trace order\n      categoryValues = dim.categoryarray;\n    } else {\n      // Get all categories up front so we can order them\n      // Should we check for numbers as sort numerically?\n      categoryValues = filterUnique(dim.values).sort();\n      if (dim.categoryorder === 'category descending') {\n        categoryValues = categoryValues.reverse();\n      }\n    }\n    return getUniqueInfo(dim.values, categoryValues);\n  });\n  var counts, count, totalCount;\n  if (Lib.isArrayOrTypedArray(trace.counts)) {\n    counts = trace.counts;\n  } else {\n    counts = [trace.counts];\n  }\n  validateDimensionDisplayInds(visibleDims);\n  visibleDims.forEach(function (dim, dimInd) {\n    validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n  });\n\n  // Handle path colors\n  // ------------------\n  var line = trace.line;\n  var markerColorscale;\n\n  // Process colorscale\n  if (line) {\n    if (hasColorscale(trace, 'line')) {\n      colorscaleCalc(gd, trace, {\n        vals: trace.line.color,\n        containerStr: 'line',\n        cLetter: 'c'\n      });\n    }\n    markerColorscale = Drawing.tryColorscale(line);\n  } else {\n    markerColorscale = Lib.identity;\n  }\n\n  // Build color generation function\n  function getMarkerColorInfo(index) {\n    var value;\n    if (Lib.isArrayOrTypedArray(line.color)) {\n      value = line.color[index % line.color.length];\n    } else {\n      value = line.color;\n    }\n    return {\n      color: markerColorscale(value),\n      rawColor: value\n    };\n  }\n\n  // Number of values and counts\n  // ---------------------------\n  var numValues = visibleDims[0].values.length;\n\n  // Build path info\n  // ---------------\n  // Mapping from category inds to PathModel objects\n  var pathModels = {};\n\n  // Category inds array for each dimension\n  var categoryIndsDims = uniqueInfoDims.map(function (di) {\n    return di.inds;\n  });\n\n  // Initialize total count\n  totalCount = 0;\n  var valueInd;\n  var d;\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    // Category inds for this input value across dimensions\n    var categoryIndsPath = [];\n    for (d = 0; d < categoryIndsDims.length; d++) {\n      categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n    }\n\n    // Count\n    count = counts[valueInd % counts.length];\n\n    // Update total count\n    totalCount += count;\n\n    // Path color\n    var pathColorInfo = getMarkerColorInfo(valueInd);\n\n    // path key\n    var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n    // Create / Update PathModel\n    if (pathModels[pathKey] === undefined) {\n      pathModels[pathKey] = createPathModel(categoryIndsPath, pathColorInfo.color, pathColorInfo.rawColor);\n    }\n    updatePathModel(pathModels[pathKey], valueInd, count);\n  }\n  var dimensionModels = visibleDims.map(function (di, i) {\n    return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n  });\n  for (valueInd = 0; valueInd < numValues; valueInd++) {\n    count = counts[valueInd % counts.length];\n    for (d = 0; d < dimensionModels.length; d++) {\n      var containerInd = dimensionModels[d].containerInd;\n      var catInd = uniqueInfoDims[d].inds[valueInd];\n      var cats = dimensionModels[d].categories;\n      if (cats[catInd] === undefined) {\n        var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n        var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n        cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n      }\n      updateCategoryModel(cats[catInd], valueInd, count);\n    }\n  }\n\n  // Compute unique\n  return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n  var maxCats = dimensions.map(function (d) {\n    return d.categories.length;\n  }).reduce(function (v1, v2) {\n    return Math.max(v1, v2);\n  });\n  return {\n    dimensions: dimensions,\n    paths: paths,\n    trace: undefined,\n    maxCats: maxCats,\n    count: count\n  };\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n  return {\n    dimensionInd: dimensionInd,\n    containerInd: containerInd,\n    displayInd: displayInd,\n    dimensionLabel: dimensionLabel,\n    count: count,\n    categories: [],\n    dragX: null\n  };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n  return {\n    dimensionInd: dimensionInd,\n    categoryInd: categoryInd,\n    categoryValue: categoryValue,\n    displayInd: categoryInd,\n    categoryLabel: categoryLabel,\n    valueInds: [],\n    count: 0,\n    dragY: null\n  };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n  categoryModel.valueInds.push(valueInd);\n  categoryModel.count += count;\n}\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n  return {\n    categoryInds: categoryInds,\n    color: color,\n    rawColor: rawColor,\n    valueInds: [],\n    count: 0\n  };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n  pathModel.valueInds.push(valueInd);\n  pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n  // Initialize uniqueValues if not specified\n  if (uniqueValues === undefined || uniqueValues === null) {\n    uniqueValues = [];\n  } else {\n    // Shallow copy so append below doesn't alter input array\n    uniqueValues = uniqueValues.map(function (e) {\n      return e;\n    });\n  }\n\n  // Initialize Variables\n  var uniqueValueCounts = {};\n  var uniqueValueInds = {};\n  var inds = [];\n\n  // Initialize uniqueValueCounts and\n  uniqueValues.forEach(function (uniqueVal, valInd) {\n    uniqueValueCounts[uniqueVal] = 0;\n    uniqueValueInds[uniqueVal] = valInd;\n  });\n\n  // Compute the necessary unique info in a single pass\n  for (var i = 0; i < values.length; i++) {\n    var item = values[i];\n    var itemInd;\n    if (uniqueValueCounts[item] === undefined) {\n      // This item has a previously unseen value\n      uniqueValueCounts[item] = 1;\n      itemInd = uniqueValues.push(item) - 1;\n      uniqueValueInds[item] = itemInd;\n    } else {\n      // Increment count for this item\n      uniqueValueCounts[item]++;\n      itemInd = uniqueValueInds[item];\n    }\n    inds.push(itemInd);\n  }\n\n  // Build UniqueInfo\n  var uniqueCounts = uniqueValues.map(function (v) {\n    return uniqueValueCounts[v];\n  });\n  return {\n    uniqueValues: uniqueValues,\n    uniqueCounts: uniqueCounts,\n    inds: inds\n  };\n}\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n  var displayInds = visibleDims.map(function (d) {\n    return d.displayindex;\n  });\n  var i;\n  if (isRangePermutation(displayInds)) {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = visibleDims[i].displayindex;\n    }\n  } else {\n    for (i = 0; i < visibleDims.length; i++) {\n      visibleDims[i]._displayindex = i;\n    }\n  }\n}\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n  // Update categoryarray\n  dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n  // Handle ticktext\n  if (dim.ticktext === null || dim.ticktext === undefined) {\n    dim._ticktext = [];\n  } else {\n    // Shallow copy to avoid modifying input array\n    dim._ticktext = dim.ticktext.slice();\n  }\n\n  // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n  for (var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n    dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n  }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n  var indsSpecified = new Array(inds.length);\n  for (var i = 0; i < inds.length; i++) {\n    // Check for out of bounds\n    if (inds[i] < 0 || inds[i] >= inds.length) {\n      return false;\n    }\n\n    // Check for collisions with already specified index\n    if (indsSpecified[inds[i]] !== undefined) {\n      return false;\n    }\n    indsSpecified[inds[i]] = true;\n  }\n\n  // Nothing out of bounds and no collisions. We have a permutation\n  return true;\n}","map":{"version":3,"names":["wrap","require","hasColorscale","colorscaleCalc","filterUnique","Drawing","Lib","module","exports","calc","gd","trace","visibleDims","filterVisible","dimensions","length","uniqueInfoDims","map","dim","categoryValues","categoryorder","categoryarray","values","sort","reverse","getUniqueInfo","counts","count","totalCount","isArrayOrTypedArray","validateDimensionDisplayInds","forEach","dimInd","validateCategoryProperties","line","markerColorscale","vals","color","containerStr","cLetter","tryColorscale","identity","getMarkerColorInfo","index","value","rawColor","numValues","pathModels","categoryIndsDims","di","inds","valueInd","d","categoryIndsPath","push","pathColorInfo","pathKey","undefined","createPathModel","updatePathModel","dimensionModels","i","createDimensionModel","_index","_displayindex","label","containerInd","catInd","cats","categories","catValue","_categoryarray","catLabel","_ticktext","createCategoryModel","updateCategoryModel","createParcatsModel","paths","maxCats","reduce","v1","v2","Math","max","dimensionInd","displayInd","dimensionLabel","dragX","categoryInd","categoryValue","categoryLabel","valueInds","dragY","categoryModel","categoryInds","pathModel","uniqueValues","e","uniqueValueCounts","uniqueValueInds","uniqueVal","valInd","item","itemInd","uniqueCounts","v","displayInds","displayindex","isRangePermutation","uniqueInfoDim","ticktext","slice","indsSpecified","Array"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/parcats/calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n// Requirements\n// ============\nvar wrap = require('../../lib/gup').wrap;\nvar hasColorscale = require('../../components/colorscale/helpers').hasColorscale;\nvar colorscaleCalc = require('../../components/colorscale/calc');\nvar filterUnique = require('../../lib/filter_unique.js');\nvar Drawing = require('../../components/drawing');\nvar Lib = require('../../lib');\n\n/**\n * Create a wrapped ParcatsModel object from trace\n *\n * Note: trace defaults have already been applied\n * @param {Object} gd\n * @param {Object} trace\n * @return {Array.<ParcatsModel>}\n */\nmodule.exports = function calc(gd, trace) {\n    var visibleDims = Lib.filterVisible(trace.dimensions);\n\n    if(visibleDims.length === 0) return [];\n\n    var uniqueInfoDims = visibleDims.map(function(dim) {\n        var categoryValues;\n        if(dim.categoryorder === 'trace') {\n            // Use order of first occurrence in trace\n            categoryValues = null;\n        } else if(dim.categoryorder === 'array') {\n            // Use categories specified in `categoryarray` first,\n            // then add extra to the end in trace order\n            categoryValues = dim.categoryarray;\n        } else {\n            // Get all categories up front so we can order them\n            // Should we check for numbers as sort numerically?\n            categoryValues = filterUnique(dim.values).sort();\n            if(dim.categoryorder === 'category descending') {\n                categoryValues = categoryValues.reverse();\n            }\n        }\n        return getUniqueInfo(dim.values, categoryValues);\n    });\n\n    var counts,\n        count,\n        totalCount;\n    if(Lib.isArrayOrTypedArray(trace.counts)) {\n        counts = trace.counts;\n    } else {\n        counts = [trace.counts];\n    }\n\n    validateDimensionDisplayInds(visibleDims);\n\n    visibleDims.forEach(function(dim, dimInd) {\n        validateCategoryProperties(dim, uniqueInfoDims[dimInd]);\n    });\n\n    // Handle path colors\n    // ------------------\n    var line = trace.line;\n    var markerColorscale;\n\n    // Process colorscale\n    if(line) {\n        if(hasColorscale(trace, 'line')) {\n            colorscaleCalc(gd, trace, {\n                vals: trace.line.color,\n                containerStr: 'line',\n                cLetter: 'c'\n            });\n        }\n        markerColorscale = Drawing.tryColorscale(line);\n    } else {\n        markerColorscale = Lib.identity;\n    }\n\n    // Build color generation function\n    function getMarkerColorInfo(index) {\n        var value;\n        if(Lib.isArrayOrTypedArray(line.color)) {\n            value = line.color[index % line.color.length];\n        } else {\n            value = line.color;\n        }\n\n        return {color: markerColorscale(value), rawColor: value};\n    }\n\n    // Number of values and counts\n    // ---------------------------\n    var numValues = visibleDims[0].values.length;\n\n    // Build path info\n    // ---------------\n    // Mapping from category inds to PathModel objects\n    var pathModels = {};\n\n    // Category inds array for each dimension\n    var categoryIndsDims = uniqueInfoDims.map(function(di) {return di.inds;});\n\n    // Initialize total count\n    totalCount = 0;\n    var valueInd;\n    var d;\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n\n        // Category inds for this input value across dimensions\n        var categoryIndsPath = [];\n        for(d = 0; d < categoryIndsDims.length; d++) {\n            categoryIndsPath.push(categoryIndsDims[d][valueInd]);\n        }\n\n        // Count\n        count = counts[valueInd % counts.length];\n\n        // Update total count\n        totalCount += count;\n\n        // Path color\n        var pathColorInfo = getMarkerColorInfo(valueInd);\n\n        // path key\n        var pathKey = categoryIndsPath + '-' + pathColorInfo.rawColor;\n\n        // Create / Update PathModel\n        if(pathModels[pathKey] === undefined) {\n            pathModels[pathKey] = createPathModel(categoryIndsPath,\n                pathColorInfo.color,\n                pathColorInfo.rawColor);\n        }\n        updatePathModel(pathModels[pathKey], valueInd, count);\n    }\n\n    var dimensionModels = visibleDims.map(function(di, i) {\n        return createDimensionModel(i, di._index, di._displayindex, di.label, totalCount);\n    });\n\n\n    for(valueInd = 0; valueInd < numValues; valueInd++) {\n\n        count = counts[valueInd % counts.length];\n\n        for(d = 0; d < dimensionModels.length; d++) {\n            var containerInd = dimensionModels[d].containerInd;\n            var catInd = uniqueInfoDims[d].inds[valueInd];\n            var cats = dimensionModels[d].categories;\n\n            if(cats[catInd] === undefined) {\n                var catValue = trace.dimensions[containerInd]._categoryarray[catInd];\n                var catLabel = trace.dimensions[containerInd]._ticktext[catInd];\n                cats[catInd] = createCategoryModel(d, catInd, catValue, catLabel);\n            }\n\n            updateCategoryModel(cats[catInd], valueInd, count);\n        }\n    }\n\n    // Compute unique\n    return wrap(createParcatsModel(dimensionModels, pathModels, totalCount));\n};\n\n// Models\n// ======\n\n// Parcats Model\n// -------------\n/**\n * @typedef {Object} ParcatsModel\n *  Object containing calculated information about a parcats trace\n *\n * @property {Array.<DimensionModel>} dimensions\n *  Array of dimension models\n * @property {Object.<string,PathModel>} paths\n *  Dictionary from category inds string (e.g. \"1,2,1,1\") to path model\n * @property {Number} maxCats\n *  The maximum number of categories of any dimension in the diagram\n * @property {Number} count\n *  Total number of input values\n * @property {Object} trace\n */\n\n/**\n * Create and new ParcatsModel object\n * @param {Array.<DimensionModel>} dimensions\n * @param {Object.<string,PathModel>} paths\n * @param {Number} count\n * @return {ParcatsModel}\n */\nfunction createParcatsModel(dimensions, paths, count) {\n    var maxCats = dimensions\n        .map(function(d) {return d.categories.length;})\n        .reduce(function(v1, v2) {return Math.max(v1, v2);});\n    return {dimensions: dimensions, paths: paths, trace: undefined, maxCats: maxCats, count: count};\n}\n\n// Dimension Model\n// ---------------\n/**\n * @typedef {Object} DimensionModel\n *  Object containing calculated information about a single dimension\n *\n * @property {Number} dimensionInd\n *  The index of this dimension among the *visible* dimensions\n * @property {Number} containerInd\n *  The index of this dimension in the original dimensions container,\n *  irrespective of dimension visibility\n * @property {Number} displayInd\n *  The display index of this dimension (where 0 is the left most dimension)\n * @property {String} dimensionLabel\n *  The label of this dimension\n * @property {Number} count\n *  Total number of input values\n * @property {Array.<CategoryModel>} categories\n * @property {Number|null} dragX\n *  The x position of dimension that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and new DimensionModel object with an empty categories array\n * @param {Number} dimensionInd\n * @param {Number} containerInd\n * @param {Number} displayInd\n * @param {String} dimensionLabel\n * @param {Number} count\n *  Total number of input values\n * @return {DimensionModel}\n */\nfunction createDimensionModel(dimensionInd, containerInd, displayInd, dimensionLabel, count) {\n    return {\n        dimensionInd: dimensionInd,\n        containerInd: containerInd,\n        displayInd: displayInd,\n        dimensionLabel: dimensionLabel,\n        count: count,\n        categories: [],\n        dragX: null\n    };\n}\n\n// Category Model\n// --------------\n/**\n * @typedef {Object} CategoryModel\n *  Object containing calculated information about a single category.\n *\n * @property {Number} dimensionInd\n *  The index of this categories dimension\n * @property {Number} categoryInd\n *  The index of this category\n * @property {Number} displayInd\n *  The display index of this category (where 0 is the topmost category)\n * @property {String} categoryLabel\n *  The name of this category\n * @property categoryValue: Raw value of the category\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this category\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {Number|null} dragY\n *  The y position of category that is currently being dragged. null if not being dragged\n */\n\n/**\n * Create and return a new CategoryModel object\n * @param {Number} dimensionInd\n * @param {Number} categoryInd\n *  The display index of this category (where 0 is the topmost category)\n * @param {String} categoryValue\n * @param {String} categoryLabel\n * @return {CategoryModel}\n */\nfunction createCategoryModel(dimensionInd, categoryInd, categoryValue, categoryLabel) {\n    return {\n        dimensionInd: dimensionInd,\n        categoryInd: categoryInd,\n        categoryValue: categoryValue,\n        displayInd: categoryInd,\n        categoryLabel: categoryLabel,\n        valueInds: [],\n        count: 0,\n        dragY: null\n    };\n}\n\n/**\n * Update a CategoryModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {CategoryModel} categoryModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updateCategoryModel(categoryModel, valueInd, count) {\n    categoryModel.valueInds.push(valueInd);\n    categoryModel.count += count;\n}\n\n\n// Path Model\n// ----------\n/**\n * @typedef {Object} PathModel\n *  Object containing calculated information about the samples in a path.\n *\n * @property {Array} categoryInds\n *  Array of category indices for each dimension (length `numDimensions`)\n * @param {String} pathColor\n *  Color of this path. (Note: Any colorscaling has already taken place)\n * @property {Array} valueInds\n *  Array of indices (into the original value array) of all samples in this path\n * @property {Number} count\n *  The number of elements from the original array in this path\n * @property {String} color\n *  The path's color (ass CSS color string)\n * @property rawColor\n *  The raw color value specified by the user. May be a CSS color string or a Number\n */\n\n/**\n * Create and return a new PathModel object\n * @param {Array} categoryInds\n * @param color\n * @param rawColor\n * @return {PathModel}\n */\nfunction createPathModel(categoryInds, color, rawColor) {\n    return {\n        categoryInds: categoryInds,\n        color: color,\n        rawColor: rawColor,\n        valueInds: [],\n        count: 0\n    };\n}\n\n/**\n * Update a PathModel object with a new value index\n * Note: The calling parameter is modified in place.\n *\n * @param {PathModel} pathModel\n * @param {Number} valueInd\n * @param {Number} count\n */\nfunction updatePathModel(pathModel, valueInd, count) {\n    pathModel.valueInds.push(valueInd);\n    pathModel.count += count;\n}\n\n// Unique calculations\n// ===================\n/**\n * @typedef {Object} UniqueInfo\n *  Object containing information about the unique values of an input array\n *\n * @property {Array} uniqueValues\n *  The unique values in the input array\n * @property {Array} uniqueCounts\n *  The number of times each entry in uniqueValues occurs in input array.\n *  This has the same length as `uniqueValues`\n * @property {Array} inds\n *  Indices into uniqueValues that would reproduce original input array\n */\n\n/**\n * Compute unique value information for an array\n *\n * IMPORTANT: Note that values are considered unique\n * if their string representations are unique.\n *\n * @param {Array} values\n * @param {Array|undefined} uniqueValues\n *  Array of expected unique values. The uniqueValues property of the resulting UniqueInfo object will begin with\n *  these entries. Entries are included even if there are zero occurrences in the values array. Entries found in\n *  the values array that are not present in uniqueValues will be included at the end of the array in the\n *  UniqueInfo object.\n * @return {UniqueInfo}\n */\nfunction getUniqueInfo(values, uniqueValues) {\n\n    // Initialize uniqueValues if not specified\n    if(uniqueValues === undefined || uniqueValues === null) {\n        uniqueValues = [];\n    } else {\n        // Shallow copy so append below doesn't alter input array\n        uniqueValues = uniqueValues.map(function(e) {return e;});\n    }\n\n    // Initialize Variables\n    var uniqueValueCounts = {};\n    var uniqueValueInds = {};\n    var inds = [];\n\n    // Initialize uniqueValueCounts and\n    uniqueValues.forEach(function(uniqueVal, valInd) {\n        uniqueValueCounts[uniqueVal] = 0;\n        uniqueValueInds[uniqueVal] = valInd;\n    });\n\n    // Compute the necessary unique info in a single pass\n    for(var i = 0; i < values.length; i++) {\n        var item = values[i];\n        var itemInd;\n\n        if(uniqueValueCounts[item] === undefined) {\n            // This item has a previously unseen value\n            uniqueValueCounts[item] = 1;\n            itemInd = uniqueValues.push(item) - 1;\n            uniqueValueInds[item] = itemInd;\n        } else {\n            // Increment count for this item\n            uniqueValueCounts[item]++;\n            itemInd = uniqueValueInds[item];\n        }\n        inds.push(itemInd);\n    }\n\n    // Build UniqueInfo\n    var uniqueCounts = uniqueValues.map(function(v) { return uniqueValueCounts[v]; });\n\n    return {\n        uniqueValues: uniqueValues,\n        uniqueCounts: uniqueCounts,\n        inds: inds\n    };\n}\n\n\n/**\n * Validate the requested display order for the dimensions.\n * If the display order is a permutation of 0 through dimensions.length - 1, link to _displayindex\n * Otherwise, replace the display order with the dimension order\n * @param {Object} trace\n */\nfunction validateDimensionDisplayInds(visibleDims) {\n    var displayInds = visibleDims.map(function(d) { return d.displayindex; });\n    var i;\n\n    if(isRangePermutation(displayInds)) {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = visibleDims[i].displayindex;\n        }\n    } else {\n        for(i = 0; i < visibleDims.length; i++) {\n            visibleDims[i]._displayindex = i;\n        }\n    }\n}\n\n\n/**\n * Update category properties based on the unique values found for this dimension\n * @param {Object} dim\n * @param {UniqueInfo} uniqueInfoDim\n */\nfunction validateCategoryProperties(dim, uniqueInfoDim) {\n\n    // Update categoryarray\n    dim._categoryarray = uniqueInfoDim.uniqueValues;\n\n    // Handle ticktext\n    if(dim.ticktext === null || dim.ticktext === undefined) {\n        dim._ticktext = [];\n    } else {\n        // Shallow copy to avoid modifying input array\n        dim._ticktext = dim.ticktext.slice();\n    }\n\n    // Extend ticktext with elements from uniqueInfoDim.uniqueValues\n    for(var i = dim._ticktext.length; i < uniqueInfoDim.uniqueValues.length; i++) {\n        dim._ticktext.push(uniqueInfoDim.uniqueValues[i]);\n    }\n}\n\n/**\n * Determine whether an array contains a permutation of the integers from 0 to the array's length - 1\n * @param {Array} inds\n * @return {boolean}\n */\nfunction isRangePermutation(inds) {\n    var indsSpecified = new Array(inds.length);\n\n    for(var i = 0; i < inds.length; i++) {\n        // Check for out of bounds\n        if(inds[i] < 0 || inds[i] >= inds.length) {\n            return false;\n        }\n\n        // Check for collisions with already specified index\n        if(indsSpecified[inds[i]] !== undefined) {\n            return false;\n        }\n\n        indsSpecified[inds[i]] = true;\n    }\n\n    // Nothing out of bounds and no collisions. We have a permutation\n    return true;\n}\n"],"mappings":"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AEqB,OAAO,EAAEA,OAAO;IAAEnD,KAAK,EAAEA;EAAK,CAAC;AACnG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmC,oBAAoB,CAACsB,YAAY,EAAElB,YAAY,EAAEmB,UAAU,EAAEC,cAAc,EAAE3D,KAAK,EAAE;EACzF,OAAO;IACHyD,YAAY,EAAEA,YAAY;IAC1BlB,YAAY,EAAEA,YAAY;IAC1BmB,UAAU,EAAEA,UAAU;IACtBC,cAAc,EAAEA,cAAc;IAC9B3D,KAAK,EAAEA,KAAK;IACZ0C,UAAU,EAAE,EAAE;IACdkB,KAAK,EAAE;EACX,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASb,mBAAmB,CAACU,YAAY,EAAEI,WAAW,EAAEC,aAAa,EAAEC,aAAa,EAAE;EAClF,OAAO;IACHN,YAAY,EAAEA,YAAY;IAC1BI,WAAW,EAAEA,WAAW;IACxBC,aAAa,EAAEA,aAAa;IAC5BJ,UAAU,EAAEG,WAAW;IACvBE,aAAa,EAAEA,aAAa;IAC5BC,SAAS,EAAE,EAAE;IACbhE,KAAK,EAAE,CAAC;IACRiE,KAAK,EAAE;EACX,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjB,mBAAmB,CAACkB,aAAa,EAAE1C,QAAQ,EAAExB,KAAK,EAAE;EACzDkE,aAAa,CAACF,SAAS,CAACrC,IAAI,CAACH,QAAQ,CAAC;EACtC0C,aAAa,CAAClE,KAAK,IAAIA,KAAK;AAChC;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;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"},"metadata":{},"sourceType":"script","externalDependencies":[]}