{"ast":null,"code":"'use strict';\n\nmodule.exports = planarGraphToPolyline;\nvar e2a = require('edges-to-adjacency-list');\nvar planarDual = require('planar-dual');\nvar preprocessPolygon = require('point-in-big-polygon');\nvar twoProduct = require('two-product');\nvar robustSum = require('robust-sum');\nvar uniq = require('uniq');\nvar trimLeaves = require('./lib/trim-leaves');\nfunction makeArray(length, fill) {\n  var result = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    result[i] = fill;\n  }\n  return result;\n}\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length);\n  for (var i = 0; i < length; ++i) {\n    result[i] = [];\n  }\n  return result;\n}\nfunction planarGraphToPolyline(edges, positions) {\n  //Trim leaves\n  var result = trimLeaves(edges, positions);\n  edges = result[0];\n  positions = result[1];\n  var numVertices = positions.length;\n  var numEdges = edges.length;\n\n  //Calculate adjacency list, check manifold\n  var adj = e2a(edges, positions.length);\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold');\n    }\n  }\n\n  //Get faces\n  var faces = planarDual(edges, positions);\n\n  //Check orientation of a polygon using exact arithmetic\n  function ccw(c) {\n    var n = c.length;\n    var area = [0];\n    for (var j = 0; j < n; ++j) {\n      var a = positions[c[j]];\n      var b = positions[c[(j + 1) % n]];\n      var t00 = twoProduct(-a[0], a[1]);\n      var t01 = twoProduct(-a[0], b[1]);\n      var t10 = twoProduct(b[0], a[1]);\n      var t11 = twoProduct(b[0], b[1]);\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)));\n    }\n    return area[area.length - 1] > 0;\n  }\n\n  //Extract all clockwise faces\n  faces = faces.filter(ccw);\n\n  //Detect which loops are contained in one another to handle parent-of relation\n  var numFaces = faces.length;\n  var parent = new Array(numFaces);\n  var containment = new Array(numFaces);\n  for (var i = 0; i < numFaces; ++i) {\n    parent[i] = i;\n    var row = new Array(numFaces);\n    var loopVertices = faces[i].map(function (v) {\n      return positions[v];\n    });\n    var pmc = preprocessPolygon([loopVertices]);\n    var count = 0;\n    outer: for (var j = 0; j < numFaces; ++j) {\n      row[j] = 0;\n      if (i === j) {\n        continue;\n      }\n      var c = faces[j];\n      var n = c.length;\n      for (var k = 0; k < n; ++k) {\n        var d = pmc(positions[c[k]]);\n        if (d !== 0) {\n          if (d < 0) {\n            row[j] = 1;\n            count += 1;\n          }\n          continue outer;\n        }\n      }\n      row[j] = 1;\n      count += 1;\n    }\n    containment[i] = [count, i, row];\n  }\n  containment.sort(function (a, b) {\n    return b[0] - a[0];\n  });\n  for (var i = 0; i < numFaces; ++i) {\n    var row = containment[i];\n    var idx = row[1];\n    var children = row[2];\n    for (var j = 0; j < numFaces; ++j) {\n      if (children[j]) {\n        parent[j] = idx;\n      }\n    }\n  }\n\n  //Initialize face adjacency list\n  var fadj = makeArrayOfArrays(numFaces);\n  for (var i = 0; i < numFaces; ++i) {\n    fadj[i].push(parent[i]);\n    fadj[parent[i]].push(i);\n  }\n\n  //Build adjacency matrix for edges\n  var edgeAdjacency = {};\n  var internalVertices = makeArray(numVertices, false);\n  for (var i = 0; i < numFaces; ++i) {\n    var c = faces[i];\n    var n = c.length;\n    for (var j = 0; j < n; ++j) {\n      var a = c[j];\n      var b = c[(j + 1) % n];\n      var key = Math.min(a, b) + \":\" + Math.max(a, b);\n      if (key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key];\n        fadj[neighbor].push(i);\n        fadj[i].push(neighbor);\n        internalVertices[a] = internalVertices[b] = true;\n      } else {\n        edgeAdjacency[key] = i;\n      }\n    }\n  }\n  function sharedBoundary(c) {\n    var n = c.length;\n    for (var i = 0; i < n; ++i) {\n      if (!internalVertices[c[i]]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  var toVisit = [];\n  var parity = makeArray(numFaces, -1);\n  for (var i = 0; i < numFaces; ++i) {\n    if (parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i);\n      parity[i] = 0;\n    } else {\n      parity[i] = -1;\n    }\n  }\n\n  //Using face adjacency, classify faces as in/out\n  var result = [];\n  while (toVisit.length > 0) {\n    var top = toVisit.pop();\n    var nbhd = fadj[top];\n    uniq(nbhd, function (a, b) {\n      return a - b;\n    });\n    var nnbhr = nbhd.length;\n    var p = parity[top];\n    var polyline;\n    if (p === 0) {\n      var c = faces[top];\n      polyline = [c];\n    }\n    for (var i = 0; i < nnbhr; ++i) {\n      var f = nbhd[i];\n      if (parity[f] >= 0) {\n        continue;\n      }\n      parity[f] = p ^ 1;\n      toVisit.push(f);\n      if (p === 0) {\n        var c = faces[f];\n        if (!sharedBoundary(c)) {\n          c.reverse();\n          polyline.push(c);\n        }\n      }\n    }\n    if (p === 0) {\n      result.push(polyline);\n    }\n  }\n  return result;\n}","map":{"version":3,"names":["module","exports","planarGraphToPolyline","e2a","require","planarDual","preprocessPolygon","twoProduct","robustSum","uniq","trimLeaves","makeArray","length","fill","result","Array","i","makeArrayOfArrays","edges","positions","numVertices","numEdges","adj","Error","faces","ccw","c","n","area","j","a","b","t00","t01","t10","t11","filter","numFaces","parent","containment","row","loopVertices","map","v","pmc","count","outer","k","d","sort","idx","children","fadj","push","edgeAdjacency","internalVertices","key","Math","min","max","neighbor","sharedBoundary","toVisit","parity","top","pop","nbhd","nnbhr","p","polyline","f","reverse"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/planar-graph-to-polyline/pg2pl.js"],"sourcesContent":["'use strict'\n\nmodule.exports = planarGraphToPolyline\n\nvar e2a = require('edges-to-adjacency-list')\nvar planarDual = require('planar-dual')\nvar preprocessPolygon = require('point-in-big-polygon')\nvar twoProduct = require('two-product')\nvar robustSum = require('robust-sum')\nvar uniq = require('uniq')\nvar trimLeaves = require('./lib/trim-leaves')\n\nfunction makeArray(length, fill) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = fill\n  }\n  return result\n}\n\nfunction makeArrayOfArrays(length) {\n  var result = new Array(length)\n  for(var i=0; i<length; ++i) {\n    result[i] = []\n  }\n  return result\n}\n\n\nfunction planarGraphToPolyline(edges, positions) {\n\n  //Trim leaves\n  var result = trimLeaves(edges, positions)\n  edges = result[0]\n  positions = result[1]\n\n  var numVertices = positions.length\n  var numEdges = edges.length\n\n  //Calculate adjacency list, check manifold\n  var adj = e2a(edges, positions.length)\n  for(var i=0; i<numVertices; ++i) {\n    if(adj[i].length % 2 === 1) {\n      throw new Error('planar-graph-to-polyline: graph must be manifold')\n    }\n  }\n\n  //Get faces\n  var faces = planarDual(edges, positions)\n\n  //Check orientation of a polygon using exact arithmetic\n  function ccw(c) {\n    var n = c.length\n    var area = [0]\n    for(var j=0; j<n; ++j) {\n      var a = positions[c[j]]\n      var b = positions[c[(j+1)%n]]\n      var t00 = twoProduct(-a[0], a[1])\n      var t01 = twoProduct(-a[0], b[1])\n      var t10 = twoProduct( b[0], a[1])\n      var t11 = twoProduct( b[0], b[1])\n      area = robustSum(area, robustSum(robustSum(t00, t01), robustSum(t10, t11)))\n    }\n    return area[area.length-1] > 0\n  }\n\n  //Extract all clockwise faces\n  faces = faces.filter(ccw)\n\n  //Detect which loops are contained in one another to handle parent-of relation\n  var numFaces = faces.length\n  var parent = new Array(numFaces)\n  var containment = new Array(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    parent[i] = i\n    var row = new Array(numFaces)\n    var loopVertices = faces[i].map(function(v) {\n      return positions[v]\n    })\n    var pmc = preprocessPolygon([loopVertices])\n    var count = 0\n    outer:\n    for(var j=0; j<numFaces; ++j) {\n      row[j] = 0\n      if(i === j) {\n        continue\n      }\n      var c = faces[j]\n      var n = c.length\n      for(var k=0; k<n; ++k) {\n        var d = pmc(positions[c[k]])\n        if(d !== 0) {\n          if(d < 0) {\n            row[j] = 1\n            count += 1\n          }\n          continue outer\n        }\n      }\n      row[j] = 1\n      count += 1\n    }\n    containment[i] = [count, i, row]\n  }\n  containment.sort(function(a,b) {\n    return b[0] - a[0]\n  })\n  for(var i=0; i<numFaces; ++i) {\n    var row = containment[i]\n    var idx = row[1]\n    var children = row[2]\n    for(var j=0; j<numFaces; ++j) {\n      if(children[j]) {\n        parent[j] = idx\n      }\n    }\n  }\n\n  //Initialize face adjacency list\n  var fadj = makeArrayOfArrays(numFaces)\n  for(var i=0; i<numFaces; ++i) {\n    fadj[i].push(parent[i])\n    fadj[parent[i]].push(i)\n  }\n\n  //Build adjacency matrix for edges\n  var edgeAdjacency = {}\n  var internalVertices = makeArray(numVertices, false)\n  for(var i=0; i<numFaces; ++i) {\n    var c = faces[i]\n    var n = c.length\n    for(var j=0; j<n; ++j) {\n      var a = c[j]\n      var b = c[(j+1)%n]\n      var key = Math.min(a,b) + \":\" + Math.max(a,b)\n      if(key in edgeAdjacency) {\n        var neighbor = edgeAdjacency[key]\n        fadj[neighbor].push(i)\n        fadj[i].push(neighbor)\n        internalVertices[a] = internalVertices[b] = true\n      } else {\n        edgeAdjacency[key] = i\n      }\n    }\n  }\n\n  function sharedBoundary(c) {\n    var n = c.length\n    for(var i=0; i<n; ++i) {\n      if(!internalVertices[c[i]]) {\n        return false\n      }\n    }\n    return true\n  }\n\n  var toVisit = []\n  var parity = makeArray(numFaces, -1)\n  for(var i=0; i<numFaces; ++i) {\n    if(parent[i] === i && !sharedBoundary(faces[i])) {\n      toVisit.push(i)\n      parity[i] = 0\n    } else {\n      parity[i] = -1\n    }\n  }\n\n  //Using face adjacency, classify faces as in/out\n  var result = []\n  while(toVisit.length > 0) {\n    var top = toVisit.pop()\n    var nbhd = fadj[top]\n    uniq(nbhd, function(a,b) {\n      return a-b\n    })\n    var nnbhr = nbhd.length\n    var p = parity[top]\n    var polyline\n    if(p === 0) {\n      var c = faces[top]\n      polyline = [c]\n    }\n    for(var i=0; i<nnbhr; ++i) {\n      var f = nbhd[i]\n      if(parity[f] >= 0) {\n        continue\n      }\n      parity[f] = p^1\n      toVisit.push(f)\n      if(p === 0) {\n        var c = faces[f]\n        if(!sharedBoundary(c)) {\n          c.reverse()\n          polyline.push(c)\n        }\n      }\n    }\n    if(p === 0) {\n      result.push(polyline)\n    }\n  }\n\n  return result\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}