{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar orientations = ['v', 'h'];\nfunction crossTraceCalc(gd, plotinfo) {\n  var calcdata = gd.calcdata;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  for (var i = 0; i < orientations.length; i++) {\n    var orientation = orientations[i];\n    var posAxis = orientation === 'h' ? ya : xa;\n    var boxList = [];\n\n    // make list of boxes / candlesticks\n    // For backward compatibility, candlesticks are treated as if they *are* box traces here\n    for (var j = 0; j < calcdata.length; j++) {\n      var cd = calcdata[j];\n      var t = cd[0].t;\n      var trace = cd[0].trace;\n      if (trace.visible === true && (trace.type === 'box' || trace.type === 'candlestick') && !t.empty && (trace.orientation || 'v') === orientation && trace.xaxis === xa._id && trace.yaxis === ya._id) {\n        boxList.push(j);\n      }\n    }\n    setPositionOffset('box', gd, boxList, posAxis);\n  }\n}\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n  var calcdata = gd.calcdata;\n  var fullLayout = gd._fullLayout;\n  var axId = posAxis._id;\n  var axLetter = axId.charAt(0);\n\n  // N.B. reused in violin\n  var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n  var i, j, calcTrace;\n  var pointList = [];\n  var shownPts = 0;\n\n  // make list of box points\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    for (j = 0; j < calcTrace.length; j++) {\n      pointList.push(calcTrace[j].pos);\n      shownPts += (calcTrace[j].pts2 || []).length;\n    }\n  }\n  if (!pointList.length) return;\n\n  // box plots - update dPos based on multiple traces\n  var boxdv = Lib.distinctVals(pointList);\n  var dPos0 = boxdv.minDiff / 2;\n\n  // check for forced minimum dtick\n  Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n  var num = fullLayout[numKey];\n  var group = fullLayout[traceType + 'mode'] === 'group' && num > 1;\n  var groupFraction = 1 - fullLayout[traceType + 'gap'];\n  var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n  for (i = 0; i < boxList.length; i++) {\n    calcTrace = calcdata[boxList[i]];\n    var trace = calcTrace[0].trace;\n    var t = calcTrace[0].t;\n    var width = trace.width;\n    var side = trace.side;\n\n    // position coordinate delta\n    var dPos;\n    // box half width;\n    var bdPos;\n    // box center offset\n    var bPos;\n    // half-width within which to accept hover for this box/violin\n    // always split the distance to the closest box/violin\n    var wHover;\n    if (width) {\n      dPos = bdPos = wHover = width / 2;\n      bPos = 0;\n    } else {\n      dPos = dPos0;\n      bdPos = dPos * groupFraction * groupGapFraction / (group ? num : 1);\n      bPos = group ? 2 * dPos * (-0.5 + (t.num + 0.5) / num) * groupFraction : 0;\n      wHover = dPos * (group ? groupFraction / num : 1);\n    }\n    t.dPos = dPos;\n    t.bPos = bPos;\n    t.bdPos = bdPos;\n    t.wHover = wHover;\n\n    // box/violin-only value-space push value\n    var pushplus;\n    var pushminus;\n    // edge of box/violin\n    var edge = bPos + bdPos;\n    var edgeplus;\n    var edgeminus;\n    if (side === 'positive') {\n      pushplus = dPos * (width ? 1 : 0.5);\n      edgeplus = edge;\n      pushminus = edgeplus = bPos;\n    } else if (side === 'negative') {\n      pushplus = edgeplus = bPos;\n      pushminus = dPos * (width ? 1 : 0.5);\n      edgeminus = edge;\n    } else {\n      pushplus = pushminus = dPos;\n      edgeplus = edgeminus = edge;\n    }\n\n    // value-space padding\n    var vpadplus;\n    var vpadminus;\n    // pixel-space padding\n    var ppadplus;\n    var ppadminus;\n    // do we add 5% of both sides (for points beyond box/violin)\n    var padded = false;\n    // does this trace show points?\n    var hasPts = (trace.boxpoints || trace.points) && shownPts > 0;\n    if (hasPts) {\n      var pointpos = trace.pointpos;\n      var jitter = trace.jitter;\n      var ms = trace.marker.size / 2;\n      var pp = 0;\n      if (pointpos + jitter >= 0) {\n        pp = edge * (pointpos + jitter);\n        if (pp > pushplus) {\n          // (++) beyond plus-value, use pp\n          padded = true;\n          ppadplus = ms;\n          vpadplus = pp;\n        } else if (pp > edgeplus) {\n          // (+), use push-value (it's bigger), but add px-pad\n          ppadplus = ms;\n          vpadplus = pushplus;\n        }\n      }\n      if (pp <= pushplus) {\n        // (->) fallback to push value\n        vpadplus = pushplus;\n      }\n      var pm = 0;\n      if (pointpos - jitter <= 0) {\n        pm = -edge * (pointpos - jitter);\n        if (pm > pushminus) {\n          // (--) beyond plus-value, use pp\n          padded = true;\n          ppadminus = ms;\n          vpadminus = pm;\n        } else if (pm > edgeminus) {\n          // (-), use push-value (it's bigger), but add px-pad\n          ppadminus = ms;\n          vpadminus = pushminus;\n        }\n      }\n      if (pm <= pushminus) {\n        // (<-) fallback to push value\n        vpadminus = pushminus;\n      }\n    } else {\n      vpadplus = pushplus;\n      vpadminus = pushminus;\n    }\n\n    // calcdata[i][j] are in ascending order\n    var firstPos = calcTrace[0].pos;\n    var lastPos = calcTrace[calcTrace.length - 1].pos;\n    trace._extremes[axId] = Axes.findExtremes(posAxis, [firstPos, lastPos], {\n      padded: padded,\n      vpadminus: vpadminus,\n      vpadplus: vpadplus,\n      // N.B. SVG px-space positive/negative\n      ppadminus: {\n        x: ppadminus,\n        y: ppadplus\n      }[axLetter],\n      ppadplus: {\n        x: ppadplus,\n        y: ppadminus\n      }[axLetter]\n    });\n  }\n}\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setPositionOffset: setPositionOffset\n};","map":{"version":3,"names":["Axes","require","Lib","orientations","crossTraceCalc","gd","plotinfo","calcdata","xa","xaxis","ya","yaxis","i","length","orientation","posAxis","boxList","j","cd","t","trace","visible","type","empty","_id","push","setPositionOffset","traceType","fullLayout","_fullLayout","axId","axLetter","charAt","numKey","calcTrace","pointList","shownPts","pos","pts2","boxdv","distinctVals","dPos0","minDiff","minDtick","vals","num","group","groupFraction","groupGapFraction","width","side","dPos","bdPos","bPos","wHover","pushplus","pushminus","edge","edgeplus","edgeminus","vpadplus","vpadminus","ppadplus","ppadminus","padded","hasPts","boxpoints","points","pointpos","jitter","ms","marker","size","pp","pm","firstPos","lastPos","_extremes","findExtremes","x","y","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/box/cross_trace_calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\n\nvar orientations = ['v', 'h'];\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var calcdata = gd.calcdata;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    for(var i = 0; i < orientations.length; i++) {\n        var orientation = orientations[i];\n        var posAxis = orientation === 'h' ? ya : xa;\n        var boxList = [];\n\n        // make list of boxes / candlesticks\n        // For backward compatibility, candlesticks are treated as if they *are* box traces here\n        for(var j = 0; j < calcdata.length; j++) {\n            var cd = calcdata[j];\n            var t = cd[0].t;\n            var trace = cd[0].trace;\n\n            if(trace.visible === true &&\n                    (trace.type === 'box' || trace.type === 'candlestick') &&\n                    !t.empty &&\n                    (trace.orientation || 'v') === orientation &&\n                    trace.xaxis === xa._id &&\n                    trace.yaxis === ya._id\n              ) {\n                boxList.push(j);\n            }\n        }\n\n        setPositionOffset('box', gd, boxList, posAxis);\n    }\n}\n\nfunction setPositionOffset(traceType, gd, boxList, posAxis) {\n    var calcdata = gd.calcdata;\n    var fullLayout = gd._fullLayout;\n    var axId = posAxis._id;\n    var axLetter = axId.charAt(0);\n\n    // N.B. reused in violin\n    var numKey = traceType === 'violin' ? '_numViolins' : '_numBoxes';\n\n    var i, j, calcTrace;\n    var pointList = [];\n    var shownPts = 0;\n\n    // make list of box points\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n        for(j = 0; j < calcTrace.length; j++) {\n            pointList.push(calcTrace[j].pos);\n            shownPts += (calcTrace[j].pts2 || []).length;\n        }\n    }\n\n    if(!pointList.length) return;\n\n    // box plots - update dPos based on multiple traces\n    var boxdv = Lib.distinctVals(pointList);\n    var dPos0 = boxdv.minDiff / 2;\n\n    // check for forced minimum dtick\n    Axes.minDtick(posAxis, boxdv.minDiff, boxdv.vals[0], true);\n\n    var num = fullLayout[numKey];\n    var group = (fullLayout[traceType + 'mode'] === 'group' && num > 1);\n    var groupFraction = 1 - fullLayout[traceType + 'gap'];\n    var groupGapFraction = 1 - fullLayout[traceType + 'groupgap'];\n\n    for(i = 0; i < boxList.length; i++) {\n        calcTrace = calcdata[boxList[i]];\n\n        var trace = calcTrace[0].trace;\n        var t = calcTrace[0].t;\n        var width = trace.width;\n        var side = trace.side;\n\n        // position coordinate delta\n        var dPos;\n        // box half width;\n        var bdPos;\n        // box center offset\n        var bPos;\n        // half-width within which to accept hover for this box/violin\n        // always split the distance to the closest box/violin\n        var wHover;\n\n        if(width) {\n            dPos = bdPos = wHover = width / 2;\n            bPos = 0;\n        } else {\n            dPos = dPos0;\n            bdPos = dPos * groupFraction * groupGapFraction / (group ? num : 1);\n            bPos = group ? 2 * dPos * (-0.5 + (t.num + 0.5) / num) * groupFraction : 0;\n            wHover = dPos * (group ? groupFraction / num : 1);\n        }\n        t.dPos = dPos;\n        t.bPos = bPos;\n        t.bdPos = bdPos;\n        t.wHover = wHover;\n\n        // box/violin-only value-space push value\n        var pushplus;\n        var pushminus;\n        // edge of box/violin\n        var edge = bPos + bdPos;\n        var edgeplus;\n        var edgeminus;\n\n        if(side === 'positive') {\n            pushplus = dPos * (width ? 1 : 0.5);\n            edgeplus = edge;\n            pushminus = edgeplus = bPos;\n        } else if(side === 'negative') {\n            pushplus = edgeplus = bPos;\n            pushminus = dPos * (width ? 1 : 0.5);\n            edgeminus = edge;\n        } else {\n            pushplus = pushminus = dPos;\n            edgeplus = edgeminus = edge;\n        }\n\n        // value-space padding\n        var vpadplus;\n        var vpadminus;\n        // pixel-space padding\n        var ppadplus;\n        var ppadminus;\n        // do we add 5% of both sides (for points beyond box/violin)\n        var padded = false;\n        // does this trace show points?\n        var hasPts = (trace.boxpoints || trace.points) && (shownPts > 0);\n\n        if(hasPts) {\n            var pointpos = trace.pointpos;\n            var jitter = trace.jitter;\n            var ms = trace.marker.size / 2;\n\n            var pp = 0;\n            if((pointpos + jitter) >= 0) {\n                pp = edge * (pointpos + jitter);\n                if(pp > pushplus) {\n                    // (++) beyond plus-value, use pp\n                    padded = true;\n                    ppadplus = ms;\n                    vpadplus = pp;\n                } else if(pp > edgeplus) {\n                    // (+), use push-value (it's bigger), but add px-pad\n                    ppadplus = ms;\n                    vpadplus = pushplus;\n                }\n            }\n            if(pp <= pushplus) {\n                // (->) fallback to push value\n                vpadplus = pushplus;\n            }\n\n            var pm = 0;\n            if((pointpos - jitter) <= 0) {\n                pm = -edge * (pointpos - jitter);\n                if(pm > pushminus) {\n                    // (--) beyond plus-value, use pp\n                    padded = true;\n                    ppadminus = ms;\n                    vpadminus = pm;\n                } else if(pm > edgeminus) {\n                    // (-), use push-value (it's bigger), but add px-pad\n                    ppadminus = ms;\n                    vpadminus = pushminus;\n                }\n            }\n            if(pm <= pushminus) {\n                // (<-) fallback to push value\n                vpadminus = pushminus;\n            }\n        } else {\n            vpadplus = pushplus;\n            vpadminus = pushminus;\n        }\n\n        // calcdata[i][j] are in ascending order\n        var firstPos = calcTrace[0].pos;\n        var lastPos = calcTrace[calcTrace.length - 1].pos;\n\n        trace._extremes[axId] = Axes.findExtremes(posAxis, [firstPos, lastPos], {\n            padded: padded,\n            vpadminus: vpadminus,\n            vpadplus: vpadplus,\n            // N.B. SVG px-space positive/negative\n            ppadminus: {x: ppadminus, y: ppadplus}[axLetter],\n            ppadplus: {x: ppadplus, y: ppadminus}[axLetter],\n        });\n    }\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setPositionOffset: setPositionOffset\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,4BAA4B,CAAC;AAChD,IAAIC,GAAG,GAAGD,OAAO,CAAC,WAAW,CAAC;AAE9B,IAAIE,YAAY,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;AAE7B,SAASC,cAAc,CAACC,EAAE,EAAEC,QAAQ,EAAE;EAClC,IAAIC,QAAQ,GAAGF,EAAE,CAACE,QAAQ;EAC1B,IAAIC,EAAE,GAAGF,QAAQ,CAACG,KAAK;EACvB,IAAIC,EAAE,GAAGJ,QAAQ,CAACK,KAAK;EAEvB,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGT,YAAY,CAACU,MAAM,EAAED,CAAC,EAAE,EAAE;IACzC,IAAIE,WAAW,GAAGX,YAAY,CAACS,CAAC,CAAC;IACjC,IAAIG,OAAO,GAAGD,WAAW,KAAK,GAAG,GAAGJ,EAAE,GAAGF,EAAE;IAC3C,IAAIQ,OAAO,GAAG,EAAE;;IAEhB;IACA;IACA,KAAI,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,QAAQ,CAACM,MAAM,EAAEI,CAAC,EAAE,EAAE;MACrC,IAAIC,EAAE,GAAGX,QAAQ,CAACU,CAAC,CAAC;MACpB,IAAIE,CAAC,GAAGD,EAAE,CAAC,CAAC,CAAC,CAACC,CAAC;MACf,IAAIC,KAAK,GAAGF,EAAE,CAAC,CAAC,CAAC,CAACE,KAAK;MAEvB,IAAGA,KAAK,CAACC,OAAO,KAAK,IAAI,KAChBD,KAAK,CAACE,IAAI,KAAK,KAAK,IAAIF,KAAK,CAACE,IAAI,KAAK,aAAa,CAAC,IACtD,CAACH,CAAC,CAACI,KAAK,IACR,CAACH,KAAK,CAACN,WAAW,IAAI,GAAG,MAAMA,WAAW,IAC1CM,KAAK,CAACX,KAAK,KAAKD,EAAE,CAACgB,GAAG,IACtBJ,KAAK,CAACT,KAAK,KAAKD,EAAE,CAACc,GAAG,EAC1B;QACAR,OAAO,CAACS,IAAI,CAACR,CAAC,CAAC;MACnB;IACJ;IAEAS,iBAAiB,CAAC,KAAK,EAAErB,EAAE,EAAEW,OAAO,EAAED,OAAO,CAAC;EAClD;AACJ;AAEA,SAASW,iBAAiB,CAACC,SAAS,EAAEtB,EAAE,EAAEW,OAAO,EAAED,OAAO,EAAE;EACxD,IAAIR,QAAQ,GAAGF,EAAE,CAACE,QAAQ;EAC1B,IAAIqB,UAAU,GAAGvB,EAAE,CAACwB,WAAW;EAC/B,IAAIC,IAAI,GAAGf,OAAO,CAACS,GAAG;EACtB,IAAIO,QAAQ,GAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,CAAC;;EAE7B;EACA,IAAIC,MAAM,GAAGN,SAAS,KAAK,QAAQ,GAAG,aAAa,GAAG,WAAW;EAEjE,IAAIf,CAAC,EAAEK,CAAC,EAAEiB,SAAS;EACnB,IAAIC,SAAS,GAAG,EAAE;EAClB,IAAIC,QAAQ,GAAG,CAAC;;EAEhB;EACA,KAAIxB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,OAAO,CAACH,MAAM,EAAED,CAAC,EAAE,EAAE;IAChCsB,SAAS,GAAG3B,QAAQ,CAACS,OAAO,CAACJ,CAAC,CAAC,CAAC;IAChC,KAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGiB,SAAS,CAACrB,MAAM,EAAEI,CAAC,EAAE,EAAE;MAClCkB,SAAS,CAACV,IAAI,CAACS,SAAS,CAACjB,CAAC,CAAC,CAACoB,GAAG,CAAC;MAChCD,QAAQ,IAAI,CAACF,SAAS,CAACjB,CAAC,CAAC,CAACqB,IAAI,IAAI,EAAE,EAAEzB,MAAM;IAChD;EACJ;EAEA,IAAG,CAACsB,SAAS,CAACtB,MAAM,EAAE;;EAEtB;EACA,IAAI0B,KAAK,GAAGrC,GAAG,CAACsC,YAAY,CAACL,SAAS,CAAC;EACvC,IAAIM,KAAK,GAAGF,KAAK,CAACG,OAAO,GAAG,CAAC;;EAE7B;EACA1C,IAAI,CAAC2C,QAAQ,CAAC5B,OAAO,EAAEwB,KAAK,CAACG,OAAO,EAAEH,KAAK,CAACK,IAAI,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;EAE1D,IAAIC,GAAG,GAAGjB,UAAU,CAACK,MAAM,CAAC;EAC5B,IAAIa,KAAK,GAAIlB,UAAU,CAACD,SAAS,GAAG,MAAM,CAAC,KAAK,OAAO,IAAIkB,GAAG,GAAG,CAAE;EACnE,IAAIE,aAAa,GAAG,CAAC,GAAGnB,UAAU,CAACD,SAAS,GAAG,KAAK,CAAC;EACrD,IAAIqB,gBAAgB,GAAG,CAAC,GAAGpB,UAAU,CAACD,SAAS,GAAG,UAAU,CAAC;EAE7D,KAAIf,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGI,OAAO,CAACH,MAAM,EAAED,CAAC,EAAE,EAAE;IAChCsB,SAAS,GAAG3B,QAAQ,CAACS,OAAO,CAACJ,CAAC,CAAC,CAAC;IAEhC,IAAIQ,KAAK,GAAGc,SAAS,CAAC,CAAC,CAAC,CAACd,KAAK;IAC9B,IAAID,CAAC,GAAGe,SAAS,CAAC,CAAC,CAAC,CAACf,CAAC;IACtB,IAAI8B,KAAK,GAAG7B,KAAK,CAAC6B,KAAK;IACvB,IAAIC,IAAI,GAAG9B,KAAK,CAAC8B,IAAI;;IAErB;IACA,IAAIC,IAAI;IACR;IACA,IAAIC,KAAK;IACT;IACA,IAAIC,IAAI;IACR;IACA;IACA,IAAIC,MAAM;IAEV,IAAGL,KAAK,EAAE;MACNE,IAAI,GAAGC,KAAK,GAAGE,MAAM,GAAGL,KAAK,GAAG,CAAC;MACjCI,IAAI,GAAG,CAAC;IACZ,CAAC,MAAM;MACHF,IAAI,GAAGV,KAAK;MACZW,KAAK,GAAGD,IAAI,GAAGJ,aAAa,GAAGC,gBAAgB,IAAIF,KAAK,GAAGD,GAAG,GAAG,CAAC,CAAC;MACnEQ,IAAI,GAAGP,KAAK,GAAG,CAAC,GAAGK,IAAI,IAAI,CAAC,GAAG,GAAG,CAAChC,CAAC,CAAC0B,GAAG,GAAG,GAAG,IAAIA,GAAG,CAAC,GAAGE,aAAa,GAAG,CAAC;MAC1EO,MAAM,GAAGH,IAAI,IAAIL,KAAK,GAAGC,aAAa,GAAGF,GAAG,GAAG,CAAC,CAAC;IACrD;IACA1B,CAAC,CAACgC,IAAI,GAAGA,IAAI;IACbhC,CAAC,CAACkC,IAAI,GAAGA,IAAI;IACblC,CAAC,CAACiC,KAAK,GAAGA,KAAK;IACfjC,CAAC,CAACmC,MAAM,GAAGA,MAAM;;IAEjB;IACA,IAAIC,QAAQ;IACZ,IAAIC,SAAS;IACb;IACA,IAAIC,IAAI,GAAGJ,IAAI,GAAGD,KAAK;IACvB,IAAIM,QAAQ;IACZ,IAAIC,SAAS;IAEb,IAAGT,IAAI,KAAK,UAAU,EAAE;MACpBK,QAAQ,GAAGJ,IAAI,IAAIF,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC;MACnCS,QAAQ,GAAGD,IAAI;MACfD,SAAS,GAAGE,QAAQ,GAAGL,IAAI;IAC/B,CAAC,MAAM,IAAGH,IAAI,KAAK,UAAU,EAAE;MAC3BK,QAAQ,GAAGG,QAAQ,GAAGL,IAAI;MAC1BG,SAAS,GAAGL,IAAI,IAAIF,KAAK,GAAG,CAAC,GAAG,GAAG,CAAC;MACpCU,SAAS,GAAGF,IAAI;IACpB,CAAC,MAAM;MACHF,QAAQ,GAAGC,SAAS,GAAGL,IAAI;MAC3BO,QAAQ,GAAGC,SAAS,GAAGF,IAAI;IAC/B;;IAEA;IACA,IAAIG,QAAQ;IACZ,IAAIC,SAAS;IACb;IACA,IAAIC,QAAQ;IACZ,IAAIC,SAAS;IACb;IACA,IAAIC,MAAM,GAAG,KAAK;IAClB;IACA,IAAIC,MAAM,GAAG,CAAC7C,KAAK,CAAC8C,SAAS,IAAI9C,KAAK,CAAC+C,MAAM,KAAM/B,QAAQ,GAAG,CAAE;IAEhE,IAAG6B,MAAM,EAAE;MACP,IAAIG,QAAQ,GAAGhD,KAAK,CAACgD,QAAQ;MAC7B,IAAIC,MAAM,GAAGjD,KAAK,CAACiD,MAAM;MACzB,IAAIC,EAAE,GAAGlD,KAAK,CAACmD,MAAM,CAACC,IAAI,GAAG,CAAC;MAE9B,IAAIC,EAAE,GAAG,CAAC;MACV,IAAIL,QAAQ,GAAGC,MAAM,IAAK,CAAC,EAAE;QACzBI,EAAE,GAAGhB,IAAI,IAAIW,QAAQ,GAAGC,MAAM,CAAC;QAC/B,IAAGI,EAAE,GAAGlB,QAAQ,EAAE;UACd;UACAS,MAAM,GAAG,IAAI;UACbF,QAAQ,GAAGQ,EAAE;UACbV,QAAQ,GAAGa,EAAE;QACjB,CAAC,MAAM,IAAGA,EAAE,GAAGf,QAAQ,EAAE;UACrB;UACAI,QAAQ,GAAGQ,EAAE;UACbV,QAAQ,GAAGL,QAAQ;QACvB;MACJ;MACA,IAAGkB,EAAE,IAAIlB,QAAQ,EAAE;QACf;QACAK,QAAQ,GAAGL,QAAQ;MACvB;MAEA,IAAImB,EAAE,GAAG,CAAC;MACV,IAAIN,QAAQ,GAAGC,MAAM,IAAK,CAAC,EAAE;QACzBK,EAAE,GAAG,CAACjB,IAAI,IAAIW,QAAQ,GAAGC,MAAM,CAAC;QAChC,IAAGK,EAAE,GAAGlB,SAAS,EAAE;UACf;UACAQ,MAAM,GAAG,IAAI;UACbD,SAAS,GAAGO,EAAE;UACdT,SAAS,GAAGa,EAAE;QAClB,CAAC,MAAM,IAAGA,EAAE,GAAGf,SAAS,EAAE;UACtB;UACAI,SAAS,GAAGO,EAAE;UACdT,SAAS,GAAGL,SAAS;QACzB;MACJ;MACA,IAAGkB,EAAE,IAAIlB,SAAS,EAAE;QAChB;QACAK,SAAS,GAAGL,SAAS;MACzB;IACJ,CAAC,MAAM;MACHI,QAAQ,GAAGL,QAAQ;MACnBM,SAAS,GAAGL,SAAS;IACzB;;IAEA;IACA,IAAImB,QAAQ,GAAGzC,SAAS,CAAC,CAAC,CAAC,CAACG,GAAG;IAC/B,IAAIuC,OAAO,GAAG1C,SAAS,CAACA,SAAS,CAACrB,MAAM,GAAG,CAAC,CAAC,CAACwB,GAAG;IAEjDjB,KAAK,CAACyD,SAAS,CAAC/C,IAAI,CAAC,GAAG9B,IAAI,CAAC8E,YAAY,CAAC/D,OAAO,EAAE,CAAC4D,QAAQ,EAAEC,OAAO,CAAC,EAAE;MACpEZ,MAAM,EAAEA,MAAM;MACdH,SAAS,EAAEA,SAAS;MACpBD,QAAQ,EAAEA,QAAQ;MAClB;MACAG,SAAS,EAAE;QAACgB,CAAC,EAAEhB,SAAS;QAAEiB,CAAC,EAAElB;MAAQ,CAAC,CAAC/B,QAAQ,CAAC;MAChD+B,QAAQ,EAAE;QAACiB,CAAC,EAAEjB,QAAQ;QAAEkB,CAAC,EAAEjB;MAAS,CAAC,CAAChC,QAAQ;IAClD,CAAC,CAAC;EACN;AACJ;AAEAkD,MAAM,CAACC,OAAO,GAAG;EACb9E,cAAc,EAAEA,cAAc;EAC9BsB,iBAAiB,EAAEA;AACvB,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}