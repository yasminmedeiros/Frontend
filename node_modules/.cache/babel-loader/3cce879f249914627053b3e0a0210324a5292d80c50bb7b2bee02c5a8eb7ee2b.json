{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Drawing = require('../../components/drawing');\nvar axisAlignedLine = require('../carpet/axis_aligned_line');\nvar Lib = require('../../lib');\nmodule.exports = function joinAllPaths(trace, pi, perimeter, ab2p, carpet, carpetcd, xa, ya) {\n  var i;\n  var fullpath = '';\n  var startsleft = pi.edgepaths.map(function (v, i) {\n    return i;\n  });\n  var newloop = true;\n  var endpt, newendpt, cnt, nexti, possiblei, addpath;\n  var atol = Math.abs(perimeter[0][0] - perimeter[2][0]) * 1e-4;\n  var btol = Math.abs(perimeter[0][1] - perimeter[2][1]) * 1e-4;\n  function istop(pt) {\n    return Math.abs(pt[1] - perimeter[0][1]) < btol;\n  }\n  function isbottom(pt) {\n    return Math.abs(pt[1] - perimeter[2][1]) < btol;\n  }\n  function isleft(pt) {\n    return Math.abs(pt[0] - perimeter[0][0]) < atol;\n  }\n  function isright(pt) {\n    return Math.abs(pt[0] - perimeter[2][0]) < atol;\n  }\n  function pathto(pt0, pt1) {\n    var i, j, segments, axis;\n    var path = '';\n    if (istop(pt0) && !isright(pt0) || isbottom(pt0) && !isleft(pt0)) {\n      axis = carpet.aaxis;\n      segments = axisAlignedLine(carpet, carpetcd, [pt0[0], pt1[0]], 0.5 * (pt0[1] + pt1[1]));\n    } else {\n      axis = carpet.baxis;\n      segments = axisAlignedLine(carpet, carpetcd, 0.5 * (pt0[0] + pt1[0]), [pt0[1], pt1[1]]);\n    }\n    for (i = 1; i < segments.length; i++) {\n      path += axis.smoothing ? 'C' : 'L';\n      for (j = 0; j < segments[i].length; j++) {\n        var pt = segments[i][j];\n        path += [xa.c2p(pt[0]), ya.c2p(pt[1])] + ' ';\n      }\n    }\n    return path;\n  }\n  i = 0;\n  endpt = null;\n  while (startsleft.length) {\n    var startpt = pi.edgepaths[i][0];\n    if (endpt) {\n      fullpath += pathto(endpt, startpt);\n    }\n    addpath = Drawing.smoothopen(pi.edgepaths[i].map(ab2p), pi.smoothing);\n    fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n    startsleft.splice(startsleft.indexOf(i), 1);\n    endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n    nexti = -1;\n\n    // now loop through sides, moving our endpoint until we find a new start\n    for (cnt = 0; cnt < 4; cnt++) {\n      // just to prevent infinite loops\n      if (!endpt) {\n        Lib.log('Missing end?', i, pi);\n        break;\n      }\n      if (istop(endpt) && !isright(endpt)) {\n        newendpt = perimeter[1]; // left top ---> right top\n      } else if (isleft(endpt)) {\n        newendpt = perimeter[0]; // left bottom ---> left top\n      } else if (isbottom(endpt)) {\n        newendpt = perimeter[3]; // right bottom\n      } else if (isright(endpt)) {\n        newendpt = perimeter[2]; // left bottom\n      }\n\n      for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n        var ptNew = pi.edgepaths[possiblei][0];\n        // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n        if (Math.abs(endpt[0] - newendpt[0]) < atol) {\n          if (Math.abs(endpt[0] - ptNew[0]) < atol && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else if (Math.abs(endpt[1] - newendpt[1]) < btol) {\n          if (Math.abs(endpt[1] - ptNew[1]) < btol && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else {\n          Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n        }\n      }\n      if (nexti >= 0) break;\n      fullpath += pathto(endpt, newendpt);\n      endpt = newendpt;\n    }\n    if (nexti === pi.edgepaths.length) {\n      Lib.log('unclosed perimeter path');\n      break;\n    }\n    i = nexti;\n\n    // if we closed back on a loop we already included,\n    // close it and start a new loop\n    newloop = startsleft.indexOf(i) === -1;\n    if (newloop) {\n      i = startsleft[0];\n      fullpath += pathto(endpt, newendpt) + 'Z';\n      endpt = null;\n    }\n  }\n\n  // finally add the interior paths\n  for (i = 0; i < pi.paths.length; i++) {\n    fullpath += Drawing.smoothclosed(pi.paths[i].map(ab2p), pi.smoothing);\n  }\n  return fullpath;\n};","map":{"version":3,"names":["Drawing","require","axisAlignedLine","Lib","module","exports","joinAllPaths","trace","pi","perimeter","ab2p","carpet","carpetcd","xa","ya","i","fullpath","startsleft","edgepaths","map","v","newloop","endpt","newendpt","cnt","nexti","possiblei","addpath","atol","Math","abs","btol","istop","pt","isbottom","isleft","isright","pathto","pt0","pt1","j","segments","axis","path","aaxis","baxis","length","smoothing","c2p","startpt","smoothopen","replace","splice","indexOf","log","ptNew","paths","smoothclosed"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/contourcarpet/join_all_paths.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Drawing = require('../../components/drawing');\nvar axisAlignedLine = require('../carpet/axis_aligned_line');\nvar Lib = require('../../lib');\n\nmodule.exports = function joinAllPaths(trace, pi, perimeter, ab2p, carpet, carpetcd, xa, ya) {\n    var i;\n    var fullpath = '';\n\n    var startsleft = pi.edgepaths.map(function(v, i) { return i; });\n    var newloop = true;\n    var endpt, newendpt, cnt, nexti, possiblei, addpath;\n\n    var atol = Math.abs(perimeter[0][0] - perimeter[2][0]) * 1e-4;\n    var btol = Math.abs(perimeter[0][1] - perimeter[2][1]) * 1e-4;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < btol; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < btol; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < atol; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < atol; }\n\n    function pathto(pt0, pt1) {\n        var i, j, segments, axis;\n        var path = '';\n\n        if((istop(pt0) && !isright(pt0)) || (isbottom(pt0) && !isleft(pt0))) {\n            axis = carpet.aaxis;\n            segments = axisAlignedLine(carpet, carpetcd, [pt0[0], pt1[0]], 0.5 * (pt0[1] + pt1[1]));\n        } else {\n            axis = carpet.baxis;\n            segments = axisAlignedLine(carpet, carpetcd, 0.5 * (pt0[0] + pt1[0]), [pt0[1], pt1[1]]);\n        }\n\n        for(i = 1; i < segments.length; i++) {\n            path += axis.smoothing ? 'C' : 'L';\n            for(j = 0; j < segments[i].length; j++) {\n                var pt = segments[i][j];\n                path += [xa.c2p(pt[0]), ya.c2p(pt[1])] + ' ';\n            }\n        }\n\n        return path;\n    }\n\n    i = 0;\n    endpt = null;\n    while(startsleft.length) {\n        var startpt = pi.edgepaths[i][0];\n\n        if(endpt) {\n            fullpath += pathto(endpt, startpt);\n        }\n\n        addpath = Drawing.smoothopen(pi.edgepaths[i].map(ab2p), pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) {\n                newendpt = perimeter[1]; // left top ---> right top\n            } else if(isleft(endpt)) {\n                newendpt = perimeter[0]; // left bottom ---> left top\n            } else if(isbottom(endpt)) {\n                newendpt = perimeter[3]; // right bottom\n            } else if(isright(endpt)) {\n                newendpt = perimeter[2]; // left bottom\n            }\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < atol) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < atol && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else if(Math.abs(endpt[1] - newendpt[1]) < btol) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < btol && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                } else {\n                    Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n                }\n            }\n\n            if(nexti >= 0) break;\n            fullpath += pathto(endpt, newendpt);\n            endpt = newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += pathto(endpt, newendpt) + 'Z';\n            endpt = null;\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i].map(ab2p), pi.smoothing);\n    }\n\n    return fullpath;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}