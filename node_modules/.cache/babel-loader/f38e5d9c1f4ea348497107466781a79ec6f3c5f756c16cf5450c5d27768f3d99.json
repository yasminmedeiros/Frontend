{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar boxPlot = require('../box/plot');\nvar linePoints = require('../scatter/line_points');\nvar helpers = require('./helpers');\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n  var fullLayout = gd._fullLayout;\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  function makePath(pts) {\n    var segments = linePoints(pts, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: true,\n      baseTolerance: 0.75,\n      shape: 'spline',\n      simplify: true\n    });\n    return Drawing.smoothopen(segments[0], 1);\n  }\n  Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var t = cd0.t;\n    var trace = cd0.trace;\n    if (!plotinfo.isRangePlot) cd0.node3 = plotGroup;\n    if (trace.visible !== true || t.empty) {\n      plotGroup.remove();\n      return;\n    }\n    var bPos = t.bPos;\n    var bdPos = t.bdPos;\n    var valAxis = plotinfo[t.valLetter + 'axis'];\n    var posAxis = plotinfo[t.posLetter + 'axis'];\n    var hasBothSides = trace.side === 'both';\n    var hasPositiveSide = hasBothSides || trace.side === 'positive';\n    var hasNegativeSide = hasBothSides || trace.side === 'negative';\n    var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n    violins.enter().append('path').style('vector-effect', 'non-scaling-stroke').attr('class', 'violin');\n    violins.exit().remove();\n    violins.each(function (d) {\n      var pathSel = d3.select(this);\n      var density = d.density;\n      var len = density.length;\n      var posCenter = d.pos + bPos;\n      var posCenterPx = posAxis.c2p(posCenter);\n      var scale;\n      if (trace.width) {\n        scale = t.maxKDE / bdPos;\n      } else {\n        var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n        scale = trace.scalemode === 'count' ? groupStats.maxKDE / bdPos * (groupStats.maxCount / d.pts.length) : groupStats.maxKDE / bdPos;\n      }\n      var pathPos, pathNeg, path;\n      var i, k, pts, pt;\n      if (hasPositiveSide) {\n        pts = new Array(len);\n        for (i = 0; i < len; i++) {\n          pt = pts[i] = {};\n          pt[t.posLetter] = posCenter + density[i].v / scale;\n          pt[t.valLetter] = density[i].t;\n        }\n        pathPos = makePath(pts);\n      }\n      if (hasNegativeSide) {\n        pts = new Array(len);\n        for (k = 0, i = len - 1; k < len; k++, i--) {\n          pt = pts[k] = {};\n          pt[t.posLetter] = posCenter - density[i].v / scale;\n          pt[t.valLetter] = density[i].t;\n        }\n        pathNeg = makePath(pts);\n      }\n      if (hasBothSides) {\n        path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n      } else {\n        var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n        var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n        if (trace.orientation === 'h') {\n          startPt.reverse();\n          endPt.reverse();\n        }\n        if (hasPositiveSide) {\n          path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n        } else {\n          path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n        }\n      }\n      pathSel.attr('d', path);\n\n      // save a few things used in getPositionOnKdePath, getKdeValue\n      // on hover and for meanline draw block below\n      d.posCenterPx = posCenterPx;\n      d.posDensityScale = scale * bdPos;\n      d.path = pathSel.node();\n      d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n    });\n    var boxAttrs = trace.box;\n    var boxWidth = boxAttrs.width;\n    var boxLineWidth = (boxAttrs.line || {}).width;\n    var bdPosScaled;\n    var bPosPxOffset;\n    if (hasBothSides) {\n      bdPosScaled = bdPos * boxWidth;\n      bPosPxOffset = 0;\n    } else if (hasPositiveSide) {\n      bdPosScaled = [0, bdPos * boxWidth / 2];\n      bPosPxOffset = -boxLineWidth;\n    } else {\n      bdPosScaled = [bdPos * boxWidth / 2, 0];\n      bPosPxOffset = boxLineWidth;\n    }\n\n    // inner box\n    boxPlot.plotBoxAndWhiskers(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n\n    // meanline insider box\n    boxPlot.plotBoxMean(plotGroup, {\n      pos: posAxis,\n      val: valAxis\n    }, trace, {\n      bPos: bPos,\n      bdPos: bdPosScaled,\n      bPosPxOffset: bPosPxOffset\n    });\n    var fn;\n    if (!trace.box.visible && trace.meanline.visible) {\n      fn = Lib.identity;\n    }\n\n    // N.B. use different class name than boxPlot.plotBoxMean,\n    // to avoid selectAll conflict\n    var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n    meanPaths.enter().append('path').attr('class', 'meanline').style('fill', 'none').style('vector-effect', 'non-scaling-stroke');\n    meanPaths.exit().remove();\n    meanPaths.each(function (d) {\n      var v = valAxis.c2p(d.mean, true);\n      var p = helpers.getPositionOnKdePath(d, trace, v);\n      d3.select(this).attr('d', trace.orientation === 'h' ? 'M' + v + ',' + p[0] + 'V' + p[1] : 'M' + p[0] + ',' + v + 'H' + p[1]);\n    });\n    boxPlot.plotPoints(plotGroup, {\n      x: xa,\n      y: ya\n    }, trace, t);\n  });\n};","map":{"version":3,"names":["d3","require","Lib","Drawing","boxPlot","linePoints","helpers","module","exports","plot","gd","plotinfo","cdViolins","violinLayer","fullLayout","_fullLayout","xa","xaxis","ya","yaxis","makePath","pts","segments","connectGaps","baseTolerance","shape","simplify","smoothopen","makeTraceGroups","each","cd","plotGroup","select","cd0","t","trace","isRangePlot","node3","visible","empty","remove","bPos","bdPos","valAxis","valLetter","posAxis","posLetter","hasBothSides","side","hasPositiveSide","hasNegativeSide","violins","selectAll","data","identity","enter","append","style","attr","exit","d","pathSel","density","len","length","posCenter","pos","posCenterPx","c2p","scale","width","maxKDE","groupStats","_violinScaleGroupStats","scalegroup","scalemode","maxCount","pathPos","pathNeg","path","i","k","pt","Array","v","substr","startPt","endPt","orientation","reverse","posDensityScale","node","pathLength","getTotalLength","boxAttrs","box","boxWidth","boxLineWidth","line","bdPosScaled","bPosPxOffset","plotBoxAndWhiskers","val","plotBoxMean","fn","meanline","meanPaths","mean","p","getPositionOnKdePath","plotPoints","x","y"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/violin/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\n\nvar boxPlot = require('../box/plot');\nvar linePoints = require('../scatter/line_points');\nvar helpers = require('./helpers');\n\nmodule.exports = function plot(gd, plotinfo, cdViolins, violinLayer) {\n    var fullLayout = gd._fullLayout;\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    function makePath(pts) {\n        var segments = linePoints(pts, {\n            xaxis: xa,\n            yaxis: ya,\n            connectGaps: true,\n            baseTolerance: 0.75,\n            shape: 'spline',\n            simplify: true\n        });\n        return Drawing.smoothopen(segments[0], 1);\n    }\n\n    Lib.makeTraceGroups(violinLayer, cdViolins, 'trace violins').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var t = cd0.t;\n        var trace = cd0.trace;\n        if(!plotinfo.isRangePlot) cd0.node3 = plotGroup;\n\n        if(trace.visible !== true || t.empty) {\n            plotGroup.remove();\n            return;\n        }\n\n        var bPos = t.bPos;\n        var bdPos = t.bdPos;\n        var valAxis = plotinfo[t.valLetter + 'axis'];\n        var posAxis = plotinfo[t.posLetter + 'axis'];\n        var hasBothSides = trace.side === 'both';\n        var hasPositiveSide = hasBothSides || trace.side === 'positive';\n        var hasNegativeSide = hasBothSides || trace.side === 'negative';\n\n        var violins = plotGroup.selectAll('path.violin').data(Lib.identity);\n\n        violins.enter().append('path')\n            .style('vector-effect', 'non-scaling-stroke')\n            .attr('class', 'violin');\n\n        violins.exit().remove();\n\n        violins.each(function(d) {\n            var pathSel = d3.select(this);\n            var density = d.density;\n            var len = density.length;\n            var posCenter = d.pos + bPos;\n            var posCenterPx = posAxis.c2p(posCenter);\n\n            var scale;\n            if(trace.width) {\n                scale = t.maxKDE / bdPos;\n            } else {\n                var groupStats = fullLayout._violinScaleGroupStats[trace.scalegroup];\n                scale = trace.scalemode === 'count' ?\n                    (groupStats.maxKDE / bdPos) * (groupStats.maxCount / d.pts.length) :\n                    groupStats.maxKDE / bdPos;\n            }\n\n            var pathPos, pathNeg, path;\n            var i, k, pts, pt;\n\n            if(hasPositiveSide) {\n                pts = new Array(len);\n                for(i = 0; i < len; i++) {\n                    pt = pts[i] = {};\n                    pt[t.posLetter] = posCenter + (density[i].v / scale);\n                    pt[t.valLetter] = density[i].t;\n                }\n                pathPos = makePath(pts);\n            }\n\n            if(hasNegativeSide) {\n                pts = new Array(len);\n                for(k = 0, i = len - 1; k < len; k++, i--) {\n                    pt = pts[k] = {};\n                    pt[t.posLetter] = posCenter - (density[i].v / scale);\n                    pt[t.valLetter] = density[i].t;\n                }\n                pathNeg = makePath(pts);\n            }\n\n            if(hasBothSides) {\n                path = pathPos + 'L' + pathNeg.substr(1) + 'Z';\n            }\n            else {\n                var startPt = [posCenterPx, valAxis.c2p(density[0].t)];\n                var endPt = [posCenterPx, valAxis.c2p(density[len - 1].t)];\n\n                if(trace.orientation === 'h') {\n                    startPt.reverse();\n                    endPt.reverse();\n                }\n\n                if(hasPositiveSide) {\n                    path = 'M' + startPt + 'L' + pathPos.substr(1) + 'L' + endPt;\n                } else {\n                    path = 'M' + endPt + 'L' + pathNeg.substr(1) + 'L' + startPt;\n                }\n            }\n            pathSel.attr('d', path);\n\n            // save a few things used in getPositionOnKdePath, getKdeValue\n            // on hover and for meanline draw block below\n            d.posCenterPx = posCenterPx;\n            d.posDensityScale = scale * bdPos;\n            d.path = pathSel.node();\n            d.pathLength = d.path.getTotalLength() / (hasBothSides ? 2 : 1);\n        });\n\n        var boxAttrs = trace.box;\n        var boxWidth = boxAttrs.width;\n        var boxLineWidth = (boxAttrs.line || {}).width;\n        var bdPosScaled;\n        var bPosPxOffset;\n\n        if(hasBothSides) {\n            bdPosScaled = bdPos * boxWidth;\n            bPosPxOffset = 0;\n        } else if(hasPositiveSide) {\n            bdPosScaled = [0, bdPos * boxWidth / 2];\n            bPosPxOffset = -boxLineWidth;\n        } else {\n            bdPosScaled = [bdPos * boxWidth / 2, 0];\n            bPosPxOffset = boxLineWidth;\n        }\n\n        // inner box\n        boxPlot.plotBoxAndWhiskers(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        // meanline insider box\n        boxPlot.plotBoxMean(plotGroup, {pos: posAxis, val: valAxis}, trace, {\n            bPos: bPos,\n            bdPos: bdPosScaled,\n            bPosPxOffset: bPosPxOffset\n        });\n\n        var fn;\n        if(!trace.box.visible && trace.meanline.visible) {\n            fn = Lib.identity;\n        }\n\n        // N.B. use different class name than boxPlot.plotBoxMean,\n        // to avoid selectAll conflict\n        var meanPaths = plotGroup.selectAll('path.meanline').data(fn || []);\n        meanPaths.enter().append('path')\n            .attr('class', 'meanline')\n            .style('fill', 'none')\n            .style('vector-effect', 'non-scaling-stroke');\n        meanPaths.exit().remove();\n        meanPaths.each(function(d) {\n            var v = valAxis.c2p(d.mean, true);\n            var p = helpers.getPositionOnKdePath(d, trace, v);\n\n            d3.select(this).attr('d',\n                trace.orientation === 'h' ?\n                    'M' + v + ',' + p[0] + 'V' + p[1] :\n                    'M' + p[0] + ',' + v + 'H' + p[1]\n            );\n        });\n\n        boxPlot.plotPoints(plotGroup, {x: xa, y: ya}, trace, t);\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}