{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/* global jQuery:false */\nvar EventEmitter = require('events').EventEmitter;\nvar Events = {\n  init: function init(plotObj) {\n    /*\n     * If we have already instantiated an emitter for this plot\n     * return early.\n     */\n    if (plotObj._ev instanceof EventEmitter) return plotObj;\n    var ev = new EventEmitter();\n    var internalEv = new EventEmitter();\n\n    /*\n     * Assign to plot._ev while we still live in a land\n     * where plot is a DOM element with stuff attached to it.\n     * In the future we can make plot the event emitter itself.\n     */\n    plotObj._ev = ev;\n\n    /*\n     * Create a second event handler that will manage events *internally*.\n     * This allows parts of plotly to respond to thing like relayout without\n     * having to use the user-facing event handler. They cannot peacefully\n     * coexist on the same handler because a user invoking\n     * plotObj.removeAllListeners() would detach internal events, breaking\n     * plotly.\n     */\n    plotObj._internalEv = internalEv;\n\n    /*\n     * Assign bound methods from the ev to the plot object. These methods\n     * will reference the 'this' of plot._ev even though they are methods\n     * of plot. This will keep the event machinery away from the plot object\n     * which currently is often a DOM element but presents an API that will\n     * continue to function when plot becomes an emitter. Not all EventEmitter\n     * methods have been bound to `plot` as some do not currently add value to\n     * the Plotly event API.\n     */\n    plotObj.on = ev.on.bind(ev);\n    plotObj.once = ev.once.bind(ev);\n    plotObj.removeListener = ev.removeListener.bind(ev);\n    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n\n    /*\n     * Create functions for managing internal events. These are *only* triggered\n     * by the mirroring of external events via the emit function.\n     */\n    plotObj._internalOn = internalEv.on.bind(internalEv);\n    plotObj._internalOnce = internalEv.once.bind(internalEv);\n    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n\n    /*\n     * We must wrap emit to continue to support JQuery events. The idea\n     * is to check to see if the user is using JQuery events, if they are\n     * we emit JQuery events to trigger user handlers as well as the EventEmitter\n     * events.\n     */\n    plotObj.emit = function (event, data) {\n      if (typeof jQuery !== 'undefined') {\n        jQuery(plotObj).trigger(event, data);\n      }\n      ev.emit(event, data);\n      internalEv.emit(event, data);\n    };\n    return plotObj;\n  },\n  /*\n   * This function behaves like jQuery's triggerHandler. It calls\n   * all handlers for a particular event and returns the return value\n   * of the LAST handler. This function also triggers jQuery's\n   * triggerHandler for backwards compatibility.\n   */\n  triggerHandler: function triggerHandler(plotObj, event, data) {\n    var jQueryHandlerValue;\n    var nodeEventHandlerValue;\n\n    /*\n     * If jQuery exists run all its handlers for this event and\n     * collect the return value of the LAST handler function\n     */\n    if (typeof jQuery !== 'undefined') {\n      jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n    }\n\n    /*\n     * Now run all the node style event handlers\n     */\n    var ev = plotObj._ev;\n    if (!ev) return jQueryHandlerValue;\n    var handlers = ev._events[event];\n    if (!handlers) return jQueryHandlerValue;\n\n    // making sure 'this' is the EventEmitter instance\n    function apply(handler) {\n      // The 'once' case, we can't just call handler() as we need\n      // the return value here. So,\n      // - remove handler\n      // - call listener and grab return value!\n      // - stash 'fired' key to not call handler twice\n      if (handler.listener) {\n        ev.removeListener(event, handler.listener);\n        if (!handler.fired) {\n          handler.fired = true;\n          return handler.listener.apply(ev, [data]);\n        }\n      } else {\n        return handler.apply(ev, [data]);\n      }\n    }\n\n    // handlers can be function or an array of functions\n    handlers = Array.isArray(handlers) ? handlers : [handlers];\n    var i;\n    for (i = 0; i < handlers.length - 1; i++) {\n      apply(handlers[i]);\n    }\n    // now call the final handler and collect its value\n    nodeEventHandlerValue = apply(handlers[i]);\n\n    /*\n     * Return either the jQuery handler value if it exists or the\n     * nodeEventHandler value. jQuery event value supersedes nodejs\n     * events for backwards compatibility reasons.\n     */\n    return jQueryHandlerValue !== undefined ? jQueryHandlerValue : nodeEventHandlerValue;\n  },\n  purge: function purge(plotObj) {\n    delete plotObj._ev;\n    delete plotObj.on;\n    delete plotObj.once;\n    delete plotObj.removeListener;\n    delete plotObj.removeAllListeners;\n    delete plotObj.emit;\n    delete plotObj._ev;\n    delete plotObj._internalEv;\n    delete plotObj._internalOn;\n    delete plotObj._internalOnce;\n    delete plotObj._removeInternalListener;\n    delete plotObj._removeAllInternalListeners;\n    return plotObj;\n  }\n};\nmodule.exports = Events;","map":{"version":3,"names":["EventEmitter","require","Events","init","plotObj","_ev","ev","internalEv","_internalEv","on","bind","once","removeListener","removeAllListeners","_internalOn","_internalOnce","_removeInternalListener","_removeAllInternalListeners","emit","event","data","jQuery","trigger","triggerHandler","jQueryHandlerValue","nodeEventHandlerValue","handlers","_events","apply","handler","listener","fired","Array","isArray","i","length","undefined","purge","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/lib/events.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n\n    init: function(plotObj) {\n\n        /*\n         * If we have already instantiated an emitter for this plot\n         * return early.\n         */\n        if(plotObj._ev instanceof EventEmitter) return plotObj;\n\n        var ev = new EventEmitter();\n        var internalEv = new EventEmitter();\n\n        /*\n         * Assign to plot._ev while we still live in a land\n         * where plot is a DOM element with stuff attached to it.\n         * In the future we can make plot the event emitter itself.\n         */\n        plotObj._ev = ev;\n\n        /*\n         * Create a second event handler that will manage events *internally*.\n         * This allows parts of plotly to respond to thing like relayout without\n         * having to use the user-facing event handler. They cannot peacefully\n         * coexist on the same handler because a user invoking\n         * plotObj.removeAllListeners() would detach internal events, breaking\n         * plotly.\n         */\n        plotObj._internalEv = internalEv;\n\n        /*\n         * Assign bound methods from the ev to the plot object. These methods\n         * will reference the 'this' of plot._ev even though they are methods\n         * of plot. This will keep the event machinery away from the plot object\n         * which currently is often a DOM element but presents an API that will\n         * continue to function when plot becomes an emitter. Not all EventEmitter\n         * methods have been bound to `plot` as some do not currently add value to\n         * the Plotly event API.\n         */\n        plotObj.on = ev.on.bind(ev);\n        plotObj.once = ev.once.bind(ev);\n        plotObj.removeListener = ev.removeListener.bind(ev);\n        plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n\n        /*\n         * Create functions for managing internal events. These are *only* triggered\n         * by the mirroring of external events via the emit function.\n         */\n        plotObj._internalOn = internalEv.on.bind(internalEv);\n        plotObj._internalOnce = internalEv.once.bind(internalEv);\n        plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n        plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n\n        /*\n         * We must wrap emit to continue to support JQuery events. The idea\n         * is to check to see if the user is using JQuery events, if they are\n         * we emit JQuery events to trigger user handlers as well as the EventEmitter\n         * events.\n         */\n        plotObj.emit = function(event, data) {\n            if(typeof jQuery !== 'undefined') {\n                jQuery(plotObj).trigger(event, data);\n            }\n\n            ev.emit(event, data);\n            internalEv.emit(event, data);\n        };\n\n        return plotObj;\n    },\n\n    /*\n     * This function behaves like jQuery's triggerHandler. It calls\n     * all handlers for a particular event and returns the return value\n     * of the LAST handler. This function also triggers jQuery's\n     * triggerHandler for backwards compatibility.\n     */\n    triggerHandler: function(plotObj, event, data) {\n        var jQueryHandlerValue;\n        var nodeEventHandlerValue;\n\n        /*\n         * If jQuery exists run all its handlers for this event and\n         * collect the return value of the LAST handler function\n         */\n        if(typeof jQuery !== 'undefined') {\n            jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n        }\n\n        /*\n         * Now run all the node style event handlers\n         */\n        var ev = plotObj._ev;\n        if(!ev) return jQueryHandlerValue;\n\n        var handlers = ev._events[event];\n        if(!handlers) return jQueryHandlerValue;\n\n        // making sure 'this' is the EventEmitter instance\n        function apply(handler) {\n            // The 'once' case, we can't just call handler() as we need\n            // the return value here. So,\n            // - remove handler\n            // - call listener and grab return value!\n            // - stash 'fired' key to not call handler twice\n            if(handler.listener) {\n                ev.removeListener(event, handler.listener);\n                if(!handler.fired) {\n                    handler.fired = true;\n                    return handler.listener.apply(ev, [data]);\n                }\n            } else {\n                return handler.apply(ev, [data]);\n            }\n        }\n\n        // handlers can be function or an array of functions\n        handlers = Array.isArray(handlers) ? handlers : [handlers];\n\n        var i;\n        for(i = 0; i < handlers.length - 1; i++) {\n            apply(handlers[i]);\n        }\n        // now call the final handler and collect its value\n        nodeEventHandlerValue = apply(handlers[i]);\n\n        /*\n         * Return either the jQuery handler value if it exists or the\n         * nodeEventHandler value. jQuery event value supersedes nodejs\n         * events for backwards compatibility reasons.\n         */\n        return jQueryHandlerValue !== undefined ?\n            jQueryHandlerValue :\n            nodeEventHandlerValue;\n    },\n\n    purge: function(plotObj) {\n        delete plotObj._ev;\n        delete plotObj.on;\n        delete plotObj.once;\n        delete plotObj.removeListener;\n        delete plotObj.removeAllListeners;\n        delete plotObj.emit;\n\n        delete plotObj._ev;\n        delete plotObj._internalEv;\n        delete plotObj._internalOn;\n        delete plotObj._internalOnce;\n        delete plotObj._removeInternalListener;\n        delete plotObj._removeAllInternalListeners;\n\n        return plotObj;\n    }\n\n};\n\nmodule.exports = Events;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}