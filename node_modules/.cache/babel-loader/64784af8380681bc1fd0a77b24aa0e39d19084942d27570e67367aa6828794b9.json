{"ast":null,"code":"'use strict';\n\nmodule.exports = createSurfacePlot;\nvar bits = require('bit-twiddle');\nvar createBuffer = require('gl-buffer');\nvar createVAO = require('gl-vao');\nvar createTexture = require('gl-texture2d');\nvar pool = require('typedarray-pool');\nvar colormap = require('colormap');\nvar ops = require('ndarray-ops');\nvar pack = require('ndarray-pack');\nvar ndarray = require('ndarray');\nvar surfaceNets = require('surface-nets');\nvar multiply = require('gl-mat4/multiply');\nvar invert = require('gl-mat4/invert');\nvar bsearch = require('binary-search-bounds');\nvar gradient = require('ndarray-gradient');\nvar shaders = require('./lib/shaders');\nvar createShader = shaders.createShader;\nvar createContourShader = shaders.createContourShader;\nvar createPickShader = shaders.createPickShader;\nvar createPickContourShader = shaders.createPickContourShader;\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3);\nvar IDENTITY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\nvar QUAD = [[0, 0], [0, 1], [1, 0], [1, 1], [1, 0], [0, 1]];\nvar PERMUTATIONS = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i];\n    var u = (i + 1) % 3;\n    var v = (i + 2) % 3;\n    p[u + 0] = 1;\n    p[v + 3] = 1;\n    p[i + 6] = 1;\n  }\n})();\nfunction SurfacePickResult(position, index, uv, level, dataCoordinate) {\n  this.position = position;\n  this.index = index;\n  this.uv = uv;\n  this.level = level;\n  this.dataCoordinate = dataCoordinate;\n}\nvar N_COLORS = 256;\nfunction SurfacePlot(gl, shape, bounds, shader, pickShader, coordinates, vao, colorMap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, objectOffset) {\n  this.gl = gl;\n  this.shape = shape;\n  this.bounds = bounds;\n  this.objectOffset = objectOffset;\n  this.intensityBounds = [];\n  this._shader = shader;\n  this._pickShader = pickShader;\n  this._coordinateBuffer = coordinates;\n  this._vao = vao;\n  this._colorMap = colorMap;\n  this._contourShader = contourShader;\n  this._contourPickShader = contourPickShader;\n  this._contourBuffer = contourBuffer;\n  this._contourVAO = contourVAO;\n  this._contourOffsets = [[], [], []];\n  this._contourCounts = [[], [], []];\n  this._vertexCount = 0;\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0]);\n  this._dynamicBuffer = dynamicBuffer;\n  this._dynamicVAO = dynamicVAO;\n  this._dynamicOffsets = [0, 0, 0];\n  this._dynamicCounts = [0, 0, 0];\n  this.contourWidth = [1, 1, 1];\n  this.contourLevels = [[1], [1], [1]];\n  this.contourTint = [0, 0, 0];\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]];\n  this.showContour = true;\n  this.showSurface = true;\n  this.enableHighlight = [true, true, true];\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.highlightTint = [1, 1, 1];\n  this.highlightLevel = [-1, -1, -1];\n\n  // Dynamic contour options\n  this.enableDynamic = [true, true, true];\n  this.dynamicLevel = [NaN, NaN, NaN];\n  this.dynamicColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\n  this.dynamicTint = [1, 1, 1];\n  this.dynamicWidth = [1, 1, 1];\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]];\n  this.surfaceProject = [false, false, false];\n  this.contourProject = [[false, false, false], [false, false, false], [false, false, false]];\n  this.colorBounds = [false, false];\n\n  // Store xyz fields, need this for picking\n  this._field = [ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0]), ndarray(pool.mallocFloat(1024), [0, 0])];\n  this.pickId = 1;\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]];\n  this.snapToData = false;\n  this.pixelRatio = 1;\n  this.opacity = 1.0;\n  this.lightPosition = [10, 10000, 0];\n  this.ambientLight = 0.8;\n  this.diffuseLight = 0.8;\n  this.specularLight = 2.0;\n  this.roughness = 0.5;\n  this.fresnel = 1.5;\n  this.vertexColor = 0;\n  this.dirty = true;\n}\nvar proto = SurfacePlot.prototype;\nproto.genColormap = function (name, opacityscale) {\n  var hasAlpha = false;\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : c[3];\n    if (a < 1) hasAlpha = true;\n    return [c[0], c[1], c[2], 255 * a];\n  })]);\n  ops.divseq(x, 255.0);\n  this.hasAlphaScale = hasAlpha;\n  return x;\n};\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.hasAlphaScale;\n};\nproto.isOpaque = function () {\n  return !this.isTransparent();\n};\nproto.pickSlots = 1;\nproto.setPickBase = function (id) {\n  this.pickId = id;\n};\nfunction getOpacityFromScale(ratio, opacityscale) {\n  // copied form gl-mesh3d\n  if (!opacityscale) return 1;\n  if (!opacityscale.length) return 1;\n  for (var i = 0; i < opacityscale.length; ++i) {\n    if (opacityscale.length < 2) return 1;\n    if (opacityscale[i][0] === ratio) return opacityscale[i][1];\n    if (opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0]);\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1];\n    }\n  }\n  return 1;\n}\nvar ZERO_VEC = [0, 0, 0];\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [[[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]], [[0, 0, 0], [0, 0, 0]]]\n};\nfunction computeProjectionData(camera, obj) {\n  var i, j, k;\n\n  // Compute cube properties\n  var cubeAxis = obj.axes && obj.axes.lastCubeProps.axis || ZERO_VEC;\n  var showSurface = obj.showSurface;\n  var showContour = obj.showContour;\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i];\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j];\n    }\n  }\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i];\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0;\n    }\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1;\n    }\n    axisSquish[5 * i] = 0;\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i];\n    multiply(axisSquish, camera.model, axisSquish);\n    var nclipBounds = PROJECT_DATA.clipBounds[i];\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j];\n      }\n    }\n    nclipBounds[0][i] = -1e8;\n    nclipBounds[1][i] = 1e8;\n  }\n  PROJECT_DATA.showSurface = showSurface;\n  PROJECT_DATA.showContour = showContour;\n  return PROJECT_DATA;\n}\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n};\nvar MATRIX_INVERSE = IDENTITY.slice();\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1];\nfunction drawCore(params, transparent) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n  this._colorMap.bind(0);\n  var uniforms = UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]];\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.contourColor = this.contourColor[0];\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model);\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n  uniforms.kambient = this.ambientLight;\n  uniforms.kdiffuse = this.diffuseLight;\n  uniforms.kspecular = this.specularLight;\n  uniforms.roughness = this.roughness;\n  uniforms.fresnel = this.fresnel;\n  uniforms.opacity = this.opacity;\n  uniforms.height = 0.0;\n  uniforms.permutation = DEFAULT_PERM;\n  uniforms.vertexColor = this.vertexColor;\n\n  // Compute camera matrix inverse\n  var invCameraMatrix = MATRIX_INVERSE;\n  multiply(invCameraMatrix, uniforms.view, uniforms.model);\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix);\n  invert(invCameraMatrix, invCameraMatrix);\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15];\n  }\n  var w = invCameraMatrix[15];\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3];\n  }\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i];\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j];\n    }\n    uniforms.lightPosition[i] = s / w;\n  }\n  var projectData = computeProjectionData(uniforms, this);\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._shader.bind();\n    this._shader.uniforms = uniforms;\n\n    // Draw it\n    this._vao.bind();\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue;\n      }\n      this._shader.uniforms.model = projectData.projections[i];\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i];\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n    this._vao.unbind();\n  }\n  if (projectData.showContour) {\n    var shader = this._contourShader;\n\n    // Don't apply lighting to contours\n    uniforms.kambient = 1.0;\n    uniforms.kdiffuse = 0.0;\n    uniforms.kspecular = 0.0;\n    uniforms.opacity = 1.0;\n    shader.bind();\n    shader.uniforms = uniforms;\n\n    // Draw contour lines\n    var vao = this._contourVAO;\n    vao.bind();\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio);\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i];\n          shader.uniforms.contourTint = this.highlightTint[i];\n        } else if (j === 0 || j - 1 === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i];\n          shader.uniforms.contourTint = this.contourTint[i];\n        }\n        if (!this._contourCounts[i][j]) {\n          continue;\n        }\n        shader.uniforms.height = this.contourLevels[i][j];\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j]);\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j];\n            shader.uniforms.contourTint = this.highlightTint[j];\n          } else if (k === 0 || k - 1 === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j];\n            shader.uniforms.contourTint = this.contourTint[j];\n          }\n          if (!this._contourCounts[j][k]) {\n            continue;\n          }\n          shader.uniforms.height = this.contourLevels[j][k];\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n        }\n      }\n    }\n    vao.unbind();\n\n    // Draw dynamic contours\n    vao = this._dynamicVAO;\n    vao.bind();\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue;\n      }\n      shader.uniforms.model = uniforms.model;\n      shader.uniforms.clipBounds = uniforms.clipBounds;\n      shader.uniforms.permutation = PERMUTATIONS[i];\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio);\n      shader.uniforms.contourColor = this.dynamicColor[i];\n      shader.uniforms.contourTint = this.dynamicTint[i];\n      shader.uniforms.height = this.dynamicLevel[i];\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue;\n        }\n        shader.uniforms.model = projectData.projections[j];\n        shader.uniforms.clipBounds = projectData.clipBounds[j];\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i]);\n      }\n    }\n    vao.unbind();\n  }\n}\nproto.draw = function (params) {\n  return drawCore.call(this, params, false);\n};\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true);\n};\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n};\nproto.drawPick = function (params) {\n  params = params || {};\n  var gl = this.gl;\n  gl.disable(gl.CULL_FACE);\n  var uniforms = PICK_UNIFORMS;\n  uniforms.model = params.model || IDENTITY;\n  uniforms.view = params.view || IDENTITY;\n  uniforms.projection = params.projection || IDENTITY;\n  uniforms.shape = this._field[2].shape;\n  uniforms.pickId = this.pickId / 255.0;\n  uniforms.lowerBound = this.bounds[0];\n  uniforms.upperBound = this.bounds[1];\n  uniforms.objectOffset = this.objectOffset;\n  uniforms.permutation = DEFAULT_PERM;\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i];\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8);\n    }\n  }\n  var projectData = computeProjectionData(uniforms, this);\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind();\n    this._pickShader.uniforms = uniforms;\n\n    // Draw it\n    this._vao.bind();\n    this._vao.draw(gl.TRIANGLES, this._vertexCount);\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue;\n      }\n      this._pickShader.uniforms.model = projectData.projections[i];\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i];\n      this._vao.draw(gl.TRIANGLES, this._vertexCount);\n    }\n    this._vao.unbind();\n  }\n  if (projectData.showContour) {\n    var shader = this._contourPickShader;\n    shader.bind();\n    shader.uniforms = uniforms;\n    var vao = this._contourVAO;\n    vao.bind();\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n      shader.uniforms.permutation = PERMUTATIONS[j];\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i];\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i]);\n        }\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i];\n      shader.uniforms.clipBounds = projectData.clipBounds[i];\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue;\n        }\n        shader.uniforms.permutation = PERMUTATIONS[j];\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio);\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k];\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k]);\n          }\n        }\n      }\n    }\n    vao.unbind();\n  }\n};\nproto.pick = function (selection) {\n  if (!selection) {\n    return null;\n  }\n  if (selection.id !== this.pickId) {\n    return null;\n  }\n  var shape = this._field[2].shape;\n  var result = this._pickResult;\n\n  // Compute uv coordinate\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0;\n  var ix = Math.floor(x);\n  var fx = x - ix;\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0;\n  var iy = Math.floor(y);\n  var fy = y - iy;\n  ix += 1;\n  iy += 1;\n\n  // Compute xyz coordinate\n  var pos = result.position;\n  pos[0] = pos[1] = pos[2] = 0;\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx;\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy;\n      var r = ix + dx;\n      var c = iy + dy;\n      var w = s * t;\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w;\n      }\n    }\n  }\n\n  // Find closest level\n  var levelIndex = this._pickResult.level;\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j]);\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0;\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]];\n      var b = this.contourLevels[j][levelIndex[j] + 1];\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1;\n      }\n    }\n  }\n  result.index[0] = fx < 0.5 ? ix : ix + 1;\n  result.index[1] = fy < 0.5 ? iy : iy + 1;\n  result.uv[0] = x / shape[0];\n  result.uv[1] = y / shape[1];\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1]);\n  }\n  return result;\n};\nproto.padField = function (dstField, srcField) {\n  var srcShape = srcField.shape.slice();\n  var dstShape = dstField.shape.slice();\n\n  // Center\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField);\n\n  // Edges\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1), srcField.hi(srcShape[0], 1));\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1), srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1));\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]), srcField.hi(1));\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]), srcField.lo(srcShape[0] - 1));\n  // Corners\n  dstField.set(0, 0, srcField.get(0, 0));\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1));\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0));\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1));\n};\nfunction handleArray(param, ctor) {\n  if (Array.isArray(param)) {\n    return [ctor(param[0]), ctor(param[1]), ctor(param[2])];\n  }\n  return [ctor(param), ctor(param), ctor(param)];\n}\nfunction toColor(x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1];\n    }\n    return [x[0], x[1], x[2], x[3]];\n  }\n  return [0, 0, 0, 1];\n}\nfunction handleColor(param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [toColor(param[0]), toColor(param[1]), toColor(param[2])];\n    } else {\n      var c = toColor(param);\n      return [c.slice(), c.slice(), c.slice()];\n    }\n  }\n}\nproto.update = function (params) {\n  params = params || {};\n  this.objectOffset = params.objectOffset || this.objectOffset;\n  this.dirty = true;\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number);\n  }\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean);\n  }\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface;\n  }\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean);\n  }\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor);\n  }\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean);\n    });\n  }\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject;\n  }\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor);\n  }\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number);\n  }\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number);\n  }\n  if ('opacity' in params) {\n    this.opacity = params.opacity;\n  }\n  if ('opacityscale' in params) {\n    this.opacityscale = params.opacityscale;\n  }\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds;\n  }\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n  if ('colormap' in params) {\n    this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale));\n  }\n  var field = params.field || params.coords && params.coords[2] || null;\n  var levelsChanged = false;\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2);\n    } else {\n      field = this._field[2].hi(0, 0);\n    }\n  }\n\n  // Update field\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2);\n\n    // Resize if necessary\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data);\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize));\n    }\n\n    // Pad field\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2]);\n    this.padField(this._field[2], field);\n\n    // Save shape of field\n    this.shape = field.shape.slice();\n    var shape = this.shape;\n\n    // Resize coordinate fields if necessary\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data);\n        this._field[i].data = pool.mallocFloat(this._field[2].size);\n      }\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2]);\n    }\n\n    // Generate x/y coordinates\n    if (params.coords) {\n      var coords = params.coords;\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y');\n      }\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i];\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape');\n          }\n        }\n        this.padField(this._field[i], coord);\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks;\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks');\n      }\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i];\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick);\n        }\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length');\n        }\n        // Make a copy view of the tick array\n        var tick2 = ndarray(tick.data, shape);\n        tick2.stride[i] = tick.stride[0];\n        tick2.stride[i ^ 1] = 0;\n\n        // Fill in field array\n        this.padField(this._field[i], tick2);\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0];\n        offset[i] = 1;\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0);\n      }\n      this._field[0].set(0, 0, 0);\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j);\n      }\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1);\n      this._field[1].set(0, 0, 0);\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j);\n      }\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1);\n    }\n\n    // Save shape\n    var fields = this._field;\n\n    // Compute surface normals\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2]);\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror');\n    }\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3]);\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0);\n        var dxdv = dfields.get(0, i, j, 1);\n        var dydu = dfields.get(1, i, j, 0);\n        var dydv = dfields.get(1, i, j, 1);\n        var dzdu = dfields.get(2, i, j, 0);\n        var dzdv = dfields.get(2, i, j, 1);\n        var nx = dydu * dzdv - dydv * dzdu;\n        var ny = dzdu * dxdv - dzdv * dxdu;\n        var nz = dxdu * dydv - dxdv * dydu;\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz);\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz));\n          if (nl < 1e-8) {\n            nz = 1.0;\n            ny = nx = 0.0;\n            nl = 1.0;\n          } else {\n            nl = 1.0 / nl;\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl);\n        }\n        normals.set(i, j, 0, nx * nl);\n        normals.set(i, j, 1, ny * nl);\n        normals.set(i, j, 2, nz * nl);\n      }\n    }\n    pool.free(dfields.data);\n\n    // Initialize surface\n    var lo = [Infinity, Infinity, Infinity];\n    var hi = [-Infinity, -Infinity, -Infinity];\n    var lo_intensity = Infinity;\n    var hi_intensity = -Infinity;\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6;\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count));\n    var tptr = 0;\n    var vertexCount = 0;\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop: for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy);\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop;\n              }\n            }\n          }\n        }\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0];\n          var c = j + QUAD[k][1];\n          var tx = this._field[0].get(r + 1, c + 1);\n          var ty = this._field[1].get(r + 1, c + 1);\n          f = this._field[2].get(r + 1, c + 1);\n          nx = normals.get(r + 1, c + 1, 0);\n          ny = normals.get(r + 1, c + 1, 1);\n          nz = normals.get(r + 1, c + 1, 2);\n          if (params.intensity) {\n            vf = params.intensity.get(r, c);\n          }\n          var vf = params.intensity ? params.intensity.get(r, c) : f + this.objectOffset[2];\n          tverts[tptr++] = r;\n          tverts[tptr++] = c;\n          tverts[tptr++] = tx;\n          tverts[tptr++] = ty;\n          tverts[tptr++] = f;\n          tverts[tptr++] = 0;\n          tverts[tptr++] = vf;\n          tverts[tptr++] = nx;\n          tverts[tptr++] = ny;\n          tverts[tptr++] = nz;\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0]);\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1]);\n          lo[2] = Math.min(lo[2], f + this.objectOffset[2]);\n          lo_intensity = Math.min(lo_intensity, vf);\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0]);\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1]);\n          hi[2] = Math.max(hi[2], f + this.objectOffset[2]);\n          hi_intensity = Math.max(hi_intensity, vf);\n          vertexCount += 1;\n        }\n      }\n    }\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0];\n      hi_intensity = +params.intensityBounds[1];\n    }\n\n    // Scale all vertex intensities\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity);\n    }\n    this._vertexCount = vertexCount;\n    this._coordinateBuffer.update(tverts.subarray(0, tptr));\n    pool.freeFloat(tverts);\n    pool.free(normals.data);\n\n    // Update bounds\n    this.bounds = [lo, hi];\n\n    // Save intensity\n    this.intensity = params.intensity || this._field[2];\n    if (this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n      levelsChanged = true;\n    }\n\n    // Save intensity bound\n    this.intensityBounds = [lo_intensity, hi_intensity];\n  }\n\n  // Update level crossings\n  if ('levels' in params) {\n    var levels = params.levels;\n    if (!Array.isArray(levels[0])) {\n      levels = [[], [], levels];\n    } else {\n      levels = levels.slice();\n    }\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice();\n      levels[i].sort(function (a, b) {\n        return a - b;\n      });\n    }\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i];\n      }\n    }\n    change_test: for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true;\n        break;\n      }\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true;\n          break change_test;\n        }\n      }\n    }\n    this.contourLevels = levels;\n  }\n  if (levelsChanged) {\n    fields = this._field;\n    shape = this.shape;\n\n    // Update contour lines\n    var contourVerts = [];\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim];\n      var levelOffsets = [];\n      var levelCounts = [];\n      var parts = [0, 0, 0];\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i]);\n        levelOffsets.push(contourVerts.length / 5 | 0);\n        vertexCount = 0;\n        edge_loop: for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j];\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]];\n            var x = p[0];\n            var ix = Math.floor(x) | 0;\n            var fx = x - ix;\n            var y = p[1];\n            var iy = Math.floor(y) | 0;\n            var fy = y - iy;\n            var hole = false;\n            axis_loop: for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0;\n              var iu = (dim + axis + 1) % 3;\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx;\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0;\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy;\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0;\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c);\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0]);\n                  }\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true;\n                    break axis_loop;\n                  }\n                  var w = s * t;\n                  parts[axis] += w * f;\n                }\n              }\n            }\n            if (!hole) {\n              contourVerts.push(parts[0], parts[1], p[0], p[1], parts[2]);\n              vertexCount += 1;\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop();\n                }\n                vertexCount -= 1;\n              }\n              continue edge_loop;\n            }\n          }\n        }\n        levelCounts.push(vertexCount);\n      }\n\n      // Store results\n      this._contourOffsets[dim] = levelOffsets;\n      this._contourCounts[dim] = levelCounts;\n    }\n    var floatBuffer = pool.mallocFloat(contourVerts.length);\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i];\n    }\n    this._contourBuffer.update(floatBuffer);\n    pool.freeFloat(floatBuffer);\n  }\n};\nproto.dispose = function () {\n  this._shader.dispose();\n  this._vao.dispose();\n  this._coordinateBuffer.dispose();\n  this._colorMap.dispose();\n  this._contourBuffer.dispose();\n  this._contourVAO.dispose();\n  this._contourShader.dispose();\n  this._contourPickShader.dispose();\n  this._dynamicBuffer.dispose();\n  this._dynamicVAO.dispose();\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data);\n  }\n};\nproto.highlight = function (selection) {\n  var i;\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0];\n    this.dyanamicLevel = [NaN, NaN, NaN];\n    this.highlightLevel = [-1, -1, -1];\n    return;\n  }\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i];\n    } else {\n      this.highlightLevel[i] = -1;\n    }\n  }\n  var levels;\n  if (this.snapToData) {\n    levels = selection.dataCoordinate;\n  } else {\n    levels = selection.position;\n  }\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i];\n  }\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) && (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) && (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return;\n  }\n  var vertexCount = 0;\n  var shape = this.shape;\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1]);\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN;\n      this._dynamicCounts[d] = 0;\n      continue;\n    }\n    this.dynamicLevel[d] = levels[d];\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var f = this._field[d];\n    var g = this._field[u];\n    var h = this._field[v];\n    var graph = surfaceNets(f, levels[d]);\n    var edges = graph.cells;\n    var positions = graph.positions;\n    this._dynamicOffsets[d] = vertexCount;\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i];\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]];\n        var x = +p[0];\n        var ix = x | 0;\n        var jx = Math.min(ix + 1, shape[0]) | 0;\n        var fx = x - ix;\n        var hx = 1.0 - fx;\n        var y = +p[1];\n        var iy = y | 0;\n        var jy = Math.min(iy + 1, shape[1]) | 0;\n        var fy = y - iy;\n        var hy = 1.0 - fy;\n        var w00 = hx * hy;\n        var w01 = hx * fy;\n        var w10 = fx * hy;\n        var w11 = fx * fy;\n        var cu = w00 * g.get(ix, iy) + w01 * g.get(ix, jy) + w10 * g.get(jx, iy) + w11 * g.get(jx, jy);\n        var cv = w00 * h.get(ix, iy) + w01 * h.get(ix, jy) + w10 * h.get(jx, iy) + w11 * h.get(jx, jy);\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1;\n          }\n          break;\n        }\n        scratchBuffer[2 * vertexCount + 0] = cu;\n        scratchBuffer[2 * vertexCount + 1] = cv;\n        vertexCount += 1;\n      }\n    }\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d];\n  }\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount));\n  pool.freeFloat(scratchBuffer);\n};\nfunction createSurfacePlot(params) {\n  var gl = params.gl;\n  var shader = createShader(gl);\n  var pickShader = createPickShader(gl);\n  var contourShader = createContourShader(gl);\n  var contourPickShader = createPickContourShader(gl);\n  var coordinateBuffer = createBuffer(gl);\n  var vao = createVAO(gl, [{\n    buffer: coordinateBuffer,\n    size: 4,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 0\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 16\n  }, {\n    buffer: coordinateBuffer,\n    size: 3,\n    stride: SURFACE_VERTEX_SIZE,\n    offset: 28\n  }]);\n  var contourBuffer = createBuffer(gl);\n  var contourVAO = createVAO(gl, [{\n    buffer: contourBuffer,\n    size: 4,\n    stride: 20,\n    offset: 0\n  }, {\n    buffer: contourBuffer,\n    size: 1,\n    stride: 20,\n    offset: 16\n  }]);\n  var dynamicBuffer = createBuffer(gl);\n  var dynamicVAO = createVAO(gl, [{\n    buffer: dynamicBuffer,\n    size: 2,\n    type: gl.FLOAT\n  }]);\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE);\n  cmap.minFilter = gl.LINEAR;\n  cmap.magFilter = gl.LINEAR;\n  var surface = new SurfacePlot(gl, [0, 0],\n  // shape\n  [[0, 0, 0], [0, 0, 0]],\n  // bounds\n  shader, pickShader, coordinateBuffer, vao, cmap, contourShader, contourPickShader, contourBuffer, contourVAO, dynamicBuffer, dynamicVAO, [0, 0, 0] // objectOffset\n  );\n\n  var nparams = {\n    levels: [[], [], []]\n  };\n  for (var id in params) {\n    nparams[id] = params[id];\n  }\n  nparams.colormap = nparams.colormap || 'jet';\n  surface.update(nparams);\n  return surface;\n}","map":{"version":3,"names":["module","exports","createSurfacePlot","bits","require","createBuffer","createVAO","createTexture","pool","colormap","ops","pack","ndarray","surfaceNets","multiply","invert","bsearch","gradient","shaders","createShader","createContourShader","createPickShader","createPickContourShader","SURFACE_VERTEX_SIZE","IDENTITY","QUAD","PERMUTATIONS","i","p","u","v","SurfacePickResult","position","index","uv","level","dataCoordinate","N_COLORS","SurfacePlot","gl","shape","bounds","shader","pickShader","coordinates","vao","colorMap","contourShader","contourPickShader","contourBuffer","contourVAO","dynamicBuffer","dynamicVAO","objectOffset","intensityBounds","_shader","_pickShader","_coordinateBuffer","_vao","_colorMap","_contourShader","_contourPickShader","_contourBuffer","_contourVAO","_contourOffsets","_contourCounts","_vertexCount","_pickResult","_dynamicBuffer","_dynamicVAO","_dynamicOffsets","_dynamicCounts","contourWidth","contourLevels","contourTint","contourColor","showContour","showSurface","enableHighlight","highlightColor","highlightTint","highlightLevel","enableDynamic","dynamicLevel","NaN","dynamicColor","dynamicTint","dynamicWidth","axesBounds","Infinity","surfaceProject","contourProject","colorBounds","_field","mallocFloat","pickId","clipBounds","snapToData","pixelRatio","opacity","lightPosition","ambientLight","diffuseLight","specularLight","roughness","fresnel","vertexColor","dirty","proto","prototype","genColormap","name","opacityscale","hasAlpha","x","nshades","format","map","c","a","getOpacityFromScale","divseq","hasAlphaScale","isTransparent","isOpaque","pickSlots","setPickBase","id","ratio","length","d","ZERO_VEC","PROJECT_DATA","projections","slice","computeProjectionData","camera","obj","j","k","cubeAxis","axes","lastCubeProps","axis","axisSquish","model","nclipBounds","UNIFORMS","view","projection","inverseModel","lowerBound","upperBound","height","permutation","zOffset","kambient","kdiffuse","kspecular","eyePosition","MATRIX_INVERSE","DEFAULT_PERM","drawCore","params","transparent","disable","CULL_FACE","bind","uniforms","clipClamped","Math","min","max","invCameraMatrix","w","s","projectData","draw","TRIANGLES","vertexCount","unbind","lineWidth","LINES","call","drawTransparent","PICK_UNIFORMS","drawPick","pick","selection","result","value","ix","floor","fx","y","iy","fy","pos","dx","dy","t","r","get","levelIndex","le","b","abs","padField","dstField","srcField","srcShape","dstShape","assign","lo","hi","set","handleArray","param","ctor","Array","isArray","toColor","handleColor","update","Number","Boolean","setPixels","field","coords","levelsChanged","fsize","data","freeFloat","nextPow2","size","Error","coord","ticks","tick","tick2","stride","offset","fields","dfields","normals","dxdu","dxdv","dydu","dydv","dzdu","dzdv","nx","ny","nz","nl","sqrt","free","lo_intensity","hi_intensity","count","tverts","tptr","j_loop","f","isNaN","isFinite","tx","ty","intensity","vf","subarray","levels","sort","change_test","contourVerts","dim","contourLevel","levelOffsets","levelCounts","parts","graph","push","edge_loop","cells","e","positions","hole","axis_loop","iu","l","pop","floatBuffer","dispose","highlight","dyanamicLevel","scratchBuffer","g","h","edges","jx","hx","jy","hy","w00","w01","w10","w11","cu","cv","coordinateBuffer","buffer","type","FLOAT","cmap","RGBA","UNSIGNED_BYTE","minFilter","LINEAR","magFilter","surface","nparams"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/gl-surface3d/surface.js"],"sourcesContent":["'use strict'\n\nmodule.exports = createSurfacePlot\n\nvar bits = require('bit-twiddle')\nvar createBuffer = require('gl-buffer')\nvar createVAO = require('gl-vao')\nvar createTexture = require('gl-texture2d')\nvar pool = require('typedarray-pool')\nvar colormap = require('colormap')\nvar ops = require('ndarray-ops')\nvar pack = require('ndarray-pack')\nvar ndarray = require('ndarray')\nvar surfaceNets = require('surface-nets')\nvar multiply = require('gl-mat4/multiply')\nvar invert = require('gl-mat4/invert')\nvar bsearch = require('binary-search-bounds')\nvar gradient = require('ndarray-gradient')\nvar shaders = require('./lib/shaders')\n\nvar createShader = shaders.createShader\nvar createContourShader = shaders.createContourShader\nvar createPickShader = shaders.createPickShader\nvar createPickContourShader = shaders.createPickContourShader\n\nvar SURFACE_VERTEX_SIZE = 4 * (4 + 3 + 3)\n\nvar IDENTITY = [\n  1, 0, 0, 0,\n  0, 1, 0, 0,\n  0, 0, 1, 0,\n  0, 0, 0, 1 ]\n\nvar QUAD = [\n  [0, 0],\n  [0, 1],\n  [1, 0],\n  [1, 1],\n  [1, 0],\n  [0, 1]\n]\n\nvar PERMUTATIONS = [\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0],\n  [0, 0, 0, 0, 0, 0, 0, 0, 0]\n]\n\n;(function () {\n  for (var i = 0; i < 3; ++i) {\n    var p = PERMUTATIONS[i]\n    var u = (i + 1) % 3\n    var v = (i + 2) % 3\n    p[u + 0] = 1\n    p[v + 3] = 1\n    p[i + 6] = 1\n  }\n})()\n\nfunction SurfacePickResult (position, index, uv, level, dataCoordinate) {\n  this.position = position\n  this.index = index\n  this.uv = uv\n  this.level = level\n  this.dataCoordinate = dataCoordinate\n}\n\nvar N_COLORS = 256\n\nfunction SurfacePlot (\n  gl,\n  shape,\n  bounds,\n  shader,\n  pickShader,\n  coordinates,\n  vao,\n  colorMap,\n  contourShader,\n  contourPickShader,\n  contourBuffer,\n  contourVAO,\n  dynamicBuffer,\n  dynamicVAO,\n  objectOffset) {\n  this.gl = gl\n  this.shape = shape\n  this.bounds = bounds\n  this.objectOffset = objectOffset\n  this.intensityBounds = []\n\n  this._shader = shader\n  this._pickShader = pickShader\n  this._coordinateBuffer = coordinates\n  this._vao = vao\n  this._colorMap = colorMap\n\n  this._contourShader = contourShader\n  this._contourPickShader = contourPickShader\n  this._contourBuffer = contourBuffer\n  this._contourVAO = contourVAO\n  this._contourOffsets = [[], [], []]\n  this._contourCounts = [[], [], []]\n  this._vertexCount = 0\n\n  this._pickResult = new SurfacePickResult([0, 0, 0], [0, 0], [0, 0], [0, 0, 0], [0, 0, 0])\n\n  this._dynamicBuffer = dynamicBuffer\n  this._dynamicVAO = dynamicVAO\n  this._dynamicOffsets = [0, 0, 0]\n  this._dynamicCounts = [0, 0, 0]\n\n  this.contourWidth = [ 1, 1, 1 ]\n  this.contourLevels = [[1], [1], [1]]\n  this.contourTint = [0, 0, 0]\n  this.contourColor = [[0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1], [0.5, 0.5, 0.5, 1]]\n\n  this.showContour = true\n  this.showSurface = true\n\n  this.enableHighlight = [true, true, true]\n  this.highlightColor = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]]\n  this.highlightTint = [ 1, 1, 1 ]\n  this.highlightLevel = [-1, -1, -1]\n\n  // Dynamic contour options\n  this.enableDynamic = [ true, true, true ]\n  this.dynamicLevel = [ NaN, NaN, NaN ]\n  this.dynamicColor = [ [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1] ]\n  this.dynamicTint = [ 1, 1, 1 ]\n  this.dynamicWidth = [ 1, 1, 1 ]\n\n  this.axesBounds = [[Infinity, Infinity, Infinity], [-Infinity, -Infinity, -Infinity]]\n  this.surfaceProject = [ false, false, false ]\n  this.contourProject = [[ false, false, false ],\n    [ false, false, false ],\n    [ false, false, false ]]\n\n  this.colorBounds = [ false, false ]\n\n  // Store xyz fields, need this for picking\n  this._field = [\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]),\n    ndarray(pool.mallocFloat(1024), [0, 0]) ]\n\n  this.pickId = 1\n  this.clipBounds = [[-Infinity, -Infinity, -Infinity], [Infinity, Infinity, Infinity]]\n\n  this.snapToData = false\n\n  this.pixelRatio = 1\n\n  this.opacity = 1.0\n\n  this.lightPosition = [10, 10000, 0]\n  this.ambientLight = 0.8\n  this.diffuseLight = 0.8\n  this.specularLight = 2.0\n  this.roughness = 0.5\n  this.fresnel = 1.5\n  this.vertexColor = 0\n\n  this.dirty = true\n}\n\nvar proto = SurfacePlot.prototype\n\nproto.genColormap = function (name, opacityscale) {\n  var hasAlpha = false\n\n  var x = pack([colormap({\n    colormap: name,\n    nshades: N_COLORS,\n    format: 'rgba'\n  }).map(function (c, i) {\n    var a = opacityscale ? getOpacityFromScale(i / 255.0, opacityscale) : c[3]\n    if(a < 1) hasAlpha = true\n    return [c[0], c[1], c[2], 255 * a]\n  })])\n  ops.divseq(x, 255.0)\n\n  this.hasAlphaScale = hasAlpha\n  return x\n}\n\nproto.isTransparent = function () {\n  return this.opacity < 1 || this.hasAlphaScale\n}\n\nproto.isOpaque = function () {\n  return !this.isTransparent()\n}\n\nproto.pickSlots = 1\n\nproto.setPickBase = function (id) {\n  this.pickId = id\n}\n\nfunction getOpacityFromScale(ratio, opacityscale) { // copied form gl-mesh3d\n  if(!opacityscale) return 1\n  if(!opacityscale.length) return 1\n\n  for(var i = 0; i < opacityscale.length; ++i) {\n    if(opacityscale.length < 2) return 1\n    if(opacityscale[i][0] === ratio) return opacityscale[i][1]\n    if(opacityscale[i][0] > ratio && i > 0) {\n      var d = (opacityscale[i][0] - ratio) / (opacityscale[i][0] - opacityscale[i - 1][0])\n      return opacityscale[i][1] * (1 - d) + d * opacityscale[i - 1][1]\n    }\n  }\n\n  return 1\n}\n\nvar ZERO_VEC = [0, 0, 0]\n\nvar PROJECT_DATA = {\n  showSurface: false,\n  showContour: false,\n  projections: [IDENTITY.slice(), IDENTITY.slice(), IDENTITY.slice()],\n  clipBounds: [\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]],\n    [[0, 0, 0], [0, 0, 0]]]\n}\n\nfunction computeProjectionData (camera, obj) {\n  var i, j, k\n\n  // Compute cube properties\n  var cubeAxis = (obj.axes && obj.axes.lastCubeProps.axis) || ZERO_VEC\n\n  var showSurface = obj.showSurface\n  var showContour = obj.showContour\n\n  for (i = 0; i < 3; ++i) {\n    showSurface = showSurface || obj.surfaceProject[i]\n    for (j = 0; j < 3; ++j) {\n      showContour = showContour || obj.contourProject[i][j]\n    }\n  }\n\n  for (i = 0; i < 3; ++i) {\n    // Construct projection onto axis\n    var axisSquish = PROJECT_DATA.projections[i]\n    for (j = 0; j < 16; ++j) {\n      axisSquish[j] = 0\n    }\n    for (j = 0; j < 4; ++j) {\n      axisSquish[5 * j] = 1\n    }\n    axisSquish[5 * i] = 0\n    axisSquish[12 + i] = obj.axesBounds[+(cubeAxis[i] > 0)][i]\n    multiply(axisSquish, camera.model, axisSquish)\n\n    var nclipBounds = PROJECT_DATA.clipBounds[i]\n    for (k = 0; k < 2; ++k) {\n      for (j = 0; j < 3; ++j) {\n        nclipBounds[k][j] = camera.clipBounds[k][j]\n      }\n    }\n    nclipBounds[0][i] = -1e8\n    nclipBounds[1][i] = 1e8\n  }\n\n  PROJECT_DATA.showSurface = showSurface\n  PROJECT_DATA.showContour = showContour\n\n  return PROJECT_DATA\n}\n\nvar UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY.slice(),\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  colorMap: 0,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  contourTint: 0,\n  contourColor: [0, 0, 0, 1],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  zOffset: -1e-4,\n  objectOffset: [0, 0, 0],\n  kambient: 1,\n  kdiffuse: 1,\n  kspecular: 1,\n  lightPosition: [1000, 1000, 1000],\n  eyePosition: [0, 0, 0],\n  roughness: 1,\n  fresnel: 1,\n  opacity: 1,\n  vertexColor: 0\n}\n\nvar MATRIX_INVERSE = IDENTITY.slice()\nvar DEFAULT_PERM = [1, 0, 0, 0, 1, 0, 0, 0, 1]\n\nfunction drawCore (params, transparent) {\n  params = params || {}\n  var gl = this.gl\n\n  gl.disable(gl.CULL_FACE)\n\n  this._colorMap.bind(0)\n\n  var uniforms = UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.lowerBound = [this.bounds[0][0], this.bounds[0][1], this.colorBounds[0] || this.bounds[0][2]]\n  uniforms.upperBound = [this.bounds[1][0], this.bounds[1][1], this.colorBounds[1] || this.bounds[1][2]]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.contourColor = this.contourColor[0]\n\n  uniforms.inverseModel = invert(uniforms.inverseModel, uniforms.model)\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  uniforms.kambient = this.ambientLight\n  uniforms.kdiffuse = this.diffuseLight\n  uniforms.kspecular = this.specularLight\n\n  uniforms.roughness = this.roughness\n  uniforms.fresnel = this.fresnel\n  uniforms.opacity = this.opacity\n\n  uniforms.height = 0.0\n  uniforms.permutation = DEFAULT_PERM\n\n  uniforms.vertexColor = this.vertexColor\n\n  // Compute camera matrix inverse\n  var invCameraMatrix = MATRIX_INVERSE\n  multiply(invCameraMatrix, uniforms.view, uniforms.model)\n  multiply(invCameraMatrix, uniforms.projection, invCameraMatrix)\n  invert(invCameraMatrix, invCameraMatrix)\n\n  for (i = 0; i < 3; ++i) {\n    uniforms.eyePosition[i] = invCameraMatrix[12 + i] / invCameraMatrix[15]\n  }\n\n  var w = invCameraMatrix[15]\n  for (i = 0; i < 3; ++i) {\n    w += this.lightPosition[i] * invCameraMatrix[4 * i + 3]\n  }\n  for (i = 0; i < 3; ++i) {\n    var s = invCameraMatrix[12 + i]\n    for (j = 0; j < 3; ++j) {\n      s += invCameraMatrix[4 * j + i] * this.lightPosition[j]\n    }\n    uniforms.lightPosition[i] = s / w\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface)  {\n    // Set up uniforms\n    this._shader.bind()\n    this._shader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n\n    if (this.showSurface && this._vertexCount) {\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i] || !this.vertexCount) {\n        continue\n      }\n      this._shader.uniforms.model = projectData.projections[i]\n      this._shader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourShader\n\n    // Don't apply lighting to contours\n    uniforms.kambient = 1.0\n    uniforms.kdiffuse = 0.0\n    uniforms.kspecular = 0.0\n    uniforms.opacity = 1.0\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    // Draw contour lines\n    var vao = this._contourVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.contourWidth[i] * this.pixelRatio)\n\n      for (j = 0; j < this.contourLevels[i].length; ++j) {\n        if (j === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.highlightColor[i]\n          shader.uniforms.contourTint = this.highlightTint[i]\n        } else if (j === 0 || (j - 1) === this.highlightLevel[i]) {\n          shader.uniforms.contourColor = this.contourColor[i]\n          shader.uniforms.contourTint = this.contourTint[i]\n        }\n        if (!this._contourCounts[i][j]) {\n          continue\n        }\n\n        shader.uniforms.height = this.contourLevels[i][j]\n        vao.draw(gl.LINES, this._contourCounts[i][j], this._contourOffsets[i][j])\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (k === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.highlightColor[j]\n            shader.uniforms.contourTint = this.highlightTint[j]\n          } else if (k === 0 || (k - 1) === this.highlightLevel[j]) {\n            shader.uniforms.contourColor = this.contourColor[j]\n            shader.uniforms.contourTint = this.contourTint[j]\n          }\n          if (!this._contourCounts[j][k]) {\n            continue\n          }\n\n          shader.uniforms.height = this.contourLevels[j][k]\n          vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n        }\n      }\n    }\n\n    vao.unbind()\n\n    // Draw dynamic contours\n    vao = this._dynamicVAO\n    vao.bind()\n\n    // Draw contour levels\n    for (i = 0; i < 3; ++i) {\n      if (this._dynamicCounts[i] === 0) {\n        continue\n      }\n\n      shader.uniforms.model = uniforms.model\n      shader.uniforms.clipBounds = uniforms.clipBounds\n      shader.uniforms.permutation = PERMUTATIONS[i]\n      gl.lineWidth(this.dynamicWidth[i] * this.pixelRatio)\n\n      shader.uniforms.contourColor = this.dynamicColor[i]\n      shader.uniforms.contourTint = this.dynamicTint[i]\n      shader.uniforms.height = this.dynamicLevel[i]\n      vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[j][i]) {\n          continue\n        }\n\n        shader.uniforms.model = projectData.projections[j]\n        shader.uniforms.clipBounds = projectData.clipBounds[j]\n        vao.draw(gl.LINES, this._dynamicCounts[i], this._dynamicOffsets[i])\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.draw = function (params) {\n  return drawCore.call(this, params, false)\n}\n\nproto.drawTransparent = function (params) {\n  return drawCore.call(this, params, true)\n}\n\nvar PICK_UNIFORMS = {\n  model: IDENTITY,\n  view: IDENTITY,\n  projection: IDENTITY,\n  inverseModel: IDENTITY,\n  clipBounds: [[0, 0, 0], [0, 0, 0]],\n  height: 0.0,\n  shape: [0, 0],\n  pickId: 0,\n  lowerBound: [0, 0, 0],\n  upperBound: [0, 0, 0],\n  zOffset: 0.0,\n  objectOffset: [0, 0, 0],\n  permutation: [1, 0, 0, 0, 1, 0, 0, 0, 1],\n  lightPosition: [0, 0, 0],\n  eyePosition: [0, 0, 0]\n}\n\nproto.drawPick = function (params) {\n  params = params || {}\n  var gl = this.gl\n  gl.disable(gl.CULL_FACE)\n\n  var uniforms = PICK_UNIFORMS\n  uniforms.model = params.model || IDENTITY\n  uniforms.view = params.view || IDENTITY\n  uniforms.projection = params.projection || IDENTITY\n  uniforms.shape = this._field[2].shape\n  uniforms.pickId = this.pickId / 255.0\n  uniforms.lowerBound = this.bounds[0]\n  uniforms.upperBound = this.bounds[1]\n  uniforms.objectOffset = this.objectOffset\n  uniforms.permutation = DEFAULT_PERM\n\n  for (var i = 0; i < 2; ++i) {\n    var clipClamped = uniforms.clipBounds[i]\n    for (var j = 0; j < 3; ++j) {\n      clipClamped[j] = Math.min(Math.max(this.clipBounds[i][j], -1e8), 1e8)\n    }\n  }\n\n  var projectData = computeProjectionData(uniforms, this)\n\n  if (projectData.showSurface) {\n    // Set up uniforms\n    this._pickShader.bind()\n    this._pickShader.uniforms = uniforms\n\n    // Draw it\n    this._vao.bind()\n    this._vao.draw(gl.TRIANGLES, this._vertexCount)\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      if (!this.surfaceProject[i]) {\n        continue\n      }\n      this._pickShader.uniforms.model = projectData.projections[i]\n      this._pickShader.uniforms.clipBounds = projectData.clipBounds[i]\n      this._vao.draw(gl.TRIANGLES, this._vertexCount)\n    }\n\n    this._vao.unbind()\n  }\n\n  if (projectData.showContour) {\n    var shader = this._contourPickShader\n\n    shader.bind()\n    shader.uniforms = uniforms\n\n    var vao = this._contourVAO\n    vao.bind()\n\n    for (j = 0; j < 3; ++j) {\n      gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n      shader.uniforms.permutation = PERMUTATIONS[j]\n      for (i = 0; i < this.contourLevels[j].length; ++i) {\n        if (this._contourCounts[j][i]) {\n          shader.uniforms.height = this.contourLevels[j][i]\n          vao.draw(gl.LINES, this._contourCounts[j][i], this._contourOffsets[j][i])\n        }\n      }\n    }\n\n    // Draw projections of surface\n    for (i = 0; i < 3; ++i) {\n      shader.uniforms.model = projectData.projections[i]\n      shader.uniforms.clipBounds = projectData.clipBounds[i]\n\n      for (j = 0; j < 3; ++j) {\n        if (!this.contourProject[i][j]) {\n          continue\n        }\n\n        shader.uniforms.permutation = PERMUTATIONS[j]\n        gl.lineWidth(this.contourWidth[j] * this.pixelRatio)\n        for (var k = 0; k < this.contourLevels[j].length; ++k) {\n          if (this._contourCounts[j][k]) {\n            shader.uniforms.height = this.contourLevels[j][k]\n            vao.draw(gl.LINES, this._contourCounts[j][k], this._contourOffsets[j][k])\n          }\n        }\n      }\n    }\n\n    vao.unbind()\n  }\n}\n\nproto.pick = function (selection) {\n  if (!selection) {\n    return null\n  }\n\n  if (selection.id !== this.pickId) {\n    return null\n  }\n\n  var shape = this._field[2].shape\n\n  var result = this._pickResult\n\n  // Compute uv coordinate\n  var x = shape[0] * (selection.value[0] + (selection.value[2] >> 4) / 16.0) / 255.0\n  var ix = Math.floor(x)\n  var fx = x - ix\n\n  var y = shape[1] * (selection.value[1] + (selection.value[2] & 15) / 16.0) / 255.0\n  var iy = Math.floor(y)\n  var fy = y - iy\n\n  ix += 1\n  iy += 1\n\n  // Compute xyz coordinate\n  var pos = result.position\n  pos[0] = pos[1] = pos[2] = 0\n  for (var dx = 0; dx < 2; ++dx) {\n    var s = dx ? fx : 1.0 - fx\n    for (var dy = 0; dy < 2; ++dy) {\n      var t = dy ? fy : 1.0 - fy\n\n      var r = ix + dx\n      var c = iy + dy\n      var w = s * t\n\n      for (var i = 0; i < 3; ++i) {\n        pos[i] += this._field[i].get(r, c) * w\n      }\n    }\n  }\n\n  // Find closest level\n  var levelIndex = this._pickResult.level\n  for (var j = 0; j < 3; ++j) {\n    levelIndex[j] = bsearch.le(this.contourLevels[j], pos[j])\n    if (levelIndex[j] < 0) {\n      if (this.contourLevels[j].length > 0) {\n        levelIndex[j] = 0\n      }\n    } else if (levelIndex[j] < this.contourLevels[j].length - 1) {\n      var a = this.contourLevels[j][levelIndex[j]]\n      var b = this.contourLevels[j][levelIndex[j] + 1]\n      if (Math.abs(a - pos[j]) > Math.abs(b - pos[j])) {\n        levelIndex[j] += 1\n      }\n    }\n  }\n\n  result.index[0] = fx < 0.5 ? ix : (ix + 1)\n  result.index[1] = fy < 0.5 ? iy : (iy + 1)\n\n  result.uv[0] = x / shape[0]\n  result.uv[1] = y / shape[1]\n\n  for (i = 0; i < 3; ++i) {\n    result.dataCoordinate[i] = this._field[i].get(result.index[0], result.index[1])\n  }\n\n  return result\n}\n\nproto.padField = function(dstField, srcField) {\n  var srcShape = srcField.shape.slice()\n  var dstShape = dstField.shape.slice()\n\n  // Center\n  ops.assign(dstField.lo(1, 1).hi(srcShape[0], srcShape[1]), srcField)\n\n  // Edges\n  ops.assign(dstField.lo(1).hi(srcShape[0], 1),\n    srcField.hi(srcShape[0], 1))\n  ops.assign(dstField.lo(1, dstShape[1] - 1).hi(srcShape[0], 1),\n    srcField.lo(0, srcShape[1] - 1).hi(srcShape[0], 1))\n  ops.assign(dstField.lo(0, 1).hi(1, srcShape[1]),\n    srcField.hi(1))\n  ops.assign(dstField.lo(dstShape[0] - 1, 1).hi(1, srcShape[1]),\n    srcField.lo(srcShape[0] - 1))\n  // Corners\n  dstField.set(0, 0, srcField.get(0, 0))\n  dstField.set(0, dstShape[1] - 1, srcField.get(0, srcShape[1] - 1))\n  dstField.set(dstShape[0] - 1, 0, srcField.get(srcShape[0] - 1, 0))\n  dstField.set(dstShape[0] - 1, dstShape[1] - 1, srcField.get(srcShape[0] - 1, srcShape[1] - 1))\n}\n\nfunction handleArray (param, ctor) {\n  if (Array.isArray(param)) {\n    return [ ctor(param[0]), ctor(param[1]), ctor(param[2]) ]\n  }\n  return [ ctor(param), ctor(param), ctor(param) ]\n}\n\nfunction toColor (x) {\n  if (Array.isArray(x)) {\n    if (x.length === 3) {\n      return [x[0], x[1], x[2], 1]\n    }\n    return [x[0], x[1], x[2], x[3]]\n  }\n  return [0, 0, 0, 1]\n}\n\nfunction handleColor (param) {\n  if (Array.isArray(param)) {\n    if (Array.isArray(param)) {\n      return [\n        toColor(param[0]),\n        toColor(param[1]),\n        toColor(param[2]) ]\n    } else {\n      var c = toColor(param)\n      return [\n        c.slice(),\n        c.slice(),\n        c.slice() ]\n    }\n  }\n}\n\nproto.update = function (params) {\n  params = params || {}\n\n  this.objectOffset = params.objectOffset || this.objectOffset\n\n  this.dirty = true\n\n  if ('contourWidth' in params) {\n    this.contourWidth = handleArray(params.contourWidth, Number)\n  }\n  if ('showContour' in params) {\n    this.showContour = handleArray(params.showContour, Boolean)\n  }\n  if ('showSurface' in params) {\n    this.showSurface = !!params.showSurface\n  }\n  if ('contourTint' in params) {\n    this.contourTint = handleArray(params.contourTint, Boolean)\n  }\n  if ('contourColor' in params) {\n    this.contourColor = handleColor(params.contourColor)\n  }\n  if ('contourProject' in params) {\n    this.contourProject = handleArray(params.contourProject, function (x) {\n      return handleArray(x, Boolean)\n    })\n  }\n  if ('surfaceProject' in params) {\n    this.surfaceProject = params.surfaceProject\n  }\n  if ('dynamicColor' in params) {\n    this.dynamicColor = handleColor(params.dynamicColor)\n  }\n  if ('dynamicTint' in params) {\n    this.dynamicTint = handleArray(params.dynamicTint, Number)\n  }\n  if ('dynamicWidth' in params) {\n    this.dynamicWidth = handleArray(params.dynamicWidth, Number)\n  }\n  if ('opacity' in params) {\n    this.opacity = params.opacity\n  }\n  if('opacityscale' in params) {\n    this.opacityscale = params.opacityscale\n  }\n  if ('colorBounds' in params) {\n    this.colorBounds = params.colorBounds\n  }\n  if ('vertexColor' in params) {\n    this.vertexColor = params.vertexColor ? 1 : 0;\n  }\n  if ('colormap' in params) {\n    this._colorMap.setPixels(this.genColormap(params.colormap, this.opacityscale))\n  }\n\n  var field = params.field || (params.coords && params.coords[2]) || null\n  var levelsChanged = false\n\n  if (!field) {\n    if (this._field[2].shape[0] || this._field[2].shape[2]) {\n      field = this._field[2].lo(1, 1).hi(this._field[2].shape[0] - 2, this._field[2].shape[1] - 2)\n    } else {\n      field = this._field[2].hi(0, 0)\n    }\n  }\n\n  // Update field\n  if ('field' in params || 'coords' in params) {\n    var fsize = (field.shape[0] + 2) * (field.shape[1] + 2)\n\n    // Resize if necessary\n    if (fsize > this._field[2].data.length) {\n      pool.freeFloat(this._field[2].data)\n      this._field[2].data = pool.mallocFloat(bits.nextPow2(fsize))\n    }\n\n    // Pad field\n    this._field[2] = ndarray(this._field[2].data, [field.shape[0] + 2, field.shape[1] + 2])\n    this.padField(this._field[2], field)\n\n    // Save shape of field\n    this.shape = field.shape.slice()\n    var shape = this.shape\n\n    // Resize coordinate fields if necessary\n    for (var i = 0; i < 2; ++i) {\n      if (this._field[2].size > this._field[i].data.length) {\n        pool.freeFloat(this._field[i].data)\n        this._field[i].data = pool.mallocFloat(this._field[2].size)\n      }\n      this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2])\n    }\n\n    // Generate x/y coordinates\n    if (params.coords) {\n      var coords = params.coords\n      if (!Array.isArray(coords) || coords.length !== 3) {\n        throw new Error('gl-surface: invalid coordinates for x/y')\n      }\n      for (i = 0; i < 2; ++i) {\n        var coord = coords[i]\n        for (j = 0; j < 2; ++j) {\n          if (coord.shape[j] !== shape[j]) {\n            throw new Error('gl-surface: coords have incorrect shape')\n          }\n        }\n        this.padField(this._field[i], coord)\n      }\n    } else if (params.ticks) {\n      var ticks = params.ticks\n      if (!Array.isArray(ticks) || ticks.length !== 2) {\n        throw new Error('gl-surface: invalid ticks')\n      }\n      for (i = 0; i < 2; ++i) {\n        var tick = ticks[i]\n        if (Array.isArray(tick) || tick.length) {\n          tick = ndarray(tick)\n        }\n        if (tick.shape[0] !== shape[i]) {\n          throw new Error('gl-surface: invalid tick length')\n        }\n        // Make a copy view of the tick array\n        var tick2 = ndarray(tick.data, shape)\n        tick2.stride[i] = tick.stride[0]\n        tick2.stride[i ^ 1] = 0\n\n        // Fill in field array\n        this.padField(this._field[i], tick2)\n      }\n    } else {\n      for (i = 0; i < 2; ++i) {\n        var offset = [0, 0]\n        offset[i] = 1\n        this._field[i] = ndarray(this._field[i].data, [shape[0] + 2, shape[1] + 2], offset, 0)\n      }\n      this._field[0].set(0, 0, 0)\n      for (var j = 0; j < shape[0]; ++j) {\n        this._field[0].set(j + 1, 0, j)\n      }\n      this._field[0].set(shape[0] + 1, 0, shape[0] - 1)\n      this._field[1].set(0, 0, 0)\n      for (j = 0; j < shape[1]; ++j) {\n        this._field[1].set(0, j + 1, j)\n      }\n      this._field[1].set(0, shape[1] + 1, shape[1] - 1)\n    }\n\n    // Save shape\n    var fields = this._field\n\n    // Compute surface normals\n    var dfields = ndarray(pool.mallocFloat(fields[2].size * 3 * 2), [3, shape[0] + 2, shape[1] + 2, 2])\n    for (i = 0; i < 3; ++i) {\n      gradient(dfields.pick(i), fields[i], 'mirror')\n    }\n    var normals = ndarray(pool.mallocFloat(fields[2].size * 3), [shape[0] + 2, shape[1] + 2, 3])\n    for (i = 0; i < shape[0] + 2; ++i) {\n      for (j = 0; j < shape[1] + 2; ++j) {\n        var dxdu = dfields.get(0, i, j, 0)\n        var dxdv = dfields.get(0, i, j, 1)\n        var dydu = dfields.get(1, i, j, 0)\n        var dydv = dfields.get(1, i, j, 1)\n        var dzdu = dfields.get(2, i, j, 0)\n        var dzdv = dfields.get(2, i, j, 1)\n\n        var nx = dydu * dzdv - dydv * dzdu\n        var ny = dzdu * dxdv - dzdv * dxdu\n        var nz = dxdu * dydv - dxdv * dydu\n\n        var nl = Math.sqrt(nx * nx + ny * ny + nz * nz)\n        if (nl < 1e-8) {\n          nl = Math.max(Math.abs(nx), Math.abs(ny), Math.abs(nz))\n          if (nl < 1e-8) {\n            nz = 1.0\n            ny = nx = 0.0\n            nl = 1.0\n          } else {\n            nl = 1.0 / nl\n          }\n        } else {\n          nl = 1.0 / Math.sqrt(nl)\n        }\n\n        normals.set(i, j, 0, nx * nl)\n        normals.set(i, j, 1, ny * nl)\n        normals.set(i, j, 2, nz * nl)\n      }\n    }\n    pool.free(dfields.data)\n\n    // Initialize surface\n    var lo = [ Infinity, Infinity, Infinity ]\n    var hi = [ -Infinity, -Infinity, -Infinity ]\n    var lo_intensity = Infinity\n    var hi_intensity = -Infinity\n    var count = (shape[0] - 1) * (shape[1] - 1) * 6\n    var tverts = pool.mallocFloat(bits.nextPow2(10 * count))\n    var tptr = 0\n    var vertexCount = 0\n    for (i = 0; i < shape[0] - 1; ++i) {\n      j_loop:\n      for (j = 0; j < shape[1] - 1; ++j) {\n        // Test for NaNs\n        for (var dx = 0; dx < 2; ++dx) {\n          for (var dy = 0; dy < 2; ++dy) {\n            for (var k = 0; k < 3; ++k) {\n              var f = this._field[k].get(1 + i + dx, 1 + j + dy)\n              if (isNaN(f) || !isFinite(f)) {\n                continue j_loop\n              }\n            }\n          }\n        }\n        for (k = 0; k < 6; ++k) {\n          var r = i + QUAD[k][0]\n          var c = j + QUAD[k][1]\n\n          var tx = this._field[0].get(r + 1, c + 1)\n          var ty = this._field[1].get(r + 1, c + 1)\n          f =      this._field[2].get(r + 1, c + 1)\n\n          nx = normals.get(r + 1, c + 1, 0)\n          ny = normals.get(r + 1, c + 1, 1)\n          nz = normals.get(r + 1, c + 1, 2)\n\n          if (params.intensity) {\n            vf = params.intensity.get(r, c)\n          }\n\n          var vf = (params.intensity) ?\n            params.intensity.get(r, c) :\n            f + this.objectOffset[2];\n\n          tverts[tptr++] = r\n          tverts[tptr++] = c\n          tverts[tptr++] = tx\n          tverts[tptr++] = ty\n          tverts[tptr++] = f\n          tverts[tptr++] = 0\n          tverts[tptr++] = vf\n          tverts[tptr++] = nx\n          tverts[tptr++] = ny\n          tverts[tptr++] = nz\n\n          lo[0] = Math.min(lo[0], tx + this.objectOffset[0])\n          lo[1] = Math.min(lo[1], ty + this.objectOffset[1])\n          lo[2] = Math.min(lo[2], f  + this.objectOffset[2])\n          lo_intensity = Math.min(lo_intensity, vf)\n\n          hi[0] = Math.max(hi[0], tx + this.objectOffset[0])\n          hi[1] = Math.max(hi[1], ty + this.objectOffset[1])\n          hi[2] = Math.max(hi[2], f  + this.objectOffset[2])\n          hi_intensity = Math.max(hi_intensity, vf)\n\n          vertexCount += 1\n        }\n      }\n    }\n\n    if (params.intensityBounds) {\n      lo_intensity = +params.intensityBounds[0]\n      hi_intensity = +params.intensityBounds[1]\n    }\n\n    // Scale all vertex intensities\n    for (i = 6; i < tptr; i += 10) {\n      tverts[i] = (tverts[i] - lo_intensity) / (hi_intensity - lo_intensity)\n    }\n\n    this._vertexCount = vertexCount\n    this._coordinateBuffer.update(tverts.subarray(0, tptr))\n    pool.freeFloat(tverts)\n    pool.free(normals.data)\n\n    // Update bounds\n    this.bounds = [lo, hi]\n\n    // Save intensity\n    this.intensity = params.intensity || this._field[2]\n\n    if(this.intensityBounds[0] !== lo_intensity || this.intensityBounds[1] !== hi_intensity) {\n        levelsChanged = true\n    }\n\n    // Save intensity bound\n    this.intensityBounds = [lo_intensity, hi_intensity]\n  }\n\n  // Update level crossings\n  if ('levels' in params) {\n    var levels = params.levels\n    if (!Array.isArray(levels[0])) {\n      levels = [ [], [], levels ]\n    } else {\n      levels = levels.slice()\n    }\n    for (i = 0; i < 3; ++i) {\n      levels[i] = levels[i].slice()\n      levels[i].sort(function (a, b) {\n        return a - b\n      })\n    }\n    for (i = 0; i < 3; ++i) {\n      for (j = 0; j < levels[i].length; ++j) {\n        levels[i][j] -= this.objectOffset[i]\n      }\n    }\n    change_test:\n    for (i = 0; i < 3; ++i) {\n      if (levels[i].length !== this.contourLevels[i].length) {\n        levelsChanged = true\n        break\n      }\n      for (j = 0; j < levels[i].length; ++j) {\n        if (levels[i][j] !== this.contourLevels[i][j]) {\n          levelsChanged = true\n          break change_test\n        }\n      }\n    }\n    this.contourLevels = levels\n  }\n\n  if (levelsChanged) {\n    fields = this._field\n    shape = this.shape\n\n    // Update contour lines\n    var contourVerts = []\n\n    for (var dim = 0; dim < 3; ++dim) {\n      var contourLevel = this.contourLevels[dim]\n\n      var levelOffsets = []\n      var levelCounts = []\n\n      var parts = [0, 0, 0]\n\n      for (i = 0; i < contourLevel.length; ++i) {\n        var graph = surfaceNets(this._field[dim], contourLevel[i])\n\n        levelOffsets.push((contourVerts.length / 5) | 0)\n        vertexCount = 0\n\n        edge_loop:\n        for (j = 0; j < graph.cells.length; ++j) {\n          var e = graph.cells[j]\n          for (k = 0; k < 2; ++k) {\n            var p = graph.positions[e[k]]\n\n            var x = p[0]\n            var ix = Math.floor(x) | 0\n            var fx = x - ix\n\n            var y = p[1]\n            var iy = Math.floor(y) | 0\n            var fy = y - iy\n\n            var hole = false\n            axis_loop:\n            for (var axis = 0; axis < 3; ++axis) {\n              parts[axis] = 0.0\n              var iu = (dim + axis + 1) % 3\n              for (dx = 0; dx < 2; ++dx) {\n                var s = dx ? fx : 1.0 - fx\n                r = Math.min(Math.max(ix + dx, 0), shape[0]) | 0\n                for (dy = 0; dy < 2; ++dy) {\n                  var t = dy ? fy : 1.0 - fy\n                  c = Math.min(Math.max(iy + dy, 0), shape[1]) | 0\n\n                  if (axis < 2) {\n                    f = this._field[iu].get(r, c)\n                  } else {\n                    f = (this.intensity.get(r, c) - this.intensityBounds[0]) / (this.intensityBounds[1] - this.intensityBounds[0])\n                  }\n                  if (!isFinite(f) || isNaN(f)) {\n                    hole = true\n                    break axis_loop\n                  }\n\n                  var w = s * t\n                  parts[axis] += w * f\n                }\n              }\n            }\n\n            if (!hole) {\n              contourVerts.push(\n                parts[0],\n                parts[1],\n                p[0],\n                p[1],\n                parts[2]\n              )\n              vertexCount += 1\n            } else {\n              if (k > 0) {\n                // If we already added first edge, pop off verts\n                for (var l = 0; l < 5; ++l) {\n                  contourVerts.pop()\n                }\n                vertexCount -= 1\n              }\n              continue edge_loop\n            }\n          }\n        }\n        levelCounts.push(vertexCount)\n      }\n\n      // Store results\n      this._contourOffsets[dim] = levelOffsets\n      this._contourCounts[dim] = levelCounts\n\n    }\n\n    var floatBuffer = pool.mallocFloat(contourVerts.length)\n    for (i = 0; i < contourVerts.length; ++i) {\n      floatBuffer[i] = contourVerts[i]\n    }\n    this._contourBuffer.update(floatBuffer)\n    pool.freeFloat(floatBuffer)\n  }\n}\n\nproto.dispose = function () {\n  this._shader.dispose()\n  this._vao.dispose()\n  this._coordinateBuffer.dispose()\n  this._colorMap.dispose()\n  this._contourBuffer.dispose()\n  this._contourVAO.dispose()\n  this._contourShader.dispose()\n  this._contourPickShader.dispose()\n  this._dynamicBuffer.dispose()\n  this._dynamicVAO.dispose()\n  for (var i = 0; i < 3; ++i) {\n    pool.freeFloat(this._field[i].data)\n  }\n}\n\nproto.highlight = function (selection) {\n  var i\n\n  if (!selection) {\n    this._dynamicCounts = [0, 0, 0]\n    this.dyanamicLevel = [NaN, NaN, NaN]\n    this.highlightLevel = [-1, -1, -1]\n    return\n  }\n\n  for (i = 0; i < 3; ++i) {\n    if (this.enableHighlight[i]) {\n      this.highlightLevel[i] = selection.level[i]\n    } else {\n      this.highlightLevel[i] = -1\n    }\n  }\n\n  var levels\n  if (this.snapToData) {\n    levels = selection.dataCoordinate\n  } else {\n    levels = selection.position\n  }\n  for (i = 0; i < 3; ++i) {\n    levels[i] -= this.objectOffset[i]\n  }\n  if ((!this.enableDynamic[0] || levels[0] === this.dynamicLevel[0]) &&\n    (!this.enableDynamic[1] || levels[1] === this.dynamicLevel[1]) &&\n    (!this.enableDynamic[2] || levels[2] === this.dynamicLevel[2])) {\n    return\n  }\n\n  var vertexCount = 0\n  var shape = this.shape\n  var scratchBuffer = pool.mallocFloat(12 * shape[0] * shape[1])\n\n  for (var d = 0; d < 3; ++d) {\n    if (!this.enableDynamic[d]) {\n      this.dynamicLevel[d] = NaN\n      this._dynamicCounts[d] = 0\n      continue\n    }\n\n    this.dynamicLevel[d] = levels[d]\n\n    var u = (d + 1) % 3\n    var v = (d + 2) % 3\n\n    var f = this._field[d]\n    var g = this._field[u]\n    var h = this._field[v]\n\n    var graph = surfaceNets(f, levels[d])\n    var edges = graph.cells\n    var positions = graph.positions\n\n    this._dynamicOffsets[d] = vertexCount\n\n    for (i = 0; i < edges.length; ++i) {\n      var e = edges[i]\n      for (var j = 0; j < 2; ++j) {\n        var p = positions[e[j]]\n\n        var x = +p[0]\n        var ix = x | 0\n        var jx = Math.min(ix + 1, shape[0]) | 0\n        var fx = x - ix\n        var hx = 1.0 - fx\n\n        var y = +p[1]\n        var iy = y | 0\n        var jy = Math.min(iy + 1, shape[1]) | 0\n        var fy = y - iy\n        var hy = 1.0 - fy\n\n        var w00 = hx * hy\n        var w01 = hx * fy\n        var w10 = fx * hy\n        var w11 = fx * fy\n\n        var cu = w00 * g.get(ix, iy) +\n          w01 * g.get(ix, jy) +\n          w10 * g.get(jx, iy) +\n          w11 * g.get(jx, jy)\n\n        var cv = w00 * h.get(ix, iy) +\n          w01 * h.get(ix, jy) +\n          w10 * h.get(jx, iy) +\n          w11 * h.get(jx, jy)\n\n        if (isNaN(cu) || isNaN(cv)) {\n          if (j) {\n            vertexCount -= 1\n          }\n          break\n        }\n\n        scratchBuffer[2 * vertexCount + 0] = cu\n        scratchBuffer[2 * vertexCount + 1] = cv\n\n        vertexCount += 1\n      }\n    }\n\n    this._dynamicCounts[d] = vertexCount - this._dynamicOffsets[d]\n  }\n\n  this._dynamicBuffer.update(scratchBuffer.subarray(0, 2 * vertexCount))\n  pool.freeFloat(scratchBuffer)\n}\n\nfunction createSurfacePlot (params) {\n  var gl = params.gl\n\n  var shader = createShader(gl)\n  var pickShader = createPickShader(gl)\n  var contourShader = createContourShader(gl)\n  var contourPickShader = createPickContourShader(gl)\n\n  var coordinateBuffer = createBuffer(gl)\n  var vao = createVAO(gl, [\n    { buffer: coordinateBuffer,\n      size: 4,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 0\n    },\n    { buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 16\n    },\n    {\n      buffer: coordinateBuffer,\n      size: 3,\n      stride: SURFACE_VERTEX_SIZE,\n      offset: 28\n    }\n  ])\n\n  var contourBuffer = createBuffer(gl)\n  var contourVAO = createVAO(gl, [\n    {\n      buffer: contourBuffer,\n      size: 4,\n      stride: 20,\n      offset: 0\n    },\n    {\n      buffer: contourBuffer,\n      size: 1,\n      stride: 20,\n      offset: 16\n    }\n  ])\n\n  var dynamicBuffer = createBuffer(gl)\n  var dynamicVAO = createVAO(gl, [\n    {\n      buffer: dynamicBuffer,\n      size: 2,\n      type: gl.FLOAT\n    }])\n\n  var cmap = createTexture(gl, 1, N_COLORS, gl.RGBA, gl.UNSIGNED_BYTE)\n  cmap.minFilter = gl.LINEAR\n  cmap.magFilter = gl.LINEAR\n\n  var surface = new SurfacePlot(\n    gl,\n    [0, 0], // shape\n    [[0, 0, 0], [0, 0, 0]], // bounds\n    shader,\n    pickShader,\n    coordinateBuffer,\n    vao,\n    cmap,\n    contourShader,\n    contourPickShader,\n    contourBuffer,\n    contourVAO,\n    dynamicBuffer,\n    dynamicVAO,\n    [0, 0, 0] // objectOffset\n  )\n\n  var nparams = {\n    levels: [[], [], []]\n  }\n  for (var id in params) {\n    nparams[id] = params[id]\n  }\n  nparams.colormap = nparams.colormap || 'jet'\n\n  surface.update(nparams)\n\n  return surface\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}