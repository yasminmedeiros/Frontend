{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectWrapper;\nvar pool = require('typedarray-pool');\nvar sweep = require('./lib/sweep');\nvar boxIntersectIter = require('./lib/intersect');\nfunction boxEmpty(d, box) {\n  for (var j = 0; j < d; ++j) {\n    if (!(box[j] <= box[j + d])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0;\n  var count = 0;\n  for (var i = 0, n = boxes.length; i < n; ++i) {\n    var b = boxes[i];\n    if (boxEmpty(d, b)) {\n      continue;\n    }\n    for (var j = 0; j < 2 * d; ++j) {\n      data[ptr++] = b[j];\n    }\n    ids[count++] = i;\n  }\n  return count;\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length;\n  var m = blue.length;\n\n  //If either array is empty, then we can skip this whole thing\n  if (n <= 0 || m <= 0) {\n    return;\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = red[0].length >>> 1;\n  if (d <= 0) {\n    return;\n  }\n  var retval;\n\n  //Convert red boxes\n  var redList = pool.mallocDouble(2 * d * n);\n  var redIds = pool.mallocInt32(n);\n  n = convertBoxes(red, d, redList, redIds);\n  if (n > 0) {\n    if (d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n);\n      retval = sweep.sweepComplete(d, visit, 0, n, redList, redIds, 0, n, redList, redIds);\n    } else {\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2 * d * m);\n      var blueIds = pool.mallocInt32(m);\n      m = convertBoxes(blue, d, blueList, blueIds);\n      if (m > 0) {\n        sweep.init(n + m);\n        if (d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(d, visit, 0, n, redList, redIds, 0, m, blueList, blueIds);\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(d, visit, full, n, redList, redIds, m, blueList, blueIds);\n        }\n        pool.free(blueList);\n        pool.free(blueIds);\n      }\n    }\n    pool.free(redList);\n    pool.free(redIds);\n  }\n  return retval;\n}\nvar RESULT;\nfunction appendItem(i, j) {\n  RESULT.push([i, j]);\n}\nfunction intersectFullArray(x) {\n  RESULT = [];\n  boxIntersect(x, x, appendItem, true);\n  return RESULT;\n}\nfunction intersectBipartiteArray(x, y) {\n  RESULT = [];\n  boxIntersect(x, y, appendItem, false);\n  return RESULT;\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result;\n  switch (arguments.length) {\n    case 1:\n      return intersectFullArray(arg0);\n    case 2:\n      if (typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true);\n      } else {\n        return intersectBipartiteArray(arg0, arg1);\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false);\n    default:\n      throw new Error('box-intersect: Invalid arguments');\n  }\n}","map":{"version":3,"names":["module","exports","boxIntersectWrapper","pool","require","sweep","boxIntersectIter","boxEmpty","d","box","j","convertBoxes","boxes","data","ids","ptr","count","i","n","length","b","boxIntersect","red","blue","visit","full","m","retval","redList","mallocDouble","redIds","mallocInt32","init","sweepComplete","blueList","blueIds","sweepBipartite","free","RESULT","appendItem","push","intersectFullArray","x","intersectBipartiteArray","y","arg0","arg1","arg2","result","arguments","Error"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/box-intersect/index.js"],"sourcesContent":["'use strict'\n\nmodule.exports = boxIntersectWrapper\n\nvar pool = require('typedarray-pool')\nvar sweep = require('./lib/sweep')\nvar boxIntersectIter = require('./lib/intersect')\n\nfunction boxEmpty(d, box) {\n  for(var j=0; j<d; ++j) {\n    if(!(box[j] <= box[j+d])) {\n      return true\n    }\n  }\n  return false\n}\n\n//Unpack boxes into a flat typed array, remove empty boxes\nfunction convertBoxes(boxes, d, data, ids) {\n  var ptr = 0\n  var count = 0\n  for(var i=0, n=boxes.length; i<n; ++i) {\n    var b = boxes[i]\n    if(boxEmpty(d, b)) {\n      continue\n    }\n    for(var j=0; j<2*d; ++j) {\n      data[ptr++] = b[j]\n    }\n    ids[count++] = i\n  }\n  return count\n}\n\n//Perform type conversions, check bounds\nfunction boxIntersect(red, blue, visit, full) {\n  var n = red.length\n  var m = blue.length\n\n  //If either array is empty, then we can skip this whole thing\n  if(n <= 0 || m <= 0) {\n    return\n  }\n\n  //Compute dimension, if it is 0 then we skip\n  var d = (red[0].length)>>>1\n  if(d <= 0) {\n    return\n  }\n\n  var retval\n\n  //Convert red boxes\n  var redList  = pool.mallocDouble(2*d*n)\n  var redIds   = pool.mallocInt32(n)\n  n = convertBoxes(red, d, redList, redIds)\n\n  if(n > 0) {\n    if(d === 1 && full) {\n      //Special case: 1d complete\n      sweep.init(n)\n      retval = sweep.sweepComplete(\n        d, visit, \n        0, n, redList, redIds,\n        0, n, redList, redIds)\n    } else {\n\n      //Convert blue boxes\n      var blueList = pool.mallocDouble(2*d*m)\n      var blueIds  = pool.mallocInt32(m)\n      m = convertBoxes(blue, d, blueList, blueIds)\n\n      if(m > 0) {\n        sweep.init(n+m)\n\n        if(d === 1) {\n          //Special case: 1d bipartite\n          retval = sweep.sweepBipartite(\n            d, visit, \n            0, n, redList,  redIds,\n            0, m, blueList, blueIds)\n        } else {\n          //General case:  d>1\n          retval = boxIntersectIter(\n            d, visit,    full,\n            n, redList,  redIds,\n            m, blueList, blueIds)\n        }\n\n        pool.free(blueList)\n        pool.free(blueIds)\n      }\n    }\n\n    pool.free(redList)\n    pool.free(redIds)\n  }\n\n  return retval\n}\n\n\nvar RESULT\n\nfunction appendItem(i,j) {\n  RESULT.push([i,j])\n}\n\nfunction intersectFullArray(x) {\n  RESULT = []\n  boxIntersect(x, x, appendItem, true)\n  return RESULT\n}\n\nfunction intersectBipartiteArray(x, y) {\n  RESULT = []\n  boxIntersect(x, y, appendItem, false)\n  return RESULT\n}\n\n//User-friendly wrapper, handle full input and no-visitor cases\nfunction boxIntersectWrapper(arg0, arg1, arg2) {\n  var result\n  switch(arguments.length) {\n    case 1:\n      return intersectFullArray(arg0)\n    case 2:\n      if(typeof arg1 === 'function') {\n        return boxIntersect(arg0, arg0, arg1, true)\n      } else {\n        return intersectBipartiteArray(arg0, arg1)\n      }\n    case 3:\n      return boxIntersect(arg0, arg1, arg2, false)\n    default:\n      throw new Error('box-intersect: Invalid arguments')\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}