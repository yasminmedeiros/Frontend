{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Colorscale = require('../../components/colorscale');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\nmodule.exports = function (gd, plotinfo, cdheatmaps, heatmapLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var z = cd0.z;\n    var x = cd0.x;\n    var y = cd0.y;\n    var xc = cd0.xCenter;\n    var yc = cd0.yCenter;\n    var isContour = Registry.traceIs(trace, 'contour');\n    var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n    // get z dims\n    var m = z.length;\n    var n = Lib.maxRowLength(z);\n    var xrev = false;\n    var yrev = false;\n    var left, right, temp, top, bottom, i;\n\n    // TODO: if there are multiple overlapping categorical heatmaps,\n    // or if we allow category sorting, then the categories may not be\n    // sequential... may need to reorder and/or expand z\n\n    // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n    // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n    // also clip the image to maximum 50% outside the visible plot area\n    // bigger image lets you pan more naturally, but slows performance.\n    // TODO: use low-resolution images outside the visible plot for panning\n    // these while loops find the first and last brick bounds that are defined\n    // (in case of log of a negative)\n    i = 0;\n    while (left === undefined && i < x.length - 1) {\n      left = xa.c2p(x[i]);\n      i++;\n    }\n    i = x.length - 1;\n    while (right === undefined && i > 0) {\n      right = xa.c2p(x[i]);\n      i--;\n    }\n    if (right < left) {\n      temp = right;\n      right = left;\n      left = temp;\n      xrev = true;\n    }\n    i = 0;\n    while (top === undefined && i < y.length - 1) {\n      top = ya.c2p(y[i]);\n      i++;\n    }\n    i = y.length - 1;\n    while (bottom === undefined && i > 0) {\n      bottom = ya.c2p(y[i]);\n      i--;\n    }\n    if (bottom < top) {\n      temp = top;\n      top = bottom;\n      bottom = temp;\n      yrev = true;\n    }\n\n    // for contours with heatmap fill, we generate the boundaries based on\n    // brick centers but then use the brick edges for drawing the bricks\n    if (isContour) {\n      xc = x;\n      yc = y;\n      x = cd0.xfill;\n      y = cd0.yfill;\n    }\n\n    // make an image that goes at most half a screen off either side, to keep\n    // time reasonable when you zoom in. if zsmooth is true/fast, don't worry\n    // about this, because zooming doesn't increase number of pixels\n    // if zsmooth is best, don't include anything off screen because it takes too long\n    if (zsmooth !== 'fast') {\n      var extra = zsmooth === 'best' ? 0 : 0.5;\n      left = Math.max(-extra * xa._length, left);\n      right = Math.min((1 + extra) * xa._length, right);\n      top = Math.max(-extra * ya._length, top);\n      bottom = Math.min((1 + extra) * ya._length, bottom);\n    }\n    var imageWidth = Math.round(right - left);\n    var imageHeight = Math.round(bottom - top);\n\n    // setup image nodes\n\n    // if image is entirely off-screen, don't even draw it\n    var isOffScreen = imageWidth <= 0 || imageHeight <= 0;\n    if (isOffScreen) {\n      var noImage = plotGroup.selectAll('image').data([]);\n      noImage.exit().remove();\n      return;\n    }\n\n    // generate image data\n\n    var canvasW, canvasH;\n    if (zsmooth === 'fast') {\n      canvasW = n;\n      canvasH = m;\n    } else {\n      canvasW = imageWidth;\n      canvasH = imageHeight;\n    }\n    var canvas = document.createElement('canvas');\n    canvas.width = canvasW;\n    canvas.height = canvasH;\n    var context = canvas.getContext('2d');\n    var sclFunc = Colorscale.makeColorScaleFunc(Colorscale.extractScale(trace, {\n      cLetter: 'z'\n    }), {\n      noNumericCheck: true,\n      returnArray: true\n    });\n\n    // map brick boundaries to image pixels\n    var xpx, ypx;\n    if (zsmooth === 'fast') {\n      xpx = xrev ? function (index) {\n        return n - 1 - index;\n      } : Lib.identity;\n      ypx = yrev ? function (index) {\n        return m - 1 - index;\n      } : Lib.identity;\n    } else {\n      xpx = function xpx(index) {\n        return Lib.constrain(Math.round(xa.c2p(x[index]) - left), 0, imageWidth);\n      };\n      ypx = function ypx(index) {\n        return Lib.constrain(Math.round(ya.c2p(y[index]) - top), 0, imageHeight);\n      };\n    }\n\n    // build the pixel map brick-by-brick\n    // cruise through z-matrix row-by-row\n    // build a brick at each z-matrix value\n    var yi = ypx(0);\n    var yb = [yi, yi];\n    var xbi = xrev ? 0 : 1;\n    var ybi = yrev ? 0 : 1;\n    // for collecting an average luminosity of the heatmap\n    var pixcount = 0;\n    var rcount = 0;\n    var gcount = 0;\n    var bcount = 0;\n    var xb, j, xi, v, row, c;\n    function setColor(v, pixsize) {\n      if (v !== undefined) {\n        var c = sclFunc(v);\n        c[0] = Math.round(c[0]);\n        c[1] = Math.round(c[1]);\n        c[2] = Math.round(c[2]);\n        pixcount += pixsize;\n        rcount += c[0] * pixsize;\n        gcount += c[1] * pixsize;\n        bcount += c[2] * pixsize;\n        return c;\n      }\n      return [0, 0, 0, 0];\n    }\n    function interpColor(r0, r1, xinterp, yinterp) {\n      var z00 = r0[xinterp.bin0];\n      if (z00 === undefined) return setColor(undefined, 1);\n      var z01 = r0[xinterp.bin1];\n      var z10 = r1[xinterp.bin0];\n      var z11 = r1[xinterp.bin1];\n      var dx = z01 - z00 || 0;\n      var dy = z10 - z00 || 0;\n      var dxy;\n\n      // the bilinear interpolation term needs different calculations\n      // for all the different permutations of missing data\n      // among the neighbors of the main point, to ensure\n      // continuity across brick boundaries.\n      if (z01 === undefined) {\n        if (z11 === undefined) dxy = 0;else if (z10 === undefined) dxy = 2 * (z11 - z00);else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n      } else if (z11 === undefined) {\n        if (z10 === undefined) dxy = 0;else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n      } else if (z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;else dxy = z11 + z00 - z01 - z10;\n      return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n    }\n    if (zsmooth) {\n      // best or fast, works fastest with imageData\n      var pxIndex = 0;\n      var pixels;\n      try {\n        pixels = new Uint8Array(imageWidth * imageHeight * 4);\n      } catch (e) {\n        pixels = new Array(imageWidth * imageHeight * 4);\n      }\n      if (zsmooth === 'best') {\n        var xForPx = xc || x;\n        var yForPx = yc || y;\n        var xPixArray = new Array(xForPx.length);\n        var yPixArray = new Array(yForPx.length);\n        var xinterpArray = new Array(imageWidth);\n        var findInterpX = xc ? findInterpFromCenters : findInterp;\n        var findInterpY = yc ? findInterpFromCenters : findInterp;\n        var yinterp, r0, r1;\n\n        // first make arrays of x and y pixel locations of brick boundaries\n        for (i = 0; i < xForPx.length; i++) {\n          xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n        }\n        for (i = 0; i < yForPx.length; i++) {\n          yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n        }\n\n        // then make arrays of interpolations\n        // (bin0=closest, bin1=next, frac=fractional dist.)\n        for (i = 0; i < imageWidth; i++) {\n          xinterpArray[i] = findInterpX(i, xPixArray);\n        }\n\n        // now do the interpolations and fill the png\n        for (j = 0; j < imageHeight; j++) {\n          yinterp = findInterpY(j, yPixArray);\n          r0 = z[yinterp.bin0];\n          r1 = z[yinterp.bin1];\n          for (i = 0; i < imageWidth; i++, pxIndex += 4) {\n            c = interpColor(r0, r1, xinterpArray[i], yinterp);\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      } else {\n        // zsmooth = fast\n        for (j = 0; j < m; j++) {\n          row = z[j];\n          yb = ypx(j);\n          for (i = 0; i < imageWidth; i++) {\n            c = setColor(row[i], 1);\n            pxIndex = (yb * imageWidth + xpx(i)) * 4;\n            putColor(pixels, pxIndex, c);\n          }\n        }\n      }\n      var imageData = context.createImageData(imageWidth, imageHeight);\n      try {\n        imageData.data.set(pixels);\n      } catch (e) {\n        var pxArray = imageData.data;\n        var dlen = pxArray.length;\n        for (j = 0; j < dlen; j++) {\n          pxArray[j] = pixels[j];\n        }\n      }\n      context.putImageData(imageData, 0, 0);\n    } else {\n      // zsmooth = false -> filling potentially large bricks works fastest with fillRect\n\n      // gaps do not need to be exact integers, but if they *are* we will get\n      // cleaner edges by rounding at least one edge\n      var xGap = trace.xgap;\n      var yGap = trace.ygap;\n      var xGapLeft = Math.floor(xGap / 2);\n      var yGapTop = Math.floor(yGap / 2);\n      for (j = 0; j < m; j++) {\n        row = z[j];\n        yb.reverse();\n        yb[ybi] = ypx(j + 1);\n        if (yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n          continue;\n        }\n        xi = xpx(0);\n        xb = [xi, xi];\n        for (i = 0; i < n; i++) {\n          // build one color brick!\n          xb.reverse();\n          xb[xbi] = xpx(i + 1);\n          if (xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n            continue;\n          }\n          v = row[i];\n          c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n          context.fillStyle = 'rgba(' + c.join(',') + ')';\n          context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop, xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n        }\n      }\n    }\n    rcount = Math.round(rcount / pixcount);\n    gcount = Math.round(gcount / pixcount);\n    bcount = Math.round(bcount / pixcount);\n    var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n    gd._hmpixcount = (gd._hmpixcount || 0) + pixcount;\n    gd._hmlumcount = (gd._hmlumcount || 0) + pixcount * avgColor.getLuminance();\n    var image3 = plotGroup.selectAll('image').data(cd);\n    image3.enter().append('svg:image').attr({\n      xmlns: xmlnsNamespaces.svg,\n      preserveAspectRatio: 'none'\n    });\n    image3.attr({\n      height: imageHeight,\n      width: imageWidth,\n      x: left,\n      y: top,\n      'xlink:href': canvas.toDataURL('image/png')\n    });\n  });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n  var maxBin = pixArray.length - 2;\n  var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n  var pix0 = pixArray[bin];\n  var pix1 = pixArray[bin + 1];\n  var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n  var bin0 = Math.round(interp);\n  var frac = Math.abs(interp - bin0);\n  if (!interp || interp === maxBin || !frac) {\n    return {\n      bin0: bin0,\n      bin1: bin0,\n      frac: 0\n    };\n  }\n  return {\n    bin0: bin0,\n    frac: frac,\n    bin1: Math.round(bin0 + frac / (interp - bin0))\n  };\n}\nfunction findInterpFromCenters(pixel, centerPixArray) {\n  var maxBin = centerPixArray.length - 1;\n  var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n  var pix0 = centerPixArray[bin];\n  var pix1 = centerPixArray[bin + 1];\n  var frac = (pixel - pix0) / (pix1 - pix0) || 0;\n  if (frac <= 0) {\n    return {\n      bin0: bin,\n      bin1: bin,\n      frac: 0\n    };\n  }\n  if (frac < 0.5) {\n    return {\n      bin0: bin,\n      bin1: bin + 1,\n      frac: frac\n    };\n  }\n  return {\n    bin0: bin + 1,\n    bin1: bin,\n    frac: 1 - frac\n  };\n}\nfunction putColor(pixels, pxIndex, c) {\n  pixels[pxIndex] = c[0];\n  pixels[pxIndex + 1] = c[1];\n  pixels[pxIndex + 2] = c[2];\n  pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}","map":{"version":3,"names":["d3","require","tinycolor","Registry","Lib","Colorscale","xmlnsNamespaces","module","exports","gd","plotinfo","cdheatmaps","heatmapLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","trace","z","x","y","xc","xCenter","yc","yCenter","isContour","traceIs","zsmooth","m","length","n","maxRowLength","xrev","yrev","left","right","temp","top","bottom","i","undefined","c2p","xfill","yfill","extra","Math","max","_length","min","imageWidth","round","imageHeight","isOffScreen","noImage","selectAll","data","exit","remove","canvasW","canvasH","canvas","document","createElement","width","height","context","getContext","sclFunc","makeColorScaleFunc","extractScale","cLetter","noNumericCheck","returnArray","xpx","ypx","index","identity","constrain","yi","yb","xbi","ybi","pixcount","rcount","gcount","bcount","xb","j","xi","v","row","c","setColor","pixsize","interpColor","r0","r1","xinterp","yinterp","z00","bin0","z01","bin1","z10","z11","dx","dy","dxy","frac","pxIndex","pixels","Uint8Array","e","Array","xForPx","yForPx","xPixArray","yPixArray","xinterpArray","findInterpX","findInterpFromCenters","findInterp","findInterpY","putColor","imageData","createImageData","set","pxArray","dlen","putImageData","xGap","xgap","yGap","ygap","xGapLeft","floor","yGapTop","reverse","fillStyle","join","fillRect","avgColor","_hmpixcount","_hmlumcount","getLuminance","image3","enter","append","attr","xmlns","svg","preserveAspectRatio","toDataURL","pixel","pixArray","maxBin","bin","findBin","pix0","pix1","interp","abs","centerPixArray"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/heatmap/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Colorscale = require('../../components/colorscale');\nvar xmlnsNamespaces = require('../../constants/xmlns_namespaces');\n\nmodule.exports = function(gd, plotinfo, cdheatmaps, heatmapLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(heatmapLayer, cdheatmaps, 'hm').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n\n        var z = cd0.z;\n        var x = cd0.x;\n        var y = cd0.y;\n        var xc = cd0.xCenter;\n        var yc = cd0.yCenter;\n        var isContour = Registry.traceIs(trace, 'contour');\n        var zsmooth = isContour ? 'best' : trace.zsmooth;\n\n        // get z dims\n        var m = z.length;\n        var n = Lib.maxRowLength(z);\n        var xrev = false;\n        var yrev = false;\n\n        var left, right, temp, top, bottom, i;\n\n        // TODO: if there are multiple overlapping categorical heatmaps,\n        // or if we allow category sorting, then the categories may not be\n        // sequential... may need to reorder and/or expand z\n\n        // Get edges of png in pixels (xa.c2p() maps axes coordinates to pixel coordinates)\n        // figure out if either axis is reversed (y is usually reversed, in pixel coords)\n        // also clip the image to maximum 50% outside the visible plot area\n        // bigger image lets you pan more naturally, but slows performance.\n        // TODO: use low-resolution images outside the visible plot for panning\n        // these while loops find the first and last brick bounds that are defined\n        // (in case of log of a negative)\n        i = 0;\n        while(left === undefined && i < x.length - 1) {\n            left = xa.c2p(x[i]);\n            i++;\n        }\n        i = x.length - 1;\n        while(right === undefined && i > 0) {\n            right = xa.c2p(x[i]);\n            i--;\n        }\n\n        if(right < left) {\n            temp = right;\n            right = left;\n            left = temp;\n            xrev = true;\n        }\n\n        i = 0;\n        while(top === undefined && i < y.length - 1) {\n            top = ya.c2p(y[i]);\n            i++;\n        }\n        i = y.length - 1;\n        while(bottom === undefined && i > 0) {\n            bottom = ya.c2p(y[i]);\n            i--;\n        }\n\n        if(bottom < top) {\n            temp = top;\n            top = bottom;\n            bottom = temp;\n            yrev = true;\n        }\n\n        // for contours with heatmap fill, we generate the boundaries based on\n        // brick centers but then use the brick edges for drawing the bricks\n        if(isContour) {\n            xc = x;\n            yc = y;\n            x = cd0.xfill;\n            y = cd0.yfill;\n        }\n\n        // make an image that goes at most half a screen off either side, to keep\n        // time reasonable when you zoom in. if zsmooth is true/fast, don't worry\n        // about this, because zooming doesn't increase number of pixels\n        // if zsmooth is best, don't include anything off screen because it takes too long\n        if(zsmooth !== 'fast') {\n            var extra = zsmooth === 'best' ? 0 : 0.5;\n            left = Math.max(-extra * xa._length, left);\n            right = Math.min((1 + extra) * xa._length, right);\n            top = Math.max(-extra * ya._length, top);\n            bottom = Math.min((1 + extra) * ya._length, bottom);\n        }\n\n        var imageWidth = Math.round(right - left);\n        var imageHeight = Math.round(bottom - top);\n\n        // setup image nodes\n\n        // if image is entirely off-screen, don't even draw it\n        var isOffScreen = (imageWidth <= 0 || imageHeight <= 0);\n\n        if(isOffScreen) {\n            var noImage = plotGroup.selectAll('image').data([]);\n            noImage.exit().remove();\n            return;\n        }\n\n        // generate image data\n\n        var canvasW, canvasH;\n        if(zsmooth === 'fast') {\n            canvasW = n;\n            canvasH = m;\n        } else {\n            canvasW = imageWidth;\n            canvasH = imageHeight;\n        }\n\n        var canvas = document.createElement('canvas');\n        canvas.width = canvasW;\n        canvas.height = canvasH;\n        var context = canvas.getContext('2d');\n\n        var sclFunc = Colorscale.makeColorScaleFunc(\n            Colorscale.extractScale(trace, {cLetter: 'z'}),\n            { noNumericCheck: true, returnArray: true }\n        );\n\n        // map brick boundaries to image pixels\n        var xpx,\n            ypx;\n        if(zsmooth === 'fast') {\n            xpx = xrev ?\n                function(index) { return n - 1 - index; } :\n                Lib.identity;\n            ypx = yrev ?\n                function(index) { return m - 1 - index; } :\n                Lib.identity;\n        }\n        else {\n            xpx = function(index) {\n                return Lib.constrain(Math.round(xa.c2p(x[index]) - left),\n                    0, imageWidth);\n            };\n            ypx = function(index) {\n                return Lib.constrain(Math.round(ya.c2p(y[index]) - top),\n                    0, imageHeight);\n            };\n        }\n\n        // build the pixel map brick-by-brick\n        // cruise through z-matrix row-by-row\n        // build a brick at each z-matrix value\n        var yi = ypx(0);\n        var yb = [yi, yi];\n        var xbi = xrev ? 0 : 1;\n        var ybi = yrev ? 0 : 1;\n        // for collecting an average luminosity of the heatmap\n        var pixcount = 0;\n        var rcount = 0;\n        var gcount = 0;\n        var bcount = 0;\n\n        var xb, j, xi, v, row, c;\n\n        function setColor(v, pixsize) {\n            if(v !== undefined) {\n                var c = sclFunc(v);\n                c[0] = Math.round(c[0]);\n                c[1] = Math.round(c[1]);\n                c[2] = Math.round(c[2]);\n\n                pixcount += pixsize;\n                rcount += c[0] * pixsize;\n                gcount += c[1] * pixsize;\n                bcount += c[2] * pixsize;\n                return c;\n            }\n            return [0, 0, 0, 0];\n        }\n\n        function interpColor(r0, r1, xinterp, yinterp) {\n            var z00 = r0[xinterp.bin0];\n            if(z00 === undefined) return setColor(undefined, 1);\n\n            var z01 = r0[xinterp.bin1];\n            var z10 = r1[xinterp.bin0];\n            var z11 = r1[xinterp.bin1];\n            var dx = (z01 - z00) || 0;\n            var dy = (z10 - z00) || 0;\n            var dxy;\n\n            // the bilinear interpolation term needs different calculations\n            // for all the different permutations of missing data\n            // among the neighbors of the main point, to ensure\n            // continuity across brick boundaries.\n            if(z01 === undefined) {\n                if(z11 === undefined) dxy = 0;\n                else if(z10 === undefined) dxy = 2 * (z11 - z00);\n                else dxy = (2 * z11 - z10 - z00) * 2 / 3;\n            }\n            else if(z11 === undefined) {\n                if(z10 === undefined) dxy = 0;\n                else dxy = (2 * z00 - z01 - z10) * 2 / 3;\n            }\n            else if(z10 === undefined) dxy = (2 * z11 - z01 - z00) * 2 / 3;\n            else dxy = (z11 + z00 - z01 - z10);\n\n            return setColor(z00 + xinterp.frac * dx + yinterp.frac * (dy + xinterp.frac * dxy));\n        }\n\n        if(zsmooth) { // best or fast, works fastest with imageData\n            var pxIndex = 0;\n            var pixels;\n\n            try {\n                pixels = new Uint8Array(imageWidth * imageHeight * 4);\n            } catch(e) {\n                pixels = new Array(imageWidth * imageHeight * 4);\n            }\n\n            if(zsmooth === 'best') {\n                var xForPx = xc || x;\n                var yForPx = yc || y;\n                var xPixArray = new Array(xForPx.length);\n                var yPixArray = new Array(yForPx.length);\n                var xinterpArray = new Array(imageWidth);\n                var findInterpX = xc ? findInterpFromCenters : findInterp;\n                var findInterpY = yc ? findInterpFromCenters : findInterp;\n                var yinterp, r0, r1;\n\n                // first make arrays of x and y pixel locations of brick boundaries\n                for(i = 0; i < xForPx.length; i++) xPixArray[i] = Math.round(xa.c2p(xForPx[i]) - left);\n                for(i = 0; i < yForPx.length; i++) yPixArray[i] = Math.round(ya.c2p(yForPx[i]) - top);\n\n                // then make arrays of interpolations\n                // (bin0=closest, bin1=next, frac=fractional dist.)\n                for(i = 0; i < imageWidth; i++) xinterpArray[i] = findInterpX(i, xPixArray);\n\n                // now do the interpolations and fill the png\n                for(j = 0; j < imageHeight; j++) {\n                    yinterp = findInterpY(j, yPixArray);\n                    r0 = z[yinterp.bin0];\n                    r1 = z[yinterp.bin1];\n                    for(i = 0; i < imageWidth; i++, pxIndex += 4) {\n                        c = interpColor(r0, r1, xinterpArray[i], yinterp);\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            }\n            else { // zsmooth = fast\n                for(j = 0; j < m; j++) {\n                    row = z[j];\n                    yb = ypx(j);\n                    for(i = 0; i < imageWidth; i++) {\n                        c = setColor(row[i], 1);\n                        pxIndex = (yb * imageWidth + xpx(i)) * 4;\n                        putColor(pixels, pxIndex, c);\n                    }\n                }\n            }\n\n            var imageData = context.createImageData(imageWidth, imageHeight);\n            try {\n                imageData.data.set(pixels);\n            } catch(e) {\n                var pxArray = imageData.data;\n                var dlen = pxArray.length;\n                for(j = 0; j < dlen; j ++) {\n                    pxArray[j] = pixels[j];\n                }\n            }\n\n            context.putImageData(imageData, 0, 0);\n        } else { // zsmooth = false -> filling potentially large bricks works fastest with fillRect\n\n            // gaps do not need to be exact integers, but if they *are* we will get\n            // cleaner edges by rounding at least one edge\n            var xGap = trace.xgap;\n            var yGap = trace.ygap;\n            var xGapLeft = Math.floor(xGap / 2);\n            var yGapTop = Math.floor(yGap / 2);\n\n            for(j = 0; j < m; j++) {\n                row = z[j];\n                yb.reverse();\n                yb[ybi] = ypx(j + 1);\n                if(yb[0] === yb[1] || yb[0] === undefined || yb[1] === undefined) {\n                    continue;\n                }\n                xi = xpx(0);\n                xb = [xi, xi];\n                for(i = 0; i < n; i++) {\n                    // build one color brick!\n                    xb.reverse();\n                    xb[xbi] = xpx(i + 1);\n                    if(xb[0] === xb[1] || xb[0] === undefined || xb[1] === undefined) {\n                        continue;\n                    }\n                    v = row[i];\n                    c = setColor(v, (xb[1] - xb[0]) * (yb[1] - yb[0]));\n                    context.fillStyle = 'rgba(' + c.join(',') + ')';\n\n                    context.fillRect(xb[0] + xGapLeft, yb[0] + yGapTop,\n                        xb[1] - xb[0] - xGap, yb[1] - yb[0] - yGap);\n                }\n            }\n        }\n\n        rcount = Math.round(rcount / pixcount);\n        gcount = Math.round(gcount / pixcount);\n        bcount = Math.round(bcount / pixcount);\n        var avgColor = tinycolor('rgb(' + rcount + ',' + gcount + ',' + bcount + ')');\n\n        gd._hmpixcount = (gd._hmpixcount||0) + pixcount;\n        gd._hmlumcount = (gd._hmlumcount||0) + pixcount * avgColor.getLuminance();\n\n        var image3 = plotGroup.selectAll('image')\n            .data(cd);\n\n        image3.enter().append('svg:image').attr({\n            xmlns: xmlnsNamespaces.svg,\n            preserveAspectRatio: 'none'\n        });\n\n        image3.attr({\n            height: imageHeight,\n            width: imageWidth,\n            x: left,\n            y: top,\n            'xlink:href': canvas.toDataURL('image/png')\n        });\n    });\n};\n\n// get interpolated bin value. Returns {bin0:closest bin, frac:fractional dist to next, bin1:next bin}\nfunction findInterp(pixel, pixArray) {\n    var maxBin = pixArray.length - 2;\n    var bin = Lib.constrain(Lib.findBin(pixel, pixArray), 0, maxBin);\n    var pix0 = pixArray[bin];\n    var pix1 = pixArray[bin + 1];\n    var interp = Lib.constrain(bin + (pixel - pix0) / (pix1 - pix0) - 0.5, 0, maxBin);\n    var bin0 = Math.round(interp);\n    var frac = Math.abs(interp - bin0);\n\n    if(!interp || interp === maxBin || !frac) {\n        return {\n            bin0: bin0,\n            bin1: bin0,\n            frac: 0\n        };\n    }\n    return {\n        bin0: bin0,\n        frac: frac,\n        bin1: Math.round(bin0 + frac / (interp - bin0))\n    };\n}\n\nfunction findInterpFromCenters(pixel, centerPixArray) {\n    var maxBin = centerPixArray.length - 1;\n    var bin = Lib.constrain(Lib.findBin(pixel, centerPixArray), 0, maxBin);\n    var pix0 = centerPixArray[bin];\n    var pix1 = centerPixArray[bin + 1];\n    var frac = ((pixel - pix0) / (pix1 - pix0)) || 0;\n    if(frac <= 0) {\n        return {\n            bin0: bin,\n            bin1: bin,\n            frac: 0\n        };\n    }\n    if(frac < 0.5) {\n        return {\n            bin0: bin,\n            bin1: bin + 1,\n            frac: frac\n        };\n    }\n    return {\n        bin0: bin + 1,\n        bin1: bin,\n        frac: 1 - frac\n    };\n}\n\nfunction putColor(pixels, pxIndex, c) {\n    pixels[pxIndex] = c[0];\n    pixels[pxIndex + 1] = c[1];\n    pixels[pxIndex + 2] = c[2];\n    pixels[pxIndex + 3] = Math.round(c[3] * 255);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}