{"ast":null,"code":"'use strict';\n\nvar createUniformWrapper = require('./lib/create-uniforms');\nvar createAttributeWrapper = require('./lib/create-attributes');\nvar makeReflect = require('./lib/reflect');\nvar shaderCache = require('./lib/shader-cache');\nvar runtime = require('./lib/runtime-reflect');\nvar GLError = require(\"./lib/GLError\");\n\n//Shader object\nfunction Shader(gl) {\n  this.gl = gl;\n  this.gl.lastAttribCount = 0; // fixme where else should we store info, safe but not nice on the gl object\n\n  //Default initialize these to null\n  this._vref = this._fref = this._relink = this.vertShader = this.fragShader = this.program = this.attributes = this.uniforms = this.types = null;\n}\nvar proto = Shader.prototype;\nproto.bind = function () {\n  if (!this.program) {\n    this._relink();\n  }\n\n  // ensuring that we have the right number of enabled vertex attributes\n  var i;\n  var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES); // more robust approach\n  //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown\n  var oldAttribCount = this.gl.lastAttribCount;\n  if (newAttribCount > oldAttribCount) {\n    for (i = oldAttribCount; i < newAttribCount; i++) {\n      this.gl.enableVertexAttribArray(i);\n    }\n  } else if (oldAttribCount > newAttribCount) {\n    for (i = newAttribCount; i < oldAttribCount; i++) {\n      this.gl.disableVertexAttribArray(i);\n    }\n  }\n  this.gl.lastAttribCount = newAttribCount;\n  this.gl.useProgram(this.program);\n};\nproto.dispose = function () {\n  // disabling vertex attributes so new shader starts with zero\n  // and it's also useful if all shaders are disposed but the\n  // gl context is reused for subsequent replotting\n  var oldAttribCount = this.gl.lastAttribCount;\n  for (var i = 0; i < oldAttribCount; i++) {\n    this.gl.disableVertexAttribArray(i);\n  }\n  this.gl.lastAttribCount = 0;\n  if (this._fref) {\n    this._fref.dispose();\n  }\n  if (this._vref) {\n    this._vref.dispose();\n  }\n  this.attributes = this.types = this.vertShader = this.fragShader = this.program = this._relink = this._fref = this._vref = null;\n};\nfunction compareAttributes(a, b) {\n  if (a.name < b.name) {\n    return -1;\n  }\n  return 1;\n}\n\n//Update export hook for glslify-live\nproto.update = function (vertSource, fragSource, uniforms, attributes) {\n  //If only one object passed, assume glslify style output\n  if (!fragSource || arguments.length === 1) {\n    var obj = vertSource;\n    vertSource = obj.vertex;\n    fragSource = obj.fragment;\n    uniforms = obj.uniforms;\n    attributes = obj.attributes;\n  }\n  var wrapper = this;\n  var gl = wrapper.gl;\n\n  //Compile vertex and fragment shaders\n  var pvref = wrapper._vref;\n  wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource);\n  if (pvref) {\n    pvref.dispose();\n  }\n  wrapper.vertShader = wrapper._vref.shader;\n  var pfref = this._fref;\n  wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource);\n  if (pfref) {\n    pfref.dispose();\n  }\n  wrapper.fragShader = wrapper._fref.shader;\n\n  //If uniforms/attributes is not specified, use RT reflection\n  if (!uniforms || !attributes) {\n    //Create initial test program\n    var testProgram = gl.createProgram();\n    gl.attachShader(testProgram, wrapper.fragShader);\n    gl.attachShader(testProgram, wrapper.vertShader);\n    gl.linkProgram(testProgram);\n    if (!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {\n      var errLog = gl.getProgramInfoLog(testProgram);\n      throw new GLError(errLog, 'Error linking program:' + errLog);\n    }\n\n    //Load data from runtime\n    uniforms = uniforms || runtime.uniforms(gl, testProgram);\n    attributes = attributes || runtime.attributes(gl, testProgram);\n\n    //Release test program\n    gl.deleteProgram(testProgram);\n  }\n\n  //Sort attributes lexicographically\n  // overrides undefined WebGL behavior for attribute locations\n  attributes = attributes.slice();\n  attributes.sort(compareAttributes);\n\n  //Convert attribute types, read out locations\n  var attributeUnpacked = [];\n  var attributeNames = [];\n  var attributeLocations = [];\n  var i;\n  for (i = 0; i < attributes.length; ++i) {\n    var attr = attributes[i];\n    if (attr.type.indexOf('mat') >= 0) {\n      var size = attr.type.charAt(attr.type.length - 1) | 0;\n      var locVector = new Array(size);\n      for (var j = 0; j < size; ++j) {\n        locVector[j] = attributeLocations.length;\n        attributeNames.push(attr.name + '[' + j + ']');\n        if (typeof attr.location === 'number') {\n          attributeLocations.push(attr.location + j);\n        } else if (Array.isArray(attr.location) && attr.location.length === size && typeof attr.location[j] === 'number') {\n          attributeLocations.push(attr.location[j] | 0);\n        } else {\n          attributeLocations.push(-1);\n        }\n      }\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: locVector\n      });\n    } else {\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: [attributeLocations.length]\n      });\n      attributeNames.push(attr.name);\n      if (typeof attr.location === 'number') {\n        attributeLocations.push(attr.location | 0);\n      } else {\n        attributeLocations.push(-1);\n      }\n    }\n  }\n\n  //For all unspecified attributes, assign them lexicographically min attribute\n  var curLocation = 0;\n  for (i = 0; i < attributeLocations.length; ++i) {\n    if (attributeLocations[i] < 0) {\n      while (attributeLocations.indexOf(curLocation) >= 0) {\n        curLocation += 1;\n      }\n      attributeLocations[i] = curLocation;\n    }\n  }\n\n  //Rebuild program and recompute all uniform locations\n  var uniformLocations = new Array(uniforms.length);\n  function relink() {\n    wrapper.program = shaderCache.program(gl, wrapper._vref, wrapper._fref, attributeNames, attributeLocations);\n    for (var i = 0; i < uniforms.length; ++i) {\n      uniformLocations[i] = gl.getUniformLocation(wrapper.program, uniforms[i].name);\n    }\n  }\n\n  //Perform initial linking, reuse program used for reflection\n  relink();\n\n  //Save relinking procedure, defer until runtime\n  wrapper._relink = relink;\n\n  //Generate type info\n  wrapper.types = {\n    uniforms: makeReflect(uniforms),\n    attributes: makeReflect(attributes)\n  };\n\n  //Generate attribute wrappers\n  wrapper.attributes = createAttributeWrapper(gl, wrapper, attributeUnpacked, attributeLocations);\n\n  //Generate uniform wrappers\n  Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(gl, wrapper, uniforms, uniformLocations));\n};\n\n//Compiles and links a shader program with the given attribute and vertex list\nfunction createShader(gl, vertSource, fragSource, uniforms, attributes) {\n  var shader = new Shader(gl);\n  shader.update(vertSource, fragSource, uniforms, attributes);\n  return shader;\n}\nmodule.exports = createShader;","map":{"version":3,"names":["createUniformWrapper","require","createAttributeWrapper","makeReflect","shaderCache","runtime","GLError","Shader","gl","lastAttribCount","_vref","_fref","_relink","vertShader","fragShader","program","attributes","uniforms","types","proto","prototype","bind","i","newAttribCount","getProgramParameter","ACTIVE_ATTRIBUTES","oldAttribCount","enableVertexAttribArray","disableVertexAttribArray","useProgram","dispose","compareAttributes","a","b","name","update","vertSource","fragSource","arguments","length","obj","vertex","fragment","wrapper","pvref","shader","VERTEX_SHADER","pfref","FRAGMENT_SHADER","testProgram","createProgram","attachShader","linkProgram","LINK_STATUS","errLog","getProgramInfoLog","deleteProgram","slice","sort","attributeUnpacked","attributeNames","attributeLocations","attr","type","indexOf","size","charAt","locVector","Array","j","push","location","isArray","locations","curLocation","uniformLocations","relink","getUniformLocation","Object","defineProperty","createShader","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/gl-shader/index.js"],"sourcesContent":["'use strict'\n\nvar createUniformWrapper   = require('./lib/create-uniforms')\nvar createAttributeWrapper = require('./lib/create-attributes')\nvar makeReflect            = require('./lib/reflect')\nvar shaderCache            = require('./lib/shader-cache')\nvar runtime                = require('./lib/runtime-reflect')\nvar GLError                = require(\"./lib/GLError\")\n\n//Shader object\nfunction Shader(gl) {\n  this.gl         = gl\n  this.gl.lastAttribCount = 0  // fixme where else should we store info, safe but not nice on the gl object\n\n  //Default initialize these to null\n  this._vref      =\n  this._fref      =\n  this._relink    =\n  this.vertShader =\n  this.fragShader =\n  this.program    =\n  this.attributes =\n  this.uniforms   =\n  this.types      = null\n}\n\nvar proto = Shader.prototype\n\nproto.bind = function() {\n  if(!this.program) {\n    this._relink()\n  }\n\n  // ensuring that we have the right number of enabled vertex attributes\n  var i\n  var newAttribCount = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES) // more robust approach\n  //var newAttribCount = Object.keys(this.attributes).length // avoids the probably immaterial introspection slowdown\n  var oldAttribCount = this.gl.lastAttribCount\n  if(newAttribCount > oldAttribCount) {\n    for(i = oldAttribCount; i < newAttribCount; i++) {\n      this.gl.enableVertexAttribArray(i)\n    }\n  } else if(oldAttribCount > newAttribCount) {\n    for(i = newAttribCount; i < oldAttribCount; i++) {\n      this.gl.disableVertexAttribArray(i)\n    }\n  }\n\n  this.gl.lastAttribCount = newAttribCount\n\n  this.gl.useProgram(this.program)\n}\n\nproto.dispose = function() {\n\n  // disabling vertex attributes so new shader starts with zero\n  // and it's also useful if all shaders are disposed but the\n  // gl context is reused for subsequent replotting\n  var oldAttribCount = this.gl.lastAttribCount\n  for (var i = 0; i < oldAttribCount; i++) {\n    this.gl.disableVertexAttribArray(i)\n  }\n  this.gl.lastAttribCount = 0\n\n  if(this._fref) {\n    this._fref.dispose()\n  }\n  if(this._vref) {\n    this._vref.dispose()\n  }\n  this.attributes =\n  this.types      =\n  this.vertShader =\n  this.fragShader =\n  this.program    =\n  this._relink    =\n  this._fref      =\n  this._vref      = null\n}\n\nfunction compareAttributes(a, b) {\n  if(a.name < b.name) {\n    return -1\n  }\n  return 1\n}\n\n//Update export hook for glslify-live\nproto.update = function(\n    vertSource\n  , fragSource\n  , uniforms\n  , attributes) {\n\n  //If only one object passed, assume glslify style output\n  if(!fragSource || arguments.length === 1) {\n    var obj = vertSource\n    vertSource = obj.vertex\n    fragSource = obj.fragment\n    uniforms   = obj.uniforms\n    attributes = obj.attributes\n  }\n\n  var wrapper = this\n  var gl      = wrapper.gl\n\n  //Compile vertex and fragment shaders\n  var pvref = wrapper._vref\n  wrapper._vref = shaderCache.shader(gl, gl.VERTEX_SHADER, vertSource)\n  if(pvref) {\n    pvref.dispose()\n  }\n  wrapper.vertShader = wrapper._vref.shader\n  var pfref = this._fref\n  wrapper._fref = shaderCache.shader(gl, gl.FRAGMENT_SHADER, fragSource)\n  if(pfref) {\n    pfref.dispose()\n  }\n  wrapper.fragShader = wrapper._fref.shader\n\n  //If uniforms/attributes is not specified, use RT reflection\n  if(!uniforms || !attributes) {\n\n    //Create initial test program\n    var testProgram = gl.createProgram()\n    gl.attachShader(testProgram, wrapper.fragShader)\n    gl.attachShader(testProgram, wrapper.vertShader)\n    gl.linkProgram(testProgram)\n    if(!gl.getProgramParameter(testProgram, gl.LINK_STATUS)) {\n      var errLog = gl.getProgramInfoLog(testProgram)\n      throw new GLError(errLog, 'Error linking program:' + errLog)\n    }\n\n    //Load data from runtime\n    uniforms   = uniforms   || runtime.uniforms(gl, testProgram)\n    attributes = attributes || runtime.attributes(gl, testProgram)\n\n    //Release test program\n    gl.deleteProgram(testProgram)\n  }\n\n  //Sort attributes lexicographically\n  // overrides undefined WebGL behavior for attribute locations\n  attributes = attributes.slice()\n  attributes.sort(compareAttributes)\n\n  //Convert attribute types, read out locations\n  var attributeUnpacked  = []\n  var attributeNames     = []\n  var attributeLocations = []\n  var i\n  for(i=0; i<attributes.length; ++i) {\n    var attr = attributes[i]\n    if(attr.type.indexOf('mat') >= 0) {\n      var size = attr.type.charAt(attr.type.length-1)|0\n      var locVector = new Array(size)\n      for(var j=0; j<size; ++j) {\n        locVector[j] = attributeLocations.length\n        attributeNames.push(attr.name + '[' + j + ']')\n        if(typeof attr.location === 'number') {\n          attributeLocations.push(attr.location + j)\n        } else if(Array.isArray(attr.location) &&\n                  attr.location.length === size &&\n                  typeof attr.location[j] === 'number') {\n          attributeLocations.push(attr.location[j]|0)\n        } else {\n          attributeLocations.push(-1)\n        }\n      }\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: locVector\n      })\n    } else {\n      attributeUnpacked.push({\n        name: attr.name,\n        type: attr.type,\n        locations: [ attributeLocations.length ]\n      })\n      attributeNames.push(attr.name)\n      if(typeof attr.location === 'number') {\n        attributeLocations.push(attr.location|0)\n      } else {\n        attributeLocations.push(-1)\n      }\n    }\n  }\n\n  //For all unspecified attributes, assign them lexicographically min attribute\n  var curLocation = 0\n  for(i=0; i<attributeLocations.length; ++i) {\n    if(attributeLocations[i] < 0) {\n      while(attributeLocations.indexOf(curLocation) >= 0) {\n        curLocation += 1\n      }\n      attributeLocations[i] = curLocation\n    }\n  }\n\n  //Rebuild program and recompute all uniform locations\n  var uniformLocations = new Array(uniforms.length)\n  function relink() {\n    wrapper.program = shaderCache.program(\n        gl\n      , wrapper._vref\n      , wrapper._fref\n      , attributeNames\n      , attributeLocations)\n\n    for(var i=0; i<uniforms.length; ++i) {\n      uniformLocations[i] = gl.getUniformLocation(\n          wrapper.program\n        , uniforms[i].name)\n    }\n  }\n\n  //Perform initial linking, reuse program used for reflection\n  relink()\n\n  //Save relinking procedure, defer until runtime\n  wrapper._relink = relink\n\n  //Generate type info\n  wrapper.types = {\n    uniforms:   makeReflect(uniforms),\n    attributes: makeReflect(attributes)\n  }\n\n  //Generate attribute wrappers\n  wrapper.attributes = createAttributeWrapper(\n      gl\n    , wrapper\n    , attributeUnpacked\n    , attributeLocations)\n\n  //Generate uniform wrappers\n  Object.defineProperty(wrapper, 'uniforms', createUniformWrapper(\n      gl\n    , wrapper\n    , uniforms\n    , uniformLocations))\n}\n\n//Compiles and links a shader program with the given attribute and vertex list\nfunction createShader(\n    gl\n  , vertSource\n  , fragSource\n  , uniforms\n  , attributes) {\n\n  var shader = new Shader(gl)\n\n  shader.update(\n      vertSource\n    , fragSource\n    , uniforms\n    , attributes)\n\n  return shader\n}\n\nmodule.exports = createShader\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}