{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\nvar attributes = require('./attributes');\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\nvar helpers = require('./helpers');\nvar style = require('./style');\n\n// padding in pixels around text\nvar TEXTPAD = 3;\nmodule.exports = function plot(gd, plotinfo, cdbar, barLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullLayout = gd._fullLayout;\n  var bartraces = Lib.makeTraceGroups(barLayer, cdbar, 'trace bars').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    if (!plotinfo.isRangePlot) cd0.node3 = plotGroup;\n    var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n    var bars = pointGroup.selectAll('g.point').data(Lib.identity);\n    bars.enter().append('g').classed('point', true);\n    bars.exit().remove();\n    bars.each(function (di, i) {\n      var bar = d3.select(this);\n\n      // now display the bar\n      // clipped xf/yf (2nd arg true): non-positive\n      // log values go off-screen by plotwidth\n      // so you see them continue if you drag the plot\n      var x0, x1, y0, y1;\n      if (trace.orientation === 'h') {\n        y0 = ya.c2p(di.p0, true);\n        y1 = ya.c2p(di.p1, true);\n        x0 = xa.c2p(di.s0, true);\n        x1 = xa.c2p(di.s1, true);\n\n        // for selections\n        di.ct = [x1, (y0 + y1) / 2];\n      } else {\n        x0 = xa.c2p(di.p0, true);\n        x1 = xa.c2p(di.p1, true);\n        y0 = ya.c2p(di.s0, true);\n        y1 = ya.c2p(di.s1, true);\n\n        // for selections\n        di.ct = [(x0 + x1) / 2, y1];\n      }\n      if (!isNumeric(x0) || !isNumeric(x1) || !isNumeric(y0) || !isNumeric(y1) || x0 === x1 || y0 === y1) {\n        bar.remove();\n        return;\n      }\n      var lw = (di.mlw + 1 || trace.marker.line.width + 1 || (di.trace ? di.trace.marker.line.width : 0) + 1) - 1;\n      var offset = d3.round(lw / 2 % 1, 2);\n      function roundWithLine(v) {\n        // if there are explicit gaps, don't round,\n        // it can make the gaps look crappy\n        return fullLayout.bargap === 0 && fullLayout.bargroupgap === 0 ? d3.round(Math.round(v) - offset, 2) : v;\n      }\n      function expandToVisible(v, vc) {\n        // if it's not in danger of disappearing entirely,\n        // round more precisely\n        return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n        // but if it's very thin, expand it so it's\n        // necessarily visible, even if it might overlap\n        // its neighbor\n        v > vc ? Math.ceil(v) : Math.floor(v);\n      }\n      if (!gd._context.staticPlot) {\n        // if bars are not fully opaque or they have a line\n        // around them, round to integer pixels, mainly for\n        // safari so we prevent overlaps from its expansive\n        // pixelation. if the bars ARE fully opaque and have\n        // no line, expand to a full pixel to make sure we\n        // can see them\n        var op = Color.opacity(di.mc || trace.marker.color);\n        var fixpx = op < 1 || lw > 0.01 ? roundWithLine : expandToVisible;\n        x0 = fixpx(x0, x1);\n        x1 = fixpx(x1, x0);\n        y0 = fixpx(y0, y1);\n        y1 = fixpx(y1, y0);\n      }\n      Lib.ensureSingle(bar, 'path').style('vector-effect', 'non-scaling-stroke').attr('d', 'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z').call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n      appendBarText(gd, bar, cd, i, x0, x1, y0, y1);\n      if (plotinfo.layerClipId) {\n        Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n      }\n    });\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = cd0.trace.cliponaxis === false;\n    Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n  });\n\n  // error bars are on the top\n  Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo);\n};\nfunction appendBarText(gd, bar, calcTrace, i, x0, x1, y0, y1) {\n  var textPosition;\n  function appendTextNode(bar, text, textFont) {\n    var textSelection = Lib.ensureSingle(bar, 'text').text(text).attr({\n      'class': 'bartext bartext-' + textPosition,\n      transform: '',\n      'text-anchor': 'middle',\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      'data-notex': 1\n    }).call(Drawing.font, textFont).call(svgTextUtils.convertToTspans, gd);\n    return textSelection;\n  }\n\n  // get trace attributes\n  var trace = calcTrace[0].trace;\n  var orientation = trace.orientation;\n  var text = getText(trace, i);\n  textPosition = getTextPosition(trace, i);\n  if (!text || textPosition === 'none') {\n    bar.select('text').remove();\n    return;\n  }\n  var layoutFont = gd._fullLayout.font;\n  var barColor = style.getBarColor(calcTrace[i], trace);\n  var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n  var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n\n  // compute text position\n  var barmode = gd._fullLayout.barmode;\n  var inStackMode = barmode === 'stack';\n  var inRelativeMode = barmode === 'relative';\n  var inStackOrRelativeMode = inStackMode || inRelativeMode;\n  var calcBar = calcTrace[i];\n  var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n  var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD; // padding excluded\n  var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD; // padding excluded\n\n  var textSelection;\n  var textBB;\n  var textWidth;\n  var textHeight;\n  if (textPosition === 'outside') {\n    if (!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n  }\n  if (textPosition === 'auto') {\n    if (isOutmostBar) {\n      // draw text using insideTextFont and check if it fits inside bar\n      textPosition = 'inside';\n      textSelection = appendTextNode(bar, text, insideTextFont);\n      textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n      var textHasSize = textWidth > 0 && textHeight > 0;\n      var fitsInside = textWidth <= barWidth && textHeight <= barHeight;\n      var fitsInsideIfRotated = textWidth <= barHeight && textHeight <= barWidth;\n      var fitsInsideIfShrunk = orientation === 'h' ? barWidth >= textWidth * (barHeight / textHeight) : barHeight >= textHeight * (barWidth / textWidth);\n      if (textHasSize && (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n        textPosition = 'inside';\n      } else {\n        textPosition = 'outside';\n        textSelection.remove();\n        textSelection = null;\n      }\n    } else textPosition = 'inside';\n  }\n  if (!textSelection) {\n    textSelection = appendTextNode(bar, text, textPosition === 'outside' ? outsideTextFont : insideTextFont);\n    textBB = Drawing.bBox(textSelection.node()), textWidth = textBB.width, textHeight = textBB.height;\n    if (textWidth <= 0 || textHeight <= 0) {\n      textSelection.remove();\n      return;\n    }\n  }\n\n  // compute text transform\n  var transform, constrained;\n  if (textPosition === 'outside') {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n    transform = getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB, orientation, constrained);\n  } else {\n    constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n    transform = getTransformToMoveInsideBar(x0, x1, y0, y1, textBB, orientation, constrained);\n  }\n  textSelection.attr('transform', transform);\n}\nfunction getTransformToMoveInsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n  // compute text and target positions\n  var textWidth = textBB.width;\n  var textHeight = textBB.height;\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var barWidth = Math.abs(x1 - x0);\n  var barHeight = Math.abs(y1 - y0);\n  var targetWidth;\n  var targetHeight;\n  var targetX;\n  var targetY;\n\n  // apply text padding\n  var textpad;\n  if (barWidth > 2 * TEXTPAD && barHeight > 2 * TEXTPAD) {\n    textpad = TEXTPAD;\n    barWidth -= 2 * textpad;\n    barHeight -= 2 * textpad;\n  } else textpad = 0;\n\n  // compute rotation and scale\n  var rotate, scale;\n  if (textWidth <= barWidth && textHeight <= barHeight) {\n    // no scale or rotation is required\n    rotate = false;\n    scale = 1;\n  } else if (textWidth <= barHeight && textHeight <= barWidth) {\n    // only rotation is required\n    rotate = true;\n    scale = 1;\n  } else if (textWidth < textHeight === barWidth < barHeight) {\n    // only scale is required\n    rotate = false;\n    scale = constrained ? Math.min(barWidth / textWidth, barHeight / textHeight) : 1;\n  } else {\n    // both scale and rotation are required\n    rotate = true;\n    scale = constrained ? Math.min(barHeight / textWidth, barWidth / textHeight) : 1;\n  }\n  if (rotate) rotate = 90; // rotate clockwise\n\n  // compute text and target positions\n  if (rotate) {\n    targetWidth = scale * textHeight;\n    targetHeight = scale * textWidth;\n  } else {\n    targetWidth = scale * textWidth;\n    targetHeight = scale * textHeight;\n  }\n  if (orientation === 'h') {\n    if (x1 < x0) {\n      // bar end is on the left hand side\n      targetX = x1 + textpad + targetWidth / 2;\n      targetY = (y0 + y1) / 2;\n    } else {\n      targetX = x1 - textpad - targetWidth / 2;\n      targetY = (y0 + y1) / 2;\n    }\n  } else {\n    if (y1 > y0) {\n      // bar end is on the bottom\n      targetX = (x0 + x1) / 2;\n      targetY = y1 - textpad - targetHeight / 2;\n    } else {\n      targetX = (x0 + x1) / 2;\n      targetY = y1 + textpad + targetHeight / 2;\n    }\n  }\n  return getTransform(textX, textY, targetX, targetY, scale, rotate);\n}\nfunction getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n  var barWidth = orientation === 'h' ? Math.abs(y1 - y0) : Math.abs(x1 - x0);\n  var textpad;\n\n  // Keep the padding so the text doesn't sit right against\n  // the bars, but don't factor it into barWidth\n  if (barWidth > 2 * TEXTPAD) {\n    textpad = TEXTPAD;\n  }\n\n  // compute rotation and scale\n  var scale = 1;\n  if (constrained) {\n    scale = orientation === 'h' ? Math.min(1, barWidth / textBB.height) : Math.min(1, barWidth / textBB.width);\n  }\n\n  // compute text and target positions\n  var textX = (textBB.left + textBB.right) / 2;\n  var textY = (textBB.top + textBB.bottom) / 2;\n  var targetWidth;\n  var targetHeight;\n  var targetX;\n  var targetY;\n  targetWidth = scale * textBB.width;\n  targetHeight = scale * textBB.height;\n  if (orientation === 'h') {\n    if (x1 < x0) {\n      // bar end is on the left hand side\n      targetX = x1 - textpad - targetWidth / 2;\n      targetY = (y0 + y1) / 2;\n    } else {\n      targetX = x1 + textpad + targetWidth / 2;\n      targetY = (y0 + y1) / 2;\n    }\n  } else {\n    if (y1 > y0) {\n      // bar end is on the bottom\n      targetX = (x0 + x1) / 2;\n      targetY = y1 + textpad + targetHeight / 2;\n    } else {\n      targetX = (x0 + x1) / 2;\n      targetY = y1 - textpad - targetHeight / 2;\n    }\n  }\n  return getTransform(textX, textY, targetX, targetY, scale, false);\n}\nfunction getTransform(textX, textY, targetX, targetY, scale, rotate) {\n  var transformScale;\n  var transformRotate;\n  var transformTranslate;\n  if (scale < 1) transformScale = 'scale(' + scale + ') ';else {\n    scale = 1;\n    transformScale = '';\n  }\n  transformRotate = rotate ? 'rotate(' + rotate + ' ' + textX + ' ' + textY + ') ' : '';\n\n  // Note that scaling also affects the center of the text box\n  var translateX = targetX - scale * textX;\n  var translateY = targetY - scale * textY;\n  transformTranslate = 'translate(' + translateX + ' ' + translateY + ')';\n  return transformTranslate + transformScale + transformRotate;\n}\nfunction getText(trace, index) {\n  var value = helpers.getValue(trace.text, index);\n  return helpers.coerceString(attributeText, value);\n}\nfunction getTextPosition(trace, index) {\n  var value = helpers.getValue(trace.textposition, index);\n  return helpers.coerceEnumerated(attributeTextPosition, value);\n}","map":{"version":3,"names":["d3","require","isNumeric","Lib","svgTextUtils","Color","Drawing","Registry","attributes","attributeText","text","attributeTextPosition","textposition","helpers","style","TEXTPAD","module","exports","plot","gd","plotinfo","cdbar","barLayer","xa","xaxis","ya","yaxis","fullLayout","_fullLayout","bartraces","makeTraceGroups","each","cd","plotGroup","select","cd0","trace","isRangePlot","node3","pointGroup","ensureSingle","bars","selectAll","data","identity","enter","append","classed","exit","remove","di","i","bar","x0","x1","y0","y1","orientation","c2p","p0","p1","s0","s1","ct","lw","mlw","marker","line","width","offset","round","roundWithLine","v","bargap","bargroupgap","Math","expandToVisible","vc","abs","ceil","floor","_context","staticPlot","op","opacity","mc","color","fixpx","attr","call","setClipUrl","layerClipId","appendBarText","hideOutsideRangePoint","xcalendar","ycalendar","hasClipOnAxisFalse","cliponaxis","getComponentMethod","calcTrace","textPosition","appendTextNode","textFont","textSelection","transform","font","convertToTspans","getText","getTextPosition","layoutFont","barColor","getBarColor","insideTextFont","getInsideTextFont","outsideTextFont","getOutsideTextFont","barmode","inStackMode","inRelativeMode","inStackOrRelativeMode","calcBar","isOutmostBar","_outmost","barWidth","barHeight","textBB","textWidth","textHeight","hasB","bBox","node","height","textHasSize","fitsInside","fitsInsideIfRotated","fitsInsideIfShrunk","constrained","constraintext","getTransformToMoveOutsideBar","getTransformToMoveInsideBar","textX","left","right","textY","top","bottom","targetWidth","targetHeight","targetX","targetY","textpad","rotate","scale","min","getTransform","transformScale","transformRotate","transformTranslate","translateX","translateY","index","value","getValue","coerceString","coerceEnumerated"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/bar/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\n\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Registry = require('../../registry');\n\nvar attributes = require('./attributes');\nvar attributeText = attributes.text;\nvar attributeTextPosition = attributes.textposition;\nvar helpers = require('./helpers');\nvar style = require('./style');\n\n// padding in pixels around text\nvar TEXTPAD = 3;\n\nmodule.exports = function plot(gd, plotinfo, cdbar, barLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var fullLayout = gd._fullLayout;\n\n    var bartraces = Lib.makeTraceGroups(barLayer, cdbar, 'trace bars').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n\n        if(!plotinfo.isRangePlot) cd0.node3 = plotGroup;\n\n        var pointGroup = Lib.ensureSingle(plotGroup, 'g', 'points');\n\n        var bars = pointGroup.selectAll('g.point').data(Lib.identity);\n\n        bars.enter().append('g')\n            .classed('point', true);\n\n        bars.exit().remove();\n\n        bars.each(function(di, i) {\n            var bar = d3.select(this);\n\n            // now display the bar\n            // clipped xf/yf (2nd arg true): non-positive\n            // log values go off-screen by plotwidth\n            // so you see them continue if you drag the plot\n            var x0, x1, y0, y1;\n            if(trace.orientation === 'h') {\n                y0 = ya.c2p(di.p0, true);\n                y1 = ya.c2p(di.p1, true);\n                x0 = xa.c2p(di.s0, true);\n                x1 = xa.c2p(di.s1, true);\n\n                // for selections\n                di.ct = [x1, (y0 + y1) / 2];\n            }\n            else {\n                x0 = xa.c2p(di.p0, true);\n                x1 = xa.c2p(di.p1, true);\n                y0 = ya.c2p(di.s0, true);\n                y1 = ya.c2p(di.s1, true);\n\n                // for selections\n                di.ct = [(x0 + x1) / 2, y1];\n            }\n\n            if(!isNumeric(x0) || !isNumeric(x1) ||\n                    !isNumeric(y0) || !isNumeric(y1) ||\n                    x0 === x1 || y0 === y1) {\n                bar.remove();\n                return;\n            }\n\n            var lw = (di.mlw + 1 || trace.marker.line.width + 1 ||\n                    (di.trace ? di.trace.marker.line.width : 0) + 1) - 1;\n            var offset = d3.round((lw / 2) % 1, 2);\n\n            function roundWithLine(v) {\n                // if there are explicit gaps, don't round,\n                // it can make the gaps look crappy\n                return (fullLayout.bargap === 0 && fullLayout.bargroupgap === 0) ?\n                    d3.round(Math.round(v) - offset, 2) : v;\n            }\n\n            function expandToVisible(v, vc) {\n                // if it's not in danger of disappearing entirely,\n                // round more precisely\n                return Math.abs(v - vc) >= 2 ? roundWithLine(v) :\n                // but if it's very thin, expand it so it's\n                // necessarily visible, even if it might overlap\n                // its neighbor\n                (v > vc ? Math.ceil(v) : Math.floor(v));\n            }\n\n            if(!gd._context.staticPlot) {\n                // if bars are not fully opaque or they have a line\n                // around them, round to integer pixels, mainly for\n                // safari so we prevent overlaps from its expansive\n                // pixelation. if the bars ARE fully opaque and have\n                // no line, expand to a full pixel to make sure we\n                // can see them\n                var op = Color.opacity(di.mc || trace.marker.color);\n                var fixpx = (op < 1 || lw > 0.01) ? roundWithLine : expandToVisible;\n                x0 = fixpx(x0, x1);\n                x1 = fixpx(x1, x0);\n                y0 = fixpx(y0, y1);\n                y1 = fixpx(y1, y0);\n            }\n\n            Lib.ensureSingle(bar, 'path')\n                .style('vector-effect', 'non-scaling-stroke')\n                .attr('d',\n                    'M' + x0 + ',' + y0 + 'V' + y1 + 'H' + x1 + 'V' + y0 + 'Z')\n                .call(Drawing.setClipUrl, plotinfo.layerClipId, gd);\n\n            appendBarText(gd, bar, cd, i, x0, x1, y0, y1);\n\n            if(plotinfo.layerClipId) {\n                Drawing.hideOutsideRangePoint(di, bar.select('text'), xa, ya, trace.xcalendar, trace.ycalendar);\n            }\n        });\n\n        // lastly, clip points groups of `cliponaxis !== false` traces\n        // on `plotinfo._hasClipOnAxisFalse === true` subplots\n        var hasClipOnAxisFalse = cd0.trace.cliponaxis === false;\n        Drawing.setClipUrl(plotGroup, hasClipOnAxisFalse ? null : plotinfo.layerClipId, gd);\n    });\n\n    // error bars are on the top\n    Registry.getComponentMethod('errorbars', 'plot')(gd, bartraces, plotinfo);\n};\n\nfunction appendBarText(gd, bar, calcTrace, i, x0, x1, y0, y1) {\n    var textPosition;\n\n    function appendTextNode(bar, text, textFont) {\n        var textSelection = Lib.ensureSingle(bar, 'text')\n            .text(text)\n            .attr({\n                'class': 'bartext bartext-' + textPosition,\n                transform: '',\n                'text-anchor': 'middle',\n                // prohibit tex interpretation until we can handle\n                // tex and regular text together\n                'data-notex': 1\n            })\n            .call(Drawing.font, textFont)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        return textSelection;\n    }\n\n    // get trace attributes\n    var trace = calcTrace[0].trace;\n    var orientation = trace.orientation;\n\n    var text = getText(trace, i);\n    textPosition = getTextPosition(trace, i);\n\n    if(!text || textPosition === 'none') {\n        bar.select('text').remove();\n        return;\n    }\n\n    var layoutFont = gd._fullLayout.font;\n    var barColor = style.getBarColor(calcTrace[i], trace);\n    var insideTextFont = style.getInsideTextFont(trace, i, layoutFont, barColor);\n    var outsideTextFont = style.getOutsideTextFont(trace, i, layoutFont);\n\n    // compute text position\n    var barmode = gd._fullLayout.barmode;\n    var inStackMode = (barmode === 'stack');\n    var inRelativeMode = (barmode === 'relative');\n    var inStackOrRelativeMode = inStackMode || inRelativeMode;\n\n    var calcBar = calcTrace[i];\n    var isOutmostBar = !inStackOrRelativeMode || calcBar._outmost;\n\n    var barWidth = Math.abs(x1 - x0) - 2 * TEXTPAD;  // padding excluded\n    var barHeight = Math.abs(y1 - y0) - 2 * TEXTPAD;  // padding excluded\n\n    var textSelection;\n    var textBB;\n    var textWidth;\n    var textHeight;\n\n    if(textPosition === 'outside') {\n        if(!isOutmostBar && !calcBar.hasB) textPosition = 'inside';\n    }\n\n    if(textPosition === 'auto') {\n        if(isOutmostBar) {\n            // draw text using insideTextFont and check if it fits inside bar\n            textPosition = 'inside';\n            textSelection = appendTextNode(bar, text, insideTextFont);\n\n            textBB = Drawing.bBox(textSelection.node()),\n            textWidth = textBB.width,\n            textHeight = textBB.height;\n\n            var textHasSize = (textWidth > 0 && textHeight > 0);\n            var fitsInside = (textWidth <= barWidth && textHeight <= barHeight);\n            var fitsInsideIfRotated = (textWidth <= barHeight && textHeight <= barWidth);\n            var fitsInsideIfShrunk = (orientation === 'h') ?\n                (barWidth >= textWidth * (barHeight / textHeight)) :\n                (barHeight >= textHeight * (barWidth / textWidth));\n\n            if(textHasSize &&\n                    (fitsInside || fitsInsideIfRotated || fitsInsideIfShrunk)) {\n                textPosition = 'inside';\n            }\n            else {\n                textPosition = 'outside';\n                textSelection.remove();\n                textSelection = null;\n            }\n        }\n        else textPosition = 'inside';\n    }\n\n    if(!textSelection) {\n        textSelection = appendTextNode(bar, text,\n                (textPosition === 'outside') ?\n                outsideTextFont : insideTextFont);\n\n        textBB = Drawing.bBox(textSelection.node()),\n        textWidth = textBB.width,\n        textHeight = textBB.height;\n\n        if(textWidth <= 0 || textHeight <= 0) {\n            textSelection.remove();\n            return;\n        }\n    }\n\n    // compute text transform\n    var transform, constrained;\n    if(textPosition === 'outside') {\n        constrained = trace.constraintext === 'both' || trace.constraintext === 'outside';\n        transform = getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB,\n            orientation, constrained);\n    }\n    else {\n        constrained = trace.constraintext === 'both' || trace.constraintext === 'inside';\n        transform = getTransformToMoveInsideBar(x0, x1, y0, y1, textBB,\n            orientation, constrained);\n    }\n\n    textSelection.attr('transform', transform);\n}\n\nfunction getTransformToMoveInsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n    // compute text and target positions\n    var textWidth = textBB.width;\n    var textHeight = textBB.height;\n    var textX = (textBB.left + textBB.right) / 2;\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var barWidth = Math.abs(x1 - x0);\n    var barHeight = Math.abs(y1 - y0);\n    var targetWidth;\n    var targetHeight;\n    var targetX;\n    var targetY;\n\n    // apply text padding\n    var textpad;\n    if(barWidth > (2 * TEXTPAD) && barHeight > (2 * TEXTPAD)) {\n        textpad = TEXTPAD;\n        barWidth -= 2 * textpad;\n        barHeight -= 2 * textpad;\n    }\n    else textpad = 0;\n\n    // compute rotation and scale\n    var rotate,\n        scale;\n\n    if(textWidth <= barWidth && textHeight <= barHeight) {\n        // no scale or rotation is required\n        rotate = false;\n        scale = 1;\n    }\n    else if(textWidth <= barHeight && textHeight <= barWidth) {\n        // only rotation is required\n        rotate = true;\n        scale = 1;\n    }\n    else if((textWidth < textHeight) === (barWidth < barHeight)) {\n        // only scale is required\n        rotate = false;\n        scale = constrained ? Math.min(barWidth / textWidth, barHeight / textHeight) : 1;\n    }\n    else {\n        // both scale and rotation are required\n        rotate = true;\n        scale = constrained ? Math.min(barHeight / textWidth, barWidth / textHeight) : 1;\n    }\n\n    if(rotate) rotate = 90;  // rotate clockwise\n\n    // compute text and target positions\n    if(rotate) {\n        targetWidth = scale * textHeight;\n        targetHeight = scale * textWidth;\n    }\n    else {\n        targetWidth = scale * textWidth;\n        targetHeight = scale * textHeight;\n    }\n\n    if(orientation === 'h') {\n        if(x1 < x0) {\n            // bar end is on the left hand side\n            targetX = x1 + textpad + targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n        else {\n            targetX = x1 - textpad - targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n    }\n    else {\n        if(y1 > y0) {\n            // bar end is on the bottom\n            targetX = (x0 + x1) / 2;\n            targetY = y1 - textpad - targetHeight / 2;\n        }\n        else {\n            targetX = (x0 + x1) / 2;\n            targetY = y1 + textpad + targetHeight / 2;\n        }\n    }\n\n    return getTransform(textX, textY, targetX, targetY, scale, rotate);\n}\n\nfunction getTransformToMoveOutsideBar(x0, x1, y0, y1, textBB, orientation, constrained) {\n    var barWidth = (orientation === 'h') ?\n        Math.abs(y1 - y0) :\n        Math.abs(x1 - x0);\n    var textpad;\n\n    // Keep the padding so the text doesn't sit right against\n    // the bars, but don't factor it into barWidth\n    if(barWidth > 2 * TEXTPAD) {\n        textpad = TEXTPAD;\n    }\n\n    // compute rotation and scale\n    var scale = 1;\n    if(constrained) {\n        scale = (orientation === 'h') ?\n            Math.min(1, barWidth / textBB.height) :\n            Math.min(1, barWidth / textBB.width);\n    }\n\n    // compute text and target positions\n    var textX = (textBB.left + textBB.right) / 2;\n    var textY = (textBB.top + textBB.bottom) / 2;\n    var targetWidth;\n    var targetHeight;\n    var targetX;\n    var targetY;\n\n    targetWidth = scale * textBB.width;\n    targetHeight = scale * textBB.height;\n\n    if(orientation === 'h') {\n        if(x1 < x0) {\n            // bar end is on the left hand side\n            targetX = x1 - textpad - targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n        else {\n            targetX = x1 + textpad + targetWidth / 2;\n            targetY = (y0 + y1) / 2;\n        }\n    }\n    else {\n        if(y1 > y0) {\n            // bar end is on the bottom\n            targetX = (x0 + x1) / 2;\n            targetY = y1 + textpad + targetHeight / 2;\n        }\n        else {\n            targetX = (x0 + x1) / 2;\n            targetY = y1 - textpad - targetHeight / 2;\n        }\n    }\n\n    return getTransform(textX, textY, targetX, targetY, scale, false);\n}\n\nfunction getTransform(textX, textY, targetX, targetY, scale, rotate) {\n    var transformScale;\n    var transformRotate;\n    var transformTranslate;\n\n    if(scale < 1) transformScale = 'scale(' + scale + ') ';\n    else {\n        scale = 1;\n        transformScale = '';\n    }\n\n    transformRotate = (rotate) ?\n        'rotate(' + rotate + ' ' + textX + ' ' + textY + ') ' : '';\n\n    // Note that scaling also affects the center of the text box\n    var translateX = (targetX - scale * textX);\n    var translateY = (targetY - scale * textY);\n    transformTranslate = 'translate(' + translateX + ' ' + translateY + ')';\n\n    return transformTranslate + transformScale + transformRotate;\n}\n\nfunction getText(trace, index) {\n    var value = helpers.getValue(trace.text, index);\n    return helpers.coerceString(attributeText, value);\n}\n\nfunction getTextPosition(trace, index) {\n    var value = helpers.getValue(trace.textposition, index);\n    return helpers.coerceEnumerated(attributeTextPosition, value);\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,YAAY;;AAEZ,IAAIA,EAAE,GAAGC,OAAO,CAAC,IAAI,CAAC;AACtB,IAAIC,SAAS,GAAGD,OAAO,CAAC,gBAAgB,CAAC;AAEzC,IAAIE,GAAG,GAAGF,OAAO,CAAC,WAAW,CAAC;AAC9B,IAAIG,YAAY,GAAGH,OAAO,CAAC,0BAA0B,CAAC;AAEtD,IAAII,KAAK,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAC7C,IAAIK,OAAO,GAAGL,OAAO,CAAC,0BAA0B,CAAC;AACjD,IAAIM,QAAQ,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AAExC,IAAIO,UAAU,GAAGP,OAAO,CAAC,cAAc,CAAC;AACxC,IAAIQ,aAAa,GAAGD,UAAU,CAACE,IAAI;AACnC,IAAIC,qBAAqB,GAAGH,UAAU,CAACI,YAAY;AACnD,IAAIC,OAAO,GAAGZ,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIa,KAAK,GAAGb,OAAO,CAAC,SAAS,CAAC;;AAE9B;AACA,IAAIc,OAAO,GAAG,CAAC;AAEfC,MAAM,CAACC,OAAO,GAAG,SAASC,IAAI,CAACC,EAAE,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC1D,IAAIC,EAAE,GAAGH,QAAQ,CAACI,KAAK;EACvB,IAAIC,EAAE,GAAGL,QAAQ,CAACM,KAAK;EACvB,IAAIC,UAAU,GAAGR,EAAE,CAACS,WAAW;EAE/B,IAAIC,SAAS,GAAG1B,GAAG,CAAC2B,eAAe,CAACR,QAAQ,EAAED,KAAK,EAAE,YAAY,CAAC,CAACU,IAAI,CAAC,UAASC,EAAE,EAAE;IACjF,IAAIC,SAAS,GAAGjC,EAAE,CAACkC,MAAM,CAAC,IAAI,CAAC;IAC/B,IAAIC,GAAG,GAAGH,EAAE,CAAC,CAAC,CAAC;IACf,IAAII,KAAK,GAAGD,GAAG,CAACC,KAAK;IAErB,IAAG,CAAChB,QAAQ,CAACiB,WAAW,EAAEF,GAAG,CAACG,KAAK,GAAGL,SAAS;IAE/C,IAAIM,UAAU,GAAGpC,GAAG,CAACqC,YAAY,CAACP,SAAS,EAAE,GAAG,EAAE,QAAQ,CAAC;IAE3D,IAAIQ,IAAI,GAAGF,UAAU,CAACG,SAAS,CAAC,SAAS,CAAC,CAACC,IAAI,CAACxC,GAAG,CAACyC,QAAQ,CAAC;IAE7DH,IAAI,CAACI,KAAK,EAAE,CAACC,MAAM,CAAC,GAAG,CAAC,CACnBC,OAAO,CAAC,OAAO,EAAE,IAAI,CAAC;IAE3BN,IAAI,CAACO,IAAI,EAAE,CAACC,MAAM,EAAE;IAEpBR,IAAI,CAACV,IAAI,CAAC,UAASmB,EAAE,EAAEC,CAAC,EAAE;MACtB,IAAIC,GAAG,GAAGpD,EAAE,CAACkC,MAAM,CAAC,IAAI,CAAC;;MAEzB;MACA;MACA;MACA;MACA,IAAImB,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE;MAClB,IAAGpB,KAAK,CAACqB,WAAW,KAAK,GAAG,EAAE;QAC1BF,EAAE,GAAG9B,EAAE,CAACiC,GAAG,CAACR,EAAE,CAACS,EAAE,EAAE,IAAI,CAAC;QACxBH,EAAE,GAAG/B,EAAE,CAACiC,GAAG,CAACR,EAAE,CAACU,EAAE,EAAE,IAAI,CAAC;QACxBP,EAAE,GAAG9B,EAAE,CAACmC,GAAG,CAACR,EAAE,CAACW,EAAE,EAAE,IAAI,CAAC;QACxBP,EAAE,GAAG/B,EAAE,CAACmC,GAAG,CAACR,EAAE,CAACY,EAAE,EAAE,IAAI,CAAC;;QAExB;QACAZ,EAAE,CAACa,EAAE,GAAG,CAACT,EAAE,EAAE,CAACC,EAAE,GAAGC,EAAE,IAAI,CAAC,CAAC;MAC/B,CAAC,MACI;QACDH,EAAE,GAAG9B,EAAE,CAACmC,GAAG,CAACR,EAAE,CAACS,EAAE,EAAE,IAAI,CAAC;QACxBL,EAAE,GAAG/B,EAAE,CAACmC,GAAG,CAACR,EAAE,CAACU,EAAE,EAAE,IAAI,CAAC;QACxBL,EAAE,GAAG9B,EAAE,CAACiC,GAAG,CAACR,EAAE,CAACW,EAAE,EAAE,IAAI,CAAC;QACxBL,EAAE,GAAG/B,EAAE,CAACiC,GAAG,CAACR,EAAE,CAACY,EAAE,EAAE,IAAI,CAAC;;QAExB;QACAZ,EAAE,CAACa,EAAE,GAAG,CAAC,CAACV,EAAE,GAAGC,EAAE,IAAI,CAAC,EAAEE,EAAE,CAAC;MAC/B;MAEA,IAAG,CAACtD,SAAS,CAACmD,EAAE,CAAC,IAAI,CAACnD,SAAS,CAACoD,EAAE,CAAC,IAC3B,CAACpD,SAAS,CAACqD,EAAE,CAAC,IAAI,CAACrD,SAAS,CAACsD,EAAE,CAAC,IAChCH,EAAE,KAAKC,EAAE,IAAIC,EAAE,KAAKC,EAAE,EAAE;QAC5BJ,GAAG,CAACH,MAAM,EAAE;QACZ;MACJ;MAEA,IAAIe,EAAE,GAAG,CAACd,EAAE,CAACe,GAAG,GAAG,CAAC,IAAI7B,KAAK,CAAC8B,MAAM,CAACC,IAAI,CAACC,KAAK,GAAG,CAAC,IAC3C,CAAClB,EAAE,CAACd,KAAK,GAAGc,EAAE,CAACd,KAAK,CAAC8B,MAAM,CAACC,IAAI,CAACC,KAAK,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC;MAC5D,IAAIC,MAAM,GAAGrE,EAAE,CAACsE,KAAK,CAAEN,EAAE,GAAG,CAAC,GAAI,CAAC,EAAE,CAAC,CAAC;MAEtC,SAASO,aAAa,CAACC,CAAC,EAAE;QACtB;QACA;QACA,OAAQ7C,UAAU,CAAC8C,MAAM,KAAK,CAAC,IAAI9C,UAAU,CAAC+C,WAAW,KAAK,CAAC,GAC3D1E,EAAE,CAACsE,KAAK,CAACK,IAAI,CAACL,KAAK,CAACE,CAAC,CAAC,GAAGH,MAAM,EAAE,CAAC,CAAC,GAAGG,CAAC;MAC/C;MAEA,SAASI,eAAe,CAACJ,CAAC,EAAEK,EAAE,EAAE;QAC5B;QACA;QACA,OAAOF,IAAI,CAACG,GAAG,CAACN,CAAC,GAAGK,EAAE,CAAC,IAAI,CAAC,GAAGN,aAAa,CAACC,CAAC,CAAC;QAC/C;QACA;QACA;QACCA,CAAC,GAAGK,EAAE,GAAGF,IAAI,CAACI,IAAI,CAACP,CAAC,CAAC,GAAGG,IAAI,CAACK,KAAK,CAACR,CAAC,CAAE;MAC3C;MAEA,IAAG,CAACrD,EAAE,CAAC8D,QAAQ,CAACC,UAAU,EAAE;QACxB;QACA;QACA;QACA;QACA;QACA;QACA,IAAIC,EAAE,GAAG9E,KAAK,CAAC+E,OAAO,CAAClC,EAAE,CAACmC,EAAE,IAAIjD,KAAK,CAAC8B,MAAM,CAACoB,KAAK,CAAC;QACnD,IAAIC,KAAK,GAAIJ,EAAE,GAAG,CAAC,IAAInB,EAAE,GAAG,IAAI,GAAIO,aAAa,GAAGK,eAAe;QACnEvB,EAAE,GAAGkC,KAAK,CAAClC,EAAE,EAAEC,EAAE,CAAC;QAClBA,EAAE,GAAGiC,KAAK,CAACjC,EAAE,EAAED,EAAE,CAAC;QAClBE,EAAE,GAAGgC,KAAK,CAAChC,EAAE,EAAEC,EAAE,CAAC;QAClBA,EAAE,GAAG+B,KAAK,CAAC/B,EAAE,EAAED,EAAE,CAAC;MACtB;MAEApD,GAAG,CAACqC,YAAY,CAACY,GAAG,EAAE,MAAM,CAAC,CACxBtC,KAAK,CAAC,eAAe,EAAE,oBAAoB,CAAC,CAC5C0E,IAAI,CAAC,GAAG,EACL,GAAG,GAAGnC,EAAE,GAAG,GAAG,GAAGE,EAAE,GAAG,GAAG,GAAGC,EAAE,GAAG,GAAG,GAAGF,EAAE,GAAG,GAAG,GAAGC,EAAE,GAAG,GAAG,CAAC,CAC9DkC,IAAI,CAACnF,OAAO,CAACoF,UAAU,EAAEtE,QAAQ,CAACuE,WAAW,EAAExE,EAAE,CAAC;MAEvDyE,aAAa,CAACzE,EAAE,EAAEiC,GAAG,EAAEpB,EAAE,EAAEmB,CAAC,EAAEE,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,CAAC;MAE7C,IAAGpC,QAAQ,CAACuE,WAAW,EAAE;QACrBrF,OAAO,CAACuF,qBAAqB,CAAC3C,EAAE,EAAEE,GAAG,CAAClB,MAAM,CAAC,MAAM,CAAC,EAAEX,EAAE,EAAEE,EAAE,EAAEW,KAAK,CAAC0D,SAAS,EAAE1D,KAAK,CAAC2D,SAAS,CAAC;MACnG;IACJ,CAAC,CAAC;;IAEF;IACA;IACA,IAAIC,kBAAkB,GAAG7D,GAAG,CAACC,KAAK,CAAC6D,UAAU,KAAK,KAAK;IACvD3F,OAAO,CAACoF,UAAU,CAACzD,SAAS,EAAE+D,kBAAkB,GAAG,IAAI,GAAG5E,QAAQ,CAACuE,WAAW,EAAExE,EAAE,CAAC;EACvF,CAAC,CAAC;;EAEF;EACAZ,QAAQ,CAAC2F,kBAAkB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC/E,EAAE,EAAEU,SAAS,EAAET,QAAQ,CAAC;AAC7E,CAAC;AAED,SAASwE,aAAa,CAACzE,EAAE,EAAEiC,GAAG,EAAE+C,SAAS,EAAEhD,CAAC,EAAEE,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAE;EAC1D,IAAI4C,YAAY;EAEhB,SAASC,cAAc,CAACjD,GAAG,EAAE1C,IAAI,EAAE4F,QAAQ,EAAE;IACzC,IAAIC,aAAa,GAAGpG,GAAG,CAACqC,YAAY,CAACY,GAAG,EAAE,MAAM,CAAC,CAC5C1C,IAAI,CAACA,IAAI,CAAC,CACV8E,IAAI,CAAC;MACF,OAAO,EAAE,kBAAkB,GAAGY,YAAY;MAC1CI,SAAS,EAAE,EAAE;MACb,aAAa,EAAE,QAAQ;MACvB;MACA;MACA,YAAY,EAAE;IAClB,CAAC,CAAC,CACDf,IAAI,CAACnF,OAAO,CAACmG,IAAI,EAAEH,QAAQ,CAAC,CAC5Bb,IAAI,CAACrF,YAAY,CAACsG,eAAe,EAAEvF,EAAE,CAAC;IAE3C,OAAOoF,aAAa;EACxB;;EAEA;EACA,IAAInE,KAAK,GAAG+D,SAAS,CAAC,CAAC,CAAC,CAAC/D,KAAK;EAC9B,IAAIqB,WAAW,GAAGrB,KAAK,CAACqB,WAAW;EAEnC,IAAI/C,IAAI,GAAGiG,OAAO,CAACvE,KAAK,EAAEe,CAAC,CAAC;EAC5BiD,YAAY,GAAGQ,eAAe,CAACxE,KAAK,EAAEe,CAAC,CAAC;EAExC,IAAG,CAACzC,IAAI,IAAI0F,YAAY,KAAK,MAAM,EAAE;IACjChD,GAAG,CAAClB,MAAM,CAAC,MAAM,CAAC,CAACe,MAAM,EAAE;IAC3B;EACJ;EAEA,IAAI4D,UAAU,GAAG1F,EAAE,CAACS,WAAW,CAAC6E,IAAI;EACpC,IAAIK,QAAQ,GAAGhG,KAAK,CAACiG,WAAW,CAACZ,SAAS,CAAChD,CAAC,CAAC,EAAEf,KAAK,CAAC;EACrD,IAAI4E,cAAc,GAAGlG,KAAK,CAACmG,iBAAiB,CAAC7E,KAAK,EAAEe,CAAC,EAAE0D,UAAU,EAAEC,QAAQ,CAAC;EAC5E,IAAII,eAAe,GAAGpG,KAAK,CAACqG,kBAAkB,CAAC/E,KAAK,EAAEe,CAAC,EAAE0D,UAAU,CAAC;;EAEpE;EACA,IAAIO,OAAO,GAAGjG,EAAE,CAACS,WAAW,CAACwF,OAAO;EACpC,IAAIC,WAAW,GAAID,OAAO,KAAK,OAAQ;EACvC,IAAIE,cAAc,GAAIF,OAAO,KAAK,UAAW;EAC7C,IAAIG,qBAAqB,GAAGF,WAAW,IAAIC,cAAc;EAEzD,IAAIE,OAAO,GAAGrB,SAAS,CAAChD,CAAC,CAAC;EAC1B,IAAIsE,YAAY,GAAG,CAACF,qBAAqB,IAAIC,OAAO,CAACE,QAAQ;EAE7D,IAAIC,QAAQ,GAAGhD,IAAI,CAACG,GAAG,CAACxB,EAAE,GAAGD,EAAE,CAAC,GAAG,CAAC,GAAGtC,OAAO,CAAC,CAAE;EACjD,IAAI6G,SAAS,GAAGjD,IAAI,CAACG,GAAG,CAACtB,EAAE,GAAGD,EAAE,CAAC,GAAG,CAAC,GAAGxC,OAAO,CAAC,CAAE;;EAElD,IAAIwF,aAAa;EACjB,IAAIsB,MAAM;EACV,IAAIC,SAAS;EACb,IAAIC,UAAU;EAEd,IAAG3B,YAAY,KAAK,SAAS,EAAE;IAC3B,IAAG,CAACqB,YAAY,IAAI,CAACD,OAAO,CAACQ,IAAI,EAAE5B,YAAY,GAAG,QAAQ;EAC9D;EAEA,IAAGA,YAAY,KAAK,MAAM,EAAE;IACxB,IAAGqB,YAAY,EAAE;MACb;MACArB,YAAY,GAAG,QAAQ;MACvBG,aAAa,GAAGF,cAAc,CAACjD,GAAG,EAAE1C,IAAI,EAAEsG,cAAc,CAAC;MAEzDa,MAAM,GAAGvH,OAAO,CAAC2H,IAAI,CAAC1B,aAAa,CAAC2B,IAAI,EAAE,CAAC,EAC3CJ,SAAS,GAAGD,MAAM,CAACzD,KAAK,EACxB2D,UAAU,GAAGF,MAAM,CAACM,MAAM;MAE1B,IAAIC,WAAW,GAAIN,SAAS,GAAG,CAAC,IAAIC,UAAU,GAAG,CAAE;MACnD,IAAIM,UAAU,GAAIP,SAAS,IAAIH,QAAQ,IAAII,UAAU,IAAIH,SAAU;MACnE,IAAIU,mBAAmB,GAAIR,SAAS,IAAIF,SAAS,IAAIG,UAAU,IAAIJ,QAAS;MAC5E,IAAIY,kBAAkB,GAAI9E,WAAW,KAAK,GAAG,GACxCkE,QAAQ,IAAIG,SAAS,IAAIF,SAAS,GAAGG,UAAU,CAAC,GAChDH,SAAS,IAAIG,UAAU,IAAIJ,QAAQ,GAAGG,SAAS,CAAE;MAEtD,IAAGM,WAAW,KACLC,UAAU,IAAIC,mBAAmB,IAAIC,kBAAkB,CAAC,EAAE;QAC/DnC,YAAY,GAAG,QAAQ;MAC3B,CAAC,MACI;QACDA,YAAY,GAAG,SAAS;QACxBG,aAAa,CAACtD,MAAM,EAAE;QACtBsD,aAAa,GAAG,IAAI;MACxB;IACJ,CAAC,MACIH,YAAY,GAAG,QAAQ;EAChC;EAEA,IAAG,CAACG,aAAa,EAAE;IACfA,aAAa,GAAGF,cAAc,CAACjD,GAAG,EAAE1C,IAAI,EAC/B0F,YAAY,KAAK,SAAS,GAC3Bc,eAAe,GAAGF,cAAc,CAAC;IAEzCa,MAAM,GAAGvH,OAAO,CAAC2H,IAAI,CAAC1B,aAAa,CAAC2B,IAAI,EAAE,CAAC,EAC3CJ,SAAS,GAAGD,MAAM,CAACzD,KAAK,EACxB2D,UAAU,GAAGF,MAAM,CAACM,MAAM;IAE1B,IAAGL,SAAS,IAAI,CAAC,IAAIC,UAAU,IAAI,CAAC,EAAE;MAClCxB,aAAa,CAACtD,MAAM,EAAE;MACtB;IACJ;EACJ;;EAEA;EACA,IAAIuD,SAAS,EAAEgC,WAAW;EAC1B,IAAGpC,YAAY,KAAK,SAAS,EAAE;IAC3BoC,WAAW,GAAGpG,KAAK,CAACqG,aAAa,KAAK,MAAM,IAAIrG,KAAK,CAACqG,aAAa,KAAK,SAAS;IACjFjC,SAAS,GAAGkC,4BAA4B,CAACrF,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEqE,MAAM,EAC3DpE,WAAW,EAAE+E,WAAW,CAAC;EACjC,CAAC,MACI;IACDA,WAAW,GAAGpG,KAAK,CAACqG,aAAa,KAAK,MAAM,IAAIrG,KAAK,CAACqG,aAAa,KAAK,QAAQ;IAChFjC,SAAS,GAAGmC,2BAA2B,CAACtF,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEqE,MAAM,EAC1DpE,WAAW,EAAE+E,WAAW,CAAC;EACjC;EAEAjC,aAAa,CAACf,IAAI,CAAC,WAAW,EAAEgB,SAAS,CAAC;AAC9C;AAEA,SAASmC,2BAA2B,CAACtF,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEqE,MAAM,EAAEpE,WAAW,EAAE+E,WAAW,EAAE;EACnF;EACA,IAAIV,SAAS,GAAGD,MAAM,CAACzD,KAAK;EAC5B,IAAI2D,UAAU,GAAGF,MAAM,CAACM,MAAM;EAC9B,IAAIS,KAAK,GAAG,CAACf,MAAM,CAACgB,IAAI,GAAGhB,MAAM,CAACiB,KAAK,IAAI,CAAC;EAC5C,IAAIC,KAAK,GAAG,CAAClB,MAAM,CAACmB,GAAG,GAAGnB,MAAM,CAACoB,MAAM,IAAI,CAAC;EAC5C,IAAItB,QAAQ,GAAGhD,IAAI,CAACG,GAAG,CAACxB,EAAE,GAAGD,EAAE,CAAC;EAChC,IAAIuE,SAAS,GAAGjD,IAAI,CAACG,GAAG,CAACtB,EAAE,GAAGD,EAAE,CAAC;EACjC,IAAI2F,WAAW;EACf,IAAIC,YAAY;EAChB,IAAIC,OAAO;EACX,IAAIC,OAAO;;EAEX;EACA,IAAIC,OAAO;EACX,IAAG3B,QAAQ,GAAI,CAAC,GAAG5G,OAAQ,IAAI6G,SAAS,GAAI,CAAC,GAAG7G,OAAQ,EAAE;IACtDuI,OAAO,GAAGvI,OAAO;IACjB4G,QAAQ,IAAI,CAAC,GAAG2B,OAAO;IACvB1B,SAAS,IAAI,CAAC,GAAG0B,OAAO;EAC5B,CAAC,MACIA,OAAO,GAAG,CAAC;;EAEhB;EACA,IAAIC,MAAM,EACNC,KAAK;EAET,IAAG1B,SAAS,IAAIH,QAAQ,IAAII,UAAU,IAAIH,SAAS,EAAE;IACjD;IACA2B,MAAM,GAAG,KAAK;IACdC,KAAK,GAAG,CAAC;EACb,CAAC,MACI,IAAG1B,SAAS,IAAIF,SAAS,IAAIG,UAAU,IAAIJ,QAAQ,EAAE;IACtD;IACA4B,MAAM,GAAG,IAAI;IACbC,KAAK,GAAG,CAAC;EACb,CAAC,MACI,IAAI1B,SAAS,GAAGC,UAAU,KAAOJ,QAAQ,GAAGC,SAAU,EAAE;IACzD;IACA2B,MAAM,GAAG,KAAK;IACdC,KAAK,GAAGhB,WAAW,GAAG7D,IAAI,CAAC8E,GAAG,CAAC9B,QAAQ,GAAGG,SAAS,EAAEF,SAAS,GAAGG,UAAU,CAAC,GAAG,CAAC;EACpF,CAAC,MACI;IACD;IACAwB,MAAM,GAAG,IAAI;IACbC,KAAK,GAAGhB,WAAW,GAAG7D,IAAI,CAAC8E,GAAG,CAAC7B,SAAS,GAAGE,SAAS,EAAEH,QAAQ,GAAGI,UAAU,CAAC,GAAG,CAAC;EACpF;EAEA,IAAGwB,MAAM,EAAEA,MAAM,GAAG,EAAE,CAAC,CAAE;;EAEzB;EACA,IAAGA,MAAM,EAAE;IACPL,WAAW,GAAGM,KAAK,GAAGzB,UAAU;IAChCoB,YAAY,GAAGK,KAAK,GAAG1B,SAAS;EACpC,CAAC,MACI;IACDoB,WAAW,GAAGM,KAAK,GAAG1B,SAAS;IAC/BqB,YAAY,GAAGK,KAAK,GAAGzB,UAAU;EACrC;EAEA,IAAGtE,WAAW,KAAK,GAAG,EAAE;IACpB,IAAGH,EAAE,GAAGD,EAAE,EAAE;MACR;MACA+F,OAAO,GAAG9F,EAAE,GAAGgG,OAAO,GAAGJ,WAAW,GAAG,CAAC;MACxCG,OAAO,GAAG,CAAC9F,EAAE,GAAGC,EAAE,IAAI,CAAC;IAC3B,CAAC,MACI;MACD4F,OAAO,GAAG9F,EAAE,GAAGgG,OAAO,GAAGJ,WAAW,GAAG,CAAC;MACxCG,OAAO,GAAG,CAAC9F,EAAE,GAAGC,EAAE,IAAI,CAAC;IAC3B;EACJ,CAAC,MACI;IACD,IAAGA,EAAE,GAAGD,EAAE,EAAE;MACR;MACA6F,OAAO,GAAG,CAAC/F,EAAE,GAAGC,EAAE,IAAI,CAAC;MACvB+F,OAAO,GAAG7F,EAAE,GAAG8F,OAAO,GAAGH,YAAY,GAAG,CAAC;IAC7C,CAAC,MACI;MACDC,OAAO,GAAG,CAAC/F,EAAE,GAAGC,EAAE,IAAI,CAAC;MACvB+F,OAAO,GAAG7F,EAAE,GAAG8F,OAAO,GAAGH,YAAY,GAAG,CAAC;IAC7C;EACJ;EAEA,OAAOO,YAAY,CAACd,KAAK,EAAEG,KAAK,EAAEK,OAAO,EAAEC,OAAO,EAAEG,KAAK,EAAED,MAAM,CAAC;AACtE;AAEA,SAASb,4BAA4B,CAACrF,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEqE,MAAM,EAAEpE,WAAW,EAAE+E,WAAW,EAAE;EACpF,IAAIb,QAAQ,GAAIlE,WAAW,KAAK,GAAG,GAC/BkB,IAAI,CAACG,GAAG,CAACtB,EAAE,GAAGD,EAAE,CAAC,GACjBoB,IAAI,CAACG,GAAG,CAACxB,EAAE,GAAGD,EAAE,CAAC;EACrB,IAAIiG,OAAO;;EAEX;EACA;EACA,IAAG3B,QAAQ,GAAG,CAAC,GAAG5G,OAAO,EAAE;IACvBuI,OAAO,GAAGvI,OAAO;EACrB;;EAEA;EACA,IAAIyI,KAAK,GAAG,CAAC;EACb,IAAGhB,WAAW,EAAE;IACZgB,KAAK,GAAI/F,WAAW,KAAK,GAAG,GACxBkB,IAAI,CAAC8E,GAAG,CAAC,CAAC,EAAE9B,QAAQ,GAAGE,MAAM,CAACM,MAAM,CAAC,GACrCxD,IAAI,CAAC8E,GAAG,CAAC,CAAC,EAAE9B,QAAQ,GAAGE,MAAM,CAACzD,KAAK,CAAC;EAC5C;;EAEA;EACA,IAAIwE,KAAK,GAAG,CAACf,MAAM,CAACgB,IAAI,GAAGhB,MAAM,CAACiB,KAAK,IAAI,CAAC;EAC5C,IAAIC,KAAK,GAAG,CAAClB,MAAM,CAACmB,GAAG,GAAGnB,MAAM,CAACoB,MAAM,IAAI,CAAC;EAC5C,IAAIC,WAAW;EACf,IAAIC,YAAY;EAChB,IAAIC,OAAO;EACX,IAAIC,OAAO;EAEXH,WAAW,GAAGM,KAAK,GAAG3B,MAAM,CAACzD,KAAK;EAClC+E,YAAY,GAAGK,KAAK,GAAG3B,MAAM,CAACM,MAAM;EAEpC,IAAG1E,WAAW,KAAK,GAAG,EAAE;IACpB,IAAGH,EAAE,GAAGD,EAAE,EAAE;MACR;MACA+F,OAAO,GAAG9F,EAAE,GAAGgG,OAAO,GAAGJ,WAAW,GAAG,CAAC;MACxCG,OAAO,GAAG,CAAC9F,EAAE,GAAGC,EAAE,IAAI,CAAC;IAC3B,CAAC,MACI;MACD4F,OAAO,GAAG9F,EAAE,GAAGgG,OAAO,GAAGJ,WAAW,GAAG,CAAC;MACxCG,OAAO,GAAG,CAAC9F,EAAE,GAAGC,EAAE,IAAI,CAAC;IAC3B;EACJ,CAAC,MACI;IACD,IAAGA,EAAE,GAAGD,EAAE,EAAE;MACR;MACA6F,OAAO,GAAG,CAAC/F,EAAE,GAAGC,EAAE,IAAI,CAAC;MACvB+F,OAAO,GAAG7F,EAAE,GAAG8F,OAAO,GAAGH,YAAY,GAAG,CAAC;IAC7C,CAAC,MACI;MACDC,OAAO,GAAG,CAAC/F,EAAE,GAAGC,EAAE,IAAI,CAAC;MACvB+F,OAAO,GAAG7F,EAAE,GAAG8F,OAAO,GAAGH,YAAY,GAAG,CAAC;IAC7C;EACJ;EAEA,OAAOO,YAAY,CAACd,KAAK,EAAEG,KAAK,EAAEK,OAAO,EAAEC,OAAO,EAAEG,KAAK,EAAE,KAAK,CAAC;AACrE;AAEA,SAASE,YAAY,CAACd,KAAK,EAAEG,KAAK,EAAEK,OAAO,EAAEC,OAAO,EAAEG,KAAK,EAAED,MAAM,EAAE;EACjE,IAAII,cAAc;EAClB,IAAIC,eAAe;EACnB,IAAIC,kBAAkB;EAEtB,IAAGL,KAAK,GAAG,CAAC,EAAEG,cAAc,GAAG,QAAQ,GAAGH,KAAK,GAAG,IAAI,CAAC,KAClD;IACDA,KAAK,GAAG,CAAC;IACTG,cAAc,GAAG,EAAE;EACvB;EAEAC,eAAe,GAAIL,MAAM,GACrB,SAAS,GAAGA,MAAM,GAAG,GAAG,GAAGX,KAAK,GAAG,GAAG,GAAGG,KAAK,GAAG,IAAI,GAAG,EAAE;;EAE9D;EACA,IAAIe,UAAU,GAAIV,OAAO,GAAGI,KAAK,GAAGZ,KAAM;EAC1C,IAAImB,UAAU,GAAIV,OAAO,GAAGG,KAAK,GAAGT,KAAM;EAC1Cc,kBAAkB,GAAG,YAAY,GAAGC,UAAU,GAAG,GAAG,GAAGC,UAAU,GAAG,GAAG;EAEvE,OAAOF,kBAAkB,GAAGF,cAAc,GAAGC,eAAe;AAChE;AAEA,SAASjD,OAAO,CAACvE,KAAK,EAAE4H,KAAK,EAAE;EAC3B,IAAIC,KAAK,GAAGpJ,OAAO,CAACqJ,QAAQ,CAAC9H,KAAK,CAAC1B,IAAI,EAAEsJ,KAAK,CAAC;EAC/C,OAAOnJ,OAAO,CAACsJ,YAAY,CAAC1J,aAAa,EAAEwJ,KAAK,CAAC;AACrD;AAEA,SAASrD,eAAe,CAACxE,KAAK,EAAE4H,KAAK,EAAE;EACnC,IAAIC,KAAK,GAAGpJ,OAAO,CAACqJ,QAAQ,CAAC9H,KAAK,CAACxB,YAAY,EAAEoJ,KAAK,CAAC;EACvD,OAAOnJ,OAAO,CAACuJ,gBAAgB,CAACzJ,qBAAqB,EAAEsJ,KAAK,CAAC;AACjE"},"metadata":{},"sourceType":"script","externalDependencies":[]}