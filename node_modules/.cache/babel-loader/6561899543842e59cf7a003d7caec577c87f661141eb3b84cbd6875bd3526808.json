{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Plots = require('../../plots/plots');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar constants = require('./constants');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\nmodule.exports = function draw(gd) {\n  var fullLayout = gd._fullLayout;\n  var sliderData = makeSliderData(fullLayout, gd);\n\n  // draw a container for *all* sliders:\n  var sliders = fullLayout._infolayer.selectAll('g.' + constants.containerClassName).data(sliderData.length > 0 ? [0] : []);\n  sliders.enter().append('g').classed(constants.containerClassName, true).style('cursor', 'ew-resize');\n  function clearSlider(sliderOpts) {\n    if (sliderOpts._commandObserver) {\n      sliderOpts._commandObserver.remove();\n      delete sliderOpts._commandObserver;\n    }\n\n    // Most components don't need to explicitly remove autoMargin, because\n    // marginPushers does this - but slider updates don't go through\n    // a full replot so we need to explicitly remove it.\n    Plots.autoMargin(gd, autoMarginId(sliderOpts));\n  }\n  sliders.exit().each(function () {\n    d3.select(this).selectAll('g.' + constants.groupClassName).each(clearSlider);\n  }).remove();\n\n  // Return early if no menus visible:\n  if (sliderData.length === 0) return;\n  var sliderGroups = sliders.selectAll('g.' + constants.groupClassName).data(sliderData, keyFunction);\n  sliderGroups.enter().append('g').classed(constants.groupClassName, true);\n  sliderGroups.exit().each(clearSlider).remove();\n\n  // Find the dimensions of the sliders:\n  for (var i = 0; i < sliderData.length; i++) {\n    var sliderOpts = sliderData[i];\n    findDimensions(gd, sliderOpts);\n  }\n  sliderGroups.each(function (sliderOpts) {\n    var gSlider = d3.select(this);\n    computeLabelSteps(sliderOpts);\n    Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function (data) {\n      // NB: Same as below. This is *not* always the same as sliderOpts since\n      // if a new set of steps comes in, the reference in this callback would\n      // be invalid. We need to refetch it from the slider group, which is\n      // the join data that creates this slider. So if this slider still exists,\n      // the group should be valid, *to the best of my knowledge.* If not,\n      // we'd have to look it up by d3 data join index/key.\n      var opts = gSlider.data()[0];\n      if (opts.active === data.index) return;\n      if (opts._dragging) return;\n      setActive(gd, gSlider, opts, data.index, false, true);\n    });\n    drawSlider(gd, d3.select(this), sliderOpts);\n  });\n};\nfunction autoMarginId(sliderOpts) {\n  return constants.autoMarginIdRoot + sliderOpts._index;\n}\n\n// This really only just filters by visibility:\nfunction makeSliderData(fullLayout, gd) {\n  var contOpts = fullLayout[constants.name];\n  var sliderData = [];\n  for (var i = 0; i < contOpts.length; i++) {\n    var item = contOpts[i];\n    if (!item.visible) continue;\n    item._gd = gd;\n    sliderData.push(item);\n  }\n  return sliderData;\n}\n\n// This is set in the defaults step:\nfunction keyFunction(opts) {\n  return opts._index;\n}\n\n// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd, sliderOpts) {\n  var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass).data(sliderOpts._visibleSteps);\n  sliderLabels.enter().append('g').classed(constants.labelGroupClass, true);\n\n  // loop over fake buttons to find width / height\n  var maxLabelWidth = 0;\n  var labelHeight = 0;\n  sliderLabels.each(function (stepOpts) {\n    var labelGroup = d3.select(this);\n    var text = drawLabel(labelGroup, {\n      step: stepOpts\n    }, sliderOpts);\n    var textNode = text.node();\n    if (textNode) {\n      var bBox = Drawing.bBox(textNode);\n      labelHeight = Math.max(labelHeight, bBox.height);\n      maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n    }\n  });\n  sliderLabels.remove();\n  var dims = sliderOpts._dims = {};\n  dims.inputAreaWidth = Math.max(constants.railWidth, constants.gripHeight);\n\n  // calculate some overall dimensions - some of these are needed for\n  // calculating the currentValue dimensions\n  var graphSize = gd._fullLayout._size;\n  dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n  dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n  if (sliderOpts.lenmode === 'fraction') {\n    // fraction:\n    dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n  } else {\n    // pixels:\n    dims.outerLength = sliderOpts.len;\n  }\n\n  // The length of the rail, *excluding* padding on either end:\n  dims.inputAreaStart = 0;\n  dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n  var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n  var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n  var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n  dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n  dims.labelHeight = labelHeight;\n\n  // loop over all possible values for currentValue to find the\n  // area we need for it\n  dims.currentValueMaxWidth = 0;\n  dims.currentValueHeight = 0;\n  dims.currentValueTotalHeight = 0;\n  dims.currentValueMaxLines = 1;\n  if (sliderOpts.currentvalue.visible) {\n    // Get the dimensions of the current value label:\n    var dummyGroup = Drawing.tester.append('g');\n    sliderLabels.each(function (stepOpts) {\n      var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n      var curValSize = curValPrefix.node() && Drawing.bBox(curValPrefix.node()) || {\n        width: 0,\n        height: 0\n      };\n      var lines = svgTextUtils.lineCount(curValPrefix);\n      dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n      dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n      dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n    });\n    dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n    dummyGroup.remove();\n  }\n  dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n  var xanchor = 'left';\n  if (Lib.isRightAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength;\n    xanchor = 'right';\n  }\n  if (Lib.isCenterAnchor(sliderOpts)) {\n    dims.lx -= dims.outerLength / 2;\n    xanchor = 'center';\n  }\n  var yanchor = 'top';\n  if (Lib.isBottomAnchor(sliderOpts)) {\n    dims.ly -= dims.height;\n    yanchor = 'bottom';\n  }\n  if (Lib.isMiddleAnchor(sliderOpts)) {\n    dims.ly -= dims.height / 2;\n    yanchor = 'middle';\n  }\n  dims.outerLength = Math.ceil(dims.outerLength);\n  dims.height = Math.ceil(dims.height);\n  dims.lx = Math.round(dims.lx);\n  dims.ly = Math.round(dims.ly);\n  var marginOpts = {\n    y: sliderOpts.y,\n    b: dims.height * FROM_BR[yanchor],\n    t: dims.height * FROM_TL[yanchor]\n  };\n  if (sliderOpts.lenmode === 'fraction') {\n    marginOpts.l = 0;\n    marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n    marginOpts.r = 0;\n    marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n  } else {\n    marginOpts.x = sliderOpts.x;\n    marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n    marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n  }\n  Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n  // This is related to the other long notes in this file regarding what happens\n  // when slider steps disappear. This particular fix handles what happens when\n  // the *current* slider step is removed. The drawing functions will error out\n  // when they fail to find it, so the fix for now is that it will just draw the\n  // slider in the first position but will not execute the command.\n  if (!(sliderOpts.steps[sliderOpts.active] || {}).visible) {\n    sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n  }\n\n  // These are carefully ordered for proper z-ordering:\n  sliderGroup.call(drawCurrentValue, sliderOpts).call(drawRail, sliderOpts).call(drawLabelGroup, sliderOpts).call(drawTicks, sliderOpts).call(drawTouchRect, gd, sliderOpts).call(drawGrip, gd, sliderOpts);\n  var dims = sliderOpts._dims;\n\n  // Position the rectangle:\n  Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n  sliderGroup.call(setGripPosition, sliderOpts, false);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n}\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n  if (!sliderOpts.currentvalue.visible) return;\n  var dims = sliderOpts._dims;\n  var x0, textAnchor;\n  switch (sliderOpts.currentvalue.xanchor) {\n    case 'right':\n      // This is anchored left and adjusted by the width of the longest label\n      // so that the prefix doesn't move. The goal of this is to emphasize\n      // what's actually changing and make the update less distracting.\n      x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n      textAnchor = 'left';\n      break;\n    case 'center':\n      x0 = dims.inputAreaLength * 0.5;\n      textAnchor = 'middle';\n      break;\n    default:\n      x0 = constants.currentValueInset;\n      textAnchor = 'left';\n  }\n  var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function (s) {\n    s.classed('user-select-none', true).attr({\n      'text-anchor': textAnchor,\n      'data-notex': 1\n    });\n  });\n  var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n  if (typeof valueOverride === 'string') {\n    str += valueOverride;\n  } else {\n    var curVal = sliderOpts.steps[sliderOpts.active].label;\n    str += curVal;\n  }\n  if (sliderOpts.currentvalue.suffix) {\n    str += sliderOpts.currentvalue.suffix;\n  }\n  text.call(Drawing.font, sliderOpts.currentvalue.font).text(str).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  var lines = svgTextUtils.lineCount(text);\n  var y0 = (dims.currentValueMaxLines + 1 - lines) * sliderOpts.currentvalue.font.size * LINE_SPACING;\n  svgTextUtils.positionText(text, x0, y0);\n  return text;\n}\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n  var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  grip.attr({\n    width: constants.gripWidth,\n    height: constants.gripHeight,\n    rx: constants.gripRadius,\n    ry: constants.gripRadius\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n}\nfunction drawLabel(item, data, sliderOpts) {\n  var text = Lib.ensureSingle(item, 'text', constants.labelClass, function (s) {\n    s.classed('user-select-none', true).attr({\n      'text-anchor': 'middle',\n      'data-notex': 1\n    });\n  });\n  text.call(Drawing.font, sliderOpts.font).text(data.step.label).call(svgTextUtils.convertToTspans, sliderOpts._gd);\n  return text;\n}\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n  var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n  var dims = sliderOpts._dims;\n  var labelItems = labels.selectAll('g.' + constants.labelGroupClass).data(dims.labelSteps);\n  labelItems.enter().append('g').classed(constants.labelGroupClass, true);\n  labelItems.exit().remove();\n  labelItems.each(function (d) {\n    var item = d3.select(this);\n    item.call(drawLabel, d, sliderOpts);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, d.fraction), constants.tickOffset + sliderOpts.ticklen +\n    // position is the baseline of the top line of text only, even\n    // if the label spans multiple lines\n    sliderOpts.font.size * LINE_SPACING + constants.labelOffset + dims.currentValueTotalHeight);\n  });\n}\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n  var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n  var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n  if (quantizedIndex !== sliderOpts.active) {\n    setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n  }\n}\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n  var previousActive = sliderOpts.active;\n  sliderOpts.active = index;\n\n  // due to templating, it's possible this slider doesn't even exist yet\n  arrayEditor(gd.layout, constants.name, sliderOpts).applyUpdate('active', index);\n  var step = sliderOpts.steps[sliderOpts.active];\n  sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n  sliderGroup.call(drawCurrentValue, sliderOpts);\n  gd.emit('plotly_sliderchange', {\n    slider: sliderOpts,\n    step: sliderOpts.steps[sliderOpts.active],\n    interaction: doCallback,\n    previousActive: previousActive\n  });\n  if (step && step.method && doCallback) {\n    if (sliderGroup._nextMethod) {\n      // If we've already queued up an update, just overwrite it with the most recent:\n      sliderGroup._nextMethod.step = step;\n      sliderGroup._nextMethod.doCallback = doCallback;\n      sliderGroup._nextMethod.doTransition = doTransition;\n    } else {\n      sliderGroup._nextMethod = {\n        step: step,\n        doCallback: doCallback,\n        doTransition: doTransition\n      };\n      sliderGroup._nextMethodRaf = window.requestAnimationFrame(function () {\n        var _step = sliderGroup._nextMethod.step;\n        if (!_step.method) return;\n        if (_step.execute) {\n          Plots.executeAPICommand(gd, _step.method, _step.args);\n        }\n        sliderGroup._nextMethod = null;\n        sliderGroup._nextMethodRaf = null;\n      });\n    }\n  }\n}\nfunction attachGripEvents(item, gd, sliderGroup) {\n  var node = sliderGroup.node();\n  var $gd = d3.select(gd);\n\n  // NB: This is *not* the same as sliderOpts itself! These callbacks\n  // are in a closure so this array won't actually be correct if the\n  // steps have changed since this was initialized. The sliderGroup,\n  // however, has not changed since that *is* the slider, so it must\n  // be present to receive mouse events.\n  function getSliderOpts() {\n    return sliderGroup.data()[0];\n  }\n  item.on('mousedown', function () {\n    var sliderOpts = getSliderOpts();\n    gd.emit('plotly_sliderstart', {\n      slider: sliderOpts\n    });\n    var grip = sliderGroup.select('.' + constants.gripRectClass);\n    d3.event.stopPropagation();\n    d3.event.preventDefault();\n    grip.call(Color.fill, sliderOpts.activebgcolor);\n    var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n    handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n    sliderOpts._dragging = true;\n    $gd.on('mousemove', function () {\n      var sliderOpts = getSliderOpts();\n      var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n      handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n    });\n    $gd.on('mouseup', function () {\n      var sliderOpts = getSliderOpts();\n      sliderOpts._dragging = false;\n      grip.call(Color.fill, sliderOpts.bgcolor);\n      $gd.on('mouseup', null);\n      $gd.on('mousemove', null);\n      gd.emit('plotly_sliderend', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active]\n      });\n    });\n  });\n}\nfunction drawTicks(sliderGroup, sliderOpts) {\n  var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass).data(sliderOpts._visibleSteps);\n  var dims = sliderOpts._dims;\n  tick.enter().append('rect').classed(constants.tickRectClass, true);\n  tick.exit().remove();\n  tick.attr({\n    width: sliderOpts.tickwidth + 'px',\n    'shape-rendering': 'crispEdges'\n  });\n  tick.each(function (d, i) {\n    var isMajor = i % dims.labelStride === 0;\n    var item = d3.select(this);\n    item.attr({\n      height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen\n    }).call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n    Drawing.setTranslate(item, normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth, (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight);\n  });\n}\nfunction computeLabelSteps(sliderOpts) {\n  var dims = sliderOpts._dims;\n  dims.labelSteps = [];\n  var nsteps = sliderOpts._stepCount;\n  for (var i = 0; i < nsteps; i += dims.labelStride) {\n    dims.labelSteps.push({\n      fraction: i / (nsteps - 1),\n      step: sliderOpts._visibleSteps[i]\n    });\n  }\n}\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n  var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n  var quantizedIndex = 0;\n  for (var i = 0; i < sliderOpts._stepCount; i++) {\n    if (sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n      quantizedIndex = i;\n      break;\n    }\n  }\n  var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));\n\n  // If this is true, then *this component* is already invoking its own command\n  // and has triggered its own animation.\n  if (sliderOpts._invokingCommand) return;\n  var el = grip;\n  if (doTransition && sliderOpts.transition.duration > 0) {\n    el = el.transition().duration(sliderOpts.transition.duration).ease(sliderOpts.transition.easing);\n  }\n\n  // Drawing.setTranslate doesn't work here becasue of the transition duck-typing.\n  // It's also not necessary because there are no other transitions to preserve.\n  el.attr('transform', 'translate(' + (x - constants.gripWidth * 0.5) + ',' + sliderOpts._dims.currentValueTotalHeight + ')');\n}\n\n// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n  var dims = sliderOpts._dims;\n  return dims.inputAreaStart + constants.stepInset + (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n}\n\n// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts, position) {\n  var dims = sliderOpts._dims;\n  return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function (s) {\n    s.call(attachGripEvents, gd, sliderGroup, sliderOpts).style('pointer-events', 'all');\n  });\n  rect.attr({\n    width: dims.inputAreaLength,\n    height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n  }).call(Color.fill, sliderOpts.bgcolor).attr('opacity', 0);\n  Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\nfunction drawRail(sliderGroup, sliderOpts) {\n  var dims = sliderOpts._dims;\n  var computedLength = dims.inputAreaLength - constants.railInset * 2;\n  var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n  rect.attr({\n    width: computedLength,\n    height: constants.railWidth,\n    rx: constants.railRadius,\n    ry: constants.railRadius,\n    'shape-rendering': 'crispEdges'\n  }).call(Color.stroke, sliderOpts.bordercolor).call(Color.fill, sliderOpts.bgcolor).style('stroke-width', sliderOpts.borderwidth + 'px');\n  Drawing.setTranslate(rect, constants.railInset, (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight);\n}","map":{"version":3,"names":["d3","require","Plots","Color","Drawing","Lib","svgTextUtils","arrayEditor","constants","alignmentConstants","LINE_SPACING","FROM_TL","FROM_BR","module","exports","draw","gd","fullLayout","_fullLayout","sliderData","makeSliderData","sliders","_infolayer","selectAll","containerClassName","data","length","enter","append","classed","style","clearSlider","sliderOpts","_commandObserver","remove","autoMargin","autoMarginId","exit","each","select","groupClassName","sliderGroups","keyFunction","i","findDimensions","gSlider","computeLabelSteps","manageCommandObserver","_visibleSteps","opts","active","index","_dragging","setActive","drawSlider","autoMarginIdRoot","_index","contOpts","name","item","visible","_gd","push","sliderLabels","tester","labelGroupClass","maxLabelWidth","labelHeight","stepOpts","labelGroup","text","drawLabel","step","textNode","node","bBox","Math","max","height","width","dims","_dims","inputAreaWidth","railWidth","gripHeight","graphSize","_size","lx","l","w","x","ly","t","h","y","lenmode","outerLength","round","len","inputAreaStart","inputAreaLength","pad","r","textableInputLength","stepInset","availableSpacePerLabel","_stepCount","computedSpacePerLabel","labelPadding","labelStride","ceil","currentValueMaxWidth","currentValueHeight","currentValueTotalHeight","currentValueMaxLines","currentvalue","dummyGroup","curValPrefix","drawCurrentValue","label","curValSize","lines","lineCount","offset","tickOffset","ticklen","labelOffset","b","xanchor","isRightAnchor","isCenterAnchor","yanchor","isBottomAnchor","isMiddleAnchor","marginOpts","xl","xr","sliderGroup","steps","call","drawRail","drawLabelGroup","drawTicks","drawTouchRect","drawGrip","setTranslate","setGripPosition","valueOverride","x0","textAnchor","currentValueInset","ensureSingle","labelClass","s","attr","str","prefix","curVal","suffix","font","convertToTspans","y0","size","positionText","grip","gripRectClass","attachGripEvents","gripWidth","rx","gripRadius","ry","stroke","bordercolor","fill","bgcolor","borderwidth","labels","labelsClass","labelItems","labelSteps","d","normalizedValueToPosition","fraction","handleInput","normalizedPosition","doTransition","quantizedPosition","quantizedIndex","doCallback","previousActive","layout","applyUpdate","emit","slider","interaction","method","_nextMethod","_nextMethodRaf","window","requestAnimationFrame","_step","execute","executeAPICommand","args","$gd","getSliderOpts","on","event","stopPropagation","preventDefault","activebgcolor","positionToNormalizedValue","mouse","tick","tickRectClass","tickwidth","isMajor","minorticklen","tickcolor","minorTickOffset","nsteps","_invokingCommand","el","transition","duration","ease","easing","min","position","rect","railTouchRectClass","computedLength","railInset","railRectClass","railRadius"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/components/sliders/draw.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Plots = require('../../plots/plots');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar constants = require('./constants');\nvar alignmentConstants = require('../../constants/alignment');\nvar LINE_SPACING = alignmentConstants.LINE_SPACING;\nvar FROM_TL = alignmentConstants.FROM_TL;\nvar FROM_BR = alignmentConstants.FROM_BR;\n\nmodule.exports = function draw(gd) {\n    var fullLayout = gd._fullLayout;\n    var sliderData = makeSliderData(fullLayout, gd);\n\n    // draw a container for *all* sliders:\n    var sliders = fullLayout._infolayer\n        .selectAll('g.' + constants.containerClassName)\n        .data(sliderData.length > 0 ? [0] : []);\n\n    sliders.enter().append('g')\n        .classed(constants.containerClassName, true)\n        .style('cursor', 'ew-resize');\n\n    function clearSlider(sliderOpts) {\n        if(sliderOpts._commandObserver) {\n            sliderOpts._commandObserver.remove();\n            delete sliderOpts._commandObserver;\n        }\n\n        // Most components don't need to explicitly remove autoMargin, because\n        // marginPushers does this - but slider updates don't go through\n        // a full replot so we need to explicitly remove it.\n        Plots.autoMargin(gd, autoMarginId(sliderOpts));\n    }\n\n    sliders.exit().each(function() {\n        d3.select(this).selectAll('g.' + constants.groupClassName)\n            .each(clearSlider);\n    })\n    .remove();\n\n    // Return early if no menus visible:\n    if(sliderData.length === 0) return;\n\n    var sliderGroups = sliders.selectAll('g.' + constants.groupClassName)\n        .data(sliderData, keyFunction);\n\n    sliderGroups.enter().append('g')\n        .classed(constants.groupClassName, true);\n\n    sliderGroups.exit()\n        .each(clearSlider)\n        .remove();\n\n    // Find the dimensions of the sliders:\n    for(var i = 0; i < sliderData.length; i++) {\n        var sliderOpts = sliderData[i];\n        findDimensions(gd, sliderOpts);\n    }\n\n    sliderGroups.each(function(sliderOpts) {\n        var gSlider = d3.select(this);\n\n        computeLabelSteps(sliderOpts);\n\n        Plots.manageCommandObserver(gd, sliderOpts, sliderOpts._visibleSteps, function(data) {\n            // NB: Same as below. This is *not* always the same as sliderOpts since\n            // if a new set of steps comes in, the reference in this callback would\n            // be invalid. We need to refetch it from the slider group, which is\n            // the join data that creates this slider. So if this slider still exists,\n            // the group should be valid, *to the best of my knowledge.* If not,\n            // we'd have to look it up by d3 data join index/key.\n            var opts = gSlider.data()[0];\n\n            if(opts.active === data.index) return;\n            if(opts._dragging) return;\n\n            setActive(gd, gSlider, opts, data.index, false, true);\n        });\n\n        drawSlider(gd, d3.select(this), sliderOpts);\n    });\n};\n\nfunction autoMarginId(sliderOpts) {\n    return constants.autoMarginIdRoot + sliderOpts._index;\n}\n\n// This really only just filters by visibility:\nfunction makeSliderData(fullLayout, gd) {\n    var contOpts = fullLayout[constants.name];\n    var sliderData = [];\n\n    for(var i = 0; i < contOpts.length; i++) {\n        var item = contOpts[i];\n        if(!item.visible) continue;\n        item._gd = gd;\n        sliderData.push(item);\n    }\n\n    return sliderData;\n}\n\n// This is set in the defaults step:\nfunction keyFunction(opts) {\n    return opts._index;\n}\n\n// Compute the dimensions (mutates sliderOpts):\nfunction findDimensions(gd, sliderOpts) {\n    var sliderLabels = Drawing.tester.selectAll('g.' + constants.labelGroupClass)\n        .data(sliderOpts._visibleSteps);\n\n    sliderLabels.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    // loop over fake buttons to find width / height\n    var maxLabelWidth = 0;\n    var labelHeight = 0;\n    sliderLabels.each(function(stepOpts) {\n        var labelGroup = d3.select(this);\n\n        var text = drawLabel(labelGroup, {step: stepOpts}, sliderOpts);\n\n        var textNode = text.node();\n        if(textNode) {\n            var bBox = Drawing.bBox(textNode);\n            labelHeight = Math.max(labelHeight, bBox.height);\n            maxLabelWidth = Math.max(maxLabelWidth, bBox.width);\n        }\n    });\n\n    sliderLabels.remove();\n\n    var dims = sliderOpts._dims = {};\n\n    dims.inputAreaWidth = Math.max(\n        constants.railWidth,\n        constants.gripHeight\n    );\n\n    // calculate some overall dimensions - some of these are needed for\n    // calculating the currentValue dimensions\n    var graphSize = gd._fullLayout._size;\n    dims.lx = graphSize.l + graphSize.w * sliderOpts.x;\n    dims.ly = graphSize.t + graphSize.h * (1 - sliderOpts.y);\n\n    if(sliderOpts.lenmode === 'fraction') {\n        // fraction:\n        dims.outerLength = Math.round(graphSize.w * sliderOpts.len);\n    } else {\n        // pixels:\n        dims.outerLength = sliderOpts.len;\n    }\n\n    // The length of the rail, *excluding* padding on either end:\n    dims.inputAreaStart = 0;\n    dims.inputAreaLength = Math.round(dims.outerLength - sliderOpts.pad.l - sliderOpts.pad.r);\n\n    var textableInputLength = dims.inputAreaLength - 2 * constants.stepInset;\n    var availableSpacePerLabel = textableInputLength / (sliderOpts._stepCount - 1);\n    var computedSpacePerLabel = maxLabelWidth + constants.labelPadding;\n    dims.labelStride = Math.max(1, Math.ceil(computedSpacePerLabel / availableSpacePerLabel));\n    dims.labelHeight = labelHeight;\n\n    // loop over all possible values for currentValue to find the\n    // area we need for it\n    dims.currentValueMaxWidth = 0;\n    dims.currentValueHeight = 0;\n    dims.currentValueTotalHeight = 0;\n    dims.currentValueMaxLines = 1;\n\n    if(sliderOpts.currentvalue.visible) {\n        // Get the dimensions of the current value label:\n        var dummyGroup = Drawing.tester.append('g');\n\n        sliderLabels.each(function(stepOpts) {\n            var curValPrefix = drawCurrentValue(dummyGroup, sliderOpts, stepOpts.label);\n            var curValSize = (curValPrefix.node() && Drawing.bBox(curValPrefix.node())) || {width: 0, height: 0};\n            var lines = svgTextUtils.lineCount(curValPrefix);\n            dims.currentValueMaxWidth = Math.max(dims.currentValueMaxWidth, Math.ceil(curValSize.width));\n            dims.currentValueHeight = Math.max(dims.currentValueHeight, Math.ceil(curValSize.height));\n            dims.currentValueMaxLines = Math.max(dims.currentValueMaxLines, lines);\n        });\n\n        dims.currentValueTotalHeight = dims.currentValueHeight + sliderOpts.currentvalue.offset;\n\n        dummyGroup.remove();\n    }\n\n    dims.height = dims.currentValueTotalHeight + constants.tickOffset + sliderOpts.ticklen + constants.labelOffset + dims.labelHeight + sliderOpts.pad.t + sliderOpts.pad.b;\n\n    var xanchor = 'left';\n    if(Lib.isRightAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength;\n        xanchor = 'right';\n    }\n    if(Lib.isCenterAnchor(sliderOpts)) {\n        dims.lx -= dims.outerLength / 2;\n        xanchor = 'center';\n    }\n\n    var yanchor = 'top';\n    if(Lib.isBottomAnchor(sliderOpts)) {\n        dims.ly -= dims.height;\n        yanchor = 'bottom';\n    }\n    if(Lib.isMiddleAnchor(sliderOpts)) {\n        dims.ly -= dims.height / 2;\n        yanchor = 'middle';\n    }\n\n    dims.outerLength = Math.ceil(dims.outerLength);\n    dims.height = Math.ceil(dims.height);\n    dims.lx = Math.round(dims.lx);\n    dims.ly = Math.round(dims.ly);\n\n    var marginOpts = {\n        y: sliderOpts.y,\n        b: dims.height * FROM_BR[yanchor],\n        t: dims.height * FROM_TL[yanchor]\n    };\n\n    if(sliderOpts.lenmode === 'fraction') {\n        marginOpts.l = 0;\n        marginOpts.xl = sliderOpts.x - sliderOpts.len * FROM_TL[xanchor];\n        marginOpts.r = 0;\n        marginOpts.xr = sliderOpts.x + sliderOpts.len * FROM_BR[xanchor];\n    }\n    else {\n        marginOpts.x = sliderOpts.x;\n        marginOpts.l = dims.outerLength * FROM_TL[xanchor];\n        marginOpts.r = dims.outerLength * FROM_BR[xanchor];\n    }\n\n    Plots.autoMargin(gd, autoMarginId(sliderOpts), marginOpts);\n}\n\nfunction drawSlider(gd, sliderGroup, sliderOpts) {\n    // This is related to the other long notes in this file regarding what happens\n    // when slider steps disappear. This particular fix handles what happens when\n    // the *current* slider step is removed. The drawing functions will error out\n    // when they fail to find it, so the fix for now is that it will just draw the\n    // slider in the first position but will not execute the command.\n    if(!((sliderOpts.steps[sliderOpts.active] || {}).visible)) {\n        sliderOpts.active = sliderOpts._visibleSteps[0]._index;\n    }\n\n    // These are carefully ordered for proper z-ordering:\n    sliderGroup\n        .call(drawCurrentValue, sliderOpts)\n        .call(drawRail, sliderOpts)\n        .call(drawLabelGroup, sliderOpts)\n        .call(drawTicks, sliderOpts)\n        .call(drawTouchRect, gd, sliderOpts)\n        .call(drawGrip, gd, sliderOpts);\n\n    var dims = sliderOpts._dims;\n\n    // Position the rectangle:\n    Drawing.setTranslate(sliderGroup, dims.lx + sliderOpts.pad.l, dims.ly + sliderOpts.pad.t);\n\n    sliderGroup.call(setGripPosition, sliderOpts, false);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n\n}\n\nfunction drawCurrentValue(sliderGroup, sliderOpts, valueOverride) {\n    if(!sliderOpts.currentvalue.visible) return;\n\n    var dims = sliderOpts._dims;\n    var x0, textAnchor;\n\n    switch(sliderOpts.currentvalue.xanchor) {\n        case 'right':\n            // This is anchored left and adjusted by the width of the longest label\n            // so that the prefix doesn't move. The goal of this is to emphasize\n            // what's actually changing and make the update less distracting.\n            x0 = dims.inputAreaLength - constants.currentValueInset - dims.currentValueMaxWidth;\n            textAnchor = 'left';\n            break;\n        case 'center':\n            x0 = dims.inputAreaLength * 0.5;\n            textAnchor = 'middle';\n            break;\n        default:\n            x0 = constants.currentValueInset;\n            textAnchor = 'left';\n    }\n\n    var text = Lib.ensureSingle(sliderGroup, 'text', constants.labelClass, function(s) {\n        s.classed('user-select-none', true)\n            .attr({\n                'text-anchor': textAnchor,\n                'data-notex': 1\n            });\n    });\n\n    var str = sliderOpts.currentvalue.prefix ? sliderOpts.currentvalue.prefix : '';\n\n    if(typeof valueOverride === 'string') {\n        str += valueOverride;\n    } else {\n        var curVal = sliderOpts.steps[sliderOpts.active].label;\n        str += curVal;\n    }\n\n    if(sliderOpts.currentvalue.suffix) {\n        str += sliderOpts.currentvalue.suffix;\n    }\n\n    text.call(Drawing.font, sliderOpts.currentvalue.font)\n        .text(str)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    var lines = svgTextUtils.lineCount(text);\n\n    var y0 = (dims.currentValueMaxLines + 1 - lines) *\n        sliderOpts.currentvalue.font.size * LINE_SPACING;\n\n    svgTextUtils.positionText(text, x0, y0);\n\n    return text;\n}\n\nfunction drawGrip(sliderGroup, gd, sliderOpts) {\n    var grip = Lib.ensureSingle(sliderGroup, 'rect', constants.gripRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    grip.attr({\n        width: constants.gripWidth,\n        height: constants.gripHeight,\n        rx: constants.gripRadius,\n        ry: constants.gripRadius,\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n}\n\nfunction drawLabel(item, data, sliderOpts) {\n    var text = Lib.ensureSingle(item, 'text', constants.labelClass, function(s) {\n        s.classed('user-select-none', true)\n            .attr({\n                'text-anchor': 'middle',\n                'data-notex': 1\n            });\n    });\n\n    text.call(Drawing.font, sliderOpts.font)\n        .text(data.step.label)\n        .call(svgTextUtils.convertToTspans, sliderOpts._gd);\n\n    return text;\n}\n\nfunction drawLabelGroup(sliderGroup, sliderOpts) {\n    var labels = Lib.ensureSingle(sliderGroup, 'g', constants.labelsClass);\n    var dims = sliderOpts._dims;\n\n    var labelItems = labels.selectAll('g.' + constants.labelGroupClass)\n        .data(dims.labelSteps);\n\n    labelItems.enter().append('g')\n        .classed(constants.labelGroupClass, true);\n\n    labelItems.exit().remove();\n\n    labelItems.each(function(d) {\n        var item = d3.select(this);\n\n        item.call(drawLabel, d, sliderOpts);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, d.fraction),\n            constants.tickOffset +\n                sliderOpts.ticklen +\n                // position is the baseline of the top line of text only, even\n                // if the label spans multiple lines\n                sliderOpts.font.size * LINE_SPACING +\n                constants.labelOffset +\n                dims.currentValueTotalHeight\n        );\n    });\n\n}\n\nfunction handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, doTransition) {\n    var quantizedPosition = Math.round(normalizedPosition * (sliderOpts._stepCount - 1));\n    var quantizedIndex = sliderOpts._visibleSteps[quantizedPosition]._index;\n\n    if(quantizedIndex !== sliderOpts.active) {\n        setActive(gd, sliderGroup, sliderOpts, quantizedIndex, true, doTransition);\n    }\n}\n\nfunction setActive(gd, sliderGroup, sliderOpts, index, doCallback, doTransition) {\n    var previousActive = sliderOpts.active;\n    sliderOpts.active = index;\n\n    // due to templating, it's possible this slider doesn't even exist yet\n    arrayEditor(gd.layout, constants.name, sliderOpts)\n        .applyUpdate('active', index);\n\n    var step = sliderOpts.steps[sliderOpts.active];\n\n    sliderGroup.call(setGripPosition, sliderOpts, doTransition);\n    sliderGroup.call(drawCurrentValue, sliderOpts);\n\n    gd.emit('plotly_sliderchange', {\n        slider: sliderOpts,\n        step: sliderOpts.steps[sliderOpts.active],\n        interaction: doCallback,\n        previousActive: previousActive\n    });\n\n    if(step && step.method && doCallback) {\n        if(sliderGroup._nextMethod) {\n            // If we've already queued up an update, just overwrite it with the most recent:\n            sliderGroup._nextMethod.step = step;\n            sliderGroup._nextMethod.doCallback = doCallback;\n            sliderGroup._nextMethod.doTransition = doTransition;\n        } else {\n            sliderGroup._nextMethod = {step: step, doCallback: doCallback, doTransition: doTransition};\n            sliderGroup._nextMethodRaf = window.requestAnimationFrame(function() {\n                var _step = sliderGroup._nextMethod.step;\n                if(!_step.method) return;\n\n                if(_step.execute) {\n                    Plots.executeAPICommand(gd, _step.method, _step.args);\n                }\n\n                sliderGroup._nextMethod = null;\n                sliderGroup._nextMethodRaf = null;\n            });\n        }\n    }\n}\n\nfunction attachGripEvents(item, gd, sliderGroup) {\n    var node = sliderGroup.node();\n    var $gd = d3.select(gd);\n\n    // NB: This is *not* the same as sliderOpts itself! These callbacks\n    // are in a closure so this array won't actually be correct if the\n    // steps have changed since this was initialized. The sliderGroup,\n    // however, has not changed since that *is* the slider, so it must\n    // be present to receive mouse events.\n    function getSliderOpts() {\n        return sliderGroup.data()[0];\n    }\n\n    item.on('mousedown', function() {\n        var sliderOpts = getSliderOpts();\n        gd.emit('plotly_sliderstart', {slider: sliderOpts});\n\n        var grip = sliderGroup.select('.' + constants.gripRectClass);\n\n        d3.event.stopPropagation();\n        d3.event.preventDefault();\n        grip.call(Color.fill, sliderOpts.activebgcolor);\n\n        var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n        handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, true);\n        sliderOpts._dragging = true;\n\n        $gd.on('mousemove', function() {\n            var sliderOpts = getSliderOpts();\n            var normalizedPosition = positionToNormalizedValue(sliderOpts, d3.mouse(node)[0]);\n            handleInput(gd, sliderGroup, sliderOpts, normalizedPosition, false);\n        });\n\n        $gd.on('mouseup', function() {\n            var sliderOpts = getSliderOpts();\n            sliderOpts._dragging = false;\n            grip.call(Color.fill, sliderOpts.bgcolor);\n            $gd.on('mouseup', null);\n            $gd.on('mousemove', null);\n\n            gd.emit('plotly_sliderend', {\n                slider: sliderOpts,\n                step: sliderOpts.steps[sliderOpts.active]\n            });\n        });\n    });\n}\n\nfunction drawTicks(sliderGroup, sliderOpts) {\n    var tick = sliderGroup.selectAll('rect.' + constants.tickRectClass)\n        .data(sliderOpts._visibleSteps);\n    var dims = sliderOpts._dims;\n\n    tick.enter().append('rect')\n        .classed(constants.tickRectClass, true);\n\n    tick.exit().remove();\n\n    tick.attr({\n        width: sliderOpts.tickwidth + 'px',\n        'shape-rendering': 'crispEdges'\n    });\n\n    tick.each(function(d, i) {\n        var isMajor = i % dims.labelStride === 0;\n        var item = d3.select(this);\n\n        item\n            .attr({height: isMajor ? sliderOpts.ticklen : sliderOpts.minorticklen})\n            .call(Color.fill, isMajor ? sliderOpts.tickcolor : sliderOpts.tickcolor);\n\n        Drawing.setTranslate(item,\n            normalizedValueToPosition(sliderOpts, i / (sliderOpts._stepCount - 1)) - 0.5 * sliderOpts.tickwidth,\n            (isMajor ? constants.tickOffset : constants.minorTickOffset) + dims.currentValueTotalHeight\n        );\n    });\n\n}\n\nfunction computeLabelSteps(sliderOpts) {\n    var dims = sliderOpts._dims;\n    dims.labelSteps = [];\n    var nsteps = sliderOpts._stepCount;\n\n    for(var i = 0; i < nsteps; i += dims.labelStride) {\n        dims.labelSteps.push({\n            fraction: i / (nsteps - 1),\n            step: sliderOpts._visibleSteps[i]\n        });\n    }\n}\n\nfunction setGripPosition(sliderGroup, sliderOpts, doTransition) {\n    var grip = sliderGroup.select('rect.' + constants.gripRectClass);\n\n    var quantizedIndex = 0;\n    for(var i = 0; i < sliderOpts._stepCount; i++) {\n        if(sliderOpts._visibleSteps[i]._index === sliderOpts.active) {\n            quantizedIndex = i;\n            break;\n        }\n    }\n\n    var x = normalizedValueToPosition(sliderOpts, quantizedIndex / (sliderOpts._stepCount - 1));\n\n    // If this is true, then *this component* is already invoking its own command\n    // and has triggered its own animation.\n    if(sliderOpts._invokingCommand) return;\n\n    var el = grip;\n    if(doTransition && sliderOpts.transition.duration > 0) {\n        el = el.transition()\n            .duration(sliderOpts.transition.duration)\n            .ease(sliderOpts.transition.easing);\n    }\n\n    // Drawing.setTranslate doesn't work here becasue of the transition duck-typing.\n    // It's also not necessary because there are no other transitions to preserve.\n    el.attr('transform', 'translate(' + (x - constants.gripWidth * 0.5) + ',' + (sliderOpts._dims.currentValueTotalHeight) + ')');\n}\n\n// Convert a number from [0-1] to a pixel position relative to the slider group container:\nfunction normalizedValueToPosition(sliderOpts, normalizedPosition) {\n    var dims = sliderOpts._dims;\n    return dims.inputAreaStart + constants.stepInset +\n        (dims.inputAreaLength - 2 * constants.stepInset) * Math.min(1, Math.max(0, normalizedPosition));\n}\n\n// Convert a position relative to the slider group to a nubmer in [0, 1]\nfunction positionToNormalizedValue(sliderOpts, position) {\n    var dims = sliderOpts._dims;\n    return Math.min(1, Math.max(0, (position - constants.stepInset - dims.inputAreaStart) / (dims.inputAreaLength - 2 * constants.stepInset - 2 * dims.inputAreaStart)));\n}\n\nfunction drawTouchRect(sliderGroup, gd, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railTouchRectClass, function(s) {\n        s.call(attachGripEvents, gd, sliderGroup, sliderOpts)\n            .style('pointer-events', 'all');\n    });\n\n    rect.attr({\n        width: dims.inputAreaLength,\n        height: Math.max(dims.inputAreaWidth, constants.tickOffset + sliderOpts.ticklen + dims.labelHeight)\n    })\n        .call(Color.fill, sliderOpts.bgcolor)\n        .attr('opacity', 0);\n\n    Drawing.setTranslate(rect, 0, dims.currentValueTotalHeight);\n}\n\nfunction drawRail(sliderGroup, sliderOpts) {\n    var dims = sliderOpts._dims;\n    var computedLength = dims.inputAreaLength - constants.railInset * 2;\n    var rect = Lib.ensureSingle(sliderGroup, 'rect', constants.railRectClass);\n\n    rect.attr({\n        width: computedLength,\n        height: constants.railWidth,\n        rx: constants.railRadius,\n        ry: constants.railRadius,\n        'shape-rendering': 'crispEdges'\n    })\n    .call(Color.stroke, sliderOpts.bordercolor)\n    .call(Color.fill, sliderOpts.bgcolor)\n    .style('stroke-width', sliderOpts.borderwidth + 'px');\n\n    Drawing.setTranslate(rect,\n        constants.railInset,\n        (dims.inputAreaWidth - constants.railWidth) * 0.5 + dims.currentValueTotalHeight\n    );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}