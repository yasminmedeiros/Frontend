{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar nestedProperty = require('./nested_property');\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n// bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n  keyName = keyName || 'name';\n  valueName = valueName || 'value';\n  var i, arr, baseProp;\n  var changeTypes = {};\n  if (path && path.length) {\n    baseProp = nestedProperty(baseObj, path);\n    arr = baseProp.get();\n  } else {\n    arr = baseObj;\n  }\n  path = path || '';\n\n  // Construct an index:\n  var indexLookup = {};\n  if (arr) {\n    for (i = 0; i < arr.length; i++) {\n      indexLookup[arr[i][keyName]] = i;\n    }\n  }\n  var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n  var obj = {\n    set: function set(name, value) {\n      var changeType = value === null ? UNSET : NONE;\n\n      // create the base array if necessary\n      if (!arr) {\n        if (!baseProp || changeType === UNSET) return;\n        arr = [];\n        baseProp.set(arr);\n      }\n      var idx = indexLookup[name];\n      if (idx === undefined) {\n        if (changeType === UNSET) return;\n        changeType = changeType | BOTH;\n        idx = arr.length;\n        indexLookup[name] = idx;\n      } else if (value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n        changeType = changeType | VALUE;\n      }\n      var newValue = arr[idx] = arr[idx] || {};\n      newValue[keyName] = name;\n      if (isSimpleValueProp) {\n        newValue[valueName] = value;\n      } else {\n        nestedProperty(newValue, valueName).set(value);\n      }\n\n      // If it's not an unset, force that bit to be unset. This is all related to the fact\n      // that undefined and null are a bit specially implemented in nestedProperties.\n      if (value !== null) {\n        changeType = changeType & ~UNSET;\n      }\n      changeTypes[idx] = changeTypes[idx] | changeType;\n      return obj;\n    },\n    get: function get(name) {\n      if (!arr) return;\n      var idx = indexLookup[name];\n      if (idx === undefined) {\n        return undefined;\n      } else if (isSimpleValueProp) {\n        return arr[idx][valueName];\n      } else {\n        return nestedProperty(arr[idx], valueName).get();\n      }\n    },\n    rename: function rename(name, newName) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      changeTypes[idx] = changeTypes[idx] | NAME;\n      indexLookup[newName] = idx;\n      delete indexLookup[name];\n      arr[idx][keyName] = newName;\n      return obj;\n    },\n    remove: function remove(name) {\n      var idx = indexLookup[name];\n      if (idx === undefined) return obj;\n      var object = arr[idx];\n      if (Object.keys(object).length > 2) {\n        // This object contains more than just the key/value, so unset\n        // the value without modifying the entry otherwise:\n        changeTypes[idx] = changeTypes[idx] | VALUE;\n        return obj.set(name, null);\n      }\n      if (isSimpleValueProp) {\n        for (i = idx; i < arr.length; i++) {\n          changeTypes[i] = changeTypes[i] | BOTH;\n        }\n        for (i = idx; i < arr.length; i++) {\n          indexLookup[arr[i][keyName]]--;\n        }\n        arr.splice(idx, 1);\n        delete indexLookup[name];\n      } else {\n        // Perform this update *strictly* so we can check whether the result's\n        // been pruned. If so, it's a removal. If not, it's a value unset only.\n        nestedProperty(object, valueName).set(null);\n\n        // Now check if the top level nested property has any keys left. If so,\n        // the object still has values so we only want to unset the key. If not,\n        // the entire object can be removed since there's no other data.\n        // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n        changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n      }\n      return obj;\n    },\n    constructUpdate: function constructUpdate() {\n      var astr, idx;\n      var update = {};\n      var changed = Object.keys(changeTypes);\n      for (var i = 0; i < changed.length; i++) {\n        idx = changed[i];\n        astr = path + '[' + idx + ']';\n        if (arr[idx]) {\n          if (changeTypes[idx] & NAME) {\n            update[astr + '.' + keyName] = arr[idx][keyName];\n          }\n          if (changeTypes[idx] & VALUE) {\n            if (isSimpleValueProp) {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : arr[idx][valueName];\n            } else {\n              update[astr + '.' + valueName] = changeTypes[idx] & UNSET ? null : nestedProperty(arr[idx], valueName).get();\n            }\n          }\n        } else {\n          update[astr] = null;\n        }\n      }\n      return update;\n    }\n  };\n  return obj;\n};","map":{"version":3,"names":["nestedProperty","require","SIMPLE_PROPERTY_REGEX","NONE","NAME","VALUE","BOTH","UNSET","module","exports","keyedContainer","baseObj","path","keyName","valueName","i","arr","baseProp","changeTypes","length","get","indexLookup","isSimpleValueProp","test","obj","set","name","value","changeType","idx","undefined","newValue","rename","newName","remove","object","Object","keys","splice","constructUpdate","astr","update","changed"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/lib/keyed_container.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar nestedProperty = require('./nested_property');\n\nvar SIMPLE_PROPERTY_REGEX = /^\\w*$/;\n\n// bitmask for deciding what's updated. Sometimes the name needs to be updated,\n// sometimes the value needs to be updated, and sometimes both do. This is just\n// a simple way to track what's updated such that it's a simple OR operation to\n// assimilate new updates.\n//\n// The only exception is the UNSET bit that tracks when we need to explicitly\n// unset and remove the property. This concrn arises because of the special\n// way in which nestedProperty handles null/undefined. When you specify `null`,\n// it prunes any unused items in the tree. I ran into some issues with it getting\n// null vs undefined confused, so UNSET is just a bit that forces the property\n// update to send `null`, removing the property explicitly rather than setting\n// it to undefined.\nvar NONE = 0;\nvar NAME = 1;\nvar VALUE = 2;\nvar BOTH = 3;\nvar UNSET = 4;\n\nmodule.exports = function keyedContainer(baseObj, path, keyName, valueName) {\n    keyName = keyName || 'name';\n    valueName = valueName || 'value';\n    var i, arr, baseProp;\n    var changeTypes = {};\n\n    if(path && path.length) {\n        baseProp = nestedProperty(baseObj, path);\n        arr = baseProp.get();\n    } else {\n        arr = baseObj;\n    }\n\n    path = path || '';\n\n    // Construct an index:\n    var indexLookup = {};\n    if(arr) {\n        for(i = 0; i < arr.length; i++) {\n            indexLookup[arr[i][keyName]] = i;\n        }\n    }\n\n    var isSimpleValueProp = SIMPLE_PROPERTY_REGEX.test(valueName);\n\n    var obj = {\n        set: function(name, value) {\n            var changeType = value === null ? UNSET : NONE;\n\n            // create the base array if necessary\n            if(!arr) {\n                if(!baseProp || changeType === UNSET) return;\n\n                arr = [];\n                baseProp.set(arr);\n            }\n\n            var idx = indexLookup[name];\n            if(idx === undefined) {\n                if(changeType === UNSET) return;\n\n                changeType = changeType | BOTH;\n                idx = arr.length;\n                indexLookup[name] = idx;\n            } else if(value !== (isSimpleValueProp ? arr[idx][valueName] : nestedProperty(arr[idx], valueName).get())) {\n                changeType = changeType | VALUE;\n            }\n\n            var newValue = arr[idx] = arr[idx] || {};\n            newValue[keyName] = name;\n\n            if(isSimpleValueProp) {\n                newValue[valueName] = value;\n            } else {\n                nestedProperty(newValue, valueName).set(value);\n            }\n\n            // If it's not an unset, force that bit to be unset. This is all related to the fact\n            // that undefined and null are a bit specially implemented in nestedProperties.\n            if(value !== null) {\n                changeType = changeType & ~UNSET;\n            }\n\n            changeTypes[idx] = changeTypes[idx] | changeType;\n\n            return obj;\n        },\n        get: function(name) {\n            if(!arr) return;\n\n            var idx = indexLookup[name];\n\n            if(idx === undefined) {\n                return undefined;\n            } else if(isSimpleValueProp) {\n                return arr[idx][valueName];\n            } else {\n                return nestedProperty(arr[idx], valueName).get();\n            }\n        },\n        rename: function(name, newName) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n            changeTypes[idx] = changeTypes[idx] | NAME;\n\n            indexLookup[newName] = idx;\n            delete indexLookup[name];\n\n            arr[idx][keyName] = newName;\n\n            return obj;\n        },\n        remove: function(name) {\n            var idx = indexLookup[name];\n\n            if(idx === undefined) return obj;\n\n            var object = arr[idx];\n            if(Object.keys(object).length > 2) {\n                // This object contains more than just the key/value, so unset\n                // the value without modifying the entry otherwise:\n                changeTypes[idx] = changeTypes[idx] | VALUE;\n                return obj.set(name, null);\n            }\n\n            if(isSimpleValueProp) {\n                for(i = idx; i < arr.length; i++) {\n                    changeTypes[i] = changeTypes[i] | BOTH;\n                }\n                for(i = idx; i < arr.length; i++) {\n                    indexLookup[arr[i][keyName]]--;\n                }\n                arr.splice(idx, 1);\n                delete(indexLookup[name]);\n            } else {\n                // Perform this update *strictly* so we can check whether the result's\n                // been pruned. If so, it's a removal. If not, it's a value unset only.\n                nestedProperty(object, valueName).set(null);\n\n                // Now check if the top level nested property has any keys left. If so,\n                // the object still has values so we only want to unset the key. If not,\n                // the entire object can be removed since there's no other data.\n                // var topLevelKeys = Object.keys(object[valueName.split('.')[0]] || []);\n\n                changeTypes[idx] = changeTypes[idx] | VALUE | UNSET;\n            }\n\n            return obj;\n        },\n        constructUpdate: function() {\n            var astr, idx;\n            var update = {};\n            var changed = Object.keys(changeTypes);\n            for(var i = 0; i < changed.length; i++) {\n                idx = changed[i];\n                astr = path + '[' + idx + ']';\n                if(arr[idx]) {\n                    if(changeTypes[idx] & NAME) {\n                        update[astr + '.' + keyName] = arr[idx][keyName];\n                    }\n                    if(changeTypes[idx] & VALUE) {\n                        if(isSimpleValueProp) {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : arr[idx][valueName];\n                        } else {\n                            update[astr + '.' + valueName] = (changeTypes[idx] & UNSET) ? null : nestedProperty(arr[idx], valueName).get();\n                        }\n                    }\n                } else {\n                    update[astr] = null;\n                }\n            }\n\n            return update;\n        }\n    };\n\n    return obj;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}