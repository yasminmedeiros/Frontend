{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar c = require('./constants');\nvar d3 = require('d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) {\n  return v * (1 - snapRatio) + vAdjacent * snapRatio;\n}\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) {\n  return v * (1 - snapClose) + vAdjacent * snapClose;\n}\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnapLo(a, v, existingRanges) {\n  if (overlappingExisting(v, existingRanges)) return v;\n  var aPrev = a[0];\n  var aPrevPrev = aPrev;\n  for (var i = 1; i < a.length; i++) {\n    var aNext = a[i];\n\n    // very close to the previous - snap down to it\n    if (v < closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n    if (v < aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n    aPrevPrev = aPrev;\n    aPrev = aNext;\n  }\n}\nfunction ordinalScaleSnapHi(a, v, existingRanges) {\n  if (overlappingExisting(v, existingRanges)) return v;\n  var aPrev = a[a.length - 1];\n  var aPrevPrev = aPrev;\n  for (var i = a.length - 2; i >= 0; i--) {\n    var aNext = a[i];\n\n    // very close to the previous - snap down to it\n    if (v > closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n    if (v > aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n    aPrevPrev = aPrev;\n    aPrev = aNext;\n  }\n}\nfunction overlappingExisting(v, existingRanges) {\n  for (var i = 0; i < existingRanges.length; i++) {\n    if (v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n  }\n  return false;\n}\nfunction barHorizontalSetup(selection) {\n  selection.attr('x', -c.bar.captureWidth / 2).attr('width', c.bar.captureWidth);\n}\nfunction backgroundBarHorizontalSetup(selection) {\n  selection.attr('visibility', 'visible').style('visibility', 'visible').attr('fill', 'yellow').attr('opacity', 0);\n}\nfunction setHighlight(d) {\n  if (!d.brush.filterSpecified) {\n    return '0,' + d.height;\n  }\n  var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n  var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n  var p, sectionHeight, iNext;\n  var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n  for (var i = 0; i < pixelRanges.length; i++) {\n    p = pixelRanges[i];\n    sectionHeight = p[1] - p[0];\n    dashArray.push(currentGap);\n    dashArray.push(sectionHeight);\n    iNext = i + 1;\n    if (iNext < pixelRanges.length) {\n      currentGap = pixelRanges[iNext][0] - p[1];\n    }\n  }\n  dashArray.push(d.height);\n  // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n  // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n  // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n  // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n  return dashArray;\n}\nfunction unitToPx(unitRanges, height) {\n  return unitRanges.map(function (pr) {\n    return pr.map(function (v) {\n      return v * height;\n    }).sort(sortAsc);\n  });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n  var pad = c.bar.handleHeight;\n  if (y > fPix[1] + pad || y < fPix[0] - pad) return;\n  if (y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n  if (y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n  return 'ns';\n}\nfunction clearCursor() {\n  d3.select(document.body).style('cursor', null);\n}\nfunction styleHighlight(selection) {\n  // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n  // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n  // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n  // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n  selection.attr('stroke-dasharray', setHighlight);\n}\nfunction renderHighlight(root, tweenCallback) {\n  var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n  var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n  styleHighlight(barToStyle);\n}\nfunction getInterval(d, y) {\n  var b = d.brush;\n  var active = b.filterSpecified;\n  var closestInterval = NaN;\n  var out = {};\n  var i;\n  if (active) {\n    var height = d.height;\n    var intervals = b.filter.getConsolidated();\n    var pixIntervals = unitToPx(intervals, height);\n    var hoveredInterval = NaN;\n    var previousInterval = NaN;\n    var nextInterval = NaN;\n    for (i = 0; i <= pixIntervals.length; i++) {\n      var p = pixIntervals[i];\n      if (p && p[0] <= y && y <= p[1]) {\n        // over a bar\n        hoveredInterval = i;\n        break;\n      } else {\n        // between bars, or before/after the first/last bar\n        previousInterval = i ? i - 1 : NaN;\n        if (p && p[0] > y) {\n          nextInterval = i;\n          break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n        }\n      }\n    }\n\n    closestInterval = hoveredInterval;\n    if (isNaN(closestInterval)) {\n      if (isNaN(previousInterval) || isNaN(nextInterval)) {\n        closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n      } else {\n        closestInterval = y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y ? previousInterval : nextInterval;\n      }\n    }\n    if (!isNaN(closestInterval)) {\n      var fPix = pixIntervals[closestInterval];\n      var region = getRegion(fPix, y);\n      if (region) {\n        out.interval = intervals[closestInterval];\n        out.intervalPix = fPix;\n        out.region = region;\n      }\n    }\n  }\n  if (d.ordinal && !out.region) {\n    var a = d.unitTickvals;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n    for (i = 0; i < a.length; i++) {\n      var rangei = [a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75, a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75];\n      if (unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n        out.clickableOrdinalRange = rangei;\n        break;\n      }\n    }\n  }\n  return out;\n}\nfunction attachDragBehavior(selection) {\n  // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n  // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n  // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n  selection.on('mousemove', function (d) {\n    d3.event.preventDefault();\n    if (!d.parent.inBrushDrag) {\n      var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n      var interval = getInterval(d, y);\n      var cursor = 'crosshair';\n      if (interval.clickableOrdinalRange) cursor = 'pointer';else if (interval.region) cursor = interval.region + '-resize';\n      d3.select(document.body).style('cursor', cursor);\n    }\n  }).on('mouseleave', function (d) {\n    if (!d.parent.inBrushDrag) clearCursor();\n  }).call(d3.behavior.drag().on('dragstart', function (d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n    var unitLocation = d.unitToPaddedPx.invert(y);\n    var b = d.brush;\n    var interval = getInterval(d, y);\n    var unitRange = interval.interval;\n    var s = b.svgBrush;\n    s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n    s.grabbingBar = interval.region === 'ns';\n    if (s.grabbingBar) {\n      var pixelRange = unitRange.map(d.unitToPaddedPx);\n      s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n      s.barLength = pixelRange[1] - pixelRange[0];\n    }\n    s.clickableOrdinalRange = interval.clickableOrdinalRange;\n    s.stayingIntervals = d.multiselect && b.filterSpecified ? b.filter.getConsolidated() : [];\n    if (unitRange) {\n      s.stayingIntervals = s.stayingIntervals.filter(function (int2) {\n        return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n      });\n    }\n    s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n    d.parent.inBrushDrag = true;\n    s.brushStartCallback();\n  }).on('drag', function (d) {\n    d3.event.sourceEvent.stopPropagation();\n    var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n    var s = d.brush.svgBrush;\n    s.wasDragged = true;\n    if (s.grabbingBar) {\n      // moving the bar\n      s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n    } else {\n      // south/north drag or new bar creation\n      s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n    }\n\n    // take care of the parcoords axis height constraint: bar can't breach it\n    var bottomViolation = Math.max(0, -s.newExtent[0]);\n    var topViolation = Math.max(0, s.newExtent[1] - 1);\n    s.newExtent[0] += bottomViolation;\n    s.newExtent[1] -= topViolation;\n    if (s.grabbingBar) {\n      // in case of bar dragging (non-resizing interaction, unlike north/south resize or new bar creation)\n      // the constraint adjustment must apply to the other end of the bar as well, otherwise it'd\n      // shorten or lengthen\n      s.newExtent[1] += bottomViolation;\n      s.newExtent[0] -= topViolation;\n    }\n    d.brush.filterSpecified = true;\n    s.extent = s.stayingIntervals.concat([s.newExtent]);\n    s.brushCallback(d);\n    renderHighlight(this.parentNode);\n  }).on('dragend', function (d) {\n    var e = d3.event;\n    e.sourceEvent.stopPropagation();\n    var brush = d.brush;\n    var filter = brush.filter;\n    var s = brush.svgBrush;\n    var grabbingBar = s.grabbingBar;\n    s.grabbingBar = false;\n    s.grabLocation = undefined;\n    d.parent.inBrushDrag = false;\n    clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n    if (!s.wasDragged) {\n      // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n      s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n      if (s.clickableOrdinalRange) {\n        if (brush.filterSpecified && d.multiselect) {\n          s.extent.push(s.clickableOrdinalRange);\n        } else {\n          s.extent = [s.clickableOrdinalRange];\n          brush.filterSpecified = true;\n        }\n      } else if (grabbingBar) {\n        s.extent = s.stayingIntervals;\n        if (s.extent.length === 0) {\n          brushClear(brush);\n        }\n      } else {\n        brushClear(brush);\n      }\n      s.brushCallback(d);\n      renderHighlight(this.parentNode);\n      s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n      return; // no need to fuse intervals or snap to ordinals, so we can bail early\n    }\n\n    var mergeIntervals = function mergeIntervals() {\n      // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n      // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n      filter.set(filter.getConsolidated());\n    };\n    if (d.ordinal) {\n      var a = d.unitTickvals;\n      if (a[a.length - 1] < a[0]) a.reverse();\n      s.newExtent = [ordinalScaleSnapLo(a, s.newExtent[0], s.stayingIntervals), ordinalScaleSnapHi(a, s.newExtent[1], s.stayingIntervals)];\n      var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n      s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n      if (!s.extent.length) {\n        brushClear(brush);\n      }\n      s.brushCallback(d);\n      if (hasNewExtent) {\n        // merging intervals post the snap tween\n        renderHighlight(this.parentNode, mergeIntervals);\n      } else {\n        // if no new interval, don't animate, just redraw the highlight immediately\n        mergeIntervals();\n        renderHighlight(this.parentNode);\n      }\n    } else {\n      mergeIntervals(); // merging intervals immediately\n    }\n\n    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n  }));\n}\nfunction startAsc(a, b) {\n  return a[0] - b[0];\n}\nfunction renderAxisBrush(axisBrush) {\n  var background = axisBrush.selectAll('.background').data(repeat);\n  background.enter().append('rect').classed('background', true).call(barHorizontalSetup).call(backgroundBarHorizontalSetup).style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n  .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n  background.call(attachDragBehavior).attr('height', function (d) {\n    return d.height - c.verticalPadding;\n  });\n  var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n  highlightShadow.enter().append('line').classed('highlight-shadow', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width + c.bar.strokeWidth).attr('stroke', c.bar.strokeColor).attr('opacity', c.bar.strokeOpacity).attr('stroke-linecap', 'butt');\n  highlightShadow.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n  var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n  highlight.enter().append('line').classed('highlight', true).attr('x', -c.bar.width / 2).attr('stroke-width', c.bar.width - c.bar.strokeWidth).attr('stroke', c.bar.fillColor).attr('opacity', c.bar.fillOpacity).attr('stroke-linecap', 'butt');\n  highlight.attr('y1', function (d) {\n    return d.height;\n  }).call(styleHighlight);\n}\nfunction ensureAxisBrush(axisOverlays) {\n  var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush).data(repeat, keyFun);\n  axisBrush.enter().append('g').classed(c.cn.axisBrush, true);\n  renderAxisBrush(axisBrush);\n}\nfunction getBrushExtent(brush) {\n  return brush.svgBrush.extent.map(function (e) {\n    return e.slice();\n  });\n}\nfunction brushClear(brush) {\n  brush.filterSpecified = false;\n  brush.svgBrush.extent = [[0, 1]];\n}\nfunction axisBrushMoved(callback) {\n  return function axisBrushMoved(dimension) {\n    var brush = dimension.brush;\n    var extent = getBrushExtent(brush);\n    var newExtent = extent.slice();\n    brush.filter.set(newExtent);\n    callback();\n  };\n}\nfunction dedupeRealRanges(intervals) {\n  // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n  // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n  var queue = intervals.slice();\n  var result = [];\n  var currentInterval;\n  var current = queue.shift();\n  while (current) {\n    // [].shift === undefined, so we don't descend into an empty array\n    currentInterval = current.slice();\n    while ((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */currentInterval[1]) {\n      currentInterval[1] = Math.max(currentInterval[1], current[1]);\n    }\n    result.push(currentInterval);\n  }\n  return result;\n}\nfunction makeFilter() {\n  var filter = [];\n  var consolidated;\n  var bounds;\n  return {\n    set: function set(a) {\n      filter = a.map(function (d) {\n        return d.slice().sort(sortAsc);\n      }).sort(startAsc);\n      consolidated = dedupeRealRanges(filter);\n      bounds = filter.reduce(function (p, n) {\n        return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n      }, [Infinity, -Infinity]);\n    },\n    get: function get() {\n      return filter.slice();\n    },\n    getConsolidated: function getConsolidated() {\n      return consolidated;\n    },\n    getBounds: function getBounds() {\n      return bounds;\n    }\n  };\n}\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n  var filter = makeFilter();\n  filter.set(initialRange);\n  return {\n    filter: filter,\n    filterSpecified: rangeSpecified,\n    // there's a difference between not filtering and filtering a non-proper subset\n    svgBrush: {\n      extent: [],\n      // this is where the svgBrush writes contents into\n      brushStartCallback: brushStartCallback,\n      brushCallback: axisBrushMoved(brushCallback),\n      brushEndCallback: brushEndCallback\n    }\n  };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n  if (Array.isArray(ranges[0])) {\n    ranges = ranges.map(function (ri) {\n      return ri.sort(sortAsc);\n    });\n    if (!dimension.multiselect) ranges = [ranges[0]];else ranges = dedupeRealRanges(ranges.sort(startAsc));\n  } else ranges = [ranges.sort(sortAsc)];\n\n  // ordinal snapping\n  if (dimension.tickvals) {\n    var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n    ranges = ranges.map(function (ri) {\n      var rSnapped = [ordinalScaleSnapLo(sortedTickVals, ri[0], []), ordinalScaleSnapHi(sortedTickVals, ri[1], [])];\n      if (rSnapped[1] > rSnapped[0]) return rSnapped;\n    }).filter(function (ri) {\n      return ri;\n    });\n    if (!ranges.length) return;\n  }\n  return ranges.length > 1 ? ranges : ranges[0];\n}\nmodule.exports = {\n  makeBrush: makeBrush,\n  ensureAxisBrush: ensureAxisBrush,\n  cleanRanges: cleanRanges\n};","map":{"version":3,"names":["c","require","d3","keyFun","repeat","sortAsc","sorterAsc","snapRatio","bar","snapOvershoot","v","vAdjacent","snapClose","closeToCovering","ordinalScaleSnapLo","a","existingRanges","overlappingExisting","aPrev","aPrevPrev","i","length","aNext","ordinalScaleSnapHi","barHorizontalSetup","selection","attr","captureWidth","backgroundBarHorizontalSetup","style","setHighlight","d","brush","filterSpecified","height","pixelRanges","unitToPx","filter","getConsolidated","dashArray","p","sectionHeight","iNext","currentGap","push","unitRanges","map","pr","sort","getRegion","fPix","y","pad","handleHeight","clearCursor","select","document","body","styleHighlight","renderHighlight","root","tweenCallback","selectAll","barToStyle","transition","duration","snapDuration","each","getInterval","b","active","closestInterval","NaN","out","intervals","pixIntervals","hoveredInterval","previousInterval","nextInterval","isNaN","region","interval","intervalPix","ordinal","unitTickvals","unitLocation","unitToPaddedPx","invert","rangei","Math","max","min","clickableOrdinalRange","attachDragBehavior","on","event","preventDefault","parent","inBrushDrag","mouse","verticalPadding","cursor","call","behavior","drag","sourceEvent","stopPropagation","unitRange","s","svgBrush","wasDragged","grabbingBar","pixelRange","grabPoint","barLength","stayingIntervals","multiselect","int2","startExtent","brushStartCallback","newExtent","bottomViolation","topViolation","extent","concat","brushCallback","parentNode","e","grabLocation","undefined","brushClear","brushEndCallback","mergeIntervals","set","reverse","hasNewExtent","startAsc","renderAxisBrush","axisBrush","background","data","enter","append","classed","highlightShadow","width","strokeWidth","strokeColor","strokeOpacity","highlight","fillColor","fillOpacity","ensureAxisBrush","axisOverlays","cn","getBrushExtent","slice","axisBrushMoved","callback","dimension","dedupeRealRanges","queue","result","currentInterval","current","shift","makeFilter","consolidated","bounds","reduce","n","Infinity","get","getBounds","makeBrush","state","rangeSpecified","initialRange","cleanRanges","ranges","Array","isArray","ri","tickvals","sortedTickVals","rSnapped","module","exports"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/parcoords/axisbrush.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar c = require('./constants');\nvar d3 = require('d3');\nvar keyFun = require('../../lib/gup').keyFun;\nvar repeat = require('../../lib/gup').repeat;\nvar sortAsc = require('../../lib').sorterAsc;\n\nvar snapRatio = c.bar.snapRatio;\nfunction snapOvershoot(v, vAdjacent) { return v * (1 - snapRatio) + vAdjacent * snapRatio; }\n\nvar snapClose = c.bar.snapClose;\nfunction closeToCovering(v, vAdjacent) { return v * (1 - snapClose) + vAdjacent * snapClose; }\n\n// snap for the low end of a range on an ordinal scale\n// on an ordinal scale, always show some overshoot from the exact value,\n// so it's clear we're covering it\n// find the interval we're in, and snap to 1/4 the distance to the next\n// these two could be unified at a slight loss of readability / perf\nfunction ordinalScaleSnapLo(a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var aPrev = a[0];\n    var aPrevPrev = aPrev;\n    for(var i = 1; i < a.length; i++) {\n        var aNext = a[i];\n\n        // very close to the previous - snap down to it\n        if(v < closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n        if(v < aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n\n        aPrevPrev = aPrev;\n        aPrev = aNext;\n    }\n}\n\nfunction ordinalScaleSnapHi(a, v, existingRanges) {\n    if(overlappingExisting(v, existingRanges)) return v;\n\n    var aPrev = a[a.length - 1];\n    var aPrevPrev = aPrev;\n    for(var i = a.length - 2; i >= 0; i--) {\n        var aNext = a[i];\n\n        // very close to the previous - snap down to it\n        if(v > closeToCovering(aPrev, aNext)) return snapOvershoot(aPrev, aPrevPrev);\n        if(v > aNext || i === a.length - 1) return snapOvershoot(aNext, aPrev);\n\n        aPrevPrev = aPrev;\n        aPrev = aNext;\n    }\n}\n\nfunction overlappingExisting(v, existingRanges) {\n    for(var i = 0; i < existingRanges.length; i++) {\n        if(v >= existingRanges[i][0] && v <= existingRanges[i][1]) return true;\n    }\n    return false;\n}\n\nfunction barHorizontalSetup(selection) {\n    selection\n        .attr('x', -c.bar.captureWidth / 2)\n        .attr('width', c.bar.captureWidth);\n}\n\nfunction backgroundBarHorizontalSetup(selection) {\n    selection\n        .attr('visibility', 'visible')\n        .style('visibility', 'visible')\n        .attr('fill', 'yellow')\n        .attr('opacity', 0);\n}\n\nfunction setHighlight(d) {\n    if(!d.brush.filterSpecified) {\n        return '0,' + d.height;\n    }\n    var pixelRanges = unitToPx(d.brush.filter.getConsolidated(), d.height);\n    var dashArray = [0]; // we start with a 0 length selection as filter ranges are inclusive, not exclusive\n    var p, sectionHeight, iNext;\n    var currentGap = pixelRanges.length ? pixelRanges[0][0] : null;\n    for(var i = 0; i < pixelRanges.length; i++) {\n        p = pixelRanges[i];\n        sectionHeight = p[1] - p[0];\n        dashArray.push(currentGap);\n        dashArray.push(sectionHeight);\n        iNext = i + 1;\n        if(iNext < pixelRanges.length) {\n            currentGap = pixelRanges[iNext][0] - p[1];\n        }\n    }\n    dashArray.push(d.height);\n    // d.height is added at the end to ensure that (1) we have an even number of dasharray points, MDN page says\n    // \"If an odd number of values is provided, then the list of values is repeated to yield an even number of values.\"\n    // and (2) it's _at least_ as long as the full height (even if range is minuscule and at the bottom) though this\n    // may not be necessary, maybe duplicating the last point would do too. But no harm in a longer dasharray than line.\n    return dashArray;\n}\n\nfunction unitToPx(unitRanges, height) {\n    return unitRanges.map(function(pr) {\n        return pr.map(function(v) { return v * height; }).sort(sortAsc);\n    });\n}\n\n// is the cursor over the north, middle, or south of a bar?\n// the end handles extend over the last 10% of the bar\nfunction getRegion(fPix, y) {\n    var pad = c.bar.handleHeight;\n    if(y > fPix[1] + pad || y < fPix[0] - pad) return;\n    if(y >= 0.9 * fPix[1] + 0.1 * fPix[0]) return 'n';\n    if(y <= 0.9 * fPix[0] + 0.1 * fPix[1]) return 's';\n    return 'ns';\n}\n\nfunction clearCursor() {\n    d3.select(document.body)\n        .style('cursor', null);\n}\n\nfunction styleHighlight(selection) {\n    // stroke-dasharray is used to minimize the number of created DOM nodes, because the requirement calls for up to\n    // 1000 individual selections on an axis, and there can be 60 axes per parcoords, and multiple parcoords per\n    // dashboard. The technique is similar to https://codepen.io/monfera/pen/rLYqWR and using a `polyline` with\n    // multiple sections, or a `path` element via its `d` attribute would also be DOM-sparing alternatives.\n    selection.attr('stroke-dasharray', setHighlight);\n}\n\nfunction renderHighlight(root, tweenCallback) {\n    var bar = d3.select(root).selectAll('.highlight, .highlight-shadow');\n    var barToStyle = tweenCallback ? bar.transition().duration(c.bar.snapDuration).each('end', tweenCallback) : bar;\n    styleHighlight(barToStyle);\n}\n\nfunction getInterval(d, y) {\n    var b = d.brush;\n    var active = b.filterSpecified;\n    var closestInterval = NaN;\n    var out = {};\n    var i;\n\n    if(active) {\n        var height = d.height;\n        var intervals = b.filter.getConsolidated();\n        var pixIntervals = unitToPx(intervals, height);\n        var hoveredInterval = NaN;\n        var previousInterval = NaN;\n        var nextInterval = NaN;\n        for(i = 0; i <= pixIntervals.length; i++) {\n            var p = pixIntervals[i];\n            if(p && p[0] <= y && y <= p[1]) {\n                // over a bar\n                hoveredInterval = i;\n                break;\n            } else {\n                // between bars, or before/after the first/last bar\n                previousInterval = i ? i - 1 : NaN;\n                if(p && p[0] > y) {\n                    nextInterval = i;\n                    break; // no point continuing as intervals are non-overlapping and sorted; could use log search\n                }\n            }\n        }\n\n        closestInterval = hoveredInterval;\n        if(isNaN(closestInterval)) {\n            if(isNaN(previousInterval) || isNaN(nextInterval)) {\n                closestInterval = isNaN(previousInterval) ? nextInterval : previousInterval;\n            }\n            else {\n                closestInterval = (y - pixIntervals[previousInterval][1] < pixIntervals[nextInterval][0] - y) ?\n                    previousInterval : nextInterval;\n            }\n        }\n\n        if(!isNaN(closestInterval)) {\n            var fPix = pixIntervals[closestInterval];\n            var region = getRegion(fPix, y);\n\n            if(region) {\n                out.interval = intervals[closestInterval];\n                out.intervalPix = fPix;\n                out.region = region;\n            }\n        }\n    }\n\n    if(d.ordinal && !out.region) {\n        var a = d.unitTickvals;\n        var unitLocation = d.unitToPaddedPx.invert(y);\n        for(i = 0; i < a.length; i++) {\n            var rangei = [\n                a[Math.max(i - 1, 0)] * 0.25 + a[i] * 0.75,\n                a[Math.min(i + 1, a.length - 1)] * 0.25 + a[i] * 0.75\n            ];\n            if(unitLocation >= rangei[0] && unitLocation <= rangei[1]) {\n                out.clickableOrdinalRange = rangei;\n                break;\n            }\n        }\n    }\n\n    return out;\n}\n\nfunction attachDragBehavior(selection) {\n    // There's some fiddling with pointer cursor styling so that the cursor preserves its shape while dragging a brush\n    // even if the cursor strays from the interacting bar, which is bound to happen as bars are thin and the user\n    // will inevitably leave the hotspot strip. In this regard, it does something similar to what the D3 brush would do.\n    selection\n        .on('mousemove', function(d) {\n            d3.event.preventDefault();\n            if(!d.parent.inBrushDrag) {\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var interval = getInterval(d, y);\n\n                var cursor = 'crosshair';\n                if(interval.clickableOrdinalRange) cursor = 'pointer';\n                else if(interval.region) cursor = interval.region + '-resize';\n                d3.select(document.body)\n                    .style('cursor', cursor);\n            }\n        })\n        .on('mouseleave', function(d) {\n            if(!d.parent.inBrushDrag) clearCursor();\n        })\n        .call(d3.behavior.drag()\n            .on('dragstart', function(d) {\n                d3.event.sourceEvent.stopPropagation();\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var unitLocation = d.unitToPaddedPx.invert(y);\n                var b = d.brush;\n                var interval = getInterval(d, y);\n                var unitRange = interval.interval;\n                var s = b.svgBrush;\n                s.wasDragged = false; // we start assuming there won't be a drag - useful for reset\n                s.grabbingBar = interval.region === 'ns';\n                if(s.grabbingBar) {\n                    var pixelRange = unitRange.map(d.unitToPaddedPx);\n                    s.grabPoint = y - pixelRange[0] - c.verticalPadding;\n                    s.barLength = pixelRange[1] - pixelRange[0];\n                }\n                s.clickableOrdinalRange = interval.clickableOrdinalRange;\n                s.stayingIntervals = (d.multiselect && b.filterSpecified) ? b.filter.getConsolidated() : [];\n                if(unitRange) {\n                    s.stayingIntervals = s.stayingIntervals.filter(function(int2) {\n                        return int2[0] !== unitRange[0] && int2[1] !== unitRange[1];\n                    });\n                }\n                s.startExtent = interval.region ? unitRange[interval.region === 's' ? 1 : 0] : unitLocation;\n                d.parent.inBrushDrag = true;\n                s.brushStartCallback();\n            })\n            .on('drag', function(d) {\n                d3.event.sourceEvent.stopPropagation();\n                var y = d.height - d3.mouse(this)[1] - 2 * c.verticalPadding;\n                var s = d.brush.svgBrush;\n                s.wasDragged = true;\n\n                if(s.grabbingBar) { // moving the bar\n                    s.newExtent = [y - s.grabPoint, y + s.barLength - s.grabPoint].map(d.unitToPaddedPx.invert);\n                } else { // south/north drag or new bar creation\n                    s.newExtent = [s.startExtent, d.unitToPaddedPx.invert(y)].sort(sortAsc);\n                }\n\n                // take care of the parcoords axis height constraint: bar can't breach it\n                var bottomViolation = Math.max(0, -s.newExtent[0]);\n                var topViolation = Math.max(0, s.newExtent[1] - 1);\n                s.newExtent[0] += bottomViolation;\n                s.newExtent[1] -= topViolation;\n                if(s.grabbingBar) {\n                    // in case of bar dragging (non-resizing interaction, unlike north/south resize or new bar creation)\n                    // the constraint adjustment must apply to the other end of the bar as well, otherwise it'd\n                    // shorten or lengthen\n                    s.newExtent[1] += bottomViolation;\n                    s.newExtent[0] -= topViolation;\n                }\n\n                d.brush.filterSpecified = true;\n                s.extent = s.stayingIntervals.concat([s.newExtent]);\n                s.brushCallback(d);\n                renderHighlight(this.parentNode);\n            })\n            .on('dragend', function(d) {\n                var e = d3.event;\n                e.sourceEvent.stopPropagation();\n                var brush = d.brush;\n                var filter = brush.filter;\n                var s = brush.svgBrush;\n                var grabbingBar = s.grabbingBar;\n                s.grabbingBar = false;\n                s.grabLocation = undefined;\n                d.parent.inBrushDrag = false;\n                clearCursor(); // instead of clearing, a nicer thing would be to set it according to current location\n                if(!s.wasDragged) { // a click+release on the same spot (ie. w/o dragging) means a bar or full reset\n                    s.wasDragged = undefined; // logic-wise unneeded, just shows `wasDragged` has no longer a meaning\n                    if(s.clickableOrdinalRange) {\n                        if(brush.filterSpecified && d.multiselect) {\n                            s.extent.push(s.clickableOrdinalRange);\n                        }\n                        else {\n                            s.extent = [s.clickableOrdinalRange];\n                            brush.filterSpecified = true;\n                        }\n                    }\n                    else if(grabbingBar) {\n                        s.extent = s.stayingIntervals;\n                        if(s.extent.length === 0) {\n                            brushClear(brush);\n                        }\n                    } else {\n                        brushClear(brush);\n                    }\n                    s.brushCallback(d);\n                    renderHighlight(this.parentNode);\n                    s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n                    return; // no need to fuse intervals or snap to ordinals, so we can bail early\n                }\n\n                var mergeIntervals = function() {\n                    // Key piece of logic: once the button is released, possibly overlapping intervals will be fused:\n                    // Here it's done immediately on click release while on ordinal snap transition it's done at the end\n                    filter.set(filter.getConsolidated());\n                };\n\n                if(d.ordinal) {\n                    var a = d.unitTickvals;\n                    if(a[a.length - 1] < a[0]) a.reverse();\n                    s.newExtent = [\n                        ordinalScaleSnapLo(a, s.newExtent[0], s.stayingIntervals),\n                        ordinalScaleSnapHi(a, s.newExtent[1], s.stayingIntervals)\n                    ];\n                    var hasNewExtent = s.newExtent[1] > s.newExtent[0];\n                    s.extent = s.stayingIntervals.concat(hasNewExtent ? [s.newExtent] : []);\n                    if(!s.extent.length) {\n                        brushClear(brush);\n                    }\n                    s.brushCallback(d);\n                    if(hasNewExtent) {\n                        // merging intervals post the snap tween\n                        renderHighlight(this.parentNode, mergeIntervals);\n                    }\n                    else {\n                        // if no new interval, don't animate, just redraw the highlight immediately\n                        mergeIntervals();\n                        renderHighlight(this.parentNode);\n                    }\n                } else {\n                    mergeIntervals(); // merging intervals immediately\n                }\n                s.brushEndCallback(brush.filterSpecified ? filter.getConsolidated() : []);\n            })\n        );\n}\n\nfunction startAsc(a, b) { return a[0] - b[0]; }\n\nfunction renderAxisBrush(axisBrush) {\n\n    var background = axisBrush.selectAll('.background').data(repeat);\n\n    background.enter()\n        .append('rect')\n        .classed('background', true)\n        .call(barHorizontalSetup)\n        .call(backgroundBarHorizontalSetup)\n        .style('pointer-events', 'auto') // parent pointer events are disabled; we must have it to register events\n        .attr('transform', 'translate(0 ' + c.verticalPadding + ')');\n\n    background\n        .call(attachDragBehavior)\n        .attr('height', function(d) {\n            return d.height - c.verticalPadding;\n        });\n\n    var highlightShadow = axisBrush.selectAll('.highlight-shadow').data(repeat); // we have a set here, can't call it `extent`\n\n    highlightShadow.enter()\n        .append('line')\n        .classed('highlight-shadow', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width + c.bar.strokeWidth)\n        .attr('stroke', c.bar.strokeColor)\n        .attr('opacity', c.bar.strokeOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlightShadow\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n\n    var highlight = axisBrush.selectAll('.highlight').data(repeat); // we have a set here, can't call it `extent`\n\n    highlight.enter()\n        .append('line')\n        .classed('highlight', true)\n        .attr('x', -c.bar.width / 2)\n        .attr('stroke-width', c.bar.width - c.bar.strokeWidth)\n        .attr('stroke', c.bar.fillColor)\n        .attr('opacity', c.bar.fillOpacity)\n        .attr('stroke-linecap', 'butt');\n\n    highlight\n        .attr('y1', function(d) { return d.height; })\n        .call(styleHighlight);\n}\n\nfunction ensureAxisBrush(axisOverlays) {\n    var axisBrush = axisOverlays.selectAll('.' + c.cn.axisBrush)\n        .data(repeat, keyFun);\n\n    axisBrush.enter()\n        .append('g')\n        .classed(c.cn.axisBrush, true);\n\n    renderAxisBrush(axisBrush);\n}\n\nfunction getBrushExtent(brush) {\n    return brush.svgBrush.extent.map(function(e) {return e.slice();});\n}\n\nfunction brushClear(brush) {\n    brush.filterSpecified = false;\n    brush.svgBrush.extent = [[0, 1]];\n}\n\nfunction axisBrushMoved(callback) {\n    return function axisBrushMoved(dimension) {\n        var brush = dimension.brush;\n        var extent = getBrushExtent(brush);\n        var newExtent = extent.slice();\n        brush.filter.set(newExtent);\n        callback();\n    };\n}\n\nfunction dedupeRealRanges(intervals) {\n    // Fuses elements of intervals if they overlap, yielding discontiguous intervals, results.length <= intervals.length\n    // Currently uses closed intervals, ie. dedupeRealRanges([[400, 800], [300, 400]]) -> [300, 800]\n    var queue = intervals.slice();\n    var result = [];\n    var currentInterval;\n    var current = queue.shift();\n    while(current) { // [].shift === undefined, so we don't descend into an empty array\n        currentInterval = current.slice();\n        while((current = queue.shift()) && current[0] <= /* right-open interval would need `<` */ currentInterval[1]) {\n            currentInterval[1] = Math.max(currentInterval[1], current[1]);\n        }\n        result.push(currentInterval);\n    }\n    return result;\n}\n\nfunction makeFilter() {\n    var filter = [];\n    var consolidated;\n    var bounds;\n    return {\n        set: function(a) {\n            filter = a\n                .map(function(d) { return d.slice().sort(sortAsc); })\n                .sort(startAsc);\n            consolidated = dedupeRealRanges(filter);\n            bounds = filter.reduce(function(p, n) {\n                return [Math.min(p[0], n[0]), Math.max(p[1], n[1])];\n            }, [Infinity, -Infinity]);\n        },\n        get: function() { return filter.slice(); },\n        getConsolidated: function() { return consolidated; },\n        getBounds: function() { return bounds; }\n    };\n}\n\nfunction makeBrush(state, rangeSpecified, initialRange, brushStartCallback, brushCallback, brushEndCallback) {\n    var filter = makeFilter();\n    filter.set(initialRange);\n    return {\n        filter: filter,\n        filterSpecified: rangeSpecified, // there's a difference between not filtering and filtering a non-proper subset\n        svgBrush: {\n            extent: [], // this is where the svgBrush writes contents into\n            brushStartCallback: brushStartCallback,\n            brushCallback: axisBrushMoved(brushCallback),\n            brushEndCallback: brushEndCallback\n        }\n    };\n}\n\n// for use by supplyDefaults, but it needed tons of pieces from here so\n// seemed to make more sense just to put the whole routine here\nfunction cleanRanges(ranges, dimension) {\n    if(Array.isArray(ranges[0])) {\n        ranges = ranges.map(function(ri) { return ri.sort(sortAsc); });\n\n        if(!dimension.multiselect) ranges = [ranges[0]];\n        else ranges = dedupeRealRanges(ranges.sort(startAsc));\n    }\n    else ranges = [ranges.sort(sortAsc)];\n\n    // ordinal snapping\n    if(dimension.tickvals) {\n        var sortedTickVals = dimension.tickvals.slice().sort(sortAsc);\n        ranges = ranges.map(function(ri) {\n            var rSnapped = [\n                ordinalScaleSnapLo(sortedTickVals, ri[0], []),\n                ordinalScaleSnapHi(sortedTickVals, ri[1], [])\n            ];\n            if(rSnapped[1] > rSnapped[0]) return rSnapped;\n        })\n        .filter(function(ri) { return ri; });\n\n        if(!ranges.length) return;\n    }\n    return ranges.length > 1 ? ranges : ranges[0];\n}\n\nmodule.exports = {\n    makeBrush: makeBrush,\n    ensureAxisBrush: ensureAxisBrush,\n    cleanRanges: cleanRanges\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}