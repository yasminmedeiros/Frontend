{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\nexports.moduleType = 'transform';\nexports.name = 'sort';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether this sort transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the target by which the sort transform is applied.', 'If a string, *target* is assumed to be a reference to a data array', 'in the parent trace object.', 'To sort about nested variables, use *.* to access them.', 'For example, set `target` to *marker.size* to sort', 'about the marker size array.', 'If an array, *target* is then the data array by which', 'the sort transform is applied.'].join(' ')\n  },\n  order: {\n    valType: 'enumerated',\n    values: ['ascending', 'descending'],\n    dflt: 'ascending',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the sort transform order.'].join(' ')\n  },\n  editType: 'calc'\n};\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n  var enabled = coerce('enabled');\n  if (enabled) {\n    coerce('target');\n    coerce('order');\n  }\n  return transformOut;\n};\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var arrayAttrs = trace._arrayAttrs;\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var indices = getIndices(opts, targetArray, d2c, len);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n  var indexToPoints = {};\n  var i, j;\n  for (i = 0; i < arrayAttrs.length; i++) {\n    var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n    var arrayOld = np.get();\n    var arrayNew = new Array(len);\n    for (j = 0; j < len; j++) {\n      arrayNew[j] = arrayOld[indices[j]];\n    }\n    np.set(arrayNew);\n  }\n  for (j = 0; j < len; j++) {\n    indexToPoints[j] = originalPointsAccessor(indices[j]);\n  }\n  opts._indexToPoints = indexToPoints;\n  trace._length = len;\n};\nfunction getIndices(opts, targetArray, d2c, len) {\n  var sortedArray = new Array(len);\n  var indices = new Array(len);\n  var i;\n  for (i = 0; i < len; i++) {\n    sortedArray[i] = {\n      v: targetArray[i],\n      i: i\n    };\n  }\n  sortedArray.sort(getSortFunc(opts, d2c));\n  for (i = 0; i < len; i++) {\n    indices[i] = sortedArray[i].i;\n  }\n  return indices;\n}\nfunction getSortFunc(opts, d2c) {\n  switch (opts.order) {\n    case 'ascending':\n      return function (a, b) {\n        return d2c(a.v) - d2c(b.v);\n      };\n    case 'descending':\n      return function (a, b) {\n        return d2c(b.v) - d2c(a.v);\n      };\n  }\n}","map":{"version":3,"names":["Lib","require","Axes","pointsAccessorFunction","exports","moduleType","name","attributes","enabled","valType","dflt","role","editType","description","join","target","strict","noBlank","arrayOk","order","values","supplyDefaults","transformIn","transformOut","coerce","attr","calcTransform","gd","trace","opts","targetArray","getTargetArray","len","length","_length","Math","min","arrayAttrs","_arrayAttrs","d2c","getDataToCoordFunc","indices","getIndices","originalPointsAccessor","transforms","indexToPoints","i","j","np","nestedProperty","arrayOld","get","arrayNew","Array","set","_indexToPoints","sortedArray","v","sort","getSortFunc","a","b"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/transforms/sort.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nexports.moduleType = 'transform';\n\nexports.name = 'sort';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Determines whether this sort transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the target by which the sort transform is applied.',\n\n            'If a string, *target* is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To sort about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.size* to sort',\n            'about the marker size array.',\n\n            'If an array, *target* is then the data array by which',\n            'the sort transform is applied.'\n        ].join(' ')\n    },\n    order: {\n        valType: 'enumerated',\n        values: ['ascending', 'descending'],\n        dflt: 'ascending',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the sort transform order.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        coerce('target');\n        coerce('order');\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var arrayAttrs = trace._arrayAttrs;\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var indices = getIndices(opts, targetArray, d2c, len);\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n    var indexToPoints = {};\n    var i, j;\n\n    for(i = 0; i < arrayAttrs.length; i++) {\n        var np = Lib.nestedProperty(trace, arrayAttrs[i]);\n        var arrayOld = np.get();\n        var arrayNew = new Array(len);\n\n        for(j = 0; j < len; j++) {\n            arrayNew[j] = arrayOld[indices[j]];\n        }\n\n        np.set(arrayNew);\n    }\n\n    for(j = 0; j < len; j++) {\n        indexToPoints[j] = originalPointsAccessor(indices[j]);\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = len;\n};\n\nfunction getIndices(opts, targetArray, d2c, len) {\n    var sortedArray = new Array(len);\n    var indices = new Array(len);\n    var i;\n\n    for(i = 0; i < len; i++) {\n        sortedArray[i] = {v: targetArray[i], i: i};\n    }\n\n    sortedArray.sort(getSortFunc(opts, d2c));\n\n    for(i = 0; i < len; i++) {\n        indices[i] = sortedArray[i].i;\n    }\n\n    return indices;\n}\n\nfunction getSortFunc(opts, d2c) {\n    switch(opts.order) {\n        case 'ascending':\n            return function(a, b) { return d2c(a.v) - d2c(b.v); };\n        case 'descending':\n            return function(a, b) { return d2c(b.v) - d2c(a.v); };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}