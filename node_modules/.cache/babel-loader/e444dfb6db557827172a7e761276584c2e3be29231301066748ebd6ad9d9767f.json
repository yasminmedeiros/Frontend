{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\nvar zoomstartStyle = {\n  cursor: 'pointer'\n};\nvar zoomendStyle = {\n  cursor: 'auto'\n};\nfunction createGeoZoom(geo, geoLayout) {\n  var projection = geo.projection;\n  var zoomConstructor;\n  if (geoLayout._isScoped) {\n    zoomConstructor = zoomScoped;\n  } else if (geoLayout._isClipped) {\n    zoomConstructor = zoomClipped;\n  } else {\n    zoomConstructor = zoomNonClipped;\n  }\n\n  // TODO add a conic-specific zoom\n\n  return zoomConstructor(geo, projection);\n}\nmodule.exports = createGeoZoom;\n\n// common to all zoom types\nfunction initZoom(geo, projection) {\n  return d3.behavior.zoom().translate(projection.translate()).scale(projection.scale());\n}\n\n// sync zoom updates with user & full layout\nfunction sync(geo, projection, cb) {\n  var id = geo.id;\n  var gd = geo.graphDiv;\n  var layout = gd.layout;\n  var userOpts = layout[id];\n  var fullLayout = gd._fullLayout;\n  var fullOpts = fullLayout[id];\n  var preGUI = {};\n  var eventData = {};\n  function set(propStr, val) {\n    preGUI[id + '.' + propStr] = Lib.nestedProperty(userOpts, propStr).get();\n    Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);\n    var fullNp = Lib.nestedProperty(fullOpts, propStr);\n    if (fullNp.get() !== val) {\n      fullNp.set(val);\n      Lib.nestedProperty(userOpts, propStr).set(val);\n      eventData[id + '.' + propStr] = val;\n    }\n  }\n  cb(set);\n  set('projection.scale', projection.scale() / geo.fitScale);\n  gd.emit('plotly_relayout', eventData);\n}\n\n// zoom for scoped projections\nfunction zoomScoped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n  }\n  function handleZoom() {\n    projection.scale(d3.event.scale).translate(d3.event.translate);\n    geo.render();\n  }\n  function syncCb(set) {\n    var center = projection.invert(geo.midPt);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    sync(geo, projection, syncCb);\n  }\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n}\n\n// zoom for non-clipped projections\nfunction zoomNonClipped(geo, projection) {\n  var zoom = initZoom(geo, projection);\n  var INSIDETOLORANCEPXS = 2;\n  var mouse0, rotate0, translate0, lastRotate, zoomPoint, mouse1, rotate1, point1, didZoom;\n  function position(x) {\n    return projection.invert(x);\n  }\n  function outside(x) {\n    var pos = position(x);\n    if (!pos) return true;\n    var pt = projection(pos);\n    return Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS || Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS;\n  }\n  function handleZoomstart() {\n    d3.select(this).style(zoomstartStyle);\n    mouse0 = d3.mouse(this);\n    rotate0 = projection.rotate();\n    translate0 = projection.translate();\n    lastRotate = rotate0;\n    zoomPoint = position(mouse0);\n  }\n  function handleZoom() {\n    mouse1 = d3.mouse(this);\n    if (outside(mouse0)) {\n      zoom.scale(projection.scale());\n      zoom.translate(projection.translate());\n      return;\n    }\n    projection.scale(d3.event.scale);\n    projection.translate([translate0[0], d3.event.translate[1]]);\n    if (!zoomPoint) {\n      mouse0 = mouse1;\n      zoomPoint = position(mouse0);\n    } else if (position(mouse1)) {\n      point1 = position(mouse1);\n      rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n      projection.rotate(rotate1);\n      lastRotate = rotate1;\n    }\n    didZoom = true;\n    geo.render();\n  }\n  function handleZoomend() {\n    d3.select(this).style(zoomendStyle);\n    if (didZoom) sync(geo, projection, syncCb);\n  }\n  function syncCb(set) {\n    var rotate = projection.rotate();\n    var center = projection.invert(geo.midPt);\n    set('projection.rotation.lon', -rotate[0]);\n    set('center.lon', center[0]);\n    set('center.lat', center[1]);\n  }\n  zoom.on('zoomstart', handleZoomstart).on('zoom', handleZoom).on('zoomend', handleZoomend);\n  return zoom;\n}\n\n// zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\nfunction zoomClipped(geo, projection) {\n  var view = {\n    r: projection.rotate(),\n    k: projection.scale()\n  };\n  var zoom = initZoom(geo, projection);\n  var event = d3eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend');\n  var zooming = 0;\n  var zoomOn = zoom.on;\n  var zoomPoint;\n  zoom.on('zoomstart', function () {\n    d3.select(this).style(zoomstartStyle);\n    var mouse0 = d3.mouse(this);\n    var rotate0 = projection.rotate();\n    var lastRotate = rotate0;\n    var translate0 = projection.translate();\n    var q = quaternionFromEuler(rotate0);\n    zoomPoint = position(projection, mouse0);\n    zoomOn.call(zoom, 'zoom', function () {\n      var mouse1 = d3.mouse(this);\n      projection.scale(view.k = d3.event.scale);\n      if (!zoomPoint) {\n        // if no zoomPoint, the mouse wasn't over the actual geography yet\n        // maybe this point is the start... we'll find out next time!\n        mouse0 = mouse1;\n        zoomPoint = position(projection, mouse0);\n      }\n      // check if the point is on the map\n      // if not, don't do anything new but scale\n      // if it is, then we can assume between will exist below\n      // so we don't need the 'bank' function, whatever that is.\n      else if (position(projection, mouse1)) {\n        // go back to original projection temporarily\n        // except for scale... that's kind of independent?\n        projection.rotate(rotate0).translate(translate0);\n\n        // calculate the new params\n        var point1 = position(projection, mouse1);\n        var between = rotateBetween(zoomPoint, point1);\n        var newEuler = eulerFromQuaternion(multiply(q, between));\n        var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n        if (!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) || !isFinite(rotateAngles[2])) {\n          rotateAngles = lastRotate;\n        }\n\n        // update the projection\n        projection.rotate(rotateAngles);\n        lastRotate = rotateAngles;\n      }\n      zoomed(event.of(this, arguments));\n    });\n    zoomstarted(event.of(this, arguments));\n  }).on('zoomend', function () {\n    d3.select(this).style(zoomendStyle);\n    zoomOn.call(zoom, 'zoom', null);\n    zoomended(event.of(this, arguments));\n    sync(geo, projection, syncCb);\n  }).on('zoom.redraw', function () {\n    geo.render();\n  });\n  function zoomstarted(dispatch) {\n    if (!zooming++) dispatch({\n      type: 'zoomstart'\n    });\n  }\n  function zoomed(dispatch) {\n    dispatch({\n      type: 'zoom'\n    });\n  }\n  function zoomended(dispatch) {\n    if (! --zooming) dispatch({\n      type: 'zoomend'\n    });\n  }\n  function syncCb(set) {\n    var _rotate = projection.rotate();\n    set('projection.rotation.lon', -_rotate[0]);\n    set('projection.rotation.lat', -_rotate[1]);\n  }\n  return d3.rebind(zoom, event, 'on');\n}\n\n// -- helper functions for zoomClipped\n\nfunction position(projection, point) {\n  var spherical = projection.invert(point);\n  return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\nfunction quaternionFromEuler(euler) {\n  var lambda = 0.5 * euler[0] * radians;\n  var phi = 0.5 * euler[1] * radians;\n  var gamma = 0.5 * euler[2] * radians;\n  var sinLambda = Math.sin(lambda);\n  var cosLambda = Math.cos(lambda);\n  var sinPhi = Math.sin(phi);\n  var cosPhi = Math.cos(phi);\n  var sinGamma = Math.sin(gamma);\n  var cosGamma = Math.cos(gamma);\n  return [cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma, sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma, cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma, cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma];\n}\nfunction multiply(a, b) {\n  var a0 = a[0];\n  var a1 = a[1];\n  var a2 = a[2];\n  var a3 = a[3];\n  var b0 = b[0];\n  var b1 = b[1];\n  var b2 = b[2];\n  var b3 = b[3];\n  return [a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3, a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2, a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1, a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0];\n}\nfunction rotateBetween(a, b) {\n  if (!a || !b) return;\n  var axis = cross(a, b);\n  var norm = Math.sqrt(dot(axis, axis));\n  var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));\n  var k = Math.sin(halfgamma) / norm;\n  return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n}\n\n// input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\nfunction unRoll(rotateAngles, pt, lastRotate) {\n  // calculate the fixed point transformed by these Euler angles\n  // but with the desired roll undone\n  var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n  ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n  ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n  var x = pt[0];\n  var y = pt[1];\n  var z = pt[2];\n  var f = ptRotated[0];\n  var g = ptRotated[1];\n  var h = ptRotated[2];\n\n  // the following essentially solves:\n  // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n  // for newYaw and newPitch, as best it can\n  var theta = Math.atan2(y, x) * degrees;\n  var a = Math.sqrt(x * x + y * y);\n  var b;\n  var newYaw1;\n  if (Math.abs(g) > a) {\n    newYaw1 = (g > 0 ? 90 : -90) - theta;\n    b = 0;\n  } else {\n    newYaw1 = Math.asin(g / a) * degrees - theta;\n    b = Math.sqrt(a * a - g * g);\n  }\n  var newYaw2 = 180 - newYaw1 - 2 * theta;\n  var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;\n  var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees;\n\n  // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n  var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);\n  var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n  if (dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];else return [newYaw2, newPitch2, lastRotate[2]];\n}\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n  var dYaw = angleMod(yaw1 - yaw0);\n  var dPitch = angleMod(pitch1 - pitch0);\n  return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n}\n\n// reduce an angle in degrees to [-180,180]\nfunction angleMod(angle) {\n  return (angle % 360 + 540) % 360 - 180;\n}\n\n// rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\nfunction rotateCartesian(vector, axis, angle) {\n  var angleRads = angle * radians;\n  var vectorOut = vector.slice();\n  var ax1 = axis === 0 ? 1 : 0;\n  var ax2 = axis === 2 ? 1 : 2;\n  var cosa = Math.cos(angleRads);\n  var sina = Math.sin(angleRads);\n  vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n  vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n  return vectorOut;\n}\nfunction eulerFromQuaternion(q) {\n  return [Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees, Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees, Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees];\n}\nfunction cartesian(spherical) {\n  var lambda = spherical[0] * radians;\n  var phi = spherical[1] * radians;\n  var cosPhi = Math.cos(phi);\n  return [cosPhi * Math.cos(lambda), cosPhi * Math.sin(lambda), Math.sin(phi)];\n}\nfunction dot(a, b) {\n  var s = 0;\n  for (var i = 0, n = a.length; i < n; ++i) {\n    s += a[i] * b[i];\n  }\n  return s;\n}\nfunction cross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3eventDispatch(target) {\n  var i = 0;\n  var n = arguments.length;\n  var argumentz = [];\n  while (++i < n) {\n    argumentz.push(arguments[i]);\n  }\n  var dispatch = d3.dispatch.apply(null, argumentz);\n\n  // Creates a dispatch context for the specified `thiz` (typically, the target\n  // DOM element that received the source event) and `argumentz` (typically, the\n  // data `d` and index `i` of the target element). The returned function can be\n  // used to dispatch an event to any registered listeners; the function takes a\n  // single argument as input, being the event to dispatch. The event must have\n  // a \"type\" attribute which corresponds to a type registered in the\n  // constructor. This context will automatically populate the \"sourceEvent\" and\n  // \"target\" attributes of the event, as well as setting the `d3.event` global\n  // for the duration of the notification.\n  dispatch.of = function (thiz, argumentz) {\n    return function (e1) {\n      var e0;\n      try {\n        e0 = e1.sourceEvent = d3.event;\n        e1.target = target;\n        d3.event = e1;\n        dispatch[e1.type].apply(thiz, argumentz);\n      } finally {\n        d3.event = e0;\n      }\n    };\n  };\n  return dispatch;\n}","map":{"version":3,"names":["d3","require","Lib","Registry","radians","Math","PI","degrees","zoomstartStyle","cursor","zoomendStyle","createGeoZoom","geo","geoLayout","projection","zoomConstructor","_isScoped","zoomScoped","_isClipped","zoomClipped","zoomNonClipped","module","exports","initZoom","behavior","zoom","translate","scale","sync","cb","id","gd","graphDiv","layout","userOpts","fullLayout","_fullLayout","fullOpts","preGUI","eventData","set","propStr","val","nestedProperty","get","call","_preGUI","fullNp","fitScale","emit","handleZoomstart","select","style","handleZoom","event","render","syncCb","center","invert","midPt","handleZoomend","on","INSIDETOLORANCEPXS","mouse0","rotate0","translate0","lastRotate","zoomPoint","mouse1","rotate1","point1","didZoom","position","x","outside","pos","pt","abs","mouse","rotate","view","r","k","d3eventDispatch","zooming","zoomOn","q","quaternionFromEuler","between","rotateBetween","newEuler","eulerFromQuaternion","multiply","rotateAngles","unRoll","isFinite","zoomed","of","arguments","zoomstarted","zoomended","dispatch","type","_rotate","rebind","point","spherical","cartesian","euler","lambda","phi","gamma","sinLambda","sin","cosLambda","cos","sinPhi","cosPhi","sinGamma","cosGamma","a","b","a0","a1","a2","a3","b0","b1","b2","b3","axis","cross","norm","sqrt","dot","halfgamma","acos","max","min","ptRotated","rotateCartesian","y","z","f","g","h","theta","atan2","newYaw1","asin","newYaw2","newPitch1","newPitch2","dist1","angleDistance","dist2","yaw0","pitch0","yaw1","pitch1","dYaw","angleMod","dPitch","angle","vector","angleRads","vectorOut","slice","ax1","ax2","cosa","sina","s","i","n","length","target","argumentz","push","apply","thiz","e1","e0","sourceEvent"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/plots/geo/zoom.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\n\nvar radians = Math.PI / 180;\nvar degrees = 180 / Math.PI;\nvar zoomstartStyle = {cursor: 'pointer'};\nvar zoomendStyle = {cursor: 'auto'};\n\nfunction createGeoZoom(geo, geoLayout) {\n    var projection = geo.projection;\n    var zoomConstructor;\n\n    if(geoLayout._isScoped) {\n        zoomConstructor = zoomScoped;\n    } else if(geoLayout._isClipped) {\n        zoomConstructor = zoomClipped;\n    } else {\n        zoomConstructor = zoomNonClipped;\n    }\n\n    // TODO add a conic-specific zoom\n\n    return zoomConstructor(geo, projection);\n}\n\nmodule.exports = createGeoZoom;\n\n// common to all zoom types\nfunction initZoom(geo, projection) {\n    return d3.behavior.zoom()\n        .translate(projection.translate())\n        .scale(projection.scale());\n}\n\n// sync zoom updates with user & full layout\nfunction sync(geo, projection, cb) {\n    var id = geo.id;\n    var gd = geo.graphDiv;\n    var layout = gd.layout;\n    var userOpts = layout[id];\n    var fullLayout = gd._fullLayout;\n    var fullOpts = fullLayout[id];\n\n    var preGUI = {};\n    var eventData = {};\n\n    function set(propStr, val) {\n        preGUI[id + '.' + propStr] = Lib.nestedProperty(userOpts, propStr).get();\n        Registry.call('_storeDirectGUIEdit', layout, fullLayout._preGUI, preGUI);\n\n        var fullNp = Lib.nestedProperty(fullOpts, propStr);\n        if(fullNp.get() !== val) {\n            fullNp.set(val);\n            Lib.nestedProperty(userOpts, propStr).set(val);\n            eventData[id + '.' + propStr] = val;\n        }\n    }\n\n    cb(set);\n    set('projection.scale', projection.scale() / geo.fitScale);\n    gd.emit('plotly_relayout', eventData);\n}\n\n// zoom for scoped projections\nfunction zoomScoped(geo, projection) {\n    var zoom = initZoom(geo, projection);\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n    }\n\n    function handleZoom() {\n        projection\n            .scale(d3.event.scale)\n            .translate(d3.event.translate);\n        geo.render();\n    }\n\n    function syncCb(set) {\n        var center = projection.invert(geo.midPt);\n\n        set('center.lon', center[0]);\n        set('center.lat', center[1]);\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n        sync(geo, projection, syncCb);\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for non-clipped projections\nfunction zoomNonClipped(geo, projection) {\n    var zoom = initZoom(geo, projection);\n\n    var INSIDETOLORANCEPXS = 2;\n\n    var mouse0, rotate0, translate0, lastRotate, zoomPoint,\n        mouse1, rotate1, point1, didZoom;\n\n    function position(x) { return projection.invert(x); }\n\n    function outside(x) {\n        var pos = position(x);\n        if(!pos) return true;\n\n        var pt = projection(pos);\n        return (\n            Math.abs(pt[0] - x[0]) > INSIDETOLORANCEPXS ||\n            Math.abs(pt[1] - x[1]) > INSIDETOLORANCEPXS\n        );\n    }\n\n    function handleZoomstart() {\n        d3.select(this).style(zoomstartStyle);\n\n        mouse0 = d3.mouse(this);\n        rotate0 = projection.rotate();\n        translate0 = projection.translate();\n        lastRotate = rotate0;\n        zoomPoint = position(mouse0);\n    }\n\n    function handleZoom() {\n        mouse1 = d3.mouse(this);\n\n        if(outside(mouse0)) {\n            zoom.scale(projection.scale());\n            zoom.translate(projection.translate());\n            return;\n        }\n\n        projection.scale(d3.event.scale);\n        projection.translate([translate0[0], d3.event.translate[1]]);\n\n        if(!zoomPoint) {\n            mouse0 = mouse1;\n            zoomPoint = position(mouse0);\n        }\n        else if(position(mouse1)) {\n            point1 = position(mouse1);\n            rotate1 = [lastRotate[0] + (point1[0] - zoomPoint[0]), rotate0[1], rotate0[2]];\n            projection.rotate(rotate1);\n            lastRotate = rotate1;\n        }\n\n        didZoom = true;\n        geo.render();\n    }\n\n    function handleZoomend() {\n        d3.select(this).style(zoomendStyle);\n        if(didZoom) sync(geo, projection, syncCb);\n    }\n\n    function syncCb(set) {\n        var rotate = projection.rotate();\n        var center = projection.invert(geo.midPt);\n\n        set('projection.rotation.lon', -rotate[0]);\n        set('center.lon', center[0]);\n        set('center.lat', center[1]);\n    }\n\n    zoom\n        .on('zoomstart', handleZoomstart)\n        .on('zoom', handleZoom)\n        .on('zoomend', handleZoomend);\n\n    return zoom;\n}\n\n// zoom for clipped projections\n// inspired by https://www.jasondavies.com/maps/d3.geo.zoom.js\nfunction zoomClipped(geo, projection) {\n    var view = {r: projection.rotate(), k: projection.scale()};\n    var zoom = initZoom(geo, projection);\n    var event = d3eventDispatch(zoom, 'zoomstart', 'zoom', 'zoomend');\n    var zooming = 0;\n    var zoomOn = zoom.on;\n\n    var zoomPoint;\n\n    zoom.on('zoomstart', function() {\n        d3.select(this).style(zoomstartStyle);\n\n        var mouse0 = d3.mouse(this);\n        var rotate0 = projection.rotate();\n        var lastRotate = rotate0;\n        var translate0 = projection.translate();\n        var q = quaternionFromEuler(rotate0);\n\n        zoomPoint = position(projection, mouse0);\n\n        zoomOn.call(zoom, 'zoom', function() {\n            var mouse1 = d3.mouse(this);\n\n            projection.scale(view.k = d3.event.scale);\n\n            if(!zoomPoint) {\n                // if no zoomPoint, the mouse wasn't over the actual geography yet\n                // maybe this point is the start... we'll find out next time!\n                mouse0 = mouse1;\n                zoomPoint = position(projection, mouse0);\n            }\n            // check if the point is on the map\n            // if not, don't do anything new but scale\n            // if it is, then we can assume between will exist below\n            // so we don't need the 'bank' function, whatever that is.\n            else if(position(projection, mouse1)) {\n                // go back to original projection temporarily\n                // except for scale... that's kind of independent?\n                projection\n                    .rotate(rotate0)\n                    .translate(translate0);\n\n                // calculate the new params\n                var point1 = position(projection, mouse1);\n                var between = rotateBetween(zoomPoint, point1);\n                var newEuler = eulerFromQuaternion(multiply(q, between));\n                var rotateAngles = view.r = unRoll(newEuler, zoomPoint, lastRotate);\n\n                if(!isFinite(rotateAngles[0]) || !isFinite(rotateAngles[1]) ||\n                   !isFinite(rotateAngles[2])) {\n                    rotateAngles = lastRotate;\n                }\n\n                // update the projection\n                projection.rotate(rotateAngles);\n                lastRotate = rotateAngles;\n            }\n\n            zoomed(event.of(this, arguments));\n        });\n\n        zoomstarted(event.of(this, arguments));\n    })\n    .on('zoomend', function() {\n        d3.select(this).style(zoomendStyle);\n        zoomOn.call(zoom, 'zoom', null);\n        zoomended(event.of(this, arguments));\n        sync(geo, projection, syncCb);\n    })\n    .on('zoom.redraw', function() {\n        geo.render();\n    });\n\n    function zoomstarted(dispatch) {\n        if(!zooming++) dispatch({type: 'zoomstart'});\n    }\n\n    function zoomed(dispatch) {\n        dispatch({type: 'zoom'});\n    }\n\n    function zoomended(dispatch) {\n        if(!--zooming) dispatch({type: 'zoomend'});\n    }\n\n    function syncCb(set) {\n        var _rotate = projection.rotate();\n        set('projection.rotation.lon', -_rotate[0]);\n        set('projection.rotation.lat', -_rotate[1]);\n    }\n\n    return d3.rebind(zoom, event, 'on');\n}\n\n// -- helper functions for zoomClipped\n\nfunction position(projection, point) {\n    var spherical = projection.invert(point);\n    return spherical && isFinite(spherical[0]) && isFinite(spherical[1]) && cartesian(spherical);\n}\n\nfunction quaternionFromEuler(euler) {\n    var lambda = 0.5 * euler[0] * radians;\n    var phi = 0.5 * euler[1] * radians;\n    var gamma = 0.5 * euler[2] * radians;\n    var sinLambda = Math.sin(lambda);\n    var cosLambda = Math.cos(lambda);\n    var sinPhi = Math.sin(phi);\n    var cosPhi = Math.cos(phi);\n    var sinGamma = Math.sin(gamma);\n    var cosGamma = Math.cos(gamma);\n    return [\n        cosLambda * cosPhi * cosGamma + sinLambda * sinPhi * sinGamma,\n        sinLambda * cosPhi * cosGamma - cosLambda * sinPhi * sinGamma,\n        cosLambda * sinPhi * cosGamma + sinLambda * cosPhi * sinGamma,\n        cosLambda * cosPhi * sinGamma - sinLambda * sinPhi * cosGamma\n    ];\n}\n\nfunction multiply(a, b) {\n    var a0 = a[0];\n    var a1 = a[1];\n    var a2 = a[2];\n    var a3 = a[3];\n    var b0 = b[0];\n    var b1 = b[1];\n    var b2 = b[2];\n    var b3 = b[3];\n    return [\n        a0 * b0 - a1 * b1 - a2 * b2 - a3 * b3,\n        a0 * b1 + a1 * b0 + a2 * b3 - a3 * b2,\n        a0 * b2 - a1 * b3 + a2 * b0 + a3 * b1,\n        a0 * b3 + a1 * b2 - a2 * b1 + a3 * b0\n    ];\n}\n\nfunction rotateBetween(a, b) {\n    if(!a || !b) return;\n    var axis = cross(a, b);\n    var norm = Math.sqrt(dot(axis, axis));\n    var halfgamma = 0.5 * Math.acos(Math.max(-1, Math.min(1, dot(a, b))));\n    var k = Math.sin(halfgamma) / norm;\n    return norm && [Math.cos(halfgamma), axis[2] * k, -axis[1] * k, axis[0] * k];\n}\n\n// input:\n//   rotateAngles: a calculated set of Euler angles\n//   pt: a point (cartesian in 3-space) to keep fixed\n//   roll0: an initial roll, to be preserved\n// output:\n//   a set of Euler angles that preserve the projection of pt\n//     but set roll (output[2]) equal to roll0\n//     note that this doesn't depend on the particular projection,\n//     just on the rotation angles\nfunction unRoll(rotateAngles, pt, lastRotate) {\n    // calculate the fixed point transformed by these Euler angles\n    // but with the desired roll undone\n    var ptRotated = rotateCartesian(pt, 2, rotateAngles[0]);\n    ptRotated = rotateCartesian(ptRotated, 1, rotateAngles[1]);\n    ptRotated = rotateCartesian(ptRotated, 0, rotateAngles[2] - lastRotate[2]);\n\n    var x = pt[0];\n    var y = pt[1];\n    var z = pt[2];\n    var f = ptRotated[0];\n    var g = ptRotated[1];\n    var h = ptRotated[2];\n\n    // the following essentially solves:\n    // ptRotated = rotateCartesian(rotateCartesian(pt, 2, newYaw), 1, newPitch)\n    // for newYaw and newPitch, as best it can\n    var theta = Math.atan2(y, x) * degrees;\n    var a = Math.sqrt(x * x + y * y);\n    var b;\n    var newYaw1;\n\n    if(Math.abs(g) > a) {\n        newYaw1 = (g > 0 ? 90 : -90) - theta;\n        b = 0;\n    } else {\n        newYaw1 = Math.asin(g / a) * degrees - theta;\n        b = Math.sqrt(a * a - g * g);\n    }\n\n    var newYaw2 = 180 - newYaw1 - 2 * theta;\n    var newPitch1 = (Math.atan2(h, f) - Math.atan2(z, b)) * degrees;\n    var newPitch2 = (Math.atan2(h, f) - Math.atan2(z, -b)) * degrees;\n\n    // which is closest to lastRotate[0,1]: newYaw/Pitch or newYaw2/Pitch2?\n    var dist1 = angleDistance(lastRotate[0], lastRotate[1], newYaw1, newPitch1);\n    var dist2 = angleDistance(lastRotate[0], lastRotate[1], newYaw2, newPitch2);\n\n    if(dist1 <= dist2) return [newYaw1, newPitch1, lastRotate[2]];\n    else return [newYaw2, newPitch2, lastRotate[2]];\n}\n\nfunction angleDistance(yaw0, pitch0, yaw1, pitch1) {\n    var dYaw = angleMod(yaw1 - yaw0);\n    var dPitch = angleMod(pitch1 - pitch0);\n    return Math.sqrt(dYaw * dYaw + dPitch * dPitch);\n}\n\n// reduce an angle in degrees to [-180,180]\nfunction angleMod(angle) {\n    return (angle % 360 + 540) % 360 - 180;\n}\n\n// rotate a cartesian vector\n// axis is 0 (x), 1 (y), or 2 (z)\n// angle is in degrees\nfunction rotateCartesian(vector, axis, angle) {\n    var angleRads = angle * radians;\n    var vectorOut = vector.slice();\n    var ax1 = (axis === 0) ? 1 : 0;\n    var ax2 = (axis === 2) ? 1 : 2;\n    var cosa = Math.cos(angleRads);\n    var sina = Math.sin(angleRads);\n\n    vectorOut[ax1] = vector[ax1] * cosa - vector[ax2] * sina;\n    vectorOut[ax2] = vector[ax2] * cosa + vector[ax1] * sina;\n\n    return vectorOut;\n}\nfunction eulerFromQuaternion(q) {\n    return [\n        Math.atan2(2 * (q[0] * q[1] + q[2] * q[3]), 1 - 2 * (q[1] * q[1] + q[2] * q[2])) * degrees,\n        Math.asin(Math.max(-1, Math.min(1, 2 * (q[0] * q[2] - q[3] * q[1])))) * degrees,\n        Math.atan2(2 * (q[0] * q[3] + q[1] * q[2]), 1 - 2 * (q[2] * q[2] + q[3] * q[3])) * degrees\n    ];\n}\n\nfunction cartesian(spherical) {\n    var lambda = spherical[0] * radians;\n    var phi = spherical[1] * radians;\n    var cosPhi = Math.cos(phi);\n    return [\n        cosPhi * Math.cos(lambda),\n        cosPhi * Math.sin(lambda),\n        Math.sin(phi)\n    ];\n}\n\nfunction dot(a, b) {\n    var s = 0;\n    for(var i = 0, n = a.length; i < n; ++i) s += a[i] * b[i];\n    return s;\n}\n\nfunction cross(a, b) {\n    return [\n        a[1] * b[2] - a[2] * b[1],\n        a[2] * b[0] - a[0] * b[2],\n        a[0] * b[1] - a[1] * b[0]\n    ];\n}\n\n// Like d3.dispatch, but for custom events abstracting native UI events. These\n// events have a target component (such as a brush), a target element (such as\n// the svg:g element containing the brush) and the standard arguments `d` (the\n// target element's data) and `i` (the selection index of the target element).\nfunction d3eventDispatch(target) {\n    var i = 0;\n    var n = arguments.length;\n    var argumentz = [];\n\n    while(++i < n) argumentz.push(arguments[i]);\n\n    var dispatch = d3.dispatch.apply(null, argumentz);\n\n    // Creates a dispatch context for the specified `thiz` (typically, the target\n    // DOM element that received the source event) and `argumentz` (typically, the\n    // data `d` and index `i` of the target element). The returned function can be\n    // used to dispatch an event to any registered listeners; the function takes a\n    // single argument as input, being the event to dispatch. The event must have\n    // a \"type\" attribute which corresponds to a type registered in the\n    // constructor. This context will automatically populate the \"sourceEvent\" and\n    // \"target\" attributes of the event, as well as setting the `d3.event` global\n    // for the duration of the notification.\n    dispatch.of = function(thiz, argumentz) {\n        return function(e1) {\n            var e0;\n            try {\n                e0 = e1.sourceEvent = d3.event;\n                e1.target = target;\n                d3.event = e1;\n                dispatch[e1.type].apply(thiz, argumentz);\n            } finally {\n                d3.event = e0;\n            }\n        };\n    };\n\n    return dispatch;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}