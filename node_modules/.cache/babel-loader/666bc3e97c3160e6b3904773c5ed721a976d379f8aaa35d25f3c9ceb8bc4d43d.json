{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function (cd) {\n    var plotGroup = d3.select(this);\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var x = cd0.x;\n    var y = cd0.y;\n    var contours = trace.contours;\n    var pathinfo = emptyPathinfo(contours, plotinfo, cd0);\n\n    // use a heatmap to fill - draw it behind the lines\n    var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n    var cdheatmaps = [];\n    if (contours.coloring === 'heatmap') {\n      if (trace.zauto && trace.autocontour === false) {\n        trace._input.zmin = trace.zmin = contours.start - contours.size / 2;\n        trace._input.zmax = trace.zmax = trace.zmin + pathinfo.length * contours.size;\n      }\n      cdheatmaps = [cd];\n    }\n    heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n    makeCrossings(pathinfo);\n    findAllPaths(pathinfo);\n    var leftedge = xa.c2p(x[0], true);\n    var rightedge = xa.c2p(x[x.length - 1], true);\n    var bottomedge = ya.c2p(y[0], true);\n    var topedge = ya.c2p(y[y.length - 1], true);\n    var perimeter = [[leftedge, topedge], [rightedge, topedge], [rightedge, bottomedge], [leftedge, bottomedge]];\n    var fillPathinfo = pathinfo;\n    if (contours.type === 'constraint') {\n      fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n      closeBoundaries(fillPathinfo, contours._operation, perimeter, trace);\n    }\n\n    // draw everything\n    makeBackground(plotGroup, perimeter, contours);\n    makeFills(plotGroup, fillPathinfo, perimeter, contours);\n    makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours, perimeter);\n    clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n  });\n};\nfunction makeBackground(plotgroup, perimeter, contours) {\n  var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n  var bgfill = bggroup.selectAll('path').data(contours.coloring === 'fill' ? [0] : []);\n  bgfill.enter().append('path');\n  bgfill.exit().remove();\n  bgfill.attr('d', 'M' + perimeter.join('L') + 'Z').style('stroke', 'none');\n}\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n  var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n  var fillitems = fillgroup.selectAll('path').data(contours.coloring === 'fill' || contours.type === 'constraint' && contours._operation !== '=' ? pathinfo : []);\n  fillitems.enter().append('path');\n  fillitems.exit().remove();\n  fillitems.each(function (pi) {\n    // join all paths for this level together into a single path\n    // first follow clockwise around the perimeter to close any open paths\n    // if the whole perimeter is above this level, start with a path\n    // enclosing the whole thing. With all that, the parity should mean\n    // that we always fill everything above the contour, nothing below\n    var fullpath = joinAllPaths(pi, perimeter);\n    if (!fullpath) d3.select(this).remove();else d3.select(this).attr('d', fullpath).style('stroke', 'none');\n  });\n}\nfunction initFullPath(pi, perimeter) {\n  var prefixBoundary = pi.prefixBoundary;\n  if (prefixBoundary === undefined) {\n    var edgeVal2 = Math.min(pi.z[0][0], pi.z[0][1]);\n    prefixBoundary = !pi.edgepaths.length && edgeVal2 > pi.level;\n  }\n  if (prefixBoundary) {\n    // TODO: why does ^^ not work for constraints?\n    // pi.prefixBoundary gets set by closeBoundaries\n    return 'M' + perimeter.join('L') + 'Z';\n  }\n  return '';\n}\nfunction joinAllPaths(pi, perimeter) {\n  var fullpath = initFullPath(pi, perimeter);\n  var i = 0;\n  var startsleft = pi.edgepaths.map(function (v, i) {\n    return i;\n  });\n  var newloop = true;\n  var endpt;\n  var newendpt;\n  var cnt;\n  var nexti;\n  var possiblei;\n  var addpath;\n  function istop(pt) {\n    return Math.abs(pt[1] - perimeter[0][1]) < 0.01;\n  }\n  function isbottom(pt) {\n    return Math.abs(pt[1] - perimeter[2][1]) < 0.01;\n  }\n  function isleft(pt) {\n    return Math.abs(pt[0] - perimeter[0][0]) < 0.01;\n  }\n  function isright(pt) {\n    return Math.abs(pt[0] - perimeter[2][0]) < 0.01;\n  }\n  while (startsleft.length) {\n    addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n    fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n    startsleft.splice(startsleft.indexOf(i), 1);\n    endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n    nexti = -1;\n\n    // now loop through sides, moving our endpoint until we find a new start\n    for (cnt = 0; cnt < 4; cnt++) {\n      // just to prevent infinite loops\n      if (!endpt) {\n        Lib.log('Missing end?', i, pi);\n        break;\n      }\n      if (istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n      else if (isleft(endpt)) newendpt = perimeter[0]; // left top\n      else if (isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n      else if (isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n      for (possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n        var ptNew = pi.edgepaths[possiblei][0];\n        // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n        if (Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n          if (Math.abs(endpt[0] - ptNew[0]) < 0.01 && (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else if (Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n          if (Math.abs(endpt[1] - ptNew[1]) < 0.01 && (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n            newendpt = ptNew;\n            nexti = possiblei;\n          }\n        } else {\n          Lib.log('endpt to newendpt is not vert. or horz.', endpt, newendpt, ptNew);\n        }\n      }\n      endpt = newendpt;\n      if (nexti >= 0) break;\n      fullpath += 'L' + newendpt;\n    }\n    if (nexti === pi.edgepaths.length) {\n      Lib.log('unclosed perimeter path');\n      break;\n    }\n    i = nexti;\n\n    // if we closed back on a loop we already included,\n    // close it and start a new loop\n    newloop = startsleft.indexOf(i) === -1;\n    if (newloop) {\n      i = startsleft[0];\n      fullpath += 'Z';\n    }\n  }\n\n  // finally add the interior paths\n  for (i = 0; i < pi.paths.length; i++) {\n    fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n  }\n  return fullpath;\n}\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours, perimeter) {\n  var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n  var showLines = contours.showlines !== false;\n  var showLabels = contours.showlabels;\n  var clipLinesForLabels = showLines && showLabels;\n\n  // Even if we're not going to show lines, we need to create them\n  // if we're showing labels, because the fill paths include the perimeter\n  // so can't be used to position the labels correctly.\n  // In this case we'll remove the lines after making the labels.\n  var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n  var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n  var labelGroup = plotgroup.selectAll('g.contourlabels').data(showLabels ? [0] : []);\n  labelGroup.exit().remove();\n  labelGroup.enter().append('g').classed('contourlabels', true);\n  if (showLabels) {\n    var labelClipPathData = [];\n    var labelData = [];\n\n    // invalidate the getTextLocation cache in case paths changed\n    Lib.clearLocationCache();\n    var contourFormat = exports.labelFormatter(contours, cd0.t.cb, gd._fullLayout);\n    var dummyText = Drawing.tester.append('text').attr('data-notex', 1).call(Drawing.font, contours.labelfont);\n    var xa = pathinfo[0].xaxis;\n    var ya = pathinfo[0].yaxis;\n    var xLen = xa._length;\n    var yLen = ya._length;\n    var xRng = xa.range;\n    var yRng = ya.range;\n    var x0 = Math.max(perimeter[0][0], 0);\n    var x1 = Math.min(perimeter[2][0], xLen);\n    var y0 = Math.max(perimeter[0][1], 0);\n    var y1 = Math.min(perimeter[2][1], yLen);\n\n    // visible bounds of the contour trace (and the midpoints, to\n    // help with cost calculations)\n    var bounds = {};\n    if (xRng[0] < xRng[1]) {\n      bounds.left = x0;\n      bounds.right = x1;\n    } else {\n      bounds.left = x1;\n      bounds.right = x0;\n    }\n    if (yRng[0] < yRng[1]) {\n      bounds.top = y0;\n      bounds.bottom = y1;\n    } else {\n      bounds.top = y1;\n      bounds.bottom = y0;\n    }\n    bounds.middle = (bounds.top + bounds.bottom) / 2;\n    bounds.center = (bounds.left + bounds.right) / 2;\n    labelClipPathData.push([[bounds.left, bounds.top], [bounds.right, bounds.top], [bounds.right, bounds.bottom], [bounds.left, bounds.bottom]]);\n    var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n    // the path length to use to scale the number of labels to draw:\n    var normLength = constants.LABELDISTANCE * plotDiagonal / Math.max(1, pathinfo.length / constants.LABELINCREASE);\n    linegroup.each(function (d) {\n      var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n      d3.select(this).selectAll('path').each(function () {\n        var path = this;\n        var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n        if (!pathBounds) return;\n        if (pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n        var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength), constants.LABELMAX);\n        for (var i = 0; i < maxLabels; i++) {\n          var loc = exports.findBestTextLocation(path, pathBounds, textOpts, labelData, bounds);\n          if (!loc) break;\n          exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n        }\n      });\n    });\n    dummyText.remove();\n    exports.drawLabels(labelGroup, labelData, gd, lineClip, clipLinesForLabels ? labelClipPathData : null);\n  }\n  if (showLabels && !showLines) linegroup.remove();\n}\nexports.createLines = function (lineContainer, makeLines, pathinfo) {\n  var smoothing = pathinfo[0].smoothing;\n  var linegroup = lineContainer.selectAll('g.contourlevel').data(makeLines ? pathinfo : []);\n  linegroup.exit().remove();\n  linegroup.enter().append('g').classed('contourlevel', true);\n  if (makeLines) {\n    // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n    // edgepaths / paths are used by contour since it's in x/y from the start\n    var opencontourlines = linegroup.selectAll('path.openline').data(function (d) {\n      return d.pedgepaths || d.edgepaths;\n    });\n    opencontourlines.exit().remove();\n    opencontourlines.enter().append('path').classed('openline', true);\n    opencontourlines.attr('d', function (d) {\n      return Drawing.smoothopen(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n    var closedcontourlines = linegroup.selectAll('path.closedline').data(function (d) {\n      return d.ppaths || d.paths;\n    });\n    closedcontourlines.exit().remove();\n    closedcontourlines.enter().append('path').classed('closedline', true);\n    closedcontourlines.attr('d', function (d) {\n      return Drawing.smoothclosed(d, smoothing);\n    }).style('stroke-miterlimit', 1).style('vector-effect', 'non-scaling-stroke');\n  }\n  return linegroup;\n};\nexports.createLineClip = function (lineContainer, clipLinesForLabels, gd, uid) {\n  var clips = gd._fullLayout._clips;\n  var clipId = clipLinesForLabels ? 'clipline' + uid : null;\n  var lineClip = clips.selectAll('#' + clipId).data(clipLinesForLabels ? [0] : []);\n  lineClip.exit().remove();\n  lineClip.enter().append('clipPath').classed('contourlineclip', true).attr('id', clipId);\n  Drawing.setClipUrl(lineContainer, clipId, gd);\n  return lineClip;\n};\nexports.labelFormatter = function (contours, colorbar, fullLayout) {\n  if (contours.labelformat) {\n    return fullLayout._d3locale.numberFormat(contours.labelformat);\n  } else {\n    var formatAxis;\n    if (colorbar) {\n      formatAxis = colorbar.axis;\n    } else {\n      formatAxis = {\n        type: 'linear',\n        _id: 'ycontour',\n        showexponent: 'all',\n        exponentformat: 'B'\n      };\n      if (contours.type === 'constraint') {\n        var value = contours.value;\n        if (Array.isArray(value)) {\n          formatAxis.range = [value[0], value[value.length - 1]];\n        } else formatAxis.range = [value, value];\n      } else {\n        formatAxis.range = [contours.start, contours.end];\n        formatAxis.nticks = (contours.end - contours.start) / contours.size;\n      }\n      if (formatAxis.range[0] === formatAxis.range[1]) {\n        formatAxis.range[1] += formatAxis.range[0] || 1;\n      }\n      if (!formatAxis.nticks) formatAxis.nticks = 1000;\n      setConvert(formatAxis, fullLayout);\n      Axes.prepTicks(formatAxis);\n      formatAxis._tmin = null;\n      formatAxis._tmax = null;\n    }\n    return function (v) {\n      return Axes.tickText(formatAxis, v).text;\n    };\n  }\n};\nexports.calcTextOpts = function (level, contourFormat, dummyText, gd) {\n  var text = contourFormat(level);\n  dummyText.text(text).call(svgTextUtils.convertToTspans, gd);\n  var bBox = Drawing.bBox(dummyText.node(), true);\n  return {\n    text: text,\n    width: bBox.width,\n    height: bBox.height,\n    level: level,\n    dy: (bBox.top + bBox.bottom) / 2\n  };\n};\nexports.findBestTextLocation = function (path, pathBounds, textOpts, labelData, plotBounds) {\n  var textWidth = textOpts.width;\n  var p0, dp, pMax, pMin, loc;\n  if (pathBounds.isClosed) {\n    dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n    p0 = pathBounds.min + dp / 2;\n    pMax = pathBounds.max;\n  } else {\n    dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n    p0 = pathBounds.min + dp + textWidth / 2;\n    pMax = pathBounds.max - (dp + textWidth) / 2;\n  }\n  var cost = Infinity;\n  for (var j = 0; j < costConstants.ITERATIONS; j++) {\n    for (var p = p0; p < pMax; p += dp) {\n      var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n      var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n      if (newCost < cost) {\n        cost = newCost;\n        loc = newLocation;\n        pMin = p;\n      }\n    }\n    if (cost > costConstants.MAXCOST * 2) break;\n\n    // subsequent iterations just look half steps away from the\n    // best we found in the previous iteration\n    if (j) dp /= 2;\n    p0 = pMin - dp / 2;\n    pMax = p0 + dp * 1.5;\n  }\n  if (cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n  var halfWidth = textOpts.width / 2;\n  var halfHeight = textOpts.height / 2;\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var dx = Math.cos(theta) * halfWidth;\n  var dy = Math.sin(theta) * halfWidth;\n\n  // cost for being near an edge\n  var normX = (x > bounds.center ? bounds.right - x : x - bounds.left) / (dx + Math.abs(Math.sin(theta) * halfHeight));\n  var normY = (y > bounds.middle ? bounds.bottom - y : y - bounds.top) / (Math.abs(dy) + Math.cos(theta) * halfHeight);\n  if (normX < 1 || normY < 1) return Infinity;\n  var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n  // cost for not being horizontal\n  cost += costConstants.ANGLECOST * theta * theta;\n\n  // cost for being close to other labels\n  var x1 = x - dx;\n  var y1 = y - dy;\n  var x2 = x + dx;\n  var y2 = y + dy;\n  for (var i = 0; i < labelData.length; i++) {\n    var labeli = labelData[i];\n    var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n    var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n    var dist = Lib.segmentDistance(x1, y1, x2, y2, labeli.x - dxd, labeli.y - dyd, labeli.x + dxd, labeli.y + dyd) * 2 / (textOpts.height + labeli.height);\n    var sameLevel = labeli.level === textOpts.level;\n    var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n    if (dist <= distOffset) return Infinity;\n    var distFactor = costConstants.NEIGHBORCOST * (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n    cost += distFactor / (dist - distOffset);\n  }\n  return cost;\n}\nexports.addLabelData = function (loc, textOpts, labelData, labelClipPathData) {\n  var halfWidth = textOpts.width / 2;\n  var halfHeight = textOpts.height / 2;\n  var x = loc.x;\n  var y = loc.y;\n  var theta = loc.theta;\n  var sin = Math.sin(theta);\n  var cos = Math.cos(theta);\n  var dxw = halfWidth * cos;\n  var dxh = halfHeight * sin;\n  var dyw = halfWidth * sin;\n  var dyh = -halfHeight * cos;\n  var bBoxPts = [[x - dxw - dxh, y - dyw - dyh], [x + dxw - dxh, y + dyw - dyh], [x + dxw + dxh, y + dyw + dyh], [x - dxw + dxh, y - dyw + dyh]];\n  labelData.push({\n    text: textOpts.text,\n    x: x,\n    y: y,\n    dy: textOpts.dy,\n    theta: theta,\n    level: textOpts.level,\n    width: textOpts.width,\n    height: textOpts.height\n  });\n  labelClipPathData.push(bBoxPts);\n};\nexports.drawLabels = function (labelGroup, labelData, gd, lineClip, labelClipPathData) {\n  var labels = labelGroup.selectAll('text').data(labelData, function (d) {\n    return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n  });\n  labels.exit().remove();\n  labels.enter().append('text').attr({\n    'data-notex': 1,\n    'text-anchor': 'middle'\n  }).each(function (d) {\n    var x = d.x + Math.sin(d.theta) * d.dy;\n    var y = d.y - Math.cos(d.theta) * d.dy;\n    d3.select(this).text(d.text).attr({\n      x: x,\n      y: y,\n      transform: 'rotate(' + 180 * d.theta / Math.PI + ' ' + x + ' ' + y + ')'\n    }).call(svgTextUtils.convertToTspans, gd);\n  });\n  if (labelClipPathData) {\n    var clipPath = '';\n    for (var i = 0; i < labelClipPathData.length; i++) {\n      clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n    }\n    var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n    lineClipPath.attr('d', clipPath);\n  }\n};\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n  var clips = gd._fullLayout._clips;\n  var clipId = 'clip' + cd0.trace.uid;\n  var clipPath = clips.selectAll('#' + clipId).data(cd0.trace.connectgaps ? [] : [0]);\n  clipPath.enter().append('clipPath').classed('contourclip', true).attr('id', clipId);\n  clipPath.exit().remove();\n  if (cd0.trace.connectgaps === false) {\n    var clipPathInfo = {\n      // fraction of the way from missing to present point\n      // to draw the boundary.\n      // if you make this 1 (or 1-epsilon) then a point in\n      // a sea of missing data will disappear entirely.\n      level: 0.9,\n      crossings: {},\n      starts: [],\n      edgepaths: [],\n      paths: [],\n      xaxis: plotinfo.xaxis,\n      yaxis: plotinfo.yaxis,\n      x: cd0.x,\n      y: cd0.y,\n      // 0 = no data, 1 = data\n      z: makeClipMask(cd0),\n      smoothing: 0\n    };\n    makeCrossings([clipPathInfo]);\n    findAllPaths([clipPathInfo]);\n    var fullpath = joinAllPaths(clipPathInfo, perimeter);\n    var path = Lib.ensureSingle(clipPath, 'path', '');\n    path.attr('d', fullpath);\n  } else clipId = null;\n  Drawing.setClipUrl(plotGroup, clipId, gd);\n}\nfunction makeClipMask(cd0) {\n  var empties = cd0.trace._emptypoints;\n  var z = [];\n  var m = cd0.z.length;\n  var n = cd0.z[0].length;\n  var i;\n  var row = [];\n  var emptyPoint;\n  for (i = 0; i < n; i++) {\n    row.push(1);\n  }\n  for (i = 0; i < m; i++) {\n    z.push(row.slice());\n  }\n  for (i = 0; i < empties.length; i++) {\n    emptyPoint = empties[i];\n    z[emptyPoint[0]][emptyPoint[1]] = 0;\n  }\n  // save this mask to determine whether to show this data in hover\n  cd0.zmask = z;\n  return z;\n}","map":{"version":3,"names":["d3","require","Lib","Drawing","svgTextUtils","Axes","setConvert","heatmapPlot","makeCrossings","findAllPaths","emptyPathinfo","convertToConstraints","closeBoundaries","constants","costConstants","LABELOPTIMIZER","exports","plot","gd","plotinfo","cdcontours","contourLayer","xa","xaxis","ya","yaxis","makeTraceGroups","each","cd","plotGroup","select","cd0","trace","x","y","contours","pathinfo","heatmapColoringLayer","ensureSingle","cdheatmaps","coloring","zauto","autocontour","_input","zmin","start","size","zmax","length","leftedge","c2p","rightedge","bottomedge","topedge","perimeter","fillPathinfo","type","_operation","makeBackground","makeFills","makeLinesAndLabels","clipGaps","plotgroup","bggroup","bgfill","selectAll","data","enter","append","exit","remove","attr","join","style","fillgroup","fillitems","pi","fullpath","joinAllPaths","initFullPath","prefixBoundary","undefined","edgeVal2","Math","min","z","edgepaths","level","i","startsleft","map","v","newloop","endpt","newendpt","cnt","nexti","possiblei","addpath","istop","pt","abs","isbottom","isleft","isright","smoothopen","smoothing","replace","splice","indexOf","log","ptNew","paths","smoothclosed","lineContainer","showLines","showlines","showLabels","showlabels","clipLinesForLabels","linegroup","createLines","lineClip","createLineClip","uid","labelGroup","classed","labelClipPathData","labelData","clearLocationCache","contourFormat","labelFormatter","t","cb","_fullLayout","dummyText","tester","call","font","labelfont","xLen","_length","yLen","xRng","range","yRng","x0","max","x1","y0","y1","bounds","left","right","top","bottom","middle","center","push","plotDiagonal","sqrt","normLength","LABELDISTANCE","LABELINCREASE","d","textOpts","calcTextOpts","path","pathBounds","getVisibleSegment","height","len","width","LABELMIN","maxLabels","ceil","LABELMAX","loc","findBestTextLocation","addLabelData","drawLabels","makeLines","opencontourlines","pedgepaths","closedcontourlines","ppaths","clips","_clips","clipId","setClipUrl","colorbar","fullLayout","labelformat","_d3locale","numberFormat","formatAxis","axis","_id","showexponent","exponentformat","value","Array","isArray","end","nticks","prepTicks","_tmin","_tmax","tickText","text","convertToTspans","bBox","node","dy","plotBounds","textWidth","p0","dp","pMax","pMin","isClosed","INITIALSEARCHPOINTS","cost","Infinity","j","ITERATIONS","p","newLocation","getTextLocation","total","newCost","locationCost","MAXCOST","halfWidth","halfHeight","theta","dx","cos","sin","normX","normY","EDGECOST","ANGLECOST","x2","y2","labeli","dxd","dyd","dist","segmentDistance","sameLevel","distOffset","SAMELEVELDISTANCE","distFactor","NEIGHBORCOST","SAMELEVELFACTOR","dxw","dxh","dyw","dyh","bBoxPts","labels","transform","PI","clipPath","lineClipPath","connectgaps","clipPathInfo","crossings","starts","makeClipMask","empties","_emptypoints","m","n","row","emptyPoint","slice","zmask"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/contour/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvert = require('../../plots/cartesian/set_convert');\n\nvar heatmapPlot = require('../heatmap/plot');\nvar makeCrossings = require('./make_crossings');\nvar findAllPaths = require('./find_all_paths');\nvar emptyPathinfo = require('./empty_pathinfo');\nvar convertToConstraints = require('./convert_to_constraints');\nvar closeBoundaries = require('./close_boundaries');\nvar constants = require('./constants');\nvar costConstants = constants.LABELOPTIMIZER;\n\nexports.plot = function plot(gd, plotinfo, cdcontours, contourLayer) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    Lib.makeTraceGroups(contourLayer, cdcontours, 'contour').each(function(cd) {\n        var plotGroup = d3.select(this);\n        var cd0 = cd[0];\n        var trace = cd0.trace;\n        var x = cd0.x;\n        var y = cd0.y;\n        var contours = trace.contours;\n        var pathinfo = emptyPathinfo(contours, plotinfo, cd0);\n\n        // use a heatmap to fill - draw it behind the lines\n        var heatmapColoringLayer = Lib.ensureSingle(plotGroup, 'g', 'heatmapcoloring');\n        var cdheatmaps = [];\n        if(contours.coloring === 'heatmap') {\n            if(trace.zauto && (trace.autocontour === false)) {\n                trace._input.zmin = trace.zmin =\n                    contours.start - contours.size / 2;\n                trace._input.zmax = trace.zmax =\n                    trace.zmin + pathinfo.length * contours.size;\n            }\n            cdheatmaps = [cd];\n        }\n        heatmapPlot(gd, plotinfo, cdheatmaps, heatmapColoringLayer);\n\n        makeCrossings(pathinfo);\n        findAllPaths(pathinfo);\n\n        var leftedge = xa.c2p(x[0], true);\n        var rightedge = xa.c2p(x[x.length - 1], true);\n        var bottomedge = ya.c2p(y[0], true);\n        var topedge = ya.c2p(y[y.length - 1], true);\n        var perimeter = [\n            [leftedge, topedge],\n            [rightedge, topedge],\n            [rightedge, bottomedge],\n            [leftedge, bottomedge]\n        ];\n\n        var fillPathinfo = pathinfo;\n        if(contours.type === 'constraint') {\n            fillPathinfo = convertToConstraints(pathinfo, contours._operation);\n            closeBoundaries(fillPathinfo, contours._operation, perimeter, trace);\n        }\n\n        // draw everything\n        makeBackground(plotGroup, perimeter, contours);\n        makeFills(plotGroup, fillPathinfo, perimeter, contours);\n        makeLinesAndLabels(plotGroup, pathinfo, gd, cd0, contours, perimeter);\n        clipGaps(plotGroup, plotinfo, gd, cd0, perimeter);\n    });\n};\n\nfunction makeBackground(plotgroup, perimeter, contours) {\n    var bggroup = Lib.ensureSingle(plotgroup, 'g', 'contourbg');\n\n    var bgfill = bggroup.selectAll('path')\n        .data(contours.coloring === 'fill' ? [0] : []);\n    bgfill.enter().append('path');\n    bgfill.exit().remove();\n    bgfill\n        .attr('d', 'M' + perimeter.join('L') + 'Z')\n        .style('stroke', 'none');\n}\n\nfunction makeFills(plotgroup, pathinfo, perimeter, contours) {\n    var fillgroup = Lib.ensureSingle(plotgroup, 'g', 'contourfill');\n\n    var fillitems = fillgroup.selectAll('path')\n        .data(contours.coloring === 'fill' || (contours.type === 'constraint' && contours._operation !== '=') ? pathinfo : []);\n    fillitems.enter().append('path');\n    fillitems.exit().remove();\n    fillitems.each(function(pi) {\n        // join all paths for this level together into a single path\n        // first follow clockwise around the perimeter to close any open paths\n        // if the whole perimeter is above this level, start with a path\n        // enclosing the whole thing. With all that, the parity should mean\n        // that we always fill everything above the contour, nothing below\n        var fullpath = joinAllPaths(pi, perimeter);\n\n        if(!fullpath) d3.select(this).remove();\n        else d3.select(this).attr('d', fullpath).style('stroke', 'none');\n    });\n}\n\nfunction initFullPath(pi, perimeter) {\n    var prefixBoundary = pi.prefixBoundary;\n    if(prefixBoundary === undefined) {\n        var edgeVal2 = Math.min(pi.z[0][0], pi.z[0][1]);\n        prefixBoundary = (!pi.edgepaths.length && edgeVal2 > pi.level);\n    }\n\n    if(prefixBoundary) {\n        // TODO: why does ^^ not work for constraints?\n        // pi.prefixBoundary gets set by closeBoundaries\n        return 'M' + perimeter.join('L') + 'Z';\n    }\n    return '';\n}\n\nfunction joinAllPaths(pi, perimeter) {\n    var fullpath = initFullPath(pi, perimeter);\n    var i = 0;\n    var startsleft = pi.edgepaths.map(function(v, i) { return i; });\n    var newloop = true;\n    var endpt;\n    var newendpt;\n    var cnt;\n    var nexti;\n    var possiblei;\n    var addpath;\n\n    function istop(pt) { return Math.abs(pt[1] - perimeter[0][1]) < 0.01; }\n    function isbottom(pt) { return Math.abs(pt[1] - perimeter[2][1]) < 0.01; }\n    function isleft(pt) { return Math.abs(pt[0] - perimeter[0][0]) < 0.01; }\n    function isright(pt) { return Math.abs(pt[0] - perimeter[2][0]) < 0.01; }\n\n    while(startsleft.length) {\n        addpath = Drawing.smoothopen(pi.edgepaths[i], pi.smoothing);\n        fullpath += newloop ? addpath : addpath.replace(/^M/, 'L');\n        startsleft.splice(startsleft.indexOf(i), 1);\n        endpt = pi.edgepaths[i][pi.edgepaths[i].length - 1];\n        nexti = -1;\n\n        // now loop through sides, moving our endpoint until we find a new start\n        for(cnt = 0; cnt < 4; cnt++) { // just to prevent infinite loops\n            if(!endpt) {\n                Lib.log('Missing end?', i, pi);\n                break;\n            }\n\n            if(istop(endpt) && !isright(endpt)) newendpt = perimeter[1]; // right top\n            else if(isleft(endpt)) newendpt = perimeter[0]; // left top\n            else if(isbottom(endpt)) newendpt = perimeter[3]; // right bottom\n            else if(isright(endpt)) newendpt = perimeter[2]; // left bottom\n\n            for(possiblei = 0; possiblei < pi.edgepaths.length; possiblei++) {\n                var ptNew = pi.edgepaths[possiblei][0];\n                // is ptNew on the (horz. or vert.) segment from endpt to newendpt?\n                if(Math.abs(endpt[0] - newendpt[0]) < 0.01) {\n                    if(Math.abs(endpt[0] - ptNew[0]) < 0.01 &&\n                            (ptNew[1] - endpt[1]) * (newendpt[1] - ptNew[1]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                }\n                else if(Math.abs(endpt[1] - newendpt[1]) < 0.01) {\n                    if(Math.abs(endpt[1] - ptNew[1]) < 0.01 &&\n                            (ptNew[0] - endpt[0]) * (newendpt[0] - ptNew[0]) >= 0) {\n                        newendpt = ptNew;\n                        nexti = possiblei;\n                    }\n                }\n                else {\n                    Lib.log('endpt to newendpt is not vert. or horz.',\n                        endpt, newendpt, ptNew);\n                }\n            }\n\n            endpt = newendpt;\n\n            if(nexti >= 0) break;\n            fullpath += 'L' + newendpt;\n        }\n\n        if(nexti === pi.edgepaths.length) {\n            Lib.log('unclosed perimeter path');\n            break;\n        }\n\n        i = nexti;\n\n        // if we closed back on a loop we already included,\n        // close it and start a new loop\n        newloop = (startsleft.indexOf(i) === -1);\n        if(newloop) {\n            i = startsleft[0];\n            fullpath += 'Z';\n        }\n    }\n\n    // finally add the interior paths\n    for(i = 0; i < pi.paths.length; i++) {\n        fullpath += Drawing.smoothclosed(pi.paths[i], pi.smoothing);\n    }\n\n    return fullpath;\n}\n\nfunction makeLinesAndLabels(plotgroup, pathinfo, gd, cd0, contours, perimeter) {\n    var lineContainer = Lib.ensureSingle(plotgroup, 'g', 'contourlines');\n    var showLines = contours.showlines !== false;\n    var showLabels = contours.showlabels;\n    var clipLinesForLabels = showLines && showLabels;\n\n    // Even if we're not going to show lines, we need to create them\n    // if we're showing labels, because the fill paths include the perimeter\n    // so can't be used to position the labels correctly.\n    // In this case we'll remove the lines after making the labels.\n    var linegroup = exports.createLines(lineContainer, showLines || showLabels, pathinfo);\n\n    var lineClip = exports.createLineClip(lineContainer, clipLinesForLabels, gd, cd0.trace.uid);\n\n    var labelGroup = plotgroup.selectAll('g.contourlabels')\n        .data(showLabels ? [0] : []);\n\n    labelGroup.exit().remove();\n\n    labelGroup.enter().append('g')\n        .classed('contourlabels', true);\n\n    if(showLabels) {\n        var labelClipPathData = [];\n        var labelData = [];\n\n        // invalidate the getTextLocation cache in case paths changed\n        Lib.clearLocationCache();\n\n        var contourFormat = exports.labelFormatter(contours, cd0.t.cb, gd._fullLayout);\n\n        var dummyText = Drawing.tester.append('text')\n            .attr('data-notex', 1)\n            .call(Drawing.font, contours.labelfont);\n\n        var xa = pathinfo[0].xaxis;\n        var ya = pathinfo[0].yaxis;\n        var xLen = xa._length;\n        var yLen = ya._length;\n        var xRng = xa.range;\n        var yRng = ya.range;\n        var x0 = Math.max(perimeter[0][0], 0);\n        var x1 = Math.min(perimeter[2][0], xLen);\n        var y0 = Math.max(perimeter[0][1], 0);\n        var y1 = Math.min(perimeter[2][1], yLen);\n\n        // visible bounds of the contour trace (and the midpoints, to\n        // help with cost calculations)\n        var bounds = {};\n\n        if(xRng[0] < xRng[1]) {\n            bounds.left = x0;\n            bounds.right = x1;\n        } else {\n            bounds.left = x1;\n            bounds.right = x0;\n        }\n\n        if(yRng[0] < yRng[1]) {\n            bounds.top = y0;\n            bounds.bottom = y1;\n        } else {\n            bounds.top = y1;\n            bounds.bottom = y0;\n        }\n\n        bounds.middle = (bounds.top + bounds.bottom) / 2;\n        bounds.center = (bounds.left + bounds.right) / 2;\n\n        labelClipPathData.push([\n            [bounds.left, bounds.top],\n            [bounds.right, bounds.top],\n            [bounds.right, bounds.bottom],\n            [bounds.left, bounds.bottom]\n        ]);\n\n        var plotDiagonal = Math.sqrt(xLen * xLen + yLen * yLen);\n\n        // the path length to use to scale the number of labels to draw:\n        var normLength = constants.LABELDISTANCE * plotDiagonal /\n            Math.max(1, pathinfo.length / constants.LABELINCREASE);\n\n        linegroup.each(function(d) {\n            var textOpts = exports.calcTextOpts(d.level, contourFormat, dummyText, gd);\n\n            d3.select(this).selectAll('path').each(function() {\n                var path = this;\n                var pathBounds = Lib.getVisibleSegment(path, bounds, textOpts.height / 2);\n                if(!pathBounds) return;\n\n                if(pathBounds.len < (textOpts.width + textOpts.height) * constants.LABELMIN) return;\n\n                var maxLabels = Math.min(Math.ceil(pathBounds.len / normLength),\n                    constants.LABELMAX);\n\n                for(var i = 0; i < maxLabels; i++) {\n                    var loc = exports.findBestTextLocation(path, pathBounds, textOpts,\n                        labelData, bounds);\n\n                    if(!loc) break;\n\n                    exports.addLabelData(loc, textOpts, labelData, labelClipPathData);\n                }\n            });\n        });\n\n        dummyText.remove();\n\n        exports.drawLabels(labelGroup, labelData, gd, lineClip,\n            clipLinesForLabels ? labelClipPathData : null);\n    }\n\n    if(showLabels && !showLines) linegroup.remove();\n}\n\nexports.createLines = function(lineContainer, makeLines, pathinfo) {\n    var smoothing = pathinfo[0].smoothing;\n\n    var linegroup = lineContainer.selectAll('g.contourlevel')\n        .data(makeLines ? pathinfo : []);\n\n    linegroup.exit().remove();\n    linegroup.enter().append('g')\n        .classed('contourlevel', true);\n\n    if(makeLines) {\n        // pedgepaths / ppaths are used by contourcarpet, for the paths transformed from a/b to x/y\n        // edgepaths / paths are used by contour since it's in x/y from the start\n        var opencontourlines = linegroup.selectAll('path.openline')\n            .data(function(d) { return d.pedgepaths || d.edgepaths; });\n\n        opencontourlines.exit().remove();\n        opencontourlines.enter().append('path')\n            .classed('openline', true);\n\n        opencontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothopen(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n\n        var closedcontourlines = linegroup.selectAll('path.closedline')\n            .data(function(d) { return d.ppaths || d.paths; });\n\n        closedcontourlines.exit().remove();\n        closedcontourlines.enter().append('path')\n            .classed('closedline', true);\n\n        closedcontourlines\n            .attr('d', function(d) {\n                return Drawing.smoothclosed(d, smoothing);\n            })\n            .style('stroke-miterlimit', 1)\n            .style('vector-effect', 'non-scaling-stroke');\n    }\n\n    return linegroup;\n};\n\nexports.createLineClip = function(lineContainer, clipLinesForLabels, gd, uid) {\n    var clips = gd._fullLayout._clips;\n    var clipId = clipLinesForLabels ? ('clipline' + uid) : null;\n\n    var lineClip = clips.selectAll('#' + clipId)\n        .data(clipLinesForLabels ? [0] : []);\n    lineClip.exit().remove();\n\n    lineClip.enter().append('clipPath')\n        .classed('contourlineclip', true)\n        .attr('id', clipId);\n\n    Drawing.setClipUrl(lineContainer, clipId, gd);\n\n    return lineClip;\n};\n\nexports.labelFormatter = function(contours, colorbar, fullLayout) {\n    if(contours.labelformat) {\n        return fullLayout._d3locale.numberFormat(contours.labelformat);\n    }\n    else {\n        var formatAxis;\n        if(colorbar) {\n            formatAxis = colorbar.axis;\n        }\n        else {\n            formatAxis = {\n                type: 'linear',\n                _id: 'ycontour',\n                showexponent: 'all',\n                exponentformat: 'B'\n            };\n\n            if(contours.type === 'constraint') {\n                var value = contours.value;\n                if(Array.isArray(value)) {\n                    formatAxis.range = [value[0], value[value.length - 1]];\n                }\n                else formatAxis.range = [value, value];\n            }\n            else {\n                formatAxis.range = [contours.start, contours.end];\n                formatAxis.nticks = (contours.end - contours.start) / contours.size;\n            }\n\n            if(formatAxis.range[0] === formatAxis.range[1]) {\n                formatAxis.range[1] += formatAxis.range[0] || 1;\n            }\n            if(!formatAxis.nticks) formatAxis.nticks = 1000;\n\n            setConvert(formatAxis, fullLayout);\n            Axes.prepTicks(formatAxis);\n            formatAxis._tmin = null;\n            formatAxis._tmax = null;\n        }\n        return function(v) {\n            return Axes.tickText(formatAxis, v).text;\n        };\n    }\n};\n\nexports.calcTextOpts = function(level, contourFormat, dummyText, gd) {\n    var text = contourFormat(level);\n    dummyText.text(text)\n        .call(svgTextUtils.convertToTspans, gd);\n    var bBox = Drawing.bBox(dummyText.node(), true);\n\n    return {\n        text: text,\n        width: bBox.width,\n        height: bBox.height,\n        level: level,\n        dy: (bBox.top + bBox.bottom) / 2\n    };\n};\n\nexports.findBestTextLocation = function(path, pathBounds, textOpts, labelData, plotBounds) {\n    var textWidth = textOpts.width;\n\n    var p0, dp, pMax, pMin, loc;\n    if(pathBounds.isClosed) {\n        dp = pathBounds.len / costConstants.INITIALSEARCHPOINTS;\n        p0 = pathBounds.min + dp / 2;\n        pMax = pathBounds.max;\n    }\n    else {\n        dp = (pathBounds.len - textWidth) / (costConstants.INITIALSEARCHPOINTS + 1);\n        p0 = pathBounds.min + dp + textWidth / 2;\n        pMax = pathBounds.max - (dp + textWidth) / 2;\n    }\n\n    var cost = Infinity;\n    for(var j = 0; j < costConstants.ITERATIONS; j++) {\n        for(var p = p0; p < pMax; p += dp) {\n            var newLocation = Lib.getTextLocation(path, pathBounds.total, p, textWidth);\n            var newCost = locationCost(newLocation, textOpts, labelData, plotBounds);\n            if(newCost < cost) {\n                cost = newCost;\n                loc = newLocation;\n                pMin = p;\n            }\n        }\n        if(cost > costConstants.MAXCOST * 2) break;\n\n        // subsequent iterations just look half steps away from the\n        // best we found in the previous iteration\n        if(j) dp /= 2;\n        p0 = pMin - dp / 2;\n        pMax = p0 + dp * 1.5;\n    }\n    if(cost <= costConstants.MAXCOST) return loc;\n};\n\n/*\n * locationCost: a cost function for label locations\n * composed of three kinds of penalty:\n * - for open paths, being close to the end of the path\n * - the angle away from horizontal\n * - being too close to already placed neighbors\n */\nfunction locationCost(loc, textOpts, labelData, bounds) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n    var dx = Math.cos(theta) * halfWidth;\n    var dy = Math.sin(theta) * halfWidth;\n\n    // cost for being near an edge\n    var normX = ((x > bounds.center) ? (bounds.right - x) : (x - bounds.left)) /\n        (dx + Math.abs(Math.sin(theta) * halfHeight));\n    var normY = ((y > bounds.middle) ? (bounds.bottom - y) : (y - bounds.top)) /\n        (Math.abs(dy) + Math.cos(theta) * halfHeight);\n    if(normX < 1 || normY < 1) return Infinity;\n    var cost = costConstants.EDGECOST * (1 / (normX - 1) + 1 / (normY - 1));\n\n    // cost for not being horizontal\n    cost += costConstants.ANGLECOST * theta * theta;\n\n    // cost for being close to other labels\n    var x1 = x - dx;\n    var y1 = y - dy;\n    var x2 = x + dx;\n    var y2 = y + dy;\n    for(var i = 0; i < labelData.length; i++) {\n        var labeli = labelData[i];\n        var dxd = Math.cos(labeli.theta) * labeli.width / 2;\n        var dyd = Math.sin(labeli.theta) * labeli.width / 2;\n        var dist = Lib.segmentDistance(\n            x1, y1,\n            x2, y2,\n            labeli.x - dxd, labeli.y - dyd,\n            labeli.x + dxd, labeli.y + dyd\n        ) * 2 / (textOpts.height + labeli.height);\n\n        var sameLevel = labeli.level === textOpts.level;\n        var distOffset = sameLevel ? costConstants.SAMELEVELDISTANCE : 1;\n\n        if(dist <= distOffset) return Infinity;\n\n        var distFactor = costConstants.NEIGHBORCOST *\n            (sameLevel ? costConstants.SAMELEVELFACTOR : 1);\n\n        cost += distFactor / (dist - distOffset);\n    }\n\n    return cost;\n}\n\nexports.addLabelData = function(loc, textOpts, labelData, labelClipPathData) {\n    var halfWidth = textOpts.width / 2;\n    var halfHeight = textOpts.height / 2;\n\n    var x = loc.x;\n    var y = loc.y;\n    var theta = loc.theta;\n\n    var sin = Math.sin(theta);\n    var cos = Math.cos(theta);\n    var dxw = halfWidth * cos;\n    var dxh = halfHeight * sin;\n    var dyw = halfWidth * sin;\n    var dyh = -halfHeight * cos;\n    var bBoxPts = [\n        [x - dxw - dxh, y - dyw - dyh],\n        [x + dxw - dxh, y + dyw - dyh],\n        [x + dxw + dxh, y + dyw + dyh],\n        [x - dxw + dxh, y - dyw + dyh],\n    ];\n\n    labelData.push({\n        text: textOpts.text,\n        x: x,\n        y: y,\n        dy: textOpts.dy,\n        theta: theta,\n        level: textOpts.level,\n        width: textOpts.width,\n        height: textOpts.height\n    });\n\n    labelClipPathData.push(bBoxPts);\n};\n\nexports.drawLabels = function(labelGroup, labelData, gd, lineClip, labelClipPathData) {\n    var labels = labelGroup.selectAll('text')\n        .data(labelData, function(d) {\n            return d.text + ',' + d.x + ',' + d.y + ',' + d.theta;\n        });\n\n    labels.exit().remove();\n\n    labels.enter().append('text')\n        .attr({\n            'data-notex': 1,\n            'text-anchor': 'middle'\n        })\n        .each(function(d) {\n            var x = d.x + Math.sin(d.theta) * d.dy;\n            var y = d.y - Math.cos(d.theta) * d.dy;\n            d3.select(this)\n                .text(d.text)\n                .attr({\n                    x: x,\n                    y: y,\n                    transform: 'rotate(' + (180 * d.theta / Math.PI) + ' ' + x + ' ' + y + ')'\n                })\n                .call(svgTextUtils.convertToTspans, gd);\n        });\n\n    if(labelClipPathData) {\n        var clipPath = '';\n        for(var i = 0; i < labelClipPathData.length; i++) {\n            clipPath += 'M' + labelClipPathData[i].join('L') + 'Z';\n        }\n\n        var lineClipPath = Lib.ensureSingle(lineClip, 'path', '');\n        lineClipPath.attr('d', clipPath);\n    }\n};\n\nfunction clipGaps(plotGroup, plotinfo, gd, cd0, perimeter) {\n    var clips = gd._fullLayout._clips;\n    var clipId = 'clip' + cd0.trace.uid;\n\n    var clipPath = clips.selectAll('#' + clipId)\n        .data(cd0.trace.connectgaps ? [] : [0]);\n    clipPath.enter().append('clipPath')\n        .classed('contourclip', true)\n        .attr('id', clipId);\n    clipPath.exit().remove();\n\n    if(cd0.trace.connectgaps === false) {\n        var clipPathInfo = {\n            // fraction of the way from missing to present point\n            // to draw the boundary.\n            // if you make this 1 (or 1-epsilon) then a point in\n            // a sea of missing data will disappear entirely.\n            level: 0.9,\n            crossings: {},\n            starts: [],\n            edgepaths: [],\n            paths: [],\n            xaxis: plotinfo.xaxis,\n            yaxis: plotinfo.yaxis,\n            x: cd0.x,\n            y: cd0.y,\n            // 0 = no data, 1 = data\n            z: makeClipMask(cd0),\n            smoothing: 0\n        };\n\n        makeCrossings([clipPathInfo]);\n        findAllPaths([clipPathInfo]);\n        var fullpath = joinAllPaths(clipPathInfo, perimeter);\n\n        var path = Lib.ensureSingle(clipPath, 'path', '');\n        path.attr('d', fullpath);\n    }\n    else clipId = null;\n\n    Drawing.setClipUrl(plotGroup, clipId, gd);\n}\n\nfunction makeClipMask(cd0) {\n    var empties = cd0.trace._emptypoints;\n    var z = [];\n    var m = cd0.z.length;\n    var n = cd0.z[0].length;\n    var i;\n    var row = [];\n    var emptyPoint;\n\n    for(i = 0; i < n; i++) row.push(1);\n    for(i = 0; i < m; i++) z.push(row.slice());\n    for(i = 0; i < empties.length; i++) {\n        emptyPoint = empties[i];\n        z[emptyPoint[0]][emptyPoint[1]] = 0;\n    }\n    // save this mask to determine whether to show this data in hover\n    cd0.zmask = z;\n    return z;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}