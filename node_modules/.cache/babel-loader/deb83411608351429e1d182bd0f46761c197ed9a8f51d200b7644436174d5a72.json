{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createMatrix = require('regl-splom');\nvar arrayRange = require('array-range');\nvar Registry = require('../../registry');\nvar Grid = require('../../components/grid');\nvar Lib = require('../../lib');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar subTypes = require('../scatter/subtypes');\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar convertMarkerSelection = require('../scattergl/convert').markerSelection;\nvar convertMarkerStyle = require('../scattergl/convert').markerStyle;\nvar calcHover = require('../scattergl').calcHover;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\nfunction calc(gd, trace) {\n  var dimensions = trace.dimensions;\n  var commonLength = trace._length;\n  var opts = {};\n  // 'c' for calculated, 'l' for linear,\n  // only differ here for log axes, pass ldata to createMatrix as 'data'\n  var cdata = opts.cdata = [];\n  var ldata = opts.data = [];\n  // keep track of visible dimensions\n  var visibleDims = trace._visibleDims = [];\n  var i, k, dim, xa, ya;\n  function makeCalcdata(ax, dim) {\n    // call makeCalcdata with fake input\n    var ccol = ax.makeCalcdata({\n      v: dim.values,\n      vcalendar: trace.calendar\n    }, 'v');\n    for (var j = 0; j < ccol.length; j++) {\n      ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];\n    }\n    cdata.push(ccol);\n    ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);\n  }\n  for (i = 0; i < dimensions.length; i++) {\n    dim = dimensions[i];\n    if (dim.visible) {\n      xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n      ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n      // if corresponding x & y axes don't have matching types, skip dim\n      if (xa && ya && xa.type !== ya.type) {\n        Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');\n        continue;\n      }\n      if (xa) {\n        makeCalcdata(xa, dim);\n        if (ya && ya.type === 'category') {\n          ya._categories = xa._categories.slice();\n        }\n      } else {\n        // should not make it here, if both xa and ya undefined\n        makeCalcdata(ya, dim);\n      }\n      visibleDims.push(i);\n    }\n  }\n  calcColorscale(gd, trace);\n  Lib.extendFlat(opts, convertMarkerStyle(trace));\n  var visibleLength = cdata.length;\n  var hasTooManyPoints = visibleLength * commonLength > TOO_MANY_POINTS;\n\n  // Reuse SVG scatter axis expansion routine.\n  // For graphs with very large number of points and array marker.size,\n  // use average marker size instead to speed things up.\n  var ppad;\n  if (hasTooManyPoints) {\n    ppad = 2 * (opts.sizeAvg || Math.max(opts.size, 3));\n  } else {\n    ppad = calcMarkerSize(trace, commonLength);\n  }\n  for (k = 0; k < visibleDims.length; k++) {\n    i = visibleDims[k];\n    dim = dimensions[i];\n    xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n    ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n    calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n  }\n  var scene = sceneUpdate(gd, trace);\n  if (!scene.matrix) scene.matrix = true;\n  scene.matrixOptions = opts;\n  scene.selectedOptions = convertMarkerSelection(trace, trace.selected);\n  scene.unselectedOptions = convertMarkerSelection(trace, trace.unselected);\n  return [{\n    x: false,\n    y: false,\n    t: {},\n    trace: trace\n  }];\n}\nfunction sceneUpdate(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var uid = trace.uid;\n\n  // must place ref to 'scene' in fullLayout, so that:\n  // - it can be relinked properly on updates\n  // - it can be destroyed properly when needed\n  var splomScenes = fullLayout._splomScenes;\n  if (!splomScenes) splomScenes = fullLayout._splomScenes = {};\n  var reset = {\n    dirty: true\n  };\n  var first = {\n    selectBatch: null,\n    unselectBatch: null,\n    matrix: false,\n    select: null\n  };\n  var scene = splomScenes[trace.uid];\n  if (!scene) {\n    scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);\n    scene.draw = function draw() {\n      if (scene.matrix && scene.matrix.draw) {\n        if (scene.selectBatch) {\n          scene.matrix.draw(scene.unselectBatch, scene.selectBatch);\n        } else {\n          scene.matrix.draw();\n        }\n      }\n      scene.dirty = false;\n    };\n\n    // remove scene resources\n    scene.destroy = function destroy() {\n      if (scene.matrix && scene.matrix.destroy) {\n        scene.matrix.destroy();\n      }\n      scene.matrixOptions = null;\n      scene.selectBatch = null;\n      scene.unselectBatch = null;\n      scene = null;\n    };\n  }\n\n  // In case if we have scene from the last calc - reset data\n  if (!scene.dirty) {\n    Lib.extendFlat(scene, reset);\n  }\n  return scene;\n}\nfunction plot(gd, _, splomCalcData) {\n  if (!splomCalcData.length) return;\n  for (var i = 0; i < splomCalcData.length; i++) {\n    plotOne(gd, splomCalcData[i][0]);\n  }\n}\nfunction plotOne(gd, cd0) {\n  var fullLayout = gd._fullLayout;\n  var gs = fullLayout._size;\n  var trace = cd0.trace;\n  var stash = cd0.t;\n  var scene = fullLayout._splomScenes[trace.uid];\n  var matrixOpts = scene.matrixOptions;\n  var cdata = matrixOpts.cdata;\n  var regl = fullLayout._glcanvas.data()[0].regl;\n  var dragmode = fullLayout.dragmode;\n  var xa, ya;\n  var i, j, k;\n  if (cdata.length === 0) return;\n\n  // augment options with proper upper/lower halves\n  // regl-splom's default grid starts from bottom-left\n  matrixOpts.lower = trace.showupperhalf;\n  matrixOpts.upper = trace.showlowerhalf;\n  matrixOpts.diagonal = trace.diagonal.visible;\n  var visibleDims = trace._visibleDims;\n  var visibleLength = cdata.length;\n  var viewOpts = scene.viewOpts = {};\n  viewOpts.ranges = new Array(visibleLength);\n  viewOpts.domains = new Array(visibleLength);\n  for (k = 0; k < visibleDims.length; k++) {\n    i = visibleDims[k];\n    var rng = viewOpts.ranges[k] = new Array(4);\n    var dmn = viewOpts.domains[k] = new Array(4);\n    xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n    if (xa) {\n      rng[0] = xa._rl[0];\n      rng[2] = xa._rl[1];\n      dmn[0] = xa.domain[0];\n      dmn[2] = xa.domain[1];\n    }\n    ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n    if (ya) {\n      rng[1] = ya._rl[0];\n      rng[3] = ya._rl[1];\n      dmn[1] = ya.domain[0];\n      dmn[3] = ya.domain[1];\n    }\n  }\n  viewOpts.viewport = [gs.l, gs.b, gs.w + gs.l, gs.h + gs.b];\n  if (scene.matrix === true) {\n    scene.matrix = createMatrix(regl);\n  }\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n  var selectMode = dragmode === 'lasso' || dragmode === 'select' || !!trace.selectedpoints || clickSelectEnabled;\n  scene.selectBatch = null;\n  scene.unselectBatch = null;\n  if (selectMode) {\n    var commonLength = trace._length;\n    if (!scene.selectBatch) {\n      scene.selectBatch = [];\n      scene.unselectBatch = [];\n    }\n\n    // regenerate scene batch, if traces number changed during selection\n    if (trace.selectedpoints) {\n      scene.selectBatch = trace.selectedpoints;\n      var selPts = trace.selectedpoints;\n      var selDict = {};\n      for (i = 0; i < selPts.length; i++) {\n        selDict[selPts[i]] = true;\n      }\n      var unselPts = [];\n      for (i = 0; i < commonLength; i++) {\n        if (!selDict[i]) unselPts.push(i);\n      }\n      scene.unselectBatch = unselPts;\n    }\n\n    // precalculate px coords since we are not going to pan during select\n    var xpx = stash.xpx = new Array(visibleLength);\n    var ypx = stash.ypx = new Array(visibleLength);\n    for (k = 0; k < visibleDims.length; k++) {\n      i = visibleDims[k];\n      xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n      if (xa) {\n        xpx[k] = new Array(commonLength);\n        for (j = 0; j < commonLength; j++) {\n          xpx[k][j] = xa.c2p(cdata[k][j]);\n        }\n      }\n      ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n      if (ya) {\n        ypx[k] = new Array(commonLength);\n        for (j = 0; j < commonLength; j++) {\n          ypx[k][j] = ya.c2p(cdata[k][j]);\n        }\n      }\n    }\n    if (scene.selectBatch) {\n      scene.matrix.update(matrixOpts, matrixOpts);\n      scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n      scene.matrix.update(viewOpts, viewOpts);\n    } else {\n      // delete selection pass\n      scene.matrix.update(viewOpts, null);\n    }\n  } else {\n    var opts = Lib.extendFlat({}, matrixOpts, viewOpts);\n    scene.matrix.update(opts, null);\n    stash.xpx = stash.ypx = null;\n  }\n}\nfunction editStyle(gd, cd0) {\n  var trace = cd0.trace;\n  var scene = gd._fullLayout._splomScenes[trace.uid];\n  if (scene) {\n    calcColorscale(gd, trace);\n    Lib.extendFlat(scene.matrixOptions, convertMarkerStyle(trace));\n    // TODO [un]selected styles?\n\n    var opts = Lib.extendFlat({}, scene.matrixOptions, scene.viewOpts);\n\n    // TODO this is too long for arrayOk attributes!\n    scene.matrix.update(opts, null);\n  }\n}\nfunction hoverPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var scene = pointData.scene;\n  var cdata = scene.matrixOptions.cdata;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var maxDistance = pointData.distance;\n  var xi = getDimIndex(trace, xa);\n  var yi = getDimIndex(trace, ya);\n  if (xi === false || yi === false) return [pointData];\n  var x = cdata[xi];\n  var y = cdata[yi];\n  var id, dxy;\n  var minDist = maxDistance;\n  for (var i = 0; i < x.length; i++) {\n    var ptx = x[i];\n    var pty = y[i];\n    var dx = xa.c2p(ptx) - xpx;\n    var dy = ya.c2p(pty) - ypx;\n    var dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist < minDist) {\n      minDist = dxy = dist;\n      id = i;\n    }\n  }\n  pointData.index = id;\n  pointData.distance = minDist;\n  pointData.dxy = dxy;\n  if (id === undefined) return [pointData];\n  calcHover(pointData, x, y, trace);\n  return [pointData];\n}\nfunction selectPoints(searchInfo, selectionTester) {\n  var cd = searchInfo.cd;\n  var trace = cd[0].trace;\n  var stash = cd[0].t;\n  var scene = searchInfo.scene;\n  var cdata = scene.matrixOptions.cdata;\n  var xa = searchInfo.xaxis;\n  var ya = searchInfo.yaxis;\n  var selection = [];\n  var i;\n  if (!scene) return selection;\n  var hasOnlyLines = !subTypes.hasMarkers(trace) && !subTypes.hasText(trace);\n  if (trace.visible !== true || hasOnlyLines) return selection;\n  var xi = getDimIndex(trace, xa);\n  var yi = getDimIndex(trace, ya);\n  if (xi === false || yi === false) return selection;\n  var xpx = stash.xpx[xi];\n  var ypx = stash.ypx[yi];\n  var x = cdata[xi];\n  var y = cdata[yi];\n\n  // degenerate polygon does not enable selection\n  // filter out points by visible scatter ones\n  var els = null;\n  var unels = null;\n  if (selectionTester !== false && !selectionTester.degenerate) {\n    els = [], unels = [];\n    for (i = 0; i < x.length; i++) {\n      if (selectionTester.contains([xpx[i], ypx[i]], null, i, searchInfo)) {\n        els.push(i);\n        selection.push({\n          pointNumber: i,\n          x: x[i],\n          y: y[i]\n        });\n      } else {\n        unels.push(i);\n      }\n    }\n  } else {\n    unels = arrayRange(stash.count);\n  }\n\n  // make sure selectBatch is created\n  if (!scene.selectBatch) {\n    scene.selectBatch = [];\n    scene.unselectBatch = [];\n  }\n  if (!scene.selectBatch) {\n    // enter every trace select mode\n    for (i = 0; i < scene.count; i++) {\n      scene.selectBatch = [];\n      scene.unselectBatch = [];\n    }\n    // we should turn scatter2d into unselected once we have any points selected\n    scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n  }\n  scene.selectBatch = els;\n  scene.unselectBatch = unels;\n  return selection;\n}\nfunction getDimIndex(trace, ax) {\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var ind = {\n    x: 0,\n    y: 1\n  }[axLetter];\n  var visibleDims = trace._visibleDims;\n  for (var k = 0; k < visibleDims.length; k++) {\n    var i = visibleDims[k];\n    if (trace._diag[i][ind] === axId) return k;\n  }\n  return false;\n}\nmodule.exports = {\n  moduleType: 'trace',\n  name: 'splom',\n  basePlotModule: require('./base_plot'),\n  categories: ['gl', 'regl', 'cartesian', 'symbols', 'showLegend', 'scatter-like'],\n  attributes: require('./attributes'),\n  supplyDefaults: require('./defaults'),\n  colorbar: require('../scatter/marker_colorbar'),\n  calc: calc,\n  plot: plot,\n  hoverPoints: hoverPoints,\n  selectPoints: selectPoints,\n  editStyle: editStyle,\n  meta: {\n    description: ['Splom traces generate scatter plot matrix visualizations.', 'Each splom `dimensions` items correspond to a generated axis.', 'Values for each of those dimensions are set in `dimensions[i].values`.', 'Splom traces support all `scattergl` marker style attributes.', 'Specify `layout.grid` attributes and/or layout x-axis and y-axis attributes', 'for more control over the axis positioning and style. '].join(' ')\n  }\n};\n\n// splom traces use the 'grid' component to generate their axes,\n// register it here\nRegistry.register(Grid);","map":{"version":3,"names":["createMatrix","require","arrayRange","Registry","Grid","Lib","AxisIDs","subTypes","calcMarkerSize","calcAxisExpansion","calcColorscale","convertMarkerSelection","markerSelection","convertMarkerStyle","markerStyle","calcHover","BADNUM","TOO_MANY_POINTS","calc","gd","trace","dimensions","commonLength","_length","opts","cdata","ldata","data","visibleDims","_visibleDims","i","k","dim","xa","ya","makeCalcdata","ax","ccol","v","values","vcalendar","calendar","j","length","NaN","push","type","simpleMap","c2l","visible","getFromId","_diag","log","_categories","slice","extendFlat","visibleLength","hasTooManyPoints","ppad","sizeAvg","Math","max","size","scene","sceneUpdate","matrix","matrixOptions","selectedOptions","selected","unselectedOptions","unselected","x","y","t","fullLayout","_fullLayout","uid","splomScenes","_splomScenes","reset","dirty","first","selectBatch","unselectBatch","select","draw","destroy","plot","_","splomCalcData","plotOne","cd0","gs","_size","stash","matrixOpts","regl","_glcanvas","dragmode","lower","showupperhalf","upper","showlowerhalf","diagonal","viewOpts","ranges","Array","domains","rng","dmn","_rl","domain","viewport","l","b","w","h","clickSelectEnabled","clickmode","indexOf","selectMode","selectedpoints","selPts","selDict","unselPts","xpx","ypx","c2p","update","editStyle","hoverPoints","pointData","xval","yval","cd","maxDistance","distance","xi","getDimIndex","yi","id","dxy","minDist","ptx","pty","dx","dy","dist","sqrt","index","undefined","selectPoints","searchInfo","selectionTester","xaxis","yaxis","selection","hasOnlyLines","hasMarkers","hasText","els","unels","degenerate","contains","pointNumber","count","axId","_id","axLetter","charAt","ind","module","exports","moduleType","name","basePlotModule","categories","attributes","supplyDefaults","colorbar","meta","description","join","register"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/splom/index.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createMatrix = require('regl-splom');\nvar arrayRange = require('array-range');\n\nvar Registry = require('../../registry');\nvar Grid = require('../../components/grid');\nvar Lib = require('../../lib');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar subTypes = require('../scatter/subtypes');\nvar calcMarkerSize = require('../scatter/calc').calcMarkerSize;\nvar calcAxisExpansion = require('../scatter/calc').calcAxisExpansion;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar convertMarkerSelection = require('../scattergl/convert').markerSelection;\nvar convertMarkerStyle = require('../scattergl/convert').markerStyle;\nvar calcHover = require('../scattergl').calcHover;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('../scattergl/constants').TOO_MANY_POINTS;\n\nfunction calc(gd, trace) {\n    var dimensions = trace.dimensions;\n    var commonLength = trace._length;\n    var opts = {};\n    // 'c' for calculated, 'l' for linear,\n    // only differ here for log axes, pass ldata to createMatrix as 'data'\n    var cdata = opts.cdata = [];\n    var ldata = opts.data = [];\n    // keep track of visible dimensions\n    var visibleDims = trace._visibleDims = [];\n    var i, k, dim, xa, ya;\n\n    function makeCalcdata(ax, dim) {\n        // call makeCalcdata with fake input\n        var ccol = ax.makeCalcdata({\n            v: dim.values,\n            vcalendar: trace.calendar\n        }, 'v');\n\n        for(var j = 0; j < ccol.length; j++) {\n            ccol[j] = ccol[j] === BADNUM ? NaN : ccol[j];\n        }\n        cdata.push(ccol);\n        ldata.push(ax.type === 'log' ? Lib.simpleMap(ccol, ax.c2l) : ccol);\n    }\n\n    for(i = 0; i < dimensions.length; i++) {\n        dim = dimensions[i];\n\n        if(dim.visible) {\n            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n\n            // if corresponding x & y axes don't have matching types, skip dim\n            if(xa && ya && xa.type !== ya.type) {\n                Lib.log('Skipping splom dimension ' + i + ' with conflicting axis types');\n                continue;\n            }\n\n            if(xa) {\n                makeCalcdata(xa, dim);\n                if(ya && ya.type === 'category') {\n                    ya._categories = xa._categories.slice();\n                }\n            } else {\n                // should not make it here, if both xa and ya undefined\n                makeCalcdata(ya, dim);\n            }\n\n            visibleDims.push(i);\n        }\n    }\n\n    calcColorscale(gd, trace);\n    Lib.extendFlat(opts, convertMarkerStyle(trace));\n\n    var visibleLength = cdata.length;\n    var hasTooManyPoints = (visibleLength * commonLength) > TOO_MANY_POINTS;\n\n    // Reuse SVG scatter axis expansion routine.\n    // For graphs with very large number of points and array marker.size,\n    // use average marker size instead to speed things up.\n    var ppad;\n    if(hasTooManyPoints) {\n        ppad = 2 * (opts.sizeAvg || Math.max(opts.size, 3));\n    } else {\n        ppad = calcMarkerSize(trace, commonLength);\n    }\n\n    for(k = 0; k < visibleDims.length; k++) {\n        i = visibleDims[k];\n        dim = dimensions[i];\n        xa = AxisIDs.getFromId(gd, trace._diag[i][0]) || {};\n        ya = AxisIDs.getFromId(gd, trace._diag[i][1]) || {};\n        calcAxisExpansion(gd, trace, xa, ya, cdata[k], cdata[k], ppad);\n    }\n\n    var scene = sceneUpdate(gd, trace);\n    if(!scene.matrix) scene.matrix = true;\n    scene.matrixOptions = opts;\n\n    scene.selectedOptions = convertMarkerSelection(trace, trace.selected);\n    scene.unselectedOptions = convertMarkerSelection(trace, trace.unselected);\n\n    return [{x: false, y: false, t: {}, trace: trace}];\n}\n\nfunction sceneUpdate(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var uid = trace.uid;\n\n    // must place ref to 'scene' in fullLayout, so that:\n    // - it can be relinked properly on updates\n    // - it can be destroyed properly when needed\n    var splomScenes = fullLayout._splomScenes;\n    if(!splomScenes) splomScenes = fullLayout._splomScenes = {};\n\n    var reset = {dirty: true};\n\n    var first = {\n        selectBatch: null,\n        unselectBatch: null,\n        matrix: false,\n        select: null\n    };\n\n    var scene = splomScenes[trace.uid];\n\n    if(!scene) {\n        scene = splomScenes[uid] = Lib.extendFlat({}, reset, first);\n\n        scene.draw = function draw() {\n            if(scene.matrix && scene.matrix.draw) {\n                if(scene.selectBatch) {\n                    scene.matrix.draw(scene.unselectBatch, scene.selectBatch);\n                } else {\n                    scene.matrix.draw();\n                }\n            }\n\n            scene.dirty = false;\n        };\n\n        // remove scene resources\n        scene.destroy = function destroy() {\n            if(scene.matrix && scene.matrix.destroy) {\n                scene.matrix.destroy();\n            }\n            scene.matrixOptions = null;\n            scene.selectBatch = null;\n            scene.unselectBatch = null;\n            scene = null;\n        };\n    }\n\n    // In case if we have scene from the last calc - reset data\n    if(!scene.dirty) {\n        Lib.extendFlat(scene, reset);\n    }\n\n    return scene;\n}\n\nfunction plot(gd, _, splomCalcData) {\n    if(!splomCalcData.length) return;\n\n    for(var i = 0; i < splomCalcData.length; i++) {\n        plotOne(gd, splomCalcData[i][0]);\n    }\n}\n\nfunction plotOne(gd, cd0) {\n    var fullLayout = gd._fullLayout;\n    var gs = fullLayout._size;\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var scene = fullLayout._splomScenes[trace.uid];\n    var matrixOpts = scene.matrixOptions;\n    var cdata = matrixOpts.cdata;\n    var regl = fullLayout._glcanvas.data()[0].regl;\n    var dragmode = fullLayout.dragmode;\n    var xa, ya;\n    var i, j, k;\n\n    if(cdata.length === 0) return;\n\n    // augment options with proper upper/lower halves\n    // regl-splom's default grid starts from bottom-left\n    matrixOpts.lower = trace.showupperhalf;\n    matrixOpts.upper = trace.showlowerhalf;\n    matrixOpts.diagonal = trace.diagonal.visible;\n\n    var visibleDims = trace._visibleDims;\n    var visibleLength = cdata.length;\n    var viewOpts = scene.viewOpts = {};\n    viewOpts.ranges = new Array(visibleLength);\n    viewOpts.domains = new Array(visibleLength);\n\n    for(k = 0; k < visibleDims.length; k++) {\n        i = visibleDims[k];\n\n        var rng = viewOpts.ranges[k] = new Array(4);\n        var dmn = viewOpts.domains[k] = new Array(4);\n\n        xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n        if(xa) {\n            rng[0] = xa._rl[0];\n            rng[2] = xa._rl[1];\n            dmn[0] = xa.domain[0];\n            dmn[2] = xa.domain[1];\n        }\n\n        ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n        if(ya) {\n            rng[1] = ya._rl[0];\n            rng[3] = ya._rl[1];\n            dmn[1] = ya.domain[0];\n            dmn[3] = ya.domain[1];\n        }\n    }\n\n    viewOpts.viewport = [gs.l, gs.b, gs.w + gs.l, gs.h + gs.b];\n\n    if(scene.matrix === true) {\n        scene.matrix = createMatrix(regl);\n    }\n\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n    var selectMode = dragmode === 'lasso' || dragmode === 'select' ||\n      !!trace.selectedpoints || clickSelectEnabled;\n    scene.selectBatch = null;\n    scene.unselectBatch = null;\n\n    if(selectMode) {\n        var commonLength = trace._length;\n\n        if(!scene.selectBatch) {\n            scene.selectBatch = [];\n            scene.unselectBatch = [];\n        }\n\n        // regenerate scene batch, if traces number changed during selection\n        if(trace.selectedpoints) {\n            scene.selectBatch = trace.selectedpoints;\n\n            var selPts = trace.selectedpoints;\n            var selDict = {};\n            for(i = 0; i < selPts.length; i++) {\n                selDict[selPts[i]] = true;\n            }\n            var unselPts = [];\n            for(i = 0; i < commonLength; i++) {\n                if(!selDict[i]) unselPts.push(i);\n            }\n            scene.unselectBatch = unselPts;\n        }\n\n        // precalculate px coords since we are not going to pan during select\n        var xpx = stash.xpx = new Array(visibleLength);\n        var ypx = stash.ypx = new Array(visibleLength);\n\n        for(k = 0; k < visibleDims.length; k++) {\n            i = visibleDims[k];\n\n            xa = AxisIDs.getFromId(gd, trace._diag[i][0]);\n            if(xa) {\n                xpx[k] = new Array(commonLength);\n                for(j = 0; j < commonLength; j++) {\n                    xpx[k][j] = xa.c2p(cdata[k][j]);\n                }\n            }\n\n            ya = AxisIDs.getFromId(gd, trace._diag[i][1]);\n            if(ya) {\n                ypx[k] = new Array(commonLength);\n                for(j = 0; j < commonLength; j++) {\n                    ypx[k][j] = ya.c2p(cdata[k][j]);\n                }\n            }\n        }\n\n        if(scene.selectBatch) {\n            scene.matrix.update(matrixOpts, matrixOpts);\n            scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n            scene.matrix.update(viewOpts, viewOpts);\n        }\n        else {\n            // delete selection pass\n            scene.matrix.update(viewOpts, null);\n        }\n    }\n    else {\n        var opts = Lib.extendFlat({}, matrixOpts, viewOpts);\n        scene.matrix.update(opts, null);\n        stash.xpx = stash.ypx = null;\n    }\n}\n\nfunction editStyle(gd, cd0) {\n    var trace = cd0.trace;\n    var scene = gd._fullLayout._splomScenes[trace.uid];\n\n    if(scene) {\n        calcColorscale(gd, trace);\n\n        Lib.extendFlat(scene.matrixOptions, convertMarkerStyle(trace));\n        // TODO [un]selected styles?\n\n        var opts = Lib.extendFlat({}, scene.matrixOptions, scene.viewOpts);\n\n        // TODO this is too long for arrayOk attributes!\n        scene.matrix.update(opts, null);\n    }\n}\n\nfunction hoverPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var scene = pointData.scene;\n    var cdata = scene.matrixOptions.cdata;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var xpx = xa.c2p(xval);\n    var ypx = ya.c2p(yval);\n    var maxDistance = pointData.distance;\n\n    var xi = getDimIndex(trace, xa);\n    var yi = getDimIndex(trace, ya);\n    if(xi === false || yi === false) return [pointData];\n\n    var x = cdata[xi];\n    var y = cdata[yi];\n\n    var id, dxy;\n    var minDist = maxDistance;\n\n    for(var i = 0; i < x.length; i++) {\n        var ptx = x[i];\n        var pty = y[i];\n        var dx = xa.c2p(ptx) - xpx;\n        var dy = ya.c2p(pty) - ypx;\n        var dist = Math.sqrt(dx * dx + dy * dy);\n\n        if(dist < minDist) {\n            minDist = dxy = dist;\n            id = i;\n        }\n    }\n\n    pointData.index = id;\n    pointData.distance = minDist;\n    pointData.dxy = dxy;\n\n    if(id === undefined) return [pointData];\n\n    calcHover(pointData, x, y, trace);\n\n    return [pointData];\n}\n\nfunction selectPoints(searchInfo, selectionTester) {\n    var cd = searchInfo.cd;\n    var trace = cd[0].trace;\n    var stash = cd[0].t;\n    var scene = searchInfo.scene;\n    var cdata = scene.matrixOptions.cdata;\n    var xa = searchInfo.xaxis;\n    var ya = searchInfo.yaxis;\n    var selection = [];\n    var i;\n\n    if(!scene) return selection;\n\n    var hasOnlyLines = (!subTypes.hasMarkers(trace) && !subTypes.hasText(trace));\n    if(trace.visible !== true || hasOnlyLines) return selection;\n\n    var xi = getDimIndex(trace, xa);\n    var yi = getDimIndex(trace, ya);\n    if(xi === false || yi === false) return selection;\n\n    var xpx = stash.xpx[xi];\n    var ypx = stash.ypx[yi];\n    var x = cdata[xi];\n    var y = cdata[yi];\n\n    // degenerate polygon does not enable selection\n    // filter out points by visible scatter ones\n    var els = null;\n    var unels = null;\n    if(selectionTester !== false && !selectionTester.degenerate) {\n        els = [], unels = [];\n        for(i = 0; i < x.length; i++) {\n            if(selectionTester.contains([xpx[i], ypx[i]], null, i, searchInfo)) {\n                els.push(i);\n                selection.push({\n                    pointNumber: i,\n                    x: x[i],\n                    y: y[i]\n                });\n            }\n            else {\n                unels.push(i);\n            }\n        }\n    } else {\n        unels = arrayRange(stash.count);\n    }\n\n    // make sure selectBatch is created\n    if(!scene.selectBatch) {\n        scene.selectBatch = [];\n        scene.unselectBatch = [];\n    }\n\n    if(!scene.selectBatch) {\n        // enter every trace select mode\n        for(i = 0; i < scene.count; i++) {\n            scene.selectBatch = [];\n            scene.unselectBatch = [];\n        }\n        // we should turn scatter2d into unselected once we have any points selected\n        scene.matrix.update(scene.unselectedOptions, scene.selectedOptions);\n    }\n\n    scene.selectBatch = els;\n    scene.unselectBatch = unels;\n\n\n    return selection;\n}\n\nfunction getDimIndex(trace, ax) {\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var ind = {x: 0, y: 1}[axLetter];\n    var visibleDims = trace._visibleDims;\n\n    for(var k = 0; k < visibleDims.length; k++) {\n        var i = visibleDims[k];\n        if(trace._diag[i][ind] === axId) return k;\n    }\n    return false;\n}\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'splom',\n\n    basePlotModule: require('./base_plot'),\n    categories: ['gl', 'regl', 'cartesian', 'symbols', 'showLegend', 'scatter-like'],\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n    colorbar: require('../scatter/marker_colorbar'),\n\n    calc: calc,\n    plot: plot,\n    hoverPoints: hoverPoints,\n    selectPoints: selectPoints,\n    editStyle: editStyle,\n\n    meta: {\n        description: [\n            'Splom traces generate scatter plot matrix visualizations.',\n            'Each splom `dimensions` items correspond to a generated axis.',\n            'Values for each of those dimensions are set in `dimensions[i].values`.',\n            'Splom traces support all `scattergl` marker style attributes.',\n            'Specify `layout.grid` attributes and/or layout x-axis and y-axis attributes',\n            'for more control over the axis positioning and style. '\n        ].join(' ')\n    }\n};\n\n// splom traces use the 'grid' component to generate their axes,\n// register it here\nRegistry.register(Grid);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}