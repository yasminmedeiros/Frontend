{"ast":null,"code":"\"use strict\";\n\nmodule.exports = createSlabDecomposition;\nvar bounds = require(\"binary-search-bounds\");\nvar createRBTree = require(\"functional-red-black-tree\");\nvar orient = require(\"robust-orientation\");\nvar orderSegments = require(\"./lib/order-segments\");\nfunction SlabDecomposition(slabs, coordinates, horizontal) {\n  this.slabs = slabs;\n  this.coordinates = coordinates;\n  this.horizontal = horizontal;\n}\nvar proto = SlabDecomposition.prototype;\nfunction compareHorizontal(e, y) {\n  return e.y - y;\n}\nfunction searchBucket(root, p) {\n  var lastNode = null;\n  while (root) {\n    var seg = root.key;\n    var l, r;\n    if (seg[0][0] < seg[1][0]) {\n      l = seg[0];\n      r = seg[1];\n    } else {\n      l = seg[1];\n      r = seg[0];\n    }\n    var o = orient(l, r, p);\n    if (o < 0) {\n      root = root.left;\n    } else if (o > 0) {\n      if (p[0] !== seg[1][0]) {\n        lastNode = root;\n        root = root.right;\n      } else {\n        var val = searchBucket(root.right, p);\n        if (val) {\n          return val;\n        }\n        root = root.left;\n      }\n    } else {\n      if (p[0] !== seg[1][0]) {\n        return root;\n      } else {\n        var val = searchBucket(root.right, p);\n        if (val) {\n          return val;\n        }\n        root = root.left;\n      }\n    }\n  }\n  return lastNode;\n}\nproto.castUp = function (p) {\n  var bucket = bounds.le(this.coordinates, p[0]);\n  if (bucket < 0) {\n    return -1;\n  }\n  var root = this.slabs[bucket];\n  var hitNode = searchBucket(this.slabs[bucket], p);\n  var lastHit = -1;\n  if (hitNode) {\n    lastHit = hitNode.value;\n  }\n  //Edge case: need to handle horizontal segments (sucks)\n  if (this.coordinates[bucket] === p[0]) {\n    var lastSegment = null;\n    if (hitNode) {\n      lastSegment = hitNode.key;\n    }\n    if (bucket > 0) {\n      var otherHitNode = searchBucket(this.slabs[bucket - 1], p);\n      if (otherHitNode) {\n        if (lastSegment) {\n          if (orderSegments(otherHitNode.key, lastSegment) > 0) {\n            lastSegment = otherHitNode.key;\n            lastHit = otherHitNode.value;\n          }\n        } else {\n          lastHit = otherHitNode.value;\n          lastSegment = otherHitNode.key;\n        }\n      }\n    }\n    var horiz = this.horizontal[bucket];\n    if (horiz.length > 0) {\n      var hbucket = bounds.ge(horiz, p[1], compareHorizontal);\n      if (hbucket < horiz.length) {\n        var e = horiz[hbucket];\n        if (p[1] === e.y) {\n          if (e.closed) {\n            return e.index;\n          } else {\n            while (hbucket < horiz.length - 1 && horiz[hbucket + 1].y === p[1]) {\n              hbucket = hbucket + 1;\n              e = horiz[hbucket];\n              if (e.closed) {\n                return e.index;\n              }\n            }\n            if (e.y === p[1] && !e.start) {\n              hbucket = hbucket + 1;\n              if (hbucket >= horiz.length) {\n                return lastHit;\n              }\n              e = horiz[hbucket];\n            }\n          }\n        }\n        //Check if e is above/below last segment\n        if (e.start) {\n          if (lastSegment) {\n            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y]);\n            if (lastSegment[0][0] > lastSegment[1][0]) {\n              o = -o;\n            }\n            if (o > 0) {\n              lastHit = e.index;\n            }\n          } else {\n            lastHit = e.index;\n          }\n        } else if (e.y !== p[1]) {\n          lastHit = e.index;\n        }\n      }\n    }\n  }\n  return lastHit;\n};\nfunction IntervalSegment(y, index, start, closed) {\n  this.y = y;\n  this.index = index;\n  this.start = start;\n  this.closed = closed;\n}\nfunction Event(x, segment, create, index) {\n  this.x = x;\n  this.segment = segment;\n  this.create = create;\n  this.index = index;\n}\nfunction createSlabDecomposition(segments) {\n  var numSegments = segments.length;\n  var numEvents = 2 * numSegments;\n  var events = new Array(numEvents);\n  for (var i = 0; i < numSegments; ++i) {\n    var s = segments[i];\n    var f = s[0][0] < s[1][0];\n    events[2 * i] = new Event(s[0][0], s, f, i);\n    events[2 * i + 1] = new Event(s[1][0], s, !f, i);\n  }\n  events.sort(function (a, b) {\n    var d = a.x - b.x;\n    if (d) {\n      return d;\n    }\n    d = a.create - b.create;\n    if (d) {\n      return d;\n    }\n    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1]);\n  });\n  var tree = createRBTree(orderSegments);\n  var slabs = [];\n  var lines = [];\n  var horizontal = [];\n  var lastX = -Infinity;\n  for (var i = 0; i < numEvents;) {\n    var x = events[i].x;\n    var horiz = [];\n    while (i < numEvents) {\n      var e = events[i];\n      if (e.x !== x) {\n        break;\n      }\n      i += 1;\n      if (e.segment[0][0] === e.x && e.segment[1][0] === e.x) {\n        if (e.create) {\n          if (e.segment[0][1] < e.segment[1][1]) {\n            horiz.push(new IntervalSegment(e.segment[0][1], e.index, true, true));\n            horiz.push(new IntervalSegment(e.segment[1][1], e.index, false, false));\n          } else {\n            horiz.push(new IntervalSegment(e.segment[1][1], e.index, true, false));\n            horiz.push(new IntervalSegment(e.segment[0][1], e.index, false, true));\n          }\n        }\n      } else {\n        if (e.create) {\n          tree = tree.insert(e.segment, e.index);\n        } else {\n          tree = tree.remove(e.segment);\n        }\n      }\n    }\n    slabs.push(tree.root);\n    lines.push(x);\n    horizontal.push(horiz);\n  }\n  return new SlabDecomposition(slabs, lines, horizontal);\n}","map":{"version":3,"names":["module","exports","createSlabDecomposition","bounds","require","createRBTree","orient","orderSegments","SlabDecomposition","slabs","coordinates","horizontal","proto","prototype","compareHorizontal","e","y","searchBucket","root","p","lastNode","seg","key","l","r","o","left","right","val","castUp","bucket","le","hitNode","lastHit","value","lastSegment","otherHitNode","horiz","length","hbucket","ge","closed","index","start","IntervalSegment","Event","x","segment","create","segments","numSegments","numEvents","events","Array","i","s","f","sort","a","b","d","Math","min","tree","lines","lastX","Infinity","push","insert","remove"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/slab-decomposition/slabs.js"],"sourcesContent":["\"use strict\"\n\nmodule.exports = createSlabDecomposition\n\nvar bounds = require(\"binary-search-bounds\")\nvar createRBTree = require(\"functional-red-black-tree\")\nvar orient = require(\"robust-orientation\")\nvar orderSegments = require(\"./lib/order-segments\")\n\nfunction SlabDecomposition(slabs, coordinates, horizontal) {\n  this.slabs = slabs\n  this.coordinates = coordinates\n  this.horizontal = horizontal\n}\n\nvar proto = SlabDecomposition.prototype\n\nfunction compareHorizontal(e, y) {\n  return e.y - y\n}\n\nfunction searchBucket(root, p) {\n  var lastNode = null\n  while(root) {\n    var seg = root.key\n    var l, r\n    if(seg[0][0] < seg[1][0]) {\n      l = seg[0]\n      r = seg[1]\n    } else {\n      l = seg[1]\n      r = seg[0]\n    }\n    var o = orient(l, r, p)\n    if(o < 0) {\n      root = root.left\n    } else if(o > 0) {\n      if(p[0] !== seg[1][0]) {\n        lastNode = root\n        root = root.right\n      } else {\n        var val = searchBucket(root.right, p)\n        if(val) {\n          return val\n        }\n        root = root.left\n      }\n    } else {\n      if(p[0] !== seg[1][0]) {\n        return root\n      } else {\n        var val = searchBucket(root.right, p)\n        if(val) {\n          return val\n        }\n        root = root.left\n      }\n    }\n  }\n  return lastNode\n}\n\nproto.castUp = function(p) {\n  var bucket = bounds.le(this.coordinates, p[0])\n  if(bucket < 0) {\n    return -1\n  }\n  var root = this.slabs[bucket]\n  var hitNode = searchBucket(this.slabs[bucket], p)\n  var lastHit = -1\n  if(hitNode) {\n    lastHit = hitNode.value\n  }\n  //Edge case: need to handle horizontal segments (sucks)\n  if(this.coordinates[bucket] === p[0]) {\n    var lastSegment = null\n    if(hitNode) {\n      lastSegment = hitNode.key\n    }\n    if(bucket > 0) {\n      var otherHitNode = searchBucket(this.slabs[bucket-1], p)\n      if(otherHitNode) {\n        if(lastSegment) {\n          if(orderSegments(otherHitNode.key, lastSegment) > 0) {\n            lastSegment = otherHitNode.key\n            lastHit = otherHitNode.value\n          }\n        } else {\n          lastHit = otherHitNode.value\n          lastSegment = otherHitNode.key\n        }\n      }\n    }\n    var horiz = this.horizontal[bucket]\n    if(horiz.length > 0) {\n      var hbucket = bounds.ge(horiz, p[1], compareHorizontal)\n      if(hbucket < horiz.length) {\n        var e = horiz[hbucket]\n        if(p[1] === e.y) {\n          if(e.closed) {\n            return e.index\n          } else {\n            while(hbucket < horiz.length-1 && horiz[hbucket+1].y === p[1]) {\n              hbucket = hbucket+1\n              e = horiz[hbucket]\n              if(e.closed) {\n                return e.index\n              }\n            }\n            if(e.y === p[1] && !e.start) {\n              hbucket = hbucket+1\n              if(hbucket >= horiz.length) {\n                return lastHit\n              }\n              e = horiz[hbucket]\n            }\n          }\n        }\n        //Check if e is above/below last segment\n        if(e.start) {\n          if(lastSegment) {\n            var o = orient(lastSegment[0], lastSegment[1], [p[0], e.y])\n            if(lastSegment[0][0] > lastSegment[1][0]) {\n              o = -o\n            }\n            if(o > 0) {\n              lastHit = e.index\n            }\n          } else {\n            lastHit = e.index\n          }\n        } else if(e.y !== p[1]) {\n          lastHit = e.index\n        }\n      }\n    }\n  }\n  return lastHit\n}\n\nfunction IntervalSegment(y, index, start, closed) {\n  this.y = y\n  this.index = index\n  this.start = start\n  this.closed = closed\n}\n\nfunction Event(x, segment, create, index) {\n  this.x = x\n  this.segment = segment\n  this.create = create\n  this.index = index\n}\n\n\nfunction createSlabDecomposition(segments) {\n  var numSegments = segments.length\n  var numEvents = 2 * numSegments\n  var events = new Array(numEvents)\n  for(var i=0; i<numSegments; ++i) {\n    var s = segments[i]\n    var f = s[0][0] < s[1][0]\n    events[2*i] = new Event(s[0][0], s, f, i)\n    events[2*i+1] = new Event(s[1][0], s, !f, i)\n  }\n  events.sort(function(a,b) {\n    var d = a.x - b.x\n    if(d) {\n      return d\n    }\n    d = a.create - b.create\n    if(d) {\n      return d\n    }\n    return Math.min(a.segment[0][1], a.segment[1][1]) - Math.min(b.segment[0][1], b.segment[1][1])\n  })\n  var tree = createRBTree(orderSegments)\n  var slabs = []\n  var lines = []\n  var horizontal = []\n  var lastX = -Infinity\n  for(var i=0; i<numEvents; ) {\n    var x = events[i].x\n    var horiz = []\n    while(i < numEvents) {\n      var e = events[i]\n      if(e.x !== x) {\n        break\n      }\n      i += 1\n      if(e.segment[0][0] === e.x && e.segment[1][0] === e.x) {\n        if(e.create) {\n          if(e.segment[0][1] < e.segment[1][1]) {\n            horiz.push(new IntervalSegment(\n                e.segment[0][1],\n                e.index,\n                true,\n                true))\n            horiz.push(new IntervalSegment(\n                e.segment[1][1],\n                e.index,\n                false,\n                false))\n          } else {\n            horiz.push(new IntervalSegment(\n                e.segment[1][1],\n                e.index,\n                true,\n                false))\n            horiz.push(new IntervalSegment(\n                e.segment[0][1],\n                e.index,\n                false,\n                true))\n          }\n        }\n      } else {\n        if(e.create) {\n          tree = tree.insert(e.segment, e.index)\n        } else {\n          tree = tree.remove(e.segment)\n        }\n      }\n    }\n    slabs.push(tree.root)\n    lines.push(x)\n    horizontal.push(horiz)\n  }\n  return new SlabDecomposition(slabs, lines, horizontal)\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}