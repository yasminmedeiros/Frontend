{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar modModule = require('./mod');\nvar mod = modModule.mod;\nvar modHalf = modModule.modHalf;\nvar PI = Math.PI;\nvar twoPI = 2 * PI;\nfunction deg2rad(deg) {\n  return deg / 180 * PI;\n}\nfunction rad2deg(rad) {\n  return rad / PI * 180;\n}\n\n/**\n * is sector a full circle?\n * ... this comes up a lot in SVG path-drawing routines\n *\n * N.B. we consider all sectors that span more that 2pi 'full' circles\n *\n * @param {2-item array} aBnds : angular bounds in *radians*\n * @return {boolean}\n */\nfunction isFullCircle(aBnds) {\n  return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-15;\n}\n\n/**\n * angular delta between angle 'a' and 'b'\n * solution taken from: https://stackoverflow.com/a/2007279\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular delta in *radians*\n */\nfunction angleDelta(a, b) {\n  return modHalf(b - a, twoPI);\n}\n\n/**\n * angular distance between angle 'a' and 'b'\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular distance in *radians*\n */\nfunction angleDist(a, b) {\n  return Math.abs(angleDelta(a, b));\n}\n\n/**\n * is angle inside sector?\n *\n * @param {number} a : angle to test in *radians*\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @param {boolean}\n */\nfunction isAngleInsideSector(a, aBnds) {\n  if (isFullCircle(aBnds)) return true;\n  var s0, s1;\n  if (aBnds[0] < aBnds[1]) {\n    s0 = aBnds[0];\n    s1 = aBnds[1];\n  } else {\n    s0 = aBnds[1];\n    s1 = aBnds[0];\n  }\n  s0 = mod(s0, twoPI);\n  s1 = mod(s1, twoPI);\n  if (s0 > s1) s1 += twoPI;\n  var a0 = mod(a, twoPI);\n  var a1 = a0 + twoPI;\n  return a0 >= s0 && a0 <= s1 || a1 >= s0 && a1 <= s1;\n}\n\n/**\n * is pt (r,a) inside sector?\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @return {boolean}\n */\nfunction isPtInsideSector(r, a, rBnds, aBnds) {\n  if (!isAngleInsideSector(a, aBnds)) return false;\n  var r0, r1;\n  if (rBnds[0] < rBnds[1]) {\n    r0 = rBnds[0];\n    r1 = rBnds[1];\n  } else {\n    r0 = rBnds[1];\n    r1 = rBnds[0];\n  }\n  return r >= r0 && r <= r1;\n}\n\n// common to pathArc, pathSector and pathAnnulus\nfunction _path(r0, r1, a0, a1, cx, cy, isClosed) {\n  cx = cx || 0;\n  cy = cy || 0;\n  var isCircle = isFullCircle([a0, a1]);\n  var aStart, aMid, aEnd;\n  var rStart, rEnd;\n  if (isCircle) {\n    aStart = 0;\n    aMid = PI;\n    aEnd = twoPI;\n  } else {\n    if (a0 < a1) {\n      aStart = a0;\n      aEnd = a1;\n    } else {\n      aStart = a1;\n      aEnd = a0;\n    }\n  }\n  if (r0 < r1) {\n    rStart = r0;\n    rEnd = r1;\n  } else {\n    rStart = r1;\n    rEnd = r0;\n  }\n\n  // N.B. svg coordinates here, where y increases downward\n  function pt(r, a) {\n    return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];\n  }\n  var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;\n  function arc(r, a, cw) {\n    return 'A' + [r, r] + ' ' + [0, largeArc, cw] + ' ' + pt(r, a);\n  }\n  var p;\n  if (isCircle) {\n    if (rStart === null) {\n      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 0) + arc(rEnd, aEnd, 0) + 'Z';\n    } else {\n      p = 'M' + pt(rStart, aStart) + arc(rStart, aMid, 0) + arc(rStart, aEnd, 0) + 'Z' + 'M' + pt(rEnd, aStart) + arc(rEnd, aMid, 1) + arc(rEnd, aEnd, 1) + 'Z';\n    }\n  } else {\n    if (rStart === null) {\n      p = 'M' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);\n      if (isClosed) p += 'L0,0Z';\n    } else {\n      p = 'M' + pt(rStart, aStart) + 'L' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0) + 'L' + pt(rStart, aEnd) + arc(rStart, aStart, 1) + 'Z';\n    }\n  }\n  return p;\n}\n\n/**\n * path an arc\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathArc(r, a0, a1, cx, cy) {\n  return _path(null, r, a0, a1, cx, cy, 0);\n}\n\n/**\n * path a sector\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathSector(r, a0, a1, cx, cy) {\n  return _path(null, r, a0, a1, cx, cy, 1);\n}\n\n/**\n * path an annulus\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathAnnulus(r0, r1, a0, a1, cx, cy) {\n  return _path(r0, r1, a0, a1, cx, cy, 1);\n}\nmodule.exports = {\n  deg2rad: deg2rad,\n  rad2deg: rad2deg,\n  angleDelta: angleDelta,\n  angleDist: angleDist,\n  isFullCircle: isFullCircle,\n  isAngleInsideSector: isAngleInsideSector,\n  isPtInsideSector: isPtInsideSector,\n  pathArc: pathArc,\n  pathSector: pathSector,\n  pathAnnulus: pathAnnulus\n};","map":{"version":3,"names":["modModule","require","mod","modHalf","PI","Math","twoPI","deg2rad","deg","rad2deg","rad","isFullCircle","aBnds","abs","angleDelta","a","b","angleDist","isAngleInsideSector","s0","s1","a0","a1","isPtInsideSector","r","rBnds","r0","r1","_path","cx","cy","isClosed","isCircle","aStart","aMid","aEnd","rStart","rEnd","pt","cos","sin","largeArc","arc","cw","p","pathArc","pathSector","pathAnnulus","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/lib/angles.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar modModule = require('./mod');\nvar mod = modModule.mod;\nvar modHalf = modModule.modHalf;\n\nvar PI = Math.PI;\nvar twoPI = 2 * PI;\n\nfunction deg2rad(deg) { return deg / 180 * PI; }\n\nfunction rad2deg(rad) { return rad / PI * 180; }\n\n/**\n * is sector a full circle?\n * ... this comes up a lot in SVG path-drawing routines\n *\n * N.B. we consider all sectors that span more that 2pi 'full' circles\n *\n * @param {2-item array} aBnds : angular bounds in *radians*\n * @return {boolean}\n */\nfunction isFullCircle(aBnds) {\n    return Math.abs(aBnds[1] - aBnds[0]) > twoPI - 1e-15;\n}\n\n/**\n * angular delta between angle 'a' and 'b'\n * solution taken from: https://stackoverflow.com/a/2007279\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular delta in *radians*\n */\nfunction angleDelta(a, b) {\n    return modHalf(b - a, twoPI);\n}\n\n/**\n * angular distance between angle 'a' and 'b'\n *\n * @param {number} a : first angle in *radians*\n * @param {number} b : second angle in *radians*\n * @return {number} angular distance in *radians*\n */\nfunction angleDist(a, b) {\n    return Math.abs(angleDelta(a, b));\n}\n\n/**\n * is angle inside sector?\n *\n * @param {number} a : angle to test in *radians*\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @param {boolean}\n */\nfunction isAngleInsideSector(a, aBnds) {\n    if(isFullCircle(aBnds)) return true;\n\n    var s0, s1;\n\n    if(aBnds[0] < aBnds[1]) {\n        s0 = aBnds[0];\n        s1 = aBnds[1];\n    } else {\n        s0 = aBnds[1];\n        s1 = aBnds[0];\n    }\n\n    s0 = mod(s0, twoPI);\n    s1 = mod(s1, twoPI);\n    if(s0 > s1) s1 += twoPI;\n\n    var a0 = mod(a, twoPI);\n    var a1 = a0 + twoPI;\n\n    return (a0 >= s0 && a0 <= s1) || (a1 >= s0 && a1 <= s1);\n}\n\n/**\n * is pt (r,a) inside sector?\n *\n * @param {number} r : pt's radial coordinate\n * @param {number} a : pt's angular coordinate in *radians*\n * @param {2-item array} rBnds : sector's radial bounds\n * @param {2-item array} aBnds : sector's angular bounds in *radians*\n * @return {boolean}\n */\nfunction isPtInsideSector(r, a, rBnds, aBnds) {\n    if(!isAngleInsideSector(a, aBnds)) return false;\n\n    var r0, r1;\n\n    if(rBnds[0] < rBnds[1]) {\n        r0 = rBnds[0];\n        r1 = rBnds[1];\n    } else {\n        r0 = rBnds[1];\n        r1 = rBnds[0];\n    }\n\n    return r >= r0 && r <= r1;\n}\n\n// common to pathArc, pathSector and pathAnnulus\nfunction _path(r0, r1, a0, a1, cx, cy, isClosed) {\n    cx = cx || 0;\n    cy = cy || 0;\n\n    var isCircle = isFullCircle([a0, a1]);\n    var aStart, aMid, aEnd;\n    var rStart, rEnd;\n\n    if(isCircle) {\n        aStart = 0;\n        aMid = PI;\n        aEnd = twoPI;\n    } else {\n        if(a0 < a1) {\n            aStart = a0;\n            aEnd = a1;\n        } else {\n            aStart = a1;\n            aEnd = a0;\n        }\n    }\n\n    if(r0 < r1) {\n        rStart = r0;\n        rEnd = r1;\n    } else {\n        rStart = r1;\n        rEnd = r0;\n    }\n\n    // N.B. svg coordinates here, where y increases downward\n    function pt(r, a) {\n        return [r * Math.cos(a) + cx, cy - r * Math.sin(a)];\n    }\n\n    var largeArc = Math.abs(aEnd - aStart) <= PI ? 0 : 1;\n    function arc(r, a, cw) {\n        return 'A' + [r, r] + ' ' + [0, largeArc, cw] + ' ' + pt(r, a);\n    }\n\n    var p;\n\n    if(isCircle) {\n        if(rStart === null) {\n            p = 'M' + pt(rEnd, aStart) +\n                arc(rEnd, aMid, 0) +\n                arc(rEnd, aEnd, 0) + 'Z';\n        } else {\n            p = 'M' + pt(rStart, aStart) +\n                arc(rStart, aMid, 0) +\n                arc(rStart, aEnd, 0) + 'Z' +\n                'M' + pt(rEnd, aStart) +\n                arc(rEnd, aMid, 1) +\n                arc(rEnd, aEnd, 1) + 'Z';\n        }\n    } else {\n        if(rStart === null) {\n            p = 'M' + pt(rEnd, aStart) + arc(rEnd, aEnd, 0);\n            if(isClosed) p += 'L0,0Z';\n        } else {\n            p = 'M' + pt(rStart, aStart) +\n                'L' + pt(rEnd, aStart) +\n                arc(rEnd, aEnd, 0) +\n                'L' + pt(rStart, aEnd) +\n                arc(rStart, aStart, 1) + 'Z';\n        }\n    }\n\n    return p;\n}\n\n/**\n * path an arc\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathArc(r, a0, a1, cx, cy) {\n    return _path(null, r, a0, a1, cx, cy, 0);\n}\n\n/**\n * path a sector\n *\n * @param {number} r : radius\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathSector(r, a0, a1, cx, cy) {\n    return _path(null, r, a0, a1, cx, cy, 1);\n}\n\n/**\n * path an annulus\n *\n * @param {number} r0 : first radial coordinate\n * @param {number} r1 : second radial coordinate\n * @param {number} a0 : first angular coordinate in *radians*\n * @param {number} a1 : second angular coordinate in *radians*\n * @param {number (optional)} cx : x coordinate of center\n * @param {number (optional)} cy : y coordinate of center\n * @return {string} svg path\n */\nfunction pathAnnulus(r0, r1, a0, a1, cx, cy) {\n    return _path(r0, r1, a0, a1, cx, cy, 1);\n}\n\nmodule.exports = {\n    deg2rad: deg2rad,\n    rad2deg: rad2deg,\n    angleDelta: angleDelta,\n    angleDist: angleDist,\n    isFullCircle: isFullCircle,\n    isAngleInsideSector: isAngleInsideSector,\n    isPtInsideSector: isPtInsideSector,\n    pathArc: pathArc,\n    pathSector: pathSector,\n    pathAnnulus: pathAnnulus\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}