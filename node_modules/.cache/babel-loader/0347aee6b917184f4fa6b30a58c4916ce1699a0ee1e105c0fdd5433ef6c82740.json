{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar INTERPTHRESHOLD = 1e-2;\nvar NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\nfunction correctionOvershoot(maxFractionalChange) {\n  // start with less overshoot, until we know it's converging,\n  // then ramp up the overshoot for faster convergence\n  return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n\n/*\n * interp2d: Fill in missing data from a 2D array using an iterative\n *   poisson equation solver with zero-derivative BC at edges.\n *   Amazingly, this just amounts to repeatedly averaging all the existing\n *   nearest neighbors, at least if we don't take x/y scaling into account,\n *   which is the right approach here where x and y may not even have the\n *   same units.\n *\n * @param {array of arrays} z\n *      The 2D array to fill in. Will be mutated here. Assumed to already be\n *      cleaned, so all entries are numbers except gaps, which are `undefined`.\n * @param {array of arrays} emptyPoints\n *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number\n *      of neighbors that are *not* missing. Assumed to be sorted from most to\n *      least neighbors, as produced by heatmap/find_empties.\n */\nmodule.exports = function interp2d(z, emptyPoints) {\n  var maxFractionalChange = 1;\n  var i;\n\n  // one pass to fill in a starting value for all the empties\n  iterateInterp2d(z, emptyPoints);\n\n  // we're don't need to iterate lone empties - remove them\n  for (i = 0; i < emptyPoints.length; i++) {\n    if (emptyPoints[i][2] < 4) break;\n  }\n  // but don't remove these points from the original array,\n  // we'll use them for masking, so make a copy.\n  emptyPoints = emptyPoints.slice(i);\n  for (i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n    maxFractionalChange = iterateInterp2d(z, emptyPoints, correctionOvershoot(maxFractionalChange));\n  }\n  if (maxFractionalChange > INTERPTHRESHOLD) {\n    Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n  }\n  return z;\n};\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n  var maxFractionalChange = 0;\n  var thisPt;\n  var i;\n  var j;\n  var p;\n  var q;\n  var neighborShift;\n  var neighborRow;\n  var neighborVal;\n  var neighborCount;\n  var neighborSum;\n  var initialVal;\n  var minNeighbor;\n  var maxNeighbor;\n  for (p = 0; p < emptyPoints.length; p++) {\n    thisPt = emptyPoints[p];\n    i = thisPt[0];\n    j = thisPt[1];\n    initialVal = z[i][j];\n    neighborSum = 0;\n    neighborCount = 0;\n    for (q = 0; q < 4; q++) {\n      neighborShift = NEIGHBORSHIFTS[q];\n      neighborRow = z[i + neighborShift[0]];\n      if (!neighborRow) continue;\n      neighborVal = neighborRow[j + neighborShift[1]];\n      if (neighborVal !== undefined) {\n        if (neighborSum === 0) {\n          minNeighbor = maxNeighbor = neighborVal;\n        } else {\n          minNeighbor = Math.min(minNeighbor, neighborVal);\n          maxNeighbor = Math.max(maxNeighbor, neighborVal);\n        }\n        neighborCount++;\n        neighborSum += neighborVal;\n      }\n    }\n    if (neighborCount === 0) {\n      throw 'iterateInterp2d order is wrong: no defined neighbors';\n    }\n\n    // this is the laplace equation interpolation:\n    // each point is just the average of its neighbors\n    // note that this ignores differential x/y scaling\n    // which I think is the right approach, since we\n    // don't know what that scaling means\n    z[i][j] = neighborSum / neighborCount;\n    if (initialVal === undefined) {\n      if (neighborCount < 4) maxFractionalChange = 1;\n    } else {\n      // we can make large empty regions converge faster\n      // if we overshoot the change vs the previous value\n      z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n      if (maxNeighbor > minNeighbor) {\n        maxFractionalChange = Math.max(maxFractionalChange, Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n      }\n    }\n  }\n  return maxFractionalChange;\n}","map":{"version":3,"names":["Lib","require","INTERPTHRESHOLD","NEIGHBORSHIFTS","correctionOvershoot","maxFractionalChange","Math","min","module","exports","interp2d","z","emptyPoints","i","iterateInterp2d","length","slice","log","overshoot","thisPt","j","p","q","neighborShift","neighborRow","neighborVal","neighborCount","neighborSum","initialVal","minNeighbor","maxNeighbor","undefined","max","abs"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/heatmap/interp2d.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\n\nvar INTERPTHRESHOLD = 1e-2;\nvar NEIGHBORSHIFTS = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n\nfunction correctionOvershoot(maxFractionalChange) {\n    // start with less overshoot, until we know it's converging,\n    // then ramp up the overshoot for faster convergence\n    return 0.5 - 0.25 * Math.min(1, maxFractionalChange * 0.5);\n}\n\n/*\n * interp2d: Fill in missing data from a 2D array using an iterative\n *   poisson equation solver with zero-derivative BC at edges.\n *   Amazingly, this just amounts to repeatedly averaging all the existing\n *   nearest neighbors, at least if we don't take x/y scaling into account,\n *   which is the right approach here where x and y may not even have the\n *   same units.\n *\n * @param {array of arrays} z\n *      The 2D array to fill in. Will be mutated here. Assumed to already be\n *      cleaned, so all entries are numbers except gaps, which are `undefined`.\n * @param {array of arrays} emptyPoints\n *      Each entry [i, j, neighborCount] for empty points z[i][j] and the number\n *      of neighbors that are *not* missing. Assumed to be sorted from most to\n *      least neighbors, as produced by heatmap/find_empties.\n */\nmodule.exports = function interp2d(z, emptyPoints) {\n    var maxFractionalChange = 1;\n    var i;\n\n    // one pass to fill in a starting value for all the empties\n    iterateInterp2d(z, emptyPoints);\n\n    // we're don't need to iterate lone empties - remove them\n    for(i = 0; i < emptyPoints.length; i++) {\n        if(emptyPoints[i][2] < 4) break;\n    }\n    // but don't remove these points from the original array,\n    // we'll use them for masking, so make a copy.\n    emptyPoints = emptyPoints.slice(i);\n\n    for(i = 0; i < 100 && maxFractionalChange > INTERPTHRESHOLD; i++) {\n        maxFractionalChange = iterateInterp2d(z, emptyPoints,\n            correctionOvershoot(maxFractionalChange));\n    }\n    if(maxFractionalChange > INTERPTHRESHOLD) {\n        Lib.log('interp2d didn\\'t converge quickly', maxFractionalChange);\n    }\n\n    return z;\n};\n\nfunction iterateInterp2d(z, emptyPoints, overshoot) {\n    var maxFractionalChange = 0;\n    var thisPt;\n    var i;\n    var j;\n    var p;\n    var q;\n    var neighborShift;\n    var neighborRow;\n    var neighborVal;\n    var neighborCount;\n    var neighborSum;\n    var initialVal;\n    var minNeighbor;\n    var maxNeighbor;\n\n    for(p = 0; p < emptyPoints.length; p++) {\n        thisPt = emptyPoints[p];\n        i = thisPt[0];\n        j = thisPt[1];\n        initialVal = z[i][j];\n        neighborSum = 0;\n        neighborCount = 0;\n\n        for(q = 0; q < 4; q++) {\n            neighborShift = NEIGHBORSHIFTS[q];\n            neighborRow = z[i + neighborShift[0]];\n            if(!neighborRow) continue;\n            neighborVal = neighborRow[j + neighborShift[1]];\n            if(neighborVal !== undefined) {\n                if(neighborSum === 0) {\n                    minNeighbor = maxNeighbor = neighborVal;\n                }\n                else {\n                    minNeighbor = Math.min(minNeighbor, neighborVal);\n                    maxNeighbor = Math.max(maxNeighbor, neighborVal);\n                }\n                neighborCount++;\n                neighborSum += neighborVal;\n            }\n        }\n\n        if(neighborCount === 0) {\n            throw 'iterateInterp2d order is wrong: no defined neighbors';\n        }\n\n        // this is the laplace equation interpolation:\n        // each point is just the average of its neighbors\n        // note that this ignores differential x/y scaling\n        // which I think is the right approach, since we\n        // don't know what that scaling means\n        z[i][j] = neighborSum / neighborCount;\n\n        if(initialVal === undefined) {\n            if(neighborCount < 4) maxFractionalChange = 1;\n        }\n        else {\n            // we can make large empty regions converge faster\n            // if we overshoot the change vs the previous value\n            z[i][j] = (1 + overshoot) * z[i][j] - overshoot * initialVal;\n\n            if(maxNeighbor > minNeighbor) {\n                maxFractionalChange = Math.max(maxFractionalChange,\n                    Math.abs(z[i][j] - initialVal) / (maxNeighbor - minNeighbor));\n            }\n        }\n    }\n\n    return maxFractionalChange;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}