{"ast":null,"code":"'use strict';\n\nmodule.exports = {\n  init: sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete: sweepComplete,\n  scanBipartite: scanBipartite,\n  scanComplete: scanComplete\n};\nvar pool = require('typedarray-pool');\nvar bits = require('bit-twiddle');\nvar isort = require('./sort');\n\n//Flag for blue\nvar BLUE_FLAG = 1 << 28;\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY = 1024;\nvar RED_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar RED_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar BLUE_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY);\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY);\nvar SWEEP_EVENTS = pool.mallocDouble(INIT_CAPACITY * 8);\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count);\n  if (RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE);\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n  if (RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX);\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n  if (BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE);\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n  if (BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX);\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n  if (COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE);\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount);\n  }\n  if (COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX);\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount);\n  }\n  var eventLength = 8 * rcount;\n  if (SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS);\n    SWEEP_EVENTS = pool.mallocDouble(eventLength);\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item];\n  var top = queue[count - 1];\n  queue[idx] = top;\n  index[top] = idx;\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item;\n  index[item] = count;\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i];\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -(idx + 1);\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + BLUE_FLAG;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    if (e >= BLUE_FLAG) {\n      //blue destroy event\n      e = e - BLUE_FLAG | 0;\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e);\n    } else if (e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e);\n    } else if (e <= -BLUE_FLAG) {\n      //blue create event\n      e = -e - BLUE_FLAG | 0;\n      for (var j = 0; j < redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e);\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e);\n    } else {\n      //red create event\n      e = -e - 1 | 0;\n      for (var j = 0; j < blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j]);\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e);\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = d - 1;\n  var iend = elemSize - 1;\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = redIndex[i] + 1 << 1;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = blueIndex[i] + 1 << 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx | 1;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx | 1;\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  var blueActive = 0;\n  var commonActive = 0;\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    var color = e & 1;\n    if (i < n - 1 && e >> 1 === SWEEP_EVENTS[2 * i + 3] >> 1) {\n      color = 2;\n      i += 1;\n    }\n    if (e < 0) {\n      //Create event\n      var id = -(e >> 1) - 1;\n\n      //Intersect with common\n      for (var j = 0; j < commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id);\n        if (retval !== void 0) {\n          return retval;\n        }\n      }\n      if (color !== 0) {\n        //Intersect with red\n        for (var j = 0; j < redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id);\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n      if (color !== 1) {\n        //Intersect with blue\n        for (var j = 0; j < blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id);\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n      if (color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id);\n      } else if (color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id);\n      } else if (color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id);\n      }\n    } else {\n      //Destroy event\n      var id = (e >> 1) - 1;\n      if (color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id);\n      } else if (color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id);\n      } else if (color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id);\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n  var redShift = 1;\n  var blueShift = 1;\n  if (flip) {\n    blueShift = BLUE_FLAG;\n  } else {\n    redShift = BLUE_FLAG;\n  }\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + redShift;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + blueShift;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    if (e < 0) {\n      var idx = -e;\n      var isRed = false;\n      if (idx >= BLUE_FLAG) {\n        isRed = !flip;\n        idx -= BLUE_FLAG;\n      } else {\n        isRed = !!flip;\n        idx -= 1;\n      }\n      if (isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx);\n      } else {\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redPtr = elemSize * oidx;\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n          var redId = redIndex[oidx];\n          var retval;\n          if (flip) {\n            retval = visit(blueId, redId);\n          } else {\n            retval = visit(redId, blueId);\n          }\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift);\n    }\n  }\n}\nfunction scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex) {\n  var ptr = 0;\n  var elemSize = 2 * d;\n  var istart = axis;\n  var iend = axis + d;\n  for (var i = redStart; i < redEnd; ++i) {\n    var idx = i + BLUE_FLAG;\n    var redOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = red[redOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n    SWEEP_EVENTS[ptr++] = red[redOffset + iend];\n    SWEEP_EVENTS[ptr++] = idx;\n  }\n  for (var i = blueStart; i < blueEnd; ++i) {\n    var idx = i + 1;\n    var blueOffset = elemSize * i;\n    SWEEP_EVENTS[ptr++] = blue[blueOffset + istart];\n    SWEEP_EVENTS[ptr++] = -idx;\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1;\n  isort(SWEEP_EVENTS, n);\n  var redActive = 0;\n  for (var i = 0; i < n; ++i) {\n    var e = SWEEP_EVENTS[2 * i + 1] | 0;\n    if (e < 0) {\n      var idx = -e;\n      if (idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG;\n      } else {\n        idx -= 1;\n        var blueId = blueIndex[idx];\n        var bluePtr = elemSize * idx;\n        var b0 = blue[bluePtr + axis + 1];\n        var b1 = blue[bluePtr + axis + 1 + d];\n        red_loop: for (var j = 0; j < redActive; ++j) {\n          var oidx = RED_SWEEP_QUEUE[j];\n          var redId = redIndex[oidx];\n          if (redId === blueId) {\n            break;\n          }\n          var redPtr = elemSize * oidx;\n          if (b1 < red[redPtr + axis + 1] || red[redPtr + axis + 1 + d] < b0) {\n            continue;\n          }\n          for (var k = axis + 2; k < d; ++k) {\n            if (blue[bluePtr + k + d] < red[redPtr + k] || red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop;\n            }\n          }\n          var retval = visit(redId, blueId);\n          if (retval !== void 0) {\n            return retval;\n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG;\n      for (var j = redActive - 1; j >= 0; --j) {\n        if (RED_SWEEP_QUEUE[j] === idx) {\n          for (var k = j + 1; k < redActive; ++k) {\n            RED_SWEEP_QUEUE[k - 1] = RED_SWEEP_QUEUE[k];\n          }\n          break;\n        }\n      }\n      --redActive;\n    }\n  }\n}","map":{"version":3,"names":["module","exports","init","sqInit","sweepBipartite","sweepComplete","scanBipartite","scanComplete","pool","require","bits","isort","BLUE_FLAG","INIT_CAPACITY","RED_SWEEP_QUEUE","mallocInt32","RED_SWEEP_INDEX","BLUE_SWEEP_QUEUE","BLUE_SWEEP_INDEX","COMMON_SWEEP_QUEUE","COMMON_SWEEP_INDEX","SWEEP_EVENTS","mallocDouble","count","rcount","nextPow2","length","free","eventLength","sqPop","queue","index","item","idx","top","sqPush","d","visit","redStart","redEnd","red","redIndex","blueStart","blueEnd","blue","blueIndex","ptr","elemSize","istart","iend","i","redOffset","blueOffset","n","redActive","blueActive","e","j","retval","commonActive","color","id","axis","flip","redShift","blueShift","isRed","blueId","bluePtr","b0","b1","red_loop","oidx","redPtr","k","redId"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/box-intersect/lib/sweep.js"],"sourcesContent":["'use strict'\n\nmodule.exports = {\n  init:           sqInit,\n  sweepBipartite: sweepBipartite,\n  sweepComplete:  sweepComplete,\n  scanBipartite:  scanBipartite,\n  scanComplete:   scanComplete\n}\n\nvar pool  = require('typedarray-pool')\nvar bits  = require('bit-twiddle')\nvar isort = require('./sort')\n\n//Flag for blue\nvar BLUE_FLAG = (1<<28)\n\n//1D sweep event queue stuff (use pool to save space)\nvar INIT_CAPACITY      = 1024\nvar RED_SWEEP_QUEUE    = pool.mallocInt32(INIT_CAPACITY)\nvar RED_SWEEP_INDEX    = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_QUEUE   = pool.mallocInt32(INIT_CAPACITY)\nvar BLUE_SWEEP_INDEX   = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_QUEUE = pool.mallocInt32(INIT_CAPACITY)\nvar COMMON_SWEEP_INDEX = pool.mallocInt32(INIT_CAPACITY)\nvar SWEEP_EVENTS       = pool.mallocDouble(INIT_CAPACITY * 8)\n\n//Reserves memory for the 1D sweep data structures\nfunction sqInit(count) {\n  var rcount = bits.nextPow2(count)\n  if(RED_SWEEP_QUEUE.length < rcount) {\n    pool.free(RED_SWEEP_QUEUE)\n    RED_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(RED_SWEEP_INDEX.length < rcount) {\n    pool.free(RED_SWEEP_INDEX)\n    RED_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_QUEUE.length < rcount) {\n    pool.free(BLUE_SWEEP_QUEUE)\n    BLUE_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(BLUE_SWEEP_INDEX.length < rcount) {\n    pool.free(BLUE_SWEEP_INDEX)\n    BLUE_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_QUEUE.length < rcount) {\n    pool.free(COMMON_SWEEP_QUEUE)\n    COMMON_SWEEP_QUEUE = pool.mallocInt32(rcount)\n  }\n  if(COMMON_SWEEP_INDEX.length < rcount) {\n    pool.free(COMMON_SWEEP_INDEX)\n    COMMON_SWEEP_INDEX = pool.mallocInt32(rcount)\n  }\n  var eventLength = 8 * rcount\n  if(SWEEP_EVENTS.length < eventLength) {\n    pool.free(SWEEP_EVENTS)\n    SWEEP_EVENTS = pool.mallocDouble(eventLength)\n  }\n}\n\n//Remove an item from the active queue in O(1)\nfunction sqPop(queue, index, count, item) {\n  var idx = index[item]\n  var top = queue[count-1]\n  queue[idx] = top\n  index[top] = idx\n}\n\n//Insert an item into the active queue in O(1)\nfunction sqPush(queue, index, count, item) {\n  queue[count] = item\n  index[item]  = count\n}\n\n//Recursion base case: use 1D sweep algorithm\nfunction sweepBipartite(\n    d, visit,\n    redStart,  redEnd, red, redIndex,\n    blueStart, blueEnd, blue, blueIndex) {\n\n  //store events as pairs [coordinate, idx]\n  //\n  //  red create:  -(idx+1)\n  //  red destroy: idx\n  //  blue create: -(idx+BLUE_FLAG)\n  //  blue destroy: idx+BLUE_FLAG\n  //\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = redIndex[i]\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -(idx+1)\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = blueIndex[i]+BLUE_FLAG\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive  = 0\n  var blueActive = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e >= BLUE_FLAG) {\n      //blue destroy event\n      e = (e-BLUE_FLAG)|0\n      sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, e)\n    } else if(e >= 0) {\n      //red destroy event\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e)\n    } else if(e <= -BLUE_FLAG) {\n      //blue create event\n      e = (-e-BLUE_FLAG)|0\n      for(var j=0; j<redActive; ++j) {\n        var retval = visit(RED_SWEEP_QUEUE[j], e)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, e)\n    } else {\n      //red create event\n      e = (-e-1)|0\n      for(var j=0; j<blueActive; ++j) {\n        var retval = visit(e, BLUE_SWEEP_QUEUE[j])\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n      sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, e)\n    }\n  }\n}\n\n//Complete sweep\nfunction sweepComplete(d, visit, \n  redStart, redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = d-1\n  var iend     = elemSize-1\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = (redIndex[i]+1)<<1\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = (blueIndex[i]+1)<<1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = (-idx)|1\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx|1\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  var blueActive   = 0\n  var commonActive = 0\n  for(var i=0; i<n; ++i) {\n    var e     = SWEEP_EVENTS[2*i+1]|0\n    var color = e&1\n    if(i < n-1 && (e>>1) === (SWEEP_EVENTS[2*i+3]>>1)) {\n      color = 2\n      i += 1\n    }\n    \n    if(e < 0) {\n      //Create event\n      var id = -(e>>1) - 1\n\n      //Intersect with common\n      for(var j=0; j<commonActive; ++j) {\n        var retval = visit(COMMON_SWEEP_QUEUE[j], id)\n        if(retval !== void 0) {\n          return retval\n        }\n      }\n\n      if(color !== 0) {\n        //Intersect with red\n        for(var j=0; j<redActive; ++j) {\n          var retval = visit(RED_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color !== 1) {\n        //Intersect with blue\n        for(var j=0; j<blueActive; ++j) {\n          var retval = visit(BLUE_SWEEP_QUEUE[j], id)\n          if(retval !== void 0) {\n            return retval\n          }\n        }\n      }\n\n      if(color === 0) {\n        //Red\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, id)\n      } else if(color === 1) {\n        //Blue\n        sqPush(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive++, id)\n      } else if(color === 2) {\n        //Both\n        sqPush(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive++, id)\n      }\n    } else {\n      //Destroy event\n      var id = (e>>1) - 1\n      if(color === 0) {\n        //Red\n        sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, id)\n      } else if(color === 1) {\n        //Blue\n        sqPop(BLUE_SWEEP_QUEUE, BLUE_SWEEP_INDEX, blueActive--, id)\n      } else if(color === 2) {\n        //Both\n        sqPop(COMMON_SWEEP_QUEUE, COMMON_SWEEP_INDEX, commonActive--, id)\n      }\n    }\n  }\n}\n\n//Sweep and prune/scanline algorithm:\n//  Scan along axis, detect intersections\n//  Brute force all boxes along axis\nfunction scanBipartite(\n  d, axis, visit, flip,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n  \n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  var redShift  = 1\n  var blueShift = 1\n  if(flip) {\n    blueShift = BLUE_FLAG\n  } else {\n    redShift  = BLUE_FLAG\n  }\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + redShift\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + blueShift\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      var isRed = false\n      if(idx >= BLUE_FLAG) {\n        isRed = !flip\n        idx -= BLUE_FLAG \n      } else {\n        isRed = !!flip\n        idx -= 1\n      }\n      if(isRed) {\n        sqPush(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive++, idx)\n      } else {\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n        \n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redPtr = elemSize * oidx\n\n          if(b1 < red[redPtr+axis+1] || \n             red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d] < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var redId  = redIndex[oidx]\n          var retval\n          if(flip) {\n            retval = visit(blueId, redId)\n          } else {\n            retval = visit(redId, blueId)\n          }\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      sqPop(RED_SWEEP_QUEUE, RED_SWEEP_INDEX, redActive--, e - redShift)\n    }\n  }\n}\n\nfunction scanComplete(\n  d, axis, visit,\n  redStart,  redEnd, red, redIndex,\n  blueStart, blueEnd, blue, blueIndex) {\n\n  var ptr      = 0\n  var elemSize = 2*d\n  var istart   = axis\n  var iend     = axis+d\n\n  for(var i=redStart; i<redEnd; ++i) {\n    var idx = i + BLUE_FLAG\n    var redOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = red[redOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n    SWEEP_EVENTS[ptr++] = red[redOffset+iend]\n    SWEEP_EVENTS[ptr++] = idx\n  }\n  for(var i=blueStart; i<blueEnd; ++i) {\n    var idx = i + 1\n    var blueOffset = elemSize*i\n    SWEEP_EVENTS[ptr++] = blue[blueOffset+istart]\n    SWEEP_EVENTS[ptr++] = -idx\n  }\n\n  //process events from left->right\n  var n = ptr >>> 1\n  isort(SWEEP_EVENTS, n)\n  \n  var redActive    = 0\n  for(var i=0; i<n; ++i) {\n    var e = SWEEP_EVENTS[2*i+1]|0\n    if(e < 0) {\n      var idx   = -e\n      if(idx >= BLUE_FLAG) {\n        RED_SWEEP_QUEUE[redActive++] = idx - BLUE_FLAG\n      } else {\n        idx -= 1\n        var blueId  = blueIndex[idx]\n        var bluePtr = elemSize * idx\n\n        var b0 = blue[bluePtr+axis+1]\n        var b1 = blue[bluePtr+axis+1+d]\n\nred_loop:\n        for(var j=0; j<redActive; ++j) {\n          var oidx   = RED_SWEEP_QUEUE[j]\n          var redId  = redIndex[oidx]\n\n          if(redId === blueId) {\n            break\n          }\n\n          var redPtr = elemSize * oidx\n          if(b1 < red[redPtr+axis+1] || \n            red[redPtr+axis+1+d] < b0) {\n            continue\n          }\n          for(var k=axis+2; k<d; ++k) {\n            if(blue[bluePtr + k + d] < red[redPtr + k] || \n               red[redPtr + k + d]   < blue[bluePtr + k]) {\n              continue red_loop\n            }\n          }\n\n          var retval = visit(redId, blueId)\n          if(retval !== void 0) {\n            return retval \n          }\n        }\n      }\n    } else {\n      var idx = e - BLUE_FLAG\n      for(var j=redActive-1; j>=0; --j) {\n        if(RED_SWEEP_QUEUE[j] === idx) {\n          for(var k=j+1; k<redActive; ++k) {\n            RED_SWEEP_QUEUE[k-1] = RED_SWEEP_QUEUE[k]\n          }\n          break\n        }\n      }\n      --redActive\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}