{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar PlotSchema = require('./plot_schema');\nvar dfltConfig = require('./plot_config').dfltConfig;\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\nmodule.exports = function validate(data, layout) {\n  var schema = PlotSchema.get();\n  var errorList = [];\n  var gd = {\n    _context: Lib.extendFlat({}, dfltConfig)\n  };\n  var dataIn, layoutIn;\n  if (isArray(data)) {\n    gd.data = Lib.extendDeep([], data);\n    dataIn = data;\n  } else {\n    gd.data = [];\n    dataIn = [];\n    errorList.push(format('array', 'data'));\n  }\n  if (isPlainObject(layout)) {\n    gd.layout = Lib.extendDeep({}, layout);\n    layoutIn = layout;\n  } else {\n    gd.layout = {};\n    layoutIn = {};\n    if (arguments.length > 1) {\n      errorList.push(format('object', 'layout'));\n    }\n  }\n\n  // N.B. dataIn and layoutIn are in general not the same as\n  // gd.data and gd.layout after supplyDefaults as some attributes\n  // in gd.data and gd.layout (still) get mutated during this step.\n\n  Plots.supplyDefaults(gd);\n  var dataOut = gd._fullData;\n  var len = dataIn.length;\n  for (var i = 0; i < len; i++) {\n    var traceIn = dataIn[i];\n    var base = ['data', i];\n    if (!isPlainObject(traceIn)) {\n      errorList.push(format('object', base));\n      continue;\n    }\n    var traceOut = dataOut[i];\n    var traceType = traceOut.type;\n    var traceSchema = schema.traces[traceType].attributes;\n\n    // PlotSchema does something fancy with trace 'type', reset it here\n    // to make the trace schema compatible with Lib.validate.\n    traceSchema.type = {\n      valType: 'enumerated',\n      values: [traceType]\n    };\n    if (traceOut.visible === false && traceIn.visible !== false) {\n      errorList.push(format('invisible', base));\n    }\n    crawl(traceIn, traceOut, traceSchema, errorList, base);\n    var transformsIn = traceIn.transforms;\n    var transformsOut = traceOut.transforms;\n    if (transformsIn) {\n      if (!isArray(transformsIn)) {\n        errorList.push(format('array', base, ['transforms']));\n      }\n      base.push('transforms');\n      for (var j = 0; j < transformsIn.length; j++) {\n        var path = ['transforms', j];\n        var transformType = transformsIn[j].type;\n        if (!isPlainObject(transformsIn[j])) {\n          errorList.push(format('object', base, path));\n          continue;\n        }\n        var transformSchema = schema.transforms[transformType] ? schema.transforms[transformType].attributes : {};\n\n        // add 'type' to transform schema to validate the transform type\n        transformSchema.type = {\n          valType: 'enumerated',\n          values: Object.keys(schema.transforms)\n        };\n        crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n      }\n    }\n  }\n  var layoutOut = gd._fullLayout;\n  var layoutSchema = fillLayoutSchema(schema, dataOut);\n  crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');\n\n  // return undefined if no validation errors were found\n  return errorList.length === 0 ? void 0 : errorList;\n};\nfunction crawl(objIn, objOut, schema, list, base, path) {\n  path = path || [];\n  var keys = Object.keys(objIn);\n  for (var i = 0; i < keys.length; i++) {\n    var k = keys[i];\n\n    // transforms are handled separately\n    if (k === 'transforms') continue;\n    var p = path.slice();\n    p.push(k);\n    var valIn = objIn[k];\n    var valOut = objOut[k];\n    var nestedSchema = getNestedSchema(schema, k);\n    var isInfoArray = (nestedSchema || {}).valType === 'info_array';\n    var isColorscale = (nestedSchema || {}).valType === 'colorscale';\n    var items = (nestedSchema || {}).items;\n    if (!isInSchema(schema, k)) {\n      list.push(format('schema', base, p));\n    } else if (isPlainObject(valIn) && isPlainObject(valOut)) {\n      crawl(valIn, valOut, nestedSchema, list, base, p);\n    } else if (isInfoArray && isArray(valIn)) {\n      if (valIn.length > valOut.length) {\n        list.push(format('unused', base, p.concat(valOut.length)));\n      }\n      var len = valOut.length;\n      var arrayItems = Array.isArray(items);\n      if (arrayItems) len = Math.min(len, items.length);\n      var m, n, item, valInPart, valOutPart;\n      if (nestedSchema.dimensions === 2) {\n        for (n = 0; n < len; n++) {\n          if (isArray(valIn[n])) {\n            if (valIn[n].length > valOut[n].length) {\n              list.push(format('unused', base, p.concat(n, valOut[n].length)));\n            }\n            var len2 = valOut[n].length;\n            for (m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {\n              item = arrayItems ? items[n][m] : items;\n              valInPart = valIn[n][m];\n              valOutPart = valOut[n][m];\n              if (!Lib.validate(valInPart, item)) {\n                list.push(format('value', base, p.concat(n, m), valInPart));\n              } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));\n              }\n            }\n          } else {\n            list.push(format('array', base, p.concat(n), valIn[n]));\n          }\n        }\n      } else {\n        for (n = 0; n < len; n++) {\n          item = arrayItems ? items[n] : items;\n          valInPart = valIn[n];\n          valOutPart = valOut[n];\n          if (!Lib.validate(valInPart, item)) {\n            list.push(format('value', base, p.concat(n), valInPart));\n          } else if (valOutPart !== valInPart && valOutPart !== +valInPart) {\n            list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));\n          }\n        }\n      }\n    } else if (nestedSchema.items && !isInfoArray && isArray(valIn)) {\n      var _nestedSchema = items[Object.keys(items)[0]];\n      var indexList = [];\n      var j, _p;\n\n      // loop over valOut items while keeping track of their\n      // corresponding input container index (given by _index)\n      for (j = 0; j < valOut.length; j++) {\n        var _index = valOut[j]._index || j;\n        _p = p.slice();\n        _p.push(_index);\n        if (isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n          indexList.push(_index);\n          var valInj = valIn[_index];\n          var valOutj = valOut[j];\n          if (isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {\n            list.push(format('invisible', base, _p));\n          } else crawl(valInj, valOutj, _nestedSchema, list, base, _p);\n        }\n      }\n\n      // loop over valIn to determine where it went wrong for some items\n      for (j = 0; j < valIn.length; j++) {\n        _p = p.slice();\n        _p.push(j);\n        if (!isPlainObject(valIn[j])) {\n          list.push(format('object', base, _p, valIn[j]));\n        } else if (indexList.indexOf(j) === -1) {\n          list.push(format('unused', base, _p));\n        }\n      }\n    } else if (!isPlainObject(valIn) && isPlainObject(valOut)) {\n      list.push(format('object', base, p, valIn));\n    } else if (!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {\n      list.push(format('array', base, p, valIn));\n    } else if (!(k in objOut)) {\n      list.push(format('unused', base, p, valIn));\n    } else if (!Lib.validate(valIn, nestedSchema)) {\n      list.push(format('value', base, p, valIn));\n    } else if (nestedSchema.valType === 'enumerated' && (nestedSchema.coerceNumber && valIn !== +valOut || valIn !== valOut)) {\n      list.push(format('dynamic', base, p, valIn, valOut));\n    }\n  }\n  return list;\n}\n\n// the 'full' layout schema depends on the traces types presents\nfunction fillLayoutSchema(schema, dataOut) {\n  var layoutSchema = schema.layout.layoutAttributes;\n  for (var i = 0; i < dataOut.length; i++) {\n    var traceOut = dataOut[i];\n    var traceSchema = schema.traces[traceOut.type];\n    var traceLayoutAttr = traceSchema.layoutAttributes;\n    if (traceLayoutAttr) {\n      if (traceOut.subplot) {\n        Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);\n      } else {\n        Lib.extendFlat(layoutSchema, traceLayoutAttr);\n      }\n    }\n  }\n  return layoutSchema;\n}\n\n// validation error codes\nvar code2msgFunc = {\n  object: function object(base, astr) {\n    var prefix;\n    if (base === 'layout' && astr === '') prefix = 'The layout argument';else if (base[0] === 'data' && astr === '') {\n      prefix = 'Trace ' + base[1] + ' in the data argument';\n    } else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an object container';\n  },\n  array: function array(base, astr) {\n    var prefix;\n    if (base === 'data') prefix = 'The data argument';else prefix = inBase(base) + 'key ' + astr;\n    return prefix + ' must be linked to an array container';\n  },\n  schema: function schema(base, astr) {\n    return inBase(base) + 'key ' + astr + ' is not part of the schema';\n  },\n  unused: function unused(base, astr, valIn) {\n    var target = isPlainObject(valIn) ? 'container' : 'key';\n    return inBase(base) + target + ' ' + astr + ' did not get coerced';\n  },\n  dynamic: function dynamic(base, astr, valIn, valOut) {\n    return [inBase(base) + 'key', astr, '(set to \\'' + valIn + '\\')', 'got reset to', '\\'' + valOut + '\\'', 'during defaults.'].join(' ');\n  },\n  invisible: function invisible(base, astr) {\n    return (astr ? inBase(base) + 'item ' + astr : 'Trace ' + base[1]) + ' got defaulted to be not visible';\n  },\n  value: function value(base, astr, valIn) {\n    return [inBase(base) + 'key ' + astr, 'is set to an invalid value (' + valIn + ')'].join(' ');\n  }\n};\nfunction inBase(base) {\n  if (isArray(base)) return 'In data trace ' + base[1] + ', ';\n  return 'In ' + base + ', ';\n}\nfunction format(code, base, path, valIn, valOut) {\n  path = path || '';\n  var container, trace;\n\n  // container is either 'data' or 'layout\n  // trace is the trace index if 'data', null otherwise\n\n  if (isArray(base)) {\n    container = base[0];\n    trace = base[1];\n  } else {\n    container = base;\n    trace = null;\n  }\n  var astr = convertPathToAttributeString(path);\n  var msg = code2msgFunc[code](base, astr, valIn, valOut);\n\n  // log to console if logger config option is enabled\n  Lib.log(msg);\n  return {\n    code: code,\n    container: container,\n    trace: trace,\n    path: path,\n    astr: astr,\n    msg: msg\n  };\n}\nfunction isInSchema(schema, key) {\n  var parts = splitKey(key);\n  var keyMinusId = parts.keyMinusId;\n  var id = parts.id;\n  if (keyMinusId in schema && schema[keyMinusId]._isSubplotObj && id) {\n    return true;\n  }\n  return key in schema;\n}\nfunction getNestedSchema(schema, key) {\n  if (key in schema) return schema[key];\n  var parts = splitKey(key);\n  return schema[parts.keyMinusId];\n}\nvar idRegex = Lib.counterRegex('([a-z]+)');\nfunction splitKey(key) {\n  var idMatch = key.match(idRegex);\n  return {\n    keyMinusId: idMatch && idMatch[1],\n    id: idMatch && idMatch[2]\n  };\n}\nfunction convertPathToAttributeString(path) {\n  if (!isArray(path)) return String(path);\n  var astr = '';\n  for (var i = 0; i < path.length; i++) {\n    var p = path[i];\n    if (typeof p === 'number') {\n      astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n    } else {\n      astr += p;\n    }\n    if (i < path.length - 1) astr += '.';\n  }\n  return astr;\n}","map":{"version":3,"names":["Lib","require","Plots","PlotSchema","dfltConfig","isPlainObject","isArray","Array","isArrayOrTypedArray","module","exports","validate","data","layout","schema","get","errorList","gd","_context","extendFlat","dataIn","layoutIn","extendDeep","push","format","arguments","length","supplyDefaults","dataOut","_fullData","len","i","traceIn","base","traceOut","traceType","type","traceSchema","traces","attributes","valType","values","visible","crawl","transformsIn","transforms","transformsOut","j","path","transformType","transformSchema","Object","keys","layoutOut","_fullLayout","layoutSchema","fillLayoutSchema","objIn","objOut","list","k","p","slice","valIn","valOut","nestedSchema","getNestedSchema","isInfoArray","isColorscale","items","isInSchema","concat","arrayItems","Math","min","m","n","item","valInPart","valOutPart","dimensions","len2","_nestedSchema","indexList","_p","_index","valInj","valOutj","indexOf","coerceNumber","layoutAttributes","traceLayoutAttr","subplot","dflt","code2msgFunc","object","astr","prefix","inBase","array","unused","target","dynamic","join","invisible","value","code","container","trace","convertPathToAttributeString","msg","log","key","parts","splitKey","keyMinusId","id","_isSubplotObj","idRegex","counterRegex","idMatch","match","String","substr"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/plot_api/validate.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Plots = require('../plots/plots');\nvar PlotSchema = require('./plot_schema');\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar isPlainObject = Lib.isPlainObject;\nvar isArray = Array.isArray;\nvar isArrayOrTypedArray = Lib.isArrayOrTypedArray;\n\n/**\n * Validate a data array and layout object.\n *\n * @param {array} data\n * @param {object} layout\n *\n * @return {array} array of error objects each containing:\n *  - {string} code\n *      error code ('object', 'array', 'schema', 'unused', 'invisible' or 'value')\n *  - {string} container\n *      container where the error occurs ('data' or 'layout')\n *  - {number} trace\n *      trace index of the 'data' container where the error occurs\n *  - {array} path\n *      nested path to the key that causes the error\n *  - {string} astr\n *      attribute string variant of 'path' compatible with Plotly.restyle and\n *      Plotly.relayout.\n *  - {string} msg\n *      error message (shown in console in logger config argument is enable)\n */\nmodule.exports = function validate(data, layout) {\n    var schema = PlotSchema.get();\n    var errorList = [];\n    var gd = {_context: Lib.extendFlat({}, dfltConfig)};\n\n    var dataIn, layoutIn;\n\n    if(isArray(data)) {\n        gd.data = Lib.extendDeep([], data);\n        dataIn = data;\n    }\n    else {\n        gd.data = [];\n        dataIn = [];\n        errorList.push(format('array', 'data'));\n    }\n\n    if(isPlainObject(layout)) {\n        gd.layout = Lib.extendDeep({}, layout);\n        layoutIn = layout;\n    }\n    else {\n        gd.layout = {};\n        layoutIn = {};\n        if(arguments.length > 1) {\n            errorList.push(format('object', 'layout'));\n        }\n    }\n\n    // N.B. dataIn and layoutIn are in general not the same as\n    // gd.data and gd.layout after supplyDefaults as some attributes\n    // in gd.data and gd.layout (still) get mutated during this step.\n\n    Plots.supplyDefaults(gd);\n\n    var dataOut = gd._fullData;\n    var len = dataIn.length;\n\n    for(var i = 0; i < len; i++) {\n        var traceIn = dataIn[i];\n        var base = ['data', i];\n\n        if(!isPlainObject(traceIn)) {\n            errorList.push(format('object', base));\n            continue;\n        }\n\n        var traceOut = dataOut[i];\n        var traceType = traceOut.type;\n        var traceSchema = schema.traces[traceType].attributes;\n\n        // PlotSchema does something fancy with trace 'type', reset it here\n        // to make the trace schema compatible with Lib.validate.\n        traceSchema.type = {\n            valType: 'enumerated',\n            values: [traceType]\n        };\n\n        if(traceOut.visible === false && traceIn.visible !== false) {\n            errorList.push(format('invisible', base));\n        }\n\n        crawl(traceIn, traceOut, traceSchema, errorList, base);\n\n        var transformsIn = traceIn.transforms;\n        var transformsOut = traceOut.transforms;\n\n        if(transformsIn) {\n            if(!isArray(transformsIn)) {\n                errorList.push(format('array', base, ['transforms']));\n            }\n\n            base.push('transforms');\n\n            for(var j = 0; j < transformsIn.length; j++) {\n                var path = ['transforms', j];\n                var transformType = transformsIn[j].type;\n\n                if(!isPlainObject(transformsIn[j])) {\n                    errorList.push(format('object', base, path));\n                    continue;\n                }\n\n                var transformSchema = schema.transforms[transformType] ?\n                    schema.transforms[transformType].attributes :\n                    {};\n\n                // add 'type' to transform schema to validate the transform type\n                transformSchema.type = {\n                    valType: 'enumerated',\n                    values: Object.keys(schema.transforms)\n                };\n\n                crawl(transformsIn[j], transformsOut[j], transformSchema, errorList, base, path);\n            }\n        }\n    }\n\n    var layoutOut = gd._fullLayout;\n    var layoutSchema = fillLayoutSchema(schema, dataOut);\n\n    crawl(layoutIn, layoutOut, layoutSchema, errorList, 'layout');\n\n    // return undefined if no validation errors were found\n    return (errorList.length === 0) ? void(0) : errorList;\n};\n\nfunction crawl(objIn, objOut, schema, list, base, path) {\n    path = path || [];\n\n    var keys = Object.keys(objIn);\n\n    for(var i = 0; i < keys.length; i++) {\n        var k = keys[i];\n\n        // transforms are handled separately\n        if(k === 'transforms') continue;\n\n        var p = path.slice();\n        p.push(k);\n\n        var valIn = objIn[k];\n        var valOut = objOut[k];\n\n        var nestedSchema = getNestedSchema(schema, k);\n        var isInfoArray = (nestedSchema || {}).valType === 'info_array';\n        var isColorscale = (nestedSchema || {}).valType === 'colorscale';\n        var items = (nestedSchema || {}).items;\n\n        if(!isInSchema(schema, k)) {\n            list.push(format('schema', base, p));\n        }\n        else if(isPlainObject(valIn) && isPlainObject(valOut)) {\n            crawl(valIn, valOut, nestedSchema, list, base, p);\n        }\n        else if(isInfoArray && isArray(valIn)) {\n            if(valIn.length > valOut.length) {\n                list.push(format('unused', base, p.concat(valOut.length)));\n            }\n            var len = valOut.length;\n            var arrayItems = Array.isArray(items);\n            if(arrayItems) len = Math.min(len, items.length);\n            var m, n, item, valInPart, valOutPart;\n            if(nestedSchema.dimensions === 2) {\n                for(n = 0; n < len; n++) {\n                    if(isArray(valIn[n])) {\n                        if(valIn[n].length > valOut[n].length) {\n                            list.push(format('unused', base, p.concat(n, valOut[n].length)));\n                        }\n                        var len2 = valOut[n].length;\n                        for(m = 0; m < (arrayItems ? Math.min(len2, items[n].length) : len2); m++) {\n                            item = arrayItems ? items[n][m] : items;\n                            valInPart = valIn[n][m];\n                            valOutPart = valOut[n][m];\n                            if(!Lib.validate(valInPart, item)) {\n                                list.push(format('value', base, p.concat(n, m), valInPart));\n                            }\n                            else if(valOutPart !== valInPart && valOutPart !== +valInPart) {\n                                list.push(format('dynamic', base, p.concat(n, m), valInPart, valOutPart));\n                            }\n                        }\n                    }\n                    else {\n                        list.push(format('array', base, p.concat(n), valIn[n]));\n                    }\n                }\n            }\n            else {\n                for(n = 0; n < len; n++) {\n                    item = arrayItems ? items[n] : items;\n                    valInPart = valIn[n];\n                    valOutPart = valOut[n];\n                    if(!Lib.validate(valInPart, item)) {\n                        list.push(format('value', base, p.concat(n), valInPart));\n                    }\n                    else if(valOutPart !== valInPart && valOutPart !== +valInPart) {\n                        list.push(format('dynamic', base, p.concat(n), valInPart, valOutPart));\n                    }\n                }\n            }\n        }\n        else if(nestedSchema.items && !isInfoArray && isArray(valIn)) {\n            var _nestedSchema = items[Object.keys(items)[0]];\n            var indexList = [];\n\n            var j, _p;\n\n            // loop over valOut items while keeping track of their\n            // corresponding input container index (given by _index)\n            for(j = 0; j < valOut.length; j++) {\n                var _index = valOut[j]._index || j;\n\n                _p = p.slice();\n                _p.push(_index);\n\n                if(isPlainObject(valIn[_index]) && isPlainObject(valOut[j])) {\n                    indexList.push(_index);\n                    var valInj = valIn[_index];\n                    var valOutj = valOut[j];\n                    if(isPlainObject(valInj) && valInj.visible !== false && valOutj.visible === false) {\n                        list.push(format('invisible', base, _p));\n                    }\n                    else crawl(valInj, valOutj, _nestedSchema, list, base, _p);\n                }\n            }\n\n            // loop over valIn to determine where it went wrong for some items\n            for(j = 0; j < valIn.length; j++) {\n                _p = p.slice();\n                _p.push(j);\n\n                if(!isPlainObject(valIn[j])) {\n                    list.push(format('object', base, _p, valIn[j]));\n                }\n                else if(indexList.indexOf(j) === -1) {\n                    list.push(format('unused', base, _p));\n                }\n            }\n        }\n        else if(!isPlainObject(valIn) && isPlainObject(valOut)) {\n            list.push(format('object', base, p, valIn));\n        }\n        else if(!isArrayOrTypedArray(valIn) && isArrayOrTypedArray(valOut) && !isInfoArray && !isColorscale) {\n            list.push(format('array', base, p, valIn));\n        }\n        else if(!(k in objOut)) {\n            list.push(format('unused', base, p, valIn));\n        }\n        else if(!Lib.validate(valIn, nestedSchema)) {\n            list.push(format('value', base, p, valIn));\n        }\n        else if(nestedSchema.valType === 'enumerated' &&\n            ((nestedSchema.coerceNumber && valIn !== +valOut) || valIn !== valOut)\n        ) {\n            list.push(format('dynamic', base, p, valIn, valOut));\n        }\n    }\n\n    return list;\n}\n\n// the 'full' layout schema depends on the traces types presents\nfunction fillLayoutSchema(schema, dataOut) {\n    var layoutSchema = schema.layout.layoutAttributes;\n\n    for(var i = 0; i < dataOut.length; i++) {\n        var traceOut = dataOut[i];\n        var traceSchema = schema.traces[traceOut.type];\n        var traceLayoutAttr = traceSchema.layoutAttributes;\n\n        if(traceLayoutAttr) {\n            if(traceOut.subplot) {\n                Lib.extendFlat(layoutSchema[traceSchema.attributes.subplot.dflt], traceLayoutAttr);\n            } else {\n                Lib.extendFlat(layoutSchema, traceLayoutAttr);\n            }\n        }\n    }\n\n    return layoutSchema;\n}\n\n// validation error codes\nvar code2msgFunc = {\n    object: function(base, astr) {\n        var prefix;\n\n        if(base === 'layout' && astr === '') prefix = 'The layout argument';\n        else if(base[0] === 'data' && astr === '') {\n            prefix = 'Trace ' + base[1] + ' in the data argument';\n        }\n        else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an object container';\n    },\n    array: function(base, astr) {\n        var prefix;\n\n        if(base === 'data') prefix = 'The data argument';\n        else prefix = inBase(base) + 'key ' + astr;\n\n        return prefix + ' must be linked to an array container';\n    },\n    schema: function(base, astr) {\n        return inBase(base) + 'key ' + astr + ' is not part of the schema';\n    },\n    unused: function(base, astr, valIn) {\n        var target = isPlainObject(valIn) ? 'container' : 'key';\n\n        return inBase(base) + target + ' ' + astr + ' did not get coerced';\n    },\n    dynamic: function(base, astr, valIn, valOut) {\n        return [\n            inBase(base) + 'key',\n            astr,\n            '(set to \\'' + valIn + '\\')',\n            'got reset to',\n            '\\'' + valOut + '\\'',\n            'during defaults.'\n        ].join(' ');\n    },\n    invisible: function(base, astr) {\n        return (\n            astr ? (inBase(base) + 'item ' + astr) : ('Trace ' + base[1])\n        ) + ' got defaulted to be not visible';\n    },\n    value: function(base, astr, valIn) {\n        return [\n            inBase(base) + 'key ' + astr,\n            'is set to an invalid value (' + valIn + ')'\n        ].join(' ');\n    }\n};\n\nfunction inBase(base) {\n    if(isArray(base)) return 'In data trace ' + base[1] + ', ';\n\n    return 'In ' + base + ', ';\n}\n\nfunction format(code, base, path, valIn, valOut) {\n    path = path || '';\n\n    var container, trace;\n\n    // container is either 'data' or 'layout\n    // trace is the trace index if 'data', null otherwise\n\n    if(isArray(base)) {\n        container = base[0];\n        trace = base[1];\n    }\n    else {\n        container = base;\n        trace = null;\n    }\n\n    var astr = convertPathToAttributeString(path);\n    var msg = code2msgFunc[code](base, astr, valIn, valOut);\n\n    // log to console if logger config option is enabled\n    Lib.log(msg);\n\n    return {\n        code: code,\n        container: container,\n        trace: trace,\n        path: path,\n        astr: astr,\n        msg: msg\n    };\n}\n\nfunction isInSchema(schema, key) {\n    var parts = splitKey(key);\n    var keyMinusId = parts.keyMinusId;\n    var id = parts.id;\n\n    if((keyMinusId in schema) && schema[keyMinusId]._isSubplotObj && id) {\n        return true;\n    }\n\n    return (key in schema);\n}\n\nfunction getNestedSchema(schema, key) {\n    if(key in schema) return schema[key];\n\n    var parts = splitKey(key);\n\n    return schema[parts.keyMinusId];\n}\n\nvar idRegex = Lib.counterRegex('([a-z]+)');\n\nfunction splitKey(key) {\n    var idMatch = key.match(idRegex);\n\n    return {\n        keyMinusId: idMatch && idMatch[1],\n        id: idMatch && idMatch[2]\n    };\n}\n\nfunction convertPathToAttributeString(path) {\n    if(!isArray(path)) return String(path);\n\n    var astr = '';\n\n    for(var i = 0; i < path.length; i++) {\n        var p = path[i];\n\n        if(typeof p === 'number') {\n            astr = astr.substr(0, astr.length - 1) + '[' + p + ']';\n        }\n        else {\n            astr += p;\n        }\n\n        if(i < path.length - 1) astr += '.';\n    }\n\n    return astr;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}