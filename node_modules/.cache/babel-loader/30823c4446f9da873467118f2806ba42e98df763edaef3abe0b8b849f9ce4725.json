{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar setConvertPolar = require('./set_convert');\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\nvar dragBox = require('../cartesian/dragbox');\nvar dragElement = require('../../components/dragelement');\nvar Fx = require('../../components/fx');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../cartesian/select').prepSelect;\nvar selectOnClick = require('../cartesian/select').selectOnClick;\nvar clearSelect = require('../cartesian/select').clearSelect;\nvar setCursor = require('../../lib/setcursor');\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar constants = require('./constants');\nvar helpers = require('./helpers');\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\nfunction Polar(gd, id) {\n  this.id = id;\n  this.gd = gd;\n  this._hasClipOnAxisFalse = null;\n  this.vangles = null;\n  this.radialAxisAngle = null;\n  this.traceHash = {};\n  this.layers = {};\n  this.clipPaths = {};\n  this.clipIds = {};\n  this.viewInitial = {};\n  var fullLayout = gd._fullLayout;\n  var clipIdBase = 'clip' + fullLayout._uid + id;\n  this.clipIds.forTraces = clipIdBase + '-for-traces';\n  this.clipPaths.forTraces = fullLayout._clips.append('clipPath').attr('id', this.clipIds.forTraces);\n  this.clipPaths.forTraces.append('path');\n  this.framework = fullLayout._polarlayer.append('g').attr('class', id);\n\n  // unfortunately, we have to keep track of some axis tick settings\n  // as polar subplots do not implement the 'ticks' editType\n  this.radialTickLayout = null;\n  this.angularTickLayout = null;\n}\nvar proto = Polar.prototype;\nmodule.exports = function createPolar(gd, id) {\n  return new Polar(gd, id);\n};\nproto.plot = function (polarCalcData, fullLayout) {\n  var _this = this;\n  var polarLayout = fullLayout[_this.id];\n  _this._hasClipOnAxisFalse = false;\n  for (var i = 0; i < polarCalcData.length; i++) {\n    var trace = polarCalcData[i][0].trace;\n    if (trace.cliponaxis === false) {\n      _this._hasClipOnAxisFalse = true;\n      break;\n    }\n  }\n  _this.updateLayers(fullLayout, polarLayout);\n  _this.updateLayout(fullLayout, polarLayout);\n  Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n  _this.updateFx(fullLayout, polarLayout);\n};\nproto.updateLayers = function (fullLayout, polarLayout) {\n  var _this = this;\n  var layers = _this.layers;\n  var radialLayout = polarLayout.radialaxis;\n  var angularLayout = polarLayout.angularaxis;\n  var layerNames = constants.layerNames;\n  var frontPlotIndex = layerNames.indexOf('frontplot');\n  var layerData = layerNames.slice(0, frontPlotIndex);\n  var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n  var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n  if (isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (isRadialAxisBelowTraces) layerData.push('radial-axis');\n  layerData.push('frontplot');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-line');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-line');\n  if (!isAngularAxisBelowTraces) layerData.push('angular-axis');\n  if (!isRadialAxisBelowTraces) layerData.push('radial-axis');\n  var join = _this.framework.selectAll('.polarsublayer').data(layerData, String);\n  join.enter().append('g').attr('class', function (d) {\n    return 'polarsublayer ' + d;\n  }).each(function (d) {\n    var sel = layers[d] = d3.select(this);\n    switch (d) {\n      case 'frontplot':\n        // TODO add option to place in 'backplot' layer??\n        sel.append('g').classed('barlayer', true);\n        sel.append('g').classed('scatterlayer', true);\n        break;\n      case 'backplot':\n        sel.append('g').classed('maplayer', true);\n        break;\n      case 'plotbg':\n        layers.bg = sel.append('path');\n        break;\n      case 'radial-grid':\n        sel.style('fill', 'none');\n        break;\n      case 'angular-grid':\n        sel.style('fill', 'none');\n        break;\n      case 'radial-line':\n        sel.append('line').style('fill', 'none');\n        break;\n      case 'angular-line':\n        sel.append('path').style('fill', 'none');\n        break;\n    }\n  });\n  join.order();\n};\n\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - polarLayout.radialaxis (aka radialLayout in this file):\n * - polarLayout.angularaxis (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends polarLayout.radialaxis, adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends polarLayout.angularaxis, adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\nproto.updateLayout = function (fullLayout, polarLayout) {\n  var _this = this;\n  var layers = _this.layers;\n  var gs = fullLayout._size;\n\n  // axis attributes\n  var radialLayout = polarLayout.radialaxis;\n  var angularLayout = polarLayout.angularaxis;\n  // layout domains\n  var xDomain = polarLayout.domain.x;\n  var yDomain = polarLayout.domain.y;\n  // offsets from paper edge to layout domain box\n  _this.xOffset = gs.l + gs.w * xDomain[0];\n  _this.yOffset = gs.t + gs.h * (1 - yDomain[1]);\n  // lengths of the layout domain box\n  var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n  var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]);\n  // sector to plot\n  var sector = polarLayout.sector;\n  _this.sectorInRad = sector.map(deg2rad);\n  var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n  var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n  var dySectorBBox = sectorBBox[3] - sectorBBox[1];\n  // aspect ratios\n  var arDomain = yLength / xLength;\n  var arSector = Math.abs(dySectorBBox / dxSectorBBox);\n  // actual lengths and domains of subplot box\n  var xLength2, yLength2;\n  var xDomain2, yDomain2;\n  var gap;\n  if (arDomain > arSector) {\n    xLength2 = xLength;\n    yLength2 = xLength * arSector;\n    gap = (yLength - yLength2) / gs.h / 2;\n    xDomain2 = [xDomain[0], xDomain[1]];\n    yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n  } else {\n    xLength2 = yLength / arSector;\n    yLength2 = yLength;\n    gap = (xLength - xLength2) / gs.w / 2;\n    xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n    yDomain2 = [yDomain[0], yDomain[1]];\n  }\n  _this.xLength2 = xLength2;\n  _this.yLength2 = yLength2;\n  _this.xDomain2 = xDomain2;\n  _this.yDomain2 = yDomain2;\n  // actual offsets from paper edge to the subplot box top-left corner\n  var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n  var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]);\n  // circle radius in px\n  var radius = _this.radius = xLength2 / dxSectorBBox;\n  // 'inner' radius in px (when polar.hole is set)\n  var innerRadius = _this.innerRadius = polarLayout.hole * radius;\n  // circle center position in px\n  var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n  var cy = _this.cy = yOffset2 + radius * sectorBBox[3];\n  // circle center in the coordinate system of plot area\n  var cxx = _this.cxx = cx - xOffset2;\n  var cyy = _this.cyy = cy - yOffset2;\n  _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n    // make this an 'x' axis to make positioning (especially rotation) easier\n    _id: 'x',\n    // convert to 'x' axis equivalent\n    side: {\n      counterclockwise: 'top',\n      clockwise: 'bottom'\n    }[radialLayout.side],\n    // spans length 1 radius\n    domain: [innerRadius / gs.w, radius / gs.w]\n  });\n  _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n    side: 'right',\n    // to get auto nticks right\n    domain: [0, Math.PI],\n    // don't pass through autorange logic\n    autorange: false\n  });\n  _this.doAutoRange(fullLayout, polarLayout);\n  // N.B. this sets _this.vangles\n  _this.updateAngularAxis(fullLayout, polarLayout);\n  // N.B. this sets _this.radialAxisAngle\n  _this.updateRadialAxis(fullLayout, polarLayout);\n  _this.updateRadialAxisTitle(fullLayout, polarLayout);\n  _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'x',\n    domain: xDomain2\n  });\n  _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n    _id: 'y',\n    domain: yDomain2\n  });\n  var dPath = _this.pathSubplot();\n  _this.clipPaths.forTraces.select('path').attr('d', dPath).attr('transform', strTranslate(cxx, cyy));\n  layers.frontplot.attr('transform', strTranslate(xOffset2, yOffset2)).call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n  layers.bg.attr('d', dPath).attr('transform', strTranslate(cx, cy)).call(Color.fill, polarLayout.bgcolor);\n};\nproto.mockAxis = function (fullLayout, polarLayout, axLayout, opts) {\n  var commonOpts = {\n    // to get _boundingBox computation right when showticklabels is false\n    anchor: 'free',\n    position: 0\n  };\n  var ax = Lib.extendFlat(commonOpts, axLayout, opts);\n  setConvertPolar(ax, polarLayout, fullLayout);\n  return ax;\n};\nproto.mockCartesianAxis = function (fullLayout, polarLayout, opts) {\n  var _this = this;\n  var axId = opts._id;\n  var ax = Lib.extendFlat({\n    type: 'linear'\n  }, opts);\n  setConvertCartesian(ax, fullLayout);\n  var bboxIndices = {\n    x: [0, 2],\n    y: [1, 3]\n  };\n  ax.setRange = function () {\n    var sectorBBox = _this.sectorBBox;\n    var ind = bboxIndices[axId];\n    var rl = _this.radialAxis._rl;\n    var drl = (rl[1] - rl[0]) / (1 - polarLayout.hole);\n    ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n  };\n  ax.isPtWithinRange = axId === 'x' ? function (d) {\n    return _this.isPtInside(d);\n  } : function () {\n    return true;\n  };\n  ax.setRange();\n  ax.setScale();\n  return ax;\n};\nproto.doAutoRange = function (fullLayout, polarLayout) {\n  var gd = this.gd;\n  var radialAxis = this.radialAxis;\n  var radialLayout = polarLayout.radialaxis;\n  radialAxis.setScale();\n  doAutoRange(gd, radialAxis);\n  var rng = radialAxis.range;\n  radialLayout.range = rng.slice();\n  radialLayout._input.range = rng.slice();\n  radialAxis._rl = [radialAxis.r2l(rng[0], null, 'gregorian'), radialAxis.r2l(rng[1], null, 'gregorian')];\n};\nproto.updateRadialAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialLayout = polarLayout.radialaxis;\n  var a0 = mod(polarLayout.sector[0], 360);\n  var ax = _this.radialAxis;\n  var hasRoomForIt = innerRadius < radius;\n  _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n  _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n  ax.setGeometry();\n\n  // rotate auto tick labels by 180 if in quadrant II and III to make them\n  // readable from left-to-right\n  //\n  // TODO try moving deeper in Axes.drawLabels for better results?\n  if (ax.tickangle === 'auto' && a0 > 90 && a0 <= 270) {\n    ax.tickangle = 180;\n  }\n\n  // easier to set rotate angle with custom translate function\n  var transFn = function transFn(d) {\n    return 'translate(' + (ax.l2p(d.x) + innerRadius) + ',0)';\n  };\n\n  // set special grid path function\n  var gridPathFn = function gridPathFn(d) {\n    return _this.pathArc(ax.r2p(d.x) + innerRadius);\n  };\n  var newTickLayout = strTickLayout(radialLayout);\n  if (_this.radialTickLayout !== newTickLayout) {\n    layers['radial-axis'].selectAll('.xtick').remove();\n    _this.radialTickLayout = newTickLayout;\n  }\n  if (hasRoomForIt) {\n    ax.setScale();\n    var vals = Axes.calcTicks(ax);\n    var valsClipped = Axes.clipEnds(ax, vals);\n    var labelFns = Axes.makeLabelFns(ax, 0);\n    var tickSign = Axes.getTickSigns(ax)[2];\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      path: Axes.makeTickPath(ax, 0, tickSign),\n      transFn: transFn,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: valsClipped,\n      layer: layers['radial-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['radial-axis'],\n      transFn: transFn,\n      labelXFn: labelFns.labelXFn,\n      labelYFn: labelFns.labelYFn,\n      labelAnchorFn: labelFns.labelAnchorFn\n    });\n  }\n\n  // stash 'actual' radial axis angle for drag handlers (in degrees)\n  var angle = _this.radialAxisAngle = _this.vangles ? rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) : radialLayout.angle;\n  var tLayer = strTranslate(cx, cy);\n  var tLayer2 = tLayer + strRotate(-angle);\n  updateElement(layers['radial-axis'], hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks), {\n    transform: tLayer2\n  });\n  updateElement(layers['radial-grid'], hasRoomForIt && radialLayout.showgrid, {\n    transform: tLayer\n  });\n  updateElement(layers['radial-line'].select('line'), hasRoomForIt && radialLayout.showline, {\n    x1: innerRadius,\n    y1: 0,\n    x2: radius,\n    y2: 0,\n    transform: tLayer2\n  }).attr('stroke-width', radialLayout.linewidth).call(Color.stroke, radialLayout.linecolor);\n};\nproto.updateRadialAxisTitle = function (fullLayout, polarLayout, _angle) {\n  var _this = this;\n  var gd = _this.gd;\n  var radius = _this.radius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialLayout = polarLayout.radialaxis;\n  var titleClass = _this.id + 'title';\n  var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n  var angleRad = deg2rad(angle);\n  var cosa = Math.cos(angleRad);\n  var sina = Math.sin(angleRad);\n  var pad = 0;\n\n  // Hint: no need to check if there is in fact a title.text set\n  // because if plot is editable, pad needs to be calculated anyways\n  // to properly show placeholder text when title is empty.\n  if (radialLayout.title) {\n    var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n    var ts = radialLayout.title.font.size;\n    pad = radialLayout.side === 'counterclockwise' ? -h - ts * 0.4 : h + ts * 0.8;\n  }\n  _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n    propContainer: radialLayout,\n    propName: _this.id + '.radialaxis.title',\n    placeholder: _(gd, 'Click to enter radial axis title'),\n    attributes: {\n      x: cx + radius / 2 * cosa + pad * sina,\n      y: cy - radius / 2 * sina + pad * cosa,\n      'text-anchor': 'middle'\n    },\n    transform: {\n      rotate: -angle\n    }\n  });\n};\nproto.updateAngularAxis = function (fullLayout, polarLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var angularLayout = polarLayout.angularaxis;\n  var ax = _this.angularAxis;\n  _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n  ax.setGeometry();\n  ax.setScale();\n\n  // 't'ick to 'g'eometric radians is used all over the place here\n  var t2g = function t2g(d) {\n    return ax.t2g(d.x);\n  };\n\n  // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n  if (ax.type === 'linear' && ax.thetaunit === 'radians') {\n    ax.tick0 = rad2deg(ax.tick0);\n    ax.dtick = rad2deg(ax.dtick);\n  }\n  var _transFn = function _transFn(rad) {\n    return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n  };\n  var transFn = function transFn(d) {\n    return _transFn(t2g(d));\n  };\n  var transFn2 = function transFn2(d) {\n    var rad = t2g(d);\n    return _transFn(rad) + strRotate(-rad2deg(rad));\n  };\n  var gridPathFn = function gridPathFn(d) {\n    var rad = t2g(d);\n    var cosRad = Math.cos(rad);\n    var sinRad = Math.sin(rad);\n    return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] + 'L' + [cx + radius * cosRad, cy - radius * sinRad];\n  };\n  var out = Axes.makeLabelFns(ax, 0);\n  var labelStandoff = out.labelStandoff;\n  var labelShift = out.labelShift;\n  var offset4fontsize = angularLayout.ticks !== 'outside' ? 0.7 : 0.5;\n  var pad = (ax.linewidth || 1) / 2;\n  var labelXFn = function labelXFn(d) {\n    var rad = t2g(d);\n    var offset4tx = signSin(rad) === 0 ? 0 : Math.cos(rad) * (labelStandoff + pad + offset4fontsize * d.fontSize);\n    var offset4tick = signCos(rad) * (d.dx + labelStandoff + pad);\n    return offset4tx + offset4tick;\n  };\n  var labelYFn = function labelYFn(d) {\n    var rad = t2g(d);\n    var offset4tx = d.dy + d.fontSize * MID_SHIFT - labelShift;\n    var offset4tick = -Math.sin(rad) * (labelStandoff + pad + offset4fontsize * d.fontSize);\n    return offset4tx + offset4tick;\n  };\n\n  // TODO maybe switch angle, d ordering ??\n  var labelAnchorFn = function labelAnchorFn(angle, d) {\n    var rad = t2g(d);\n    return signSin(rad) === 0 ? signCos(rad) > 0 ? 'start' : 'end' : 'middle';\n  };\n  var newTickLayout = strTickLayout(angularLayout);\n  if (_this.angularTickLayout !== newTickLayout) {\n    layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n    _this.angularTickLayout = newTickLayout;\n  }\n  var vals = Axes.calcTicks(ax);\n\n  // angle of polygon vertices in geometric radians (null means circles)\n  // TODO what to do when ax.period > ax._categories ??\n  var vangles;\n  if (polarLayout.gridshape === 'linear') {\n    vangles = vals.map(t2g);\n\n    // ax._vals should be always ordered, make them\n    // always turn counterclockwise for convenience here\n    if (Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n      vangles = vangles.slice().reverse();\n    }\n  } else {\n    vangles = null;\n  }\n  _this.vangles = vangles;\n\n  // Use tickval filter for category axes instead of tweaking\n  // the range w.r.t sector, so that sectors that cross 360 can\n  // show all their ticks.\n  if (ax.type === 'category') {\n    vals = vals.filter(function (d) {\n      return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n    });\n  }\n  if (ax.visible) {\n    var tickSign = ax.ticks === 'inside' ? -1 : 1;\n    Axes.drawTicks(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      path: 'M' + tickSign * pad + ',0h' + tickSign * ax.ticklen,\n      transFn: transFn2,\n      crisp: false\n    });\n    Axes.drawGrid(gd, ax, {\n      vals: vals,\n      layer: layers['angular-grid'],\n      path: gridPathFn,\n      transFn: Lib.noop,\n      crisp: false\n    });\n    Axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: layers['angular-axis'],\n      repositionOnUpdate: true,\n      transFn: transFn,\n      labelXFn: labelXFn,\n      labelYFn: labelYFn,\n      labelAnchorFn: labelAnchorFn\n    });\n  }\n\n  // TODO maybe two arcs is better here?\n  // maybe split style attributes between inner and outer angular axes?\n\n  updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n    d: _this.pathSubplot(),\n    transform: strTranslate(cx, cy)\n  }).attr('stroke-width', angularLayout.linewidth).call(Color.stroke, angularLayout.linecolor);\n};\nproto.updateFx = function (fullLayout, polarLayout) {\n  if (!this.gd._context.staticPlot) {\n    this.updateAngularDrag(fullLayout);\n    this.updateRadialDrag(fullLayout, polarLayout, 0);\n    this.updateRadialDrag(fullLayout, polarLayout, 1);\n    this.updateMainDrag(fullLayout);\n  }\n};\nproto.updateMainDrag = function (fullLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var zoomlayer = fullLayout._zoomlayer;\n  var MINZOOM = constants.MINZOOM;\n  var OFFEDGE = constants.OFFEDGE;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var sectorInRad = _this.sectorInRad;\n  var vangles = _this.vangles;\n  var radialAxis = _this.radialAxis;\n  var clampTiny = helpers.clampTiny;\n  var findXYatLength = helpers.findXYatLength;\n  var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n  var chw = constants.cornerHalfWidth;\n  var chl = constants.cornerLen / 2;\n  var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', 'crosshair');\n  d3.select(mainDrag).attr('d', _this.pathSubplot()).attr('transform', strTranslate(cx, cy));\n  var dragOpts = {\n    element: mainDrag,\n    gd: gd,\n    subplot: _this.id,\n    plotinfo: {\n      id: _this.id,\n      xaxis: _this.xaxis,\n      yaxis: _this.yaxis\n    },\n    xaxes: [_this.xaxis],\n    yaxes: [_this.yaxis]\n  };\n\n  // mouse px position at drag start (0), move (1)\n  var x0, y0;\n  // radial distance from circle center at drag start (0), move (1)\n  var r0, r1;\n  // zoombox persistent quantities\n  var path0, dimmed, lum;\n  // zoombox, corners elements\n  var zb, corners;\n  function norm(x, y) {\n    return Math.sqrt(x * x + y * y);\n  }\n  function xy2r(x, y) {\n    return norm(x - cxx, y - cyy);\n  }\n  function xy2a(x, y) {\n    return Math.atan2(cyy - y, x - cxx);\n  }\n  function ra2xy(r, a) {\n    return [r * Math.cos(a), r * Math.sin(-a)];\n  }\n  function pathCorner(r, a) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var da = chl / r;\n    var am = a - da;\n    var ap = a + da;\n    var rb = Math.max(0, Math.min(r, radius));\n    var rm = rb - chw;\n    var rp = rb + chw;\n    return 'M' + ra2xy(rm, am) + 'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) + 'L' + ra2xy(rp, ap) + 'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) + 'Z';\n  }\n\n  // (x,y) is the pt at middle of the va0 <-> va1 edge\n  //\n  // ... we could eventually add another mode for cursor\n  // angles 'close to' enough to a particular vertex.\n  function pathCornerForPolygons(r, va0, va1) {\n    if (r === 0) return _this.pathSector(2 * chw);\n    var xy0 = ra2xy(r, va0);\n    var xy1 = ra2xy(r, va1);\n    var x = clampTiny((xy0[0] + xy1[0]) / 2);\n    var y = clampTiny((xy0[1] + xy1[1]) / 2);\n    var innerPts, outerPts;\n    if (x && y) {\n      var m = y / x;\n      var mperp = -1 / m;\n      var midPts = findXYatLength(chw, m, x, y);\n      innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n      outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n    } else {\n      var dx, dy;\n      if (y) {\n        // horizontal handles\n        dx = chl;\n        dy = chw;\n      } else {\n        // vertical handles\n        dx = chw;\n        dy = chl;\n      }\n      innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n      outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n    }\n    return 'M' + innerPts.join('L') + 'L' + outerPts.reverse().join('L') + 'Z';\n  }\n  function zoomPrep() {\n    r0 = null;\n    r1 = null;\n    path0 = _this.pathSubplot();\n    dimmed = false;\n    var polarLayoutNow = gd._fullLayout[_this.id];\n    lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n    zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n    zb.attr('fill-rule', 'evenodd');\n    corners = dragBox.makeCorners(zoomlayer, cx, cy);\n    clearSelect(zoomlayer);\n  }\n\n  // N.B. this sets scoped 'r0' and 'r1'\n  // return true if 'valid' zoom distance, false otherwise\n  function clampAndSetR0R1(rr0, rr1) {\n    rr1 = Math.max(Math.min(rr1, radius), innerRadius);\n\n    // starting or ending drag near center (outer edge),\n    // clamps radial distance at origin (at r=radius)\n    if (rr0 < OFFEDGE) rr0 = 0;else if (radius - rr0 < OFFEDGE) rr0 = radius;else if (rr1 < OFFEDGE) rr1 = 0;else if (radius - rr1 < OFFEDGE) rr1 = radius;\n\n    // make sure r0 < r1,\n    // to get correct fill pattern in path1 below\n    if (Math.abs(rr1 - rr0) > MINZOOM) {\n      if (rr0 < rr1) {\n        r0 = rr0;\n        r1 = rr1;\n      } else {\n        r0 = rr1;\n        r1 = rr0;\n      }\n      return true;\n    } else {\n      r0 = null;\n      r1 = null;\n      return false;\n    }\n  }\n  function applyZoomMove(path1, cpath) {\n    path1 = path1 || path0;\n    cpath = cpath || 'M0,0Z';\n    zb.attr('d', path1);\n    corners.attr('d', cpath);\n    dragBox.transitionZoombox(zb, corners, dimmed, lum);\n    dimmed = true;\n  }\n  function zoomMove(dx, dy) {\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var rr0 = xy2r(x0, y0);\n    var rr1 = Math.min(xy2r(x1, y1), radius);\n    var a0 = xy2a(x0, y0);\n    var path1;\n    var cpath;\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0);\n      // keep 'starting' angle\n      cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n    }\n    applyZoomMove(path1, cpath);\n  }\n  function findPolygonRadius(x, y, va0, va1) {\n    var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n    return norm(xy[0], xy[1]);\n  }\n  function zoomMoveForPolygons(dx, dy) {\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var a0 = xy2a(x0, y0);\n    var a1 = xy2a(x1, y1);\n    var vangles0 = findEnclosingVertexAngles(a0, vangles);\n    var vangles1 = findEnclosingVertexAngles(a1, vangles);\n    var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n    var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n    var path1;\n    var cpath;\n    if (clampAndSetR0R1(rr0, rr1)) {\n      path1 = path0 + _this.pathSector(r1);\n      if (r0) path1 += _this.pathSector(r0);\n      // keep 'starting' angle here too\n      cpath = [pathCornerForPolygons(r0, vangles0[0], vangles0[1]), pathCornerForPolygons(r1, vangles0[0], vangles0[1])].join(' ');\n    }\n    applyZoomMove(path1, cpath);\n  }\n  function zoomDone() {\n    dragBox.removeZoombox(gd);\n    if (r0 === null || r1 === null) return;\n    dragBox.showDoubleClickNotifier(gd);\n    var rl = radialAxis._rl;\n    var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n    var newRng = [rl[0] + (r0 - innerRadius) * m, rl[0] + (r1 - innerRadius) * m];\n    Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range', newRng);\n  }\n  function zoomClick(numClicks, evt) {\n    var clickMode = gd._fullLayout.clickmode;\n    dragBox.removeZoombox(gd);\n\n    // TODO double once vs twice logic (autorange vs fixed range)\n    if (numClicks === 2) {\n      var updateObj = {};\n      for (var k in _this.viewInitial) {\n        updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n      }\n      gd.emit('plotly_doubleclick', null);\n      Registry.call('_guiRelayout', gd, updateObj);\n    }\n    if (clickMode.indexOf('select') > -1 && numClicks === 1) {\n      selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n    }\n    if (clickMode.indexOf('event') > -1) {\n      Fx.click(gd, evt, _this.id);\n    }\n  }\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var dragModeNow = gd._fullLayout.dragmode;\n    var bbox = mainDrag.getBoundingClientRect();\n    x0 = startX - bbox.left;\n    y0 = startY - bbox.top;\n\n    // need to offset x/y as bbox center does not\n    // match origin for asymmetric polygons\n    if (vangles) {\n      var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n      x0 += cxx + offset[0];\n      y0 += cyy + offset[1];\n    }\n    switch (dragModeNow) {\n      case 'zoom':\n        if (vangles) {\n          dragOpts.moveFn = zoomMoveForPolygons;\n        } else {\n          dragOpts.moveFn = zoomMove;\n        }\n        dragOpts.clickFn = zoomClick;\n        dragOpts.doneFn = zoomDone;\n        zoomPrep(evt, startX, startY);\n        break;\n      case 'select':\n      case 'lasso':\n        prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n        break;\n    }\n  };\n  mainDrag.onmousemove = function (evt) {\n    Fx.hover(gd, evt, _this.id);\n    gd._fullLayout._lasthover = mainDrag;\n    gd._fullLayout._hoversubplot = _this.id;\n  };\n  mainDrag.onmouseout = function (evt) {\n    if (gd._dragging) return;\n    dragElement.unhover(gd, evt);\n  };\n  dragElement.init(dragOpts);\n};\nproto.updateRadialDrag = function (fullLayout, polarLayout, rngIndex) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var innerRadius = _this.innerRadius;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var radialAxis = _this.radialAxis;\n  var bl = constants.radialDragBoxSize;\n  var bl2 = bl / 2;\n  if (!radialAxis.visible) return;\n  var angle0 = deg2rad(_this.radialAxisAngle);\n  var rl = radialAxis._rl;\n  var rl0 = rl[0];\n  var rl1 = rl[1];\n  var rbase = rl[rngIndex];\n  var m = 0.75 * (rl[1] - rl[0]) / (1 - polarLayout.hole) / radius;\n  var tx, ty, className;\n  if (rngIndex) {\n    tx = cx + (radius + bl2) * Math.cos(angle0);\n    ty = cy - (radius + bl2) * Math.sin(angle0);\n    className = 'radialdrag';\n  } else {\n    // the 'inner' box can get called:\n    // - when polar.hole>0\n    // - when polar.sector isn't a full circle\n    // otherwise it is hidden behind the main drag.\n    tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n    ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n    className = 'radialdrag-inner';\n  }\n  var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n  var dragOpts = {\n    element: radialDrag,\n    gd: gd\n  };\n  updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n    transform: strTranslate(tx, ty)\n  });\n\n  // move function (either rotate or re-range flavor)\n  var moveFn2;\n  // rotate angle on done\n  var angle1;\n  // re-range range[1] (or range[0]) on done\n  var rprime;\n  function moveFn(dx, dy) {\n    if (moveFn2) {\n      moveFn2(dx, dy);\n    } else {\n      var dvec = [dx, -dy];\n      var rvec = [Math.cos(angle0), Math.sin(angle0)];\n      var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec)));\n\n      // mostly perpendicular motions rotate,\n      // mostly parallel motions re-range\n      if (!isNaN(comp)) {\n        moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n      }\n    }\n  }\n  function doneFn() {\n    if (angle1 !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n    } else if (rprime !== null) {\n      Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n    }\n  }\n  function rotateMove(dx, dy) {\n    // disable for inner drag boxes\n    if (rngIndex === 0) return;\n    var x1 = tx + dx;\n    var y1 = ty + dy;\n    angle1 = Math.atan2(cy - y1, x1 - cx);\n    if (_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n    angle1 = rad2deg(angle1);\n    var transform = strTranslate(cx, cy) + strRotate(-angle1);\n    layers['radial-axis'].attr('transform', transform);\n    layers['radial-line'].select('line').attr('transform', transform);\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n  }\n  function rerangeMove(dx, dy) {\n    // project (dx, dy) unto unit radial axis vector\n    var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n    rprime = rbase - m * dr;\n\n    // make sure rprime does not change the range[0] -> range[1] sign\n    if (m > 0 !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n      rprime = null;\n      return;\n    }\n    var fullLayoutNow = gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n\n    // update radial range -> update c2g -> update _m,_b\n    radialAxis.range[rngIndex] = rprime;\n    radialAxis._rl[rngIndex] = rprime;\n    _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n    _this.xaxis.setRange();\n    _this.xaxis.setScale();\n    _this.yaxis.setRange();\n    _this.yaxis.setScale();\n    var hasRegl = false;\n    for (var traceType in _this.traceHash) {\n      var moduleCalcData = _this.traceHash[traceType];\n      var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n      var _module = moduleCalcData[0][0].trace._module;\n      _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n      if (Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n    }\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n  }\n  dragOpts.prepFn = function () {\n    moveFn2 = null;\n    angle1 = null;\n    rprime = null;\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearSelect(fullLayout._zoomlayer);\n  };\n  dragOpts.clampFn = function (dx, dy) {\n    if (Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n      dx = 0;\n      dy = 0;\n    }\n    return [dx, dy];\n  };\n  dragElement.init(dragOpts);\n};\nproto.updateAngularDrag = function (fullLayout) {\n  var _this = this;\n  var gd = _this.gd;\n  var layers = _this.layers;\n  var radius = _this.radius;\n  var angularAxis = _this.angularAxis;\n  var cx = _this.cx;\n  var cy = _this.cy;\n  var cxx = _this.cxx;\n  var cyy = _this.cyy;\n  var dbs = constants.angularDragBoxSize;\n  var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', 'move');\n  var dragOpts = {\n    element: angularDrag,\n    gd: gd\n  };\n  d3.select(angularDrag).attr('d', _this.pathAnnulus(radius, radius + dbs)).attr('transform', strTranslate(cx, cy)).call(setCursor, 'move');\n  function xy2a(x, y) {\n    return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n  }\n\n  // scatter trace, points and textpoints selections\n  var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n  var scatterPoints = scatterTraces.selectAll('.point');\n  var scatterTextPoints = scatterTraces.selectAll('.textpoint');\n\n  // mouse px position at drag start (0), move (1)\n  var x0, y0;\n  // angular axis angle rotation at drag start (0), move (1)\n  var rot0, rot1;\n  // induced radial axis rotation (only used on polygon grids)\n  var rrot1;\n  // angle about circle center at drag start\n  var a0;\n  function moveFn(dx, dy) {\n    var fullLayoutNow = _this.gd._fullLayout;\n    var polarLayoutNow = fullLayoutNow[_this.id];\n    var x1 = x0 + dx;\n    var y1 = y0 + dy;\n    var a1 = xy2a(x1, y1);\n    var da = rad2deg(a1 - a0);\n    rot1 = rot0 + da;\n    layers.frontplot.attr('transform', strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy]));\n    if (_this.vangles) {\n      rrot1 = _this.radialAxisAngle + da;\n      var trans = strTranslate(cx, cy) + strRotate(-da);\n      var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n      layers.bg.attr('transform', trans);\n      layers['radial-grid'].attr('transform', trans);\n      layers['radial-axis'].attr('transform', trans2);\n      layers['radial-line'].select('line').attr('transform', trans2);\n      _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n    } else {\n      _this.clipPaths.forTraces.select('path').attr('transform', strTranslate(cxx, cyy) + strRotate(da));\n    }\n\n    // 'un-rotate' marker and text points\n    scatterPoints.each(function () {\n      var sel = d3.select(this);\n      var xy = Drawing.getTranslate(sel);\n      sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n    });\n    scatterTextPoints.each(function () {\n      var sel = d3.select(this);\n      var tx = sel.select('text');\n      var xy = Drawing.getTranslate(sel);\n      // N.B rotate -> translate ordering matters\n      sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n    });\n\n    // update rotation -> range -> _m,_b\n    angularAxis.rotation = Lib.modHalf(rot1, 360);\n    _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n    if (_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n      scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n    }\n    var hasRegl = false;\n    for (var traceType in _this.traceHash) {\n      if (Registry.traceIs(traceType, 'gl')) {\n        var moduleCalcData = _this.traceHash[traceType];\n        var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n        var _module = moduleCalcData[0][0].trace._module;\n        _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n        if (moduleCalcDataVisible.length) hasRegl = true;\n      }\n    }\n    if (hasRegl) {\n      clearGlCanvases(gd);\n      redrawReglTraces(gd);\n    }\n  }\n  function doneFn() {\n    scatterTextPoints.select('text').attr('transform', null);\n    var updateObj = {};\n    updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n    if (_this.vangles) {\n      updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n    }\n    Registry.call('_guiRelayout', gd, updateObj);\n  }\n  dragOpts.prepFn = function (evt, startX, startY) {\n    var polarLayoutNow = fullLayout[_this.id];\n    rot0 = polarLayoutNow.angularaxis.rotation;\n    var bbox = angularDrag.getBoundingClientRect();\n    x0 = startX - bbox.left;\n    y0 = startY - bbox.top;\n    a0 = xy2a(x0, y0);\n    dragOpts.moveFn = moveFn;\n    dragOpts.doneFn = doneFn;\n    clearSelect(fullLayout._zoomlayer);\n  };\n\n  // I don't what we should do in this case, skip we now\n  if (_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n    dragOpts.prepFn = Lib.noop;\n    setCursor(d3.select(angularDrag), null);\n  }\n  dragElement.init(dragOpts);\n};\nproto.isPtInside = function (d) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var thetag = this.angularAxis.c2g(d.theta);\n  var radialAxis = this.radialAxis;\n  var r = radialAxis.c2l(d.r);\n  var rl = radialAxis._rl;\n  var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n  return fn(r, thetag, rl, sectorInRad, vangles);\n};\nproto.pathArc = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathSector = function (r) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n  return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathAnnulus = function (r0, r1) {\n  var sectorInRad = this.sectorInRad;\n  var vangles = this.vangles;\n  var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n  return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\nproto.pathSubplot = function () {\n  var r0 = this.innerRadius;\n  var r1 = this.radius;\n  return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\nproto.fillViewInitialKey = function (key, val) {\n  if (!(key in this.viewInitial)) {\n    this.viewInitial[key] = val;\n  }\n};\nfunction strTickLayout(axLayout) {\n  var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n  if ('side' in axLayout) out += axLayout.side;\n  return out;\n}\n\n// Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\nfunction computeSectorBBox(sector) {\n  var s0 = sector[0];\n  var s1 = sector[1];\n  var arc = s1 - s0;\n  var a0 = mod(s0, 360);\n  var a1 = a0 + arc;\n  var ax0 = Math.cos(deg2rad(a0));\n  var ay0 = Math.sin(deg2rad(a0));\n  var ax1 = Math.cos(deg2rad(a1));\n  var ay1 = Math.sin(deg2rad(a1));\n  var x0, y0, x1, y1;\n  if (a0 <= 90 && a1 >= 90 || a0 > 90 && a1 >= 450) {\n    y1 = 1;\n  } else if (ay0 <= 0 && ay1 <= 0) {\n    y1 = 0;\n  } else {\n    y1 = Math.max(ay0, ay1);\n  }\n  if (a0 <= 180 && a1 >= 180 || a0 > 180 && a1 >= 540) {\n    x0 = -1;\n  } else if (ax0 >= 0 && ax1 >= 0) {\n    x0 = 0;\n  } else {\n    x0 = Math.min(ax0, ax1);\n  }\n  if (a0 <= 270 && a1 >= 270 || a0 > 270 && a1 >= 630) {\n    y0 = -1;\n  } else if (ay0 >= 0 && ay1 >= 0) {\n    y0 = 0;\n  } else {\n    y0 = Math.min(ay0, ay1);\n  }\n  if (a1 >= 360) {\n    x1 = 1;\n  } else if (ax0 <= 0 && ax1 <= 0) {\n    x1 = 0;\n  } else {\n    x1 = Math.max(ax0, ax1);\n  }\n  return [x0, y0, x1, y1];\n}\nfunction snapToVertexAngle(a, vangles) {\n  var fn = function fn(v) {\n    return Lib.angleDist(a, v);\n  };\n  var ind = Lib.findIndexOfMin(vangles, fn);\n  return vangles[ind];\n}\nfunction updateElement(sel, showAttr, attrs) {\n  if (showAttr) {\n    sel.attr('display', null);\n    sel.attr(attrs);\n  } else if (sel) {\n    sel.attr('display', 'none');\n  }\n  return sel;\n}\nfunction strTranslate(x, y) {\n  return 'translate(' + x + ',' + y + ')';\n}\nfunction strRotate(angle) {\n  return 'rotate(' + angle + ')';\n}\n\n// because Math.sign(Math.cos(Math.PI / 2)) === 1\n// oh javascript ;)\nfunction sign(v) {\n  return Math.abs(v) < 1e-10 ? 0 : v > 0 ? 1 : -1;\n}\nfunction signCos(v) {\n  return sign(Math.cos(v));\n}\nfunction signSin(v) {\n  return sign(Math.sin(v));\n}","map":{"version":3,"names":["d3","require","tinycolor","Registry","Lib","Color","Drawing","Plots","Axes","setConvertCartesian","setConvertPolar","doAutoRange","dragBox","dragElement","Fx","Titles","prepSelect","selectOnClick","clearSelect","setCursor","clearGlCanvases","redrawReglTraces","MID_SHIFT","constants","helpers","_","mod","deg2rad","rad2deg","Polar","gd","id","_hasClipOnAxisFalse","vangles","radialAxisAngle","traceHash","layers","clipPaths","clipIds","viewInitial","fullLayout","_fullLayout","clipIdBase","_uid","forTraces","_clips","append","attr","framework","_polarlayer","radialTickLayout","angularTickLayout","proto","prototype","module","exports","createPolar","plot","polarCalcData","_this","polarLayout","i","length","trace","cliponaxis","updateLayers","updateLayout","generalUpdatePerTraceModule","updateFx","radialLayout","radialaxis","angularLayout","angularaxis","layerNames","frontPlotIndex","indexOf","layerData","slice","isAngularAxisBelowTraces","layer","isRadialAxisBelowTraces","push","join","selectAll","data","String","enter","d","each","sel","select","classed","bg","style","order","gs","_size","xDomain","domain","x","yDomain","y","xOffset","l","w","yOffset","t","h","xLength","yLength","sector","sectorInRad","map","sectorBBox","computeSectorBBox","dxSectorBBox","dySectorBBox","arDomain","arSector","Math","abs","xLength2","yLength2","xDomain2","yDomain2","gap","xOffset2","yOffset2","radius","innerRadius","hole","cx","cy","cxx","cyy","radialAxis","mockAxis","_id","side","counterclockwise","clockwise","angularAxis","PI","autorange","updateAngularAxis","updateRadialAxis","updateRadialAxisTitle","xaxis","mockCartesianAxis","yaxis","dPath","pathSubplot","strTranslate","frontplot","call","setClipUrl","fill","bgcolor","axLayout","opts","commonOpts","anchor","position","ax","extendFlat","axId","type","bboxIndices","setRange","ind","rl","_rl","drl","range","isPtWithinRange","isPtInside","setScale","rng","_input","r2l","a0","hasRoomForIt","fillViewInitialKey","angle","setGeometry","tickangle","transFn","l2p","gridPathFn","pathArc","r2p","newTickLayout","strTickLayout","remove","vals","calcTicks","valsClipped","clipEnds","labelFns","makeLabelFns","tickSign","getTickSigns","drawTicks","path","makeTickPath","crisp","drawGrid","noop","drawLabels","labelXFn","labelYFn","labelAnchorFn","snapToVertexAngle","tLayer","tLayer2","strRotate","updateElement","showticklabels","ticks","transform","showgrid","showline","x1","y1","x2","y2","linewidth","stroke","linecolor","_angle","titleClass","undefined","angleRad","cosa","cos","sina","sin","pad","title","bBox","node","height","ts","font","size","draw","propContainer","propName","placeholder","attributes","rotate","rotation","t2g","thetaunit","tick0","dtick","_transFn","rad","transFn2","cosRad","sinRad","out","labelStandoff","labelShift","offset4fontsize","offset4tx","signSin","fontSize","offset4tick","signCos","dx","dy","gridshape","angleDelta","reverse","filter","isAngleInsideSector","visible","ticklen","repositionOnUpdate","_context","staticPlot","updateAngularDrag","updateRadialDrag","updateMainDrag","zoomlayer","_zoomlayer","MINZOOM","OFFEDGE","clampTiny","findXYatLength","findEnclosingVertexAngles","chw","cornerHalfWidth","chl","cornerLen","mainDrag","makeDragger","dragOpts","element","subplot","plotinfo","xaxes","yaxes","x0","y0","r0","r1","path0","dimmed","lum","zb","corners","norm","sqrt","xy2r","xy2a","atan2","ra2xy","r","a","pathCorner","pathSector","da","am","ap","rb","max","min","rm","rp","pathCornerForPolygons","va0","va1","xy0","xy1","innerPts","outerPts","m","mperp","midPts","zoomPrep","polarLayoutNow","getLuminance","makeZoombox","makeCorners","clampAndSetR0R1","rr0","rr1","applyZoomMove","path1","cpath","transitionZoombox","zoomMove","findPolygonRadius","xy","findIntersectionXY","zoomMoveForPolygons","a1","vangles0","vangles1","zoomDone","removeZoombox","showDoubleClickNotifier","newRng","zoomClick","numClicks","evt","clickMode","clickmode","updateObj","k","emit","click","prepFn","startX","startY","dragModeNow","dragmode","bbox","getBoundingClientRect","left","top","offset","findPolygonOffset","moveFn","clickFn","doneFn","onmousemove","hover","_lasthover","_hoversubplot","onmouseout","_dragging","unhover","init","rngIndex","bl","radialDragBoxSize","bl2","angle0","rl0","rl1","rbase","tx","ty","className","radialDrag","makeRectDragger","moveFn2","angle1","rprime","dvec","rvec","comp","dot","isNaN","rotateMove","rerangeMove","fullLayoutNow","dr","hasRegl","traceType","moduleCalcData","moduleCalcDataVisible","filterVisible","_module","traceIs","clampFn","MINDRAG","dbs","angularDragBoxSize","angularDrag","pathAnnulus","scatterTraces","scatterPoints","scatterTextPoints","rot0","rot1","rrot1","trans","trans2","getTranslate","modHalf","isFullCircle","hideOutsideRangePoints","thetag","c2g","theta","c2l","fn","isPtInsidePolygon","isPtInsideSector","pathPolygon","pathPolygonAnnulus","key","val","s0","s1","arc","ax0","ay0","ax1","ay1","v","angleDist","findIndexOfMin","showAttr","attrs","sign"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plots/polar/polar.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar tinycolor = require('tinycolor2');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar Plots = require('../plots');\nvar Axes = require('../../plots/cartesian/axes');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar setConvertPolar = require('./set_convert');\nvar doAutoRange = require('../cartesian/autorange').doAutoRange;\nvar dragBox = require('../cartesian/dragbox');\nvar dragElement = require('../../components/dragelement');\nvar Fx = require('../../components/fx');\nvar Titles = require('../../components/titles');\nvar prepSelect = require('../cartesian/select').prepSelect;\nvar selectOnClick = require('../cartesian/select').selectOnClick;\nvar clearSelect = require('../cartesian/select').clearSelect;\nvar setCursor = require('../../lib/setcursor');\nvar clearGlCanvases = require('../../lib/clear_gl_canvases');\nvar redrawReglTraces = require('../../plot_api/subroutines').redrawReglTraces;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\nvar _ = Lib._;\nvar mod = Lib.mod;\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\nfunction Polar(gd, id) {\n    this.id = id;\n    this.gd = gd;\n\n    this._hasClipOnAxisFalse = null;\n    this.vangles = null;\n    this.radialAxisAngle = null;\n    this.traceHash = {};\n    this.layers = {};\n    this.clipPaths = {};\n    this.clipIds = {};\n    this.viewInitial = {};\n\n    var fullLayout = gd._fullLayout;\n    var clipIdBase = 'clip' + fullLayout._uid + id;\n\n    this.clipIds.forTraces = clipIdBase + '-for-traces';\n    this.clipPaths.forTraces = fullLayout._clips.append('clipPath')\n        .attr('id', this.clipIds.forTraces);\n    this.clipPaths.forTraces.append('path');\n\n    this.framework = fullLayout._polarlayer.append('g')\n        .attr('class', id);\n\n    // unfortunately, we have to keep track of some axis tick settings\n    // as polar subplots do not implement the 'ticks' editType\n    this.radialTickLayout = null;\n    this.angularTickLayout = null;\n}\n\nvar proto = Polar.prototype;\n\nmodule.exports = function createPolar(gd, id) {\n    return new Polar(gd, id);\n};\n\nproto.plot = function(polarCalcData, fullLayout) {\n    var _this = this;\n    var polarLayout = fullLayout[_this.id];\n\n    _this._hasClipOnAxisFalse = false;\n    for(var i = 0; i < polarCalcData.length; i++) {\n        var trace = polarCalcData[i][0].trace;\n        if(trace.cliponaxis === false) {\n            _this._hasClipOnAxisFalse = true;\n            break;\n        }\n    }\n\n    _this.updateLayers(fullLayout, polarLayout);\n    _this.updateLayout(fullLayout, polarLayout);\n    Plots.generalUpdatePerTraceModule(_this.gd, _this, polarCalcData, polarLayout);\n    _this.updateFx(fullLayout, polarLayout);\n};\n\nproto.updateLayers = function(fullLayout, polarLayout) {\n    var _this = this;\n    var layers = _this.layers;\n    var radialLayout = polarLayout.radialaxis;\n    var angularLayout = polarLayout.angularaxis;\n    var layerNames = constants.layerNames;\n\n    var frontPlotIndex = layerNames.indexOf('frontplot');\n    var layerData = layerNames.slice(0, frontPlotIndex);\n    var isAngularAxisBelowTraces = angularLayout.layer === 'below traces';\n    var isRadialAxisBelowTraces = radialLayout.layer === 'below traces';\n\n    if(isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    layerData.push('frontplot');\n\n    if(!isAngularAxisBelowTraces) layerData.push('angular-line');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-line');\n    if(!isAngularAxisBelowTraces) layerData.push('angular-axis');\n    if(!isRadialAxisBelowTraces) layerData.push('radial-axis');\n\n    var join = _this.framework.selectAll('.polarsublayer')\n        .data(layerData, String);\n\n    join.enter().append('g')\n        .attr('class', function(d) { return 'polarsublayer ' + d;})\n        .each(function(d) {\n            var sel = layers[d] = d3.select(this);\n\n            switch(d) {\n                case 'frontplot':\n                    // TODO add option to place in 'backplot' layer??\n                    sel.append('g').classed('barlayer', true);\n                    sel.append('g').classed('scatterlayer', true);\n                    break;\n                case 'backplot':\n                    sel.append('g').classed('maplayer', true);\n                    break;\n                case 'plotbg':\n                    layers.bg = sel.append('path');\n                    break;\n                case 'radial-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'angular-grid':\n                    sel.style('fill', 'none');\n                    break;\n                case 'radial-line':\n                    sel.append('line').style('fill', 'none');\n                    break;\n                case 'angular-line':\n                    sel.append('path').style('fill', 'none');\n                    break;\n            }\n        });\n\n    join.order();\n};\n\n/* Polar subplots juggle with 6 'axis objects' (!), these are:\n *\n * - polarLayout.radialaxis (aka radialLayout in this file):\n * - polarLayout.angularaxis (aka angularLayout in this file):\n *   used for data -> calcdata conversions (aka d2c) during the calc step\n *\n * - this.radialAxis\n *   extends polarLayout.radialaxis, adds mocked 'domain' and\n *   few other keys in order to reuse Cartesian doAutoRange and the Axes\n *   drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g for given ax.range\n *   + setScale setups ax._m,ax._b for given ax.range\n *\n * - this.angularAxis\n *   extends polarLayout.angularaxis, adds mocked 'range' and 'domain' and\n *   a few other keys in order to reuse the Axes drawing routines.\n *   used for calcdata -> geometric conversions (aka c2g) during the plot step\n *   + setGeometry setups ax.c2g given ax.rotation, ax.direction & ax._categories,\n *                 and mocks ax.range\n *   + setScale setups ax._m,ax._b with that mocked ax.range\n *\n * - this.xaxis\n * - this.yaxis\n *   setup so that polar traces can reuse plot methods of Cartesian traces\n *   which mostly rely on 2pixel methods (e.g ax.c2p)\n */\nproto.updateLayout = function(fullLayout, polarLayout) {\n    var _this = this;\n    var layers = _this.layers;\n    var gs = fullLayout._size;\n\n    // axis attributes\n    var radialLayout = polarLayout.radialaxis;\n    var angularLayout = polarLayout.angularaxis;\n    // layout domains\n    var xDomain = polarLayout.domain.x;\n    var yDomain = polarLayout.domain.y;\n    // offsets from paper edge to layout domain box\n    _this.xOffset = gs.l + gs.w * xDomain[0];\n    _this.yOffset = gs.t + gs.h * (1 - yDomain[1]);\n    // lengths of the layout domain box\n    var xLength = _this.xLength = gs.w * (xDomain[1] - xDomain[0]);\n    var yLength = _this.yLength = gs.h * (yDomain[1] - yDomain[0]);\n    // sector to plot\n    var sector = polarLayout.sector;\n    _this.sectorInRad = sector.map(deg2rad);\n    var sectorBBox = _this.sectorBBox = computeSectorBBox(sector);\n    var dxSectorBBox = sectorBBox[2] - sectorBBox[0];\n    var dySectorBBox = sectorBBox[3] - sectorBBox[1];\n    // aspect ratios\n    var arDomain = yLength / xLength;\n    var arSector = Math.abs(dySectorBBox / dxSectorBBox);\n    // actual lengths and domains of subplot box\n    var xLength2, yLength2;\n    var xDomain2, yDomain2;\n    var gap;\n    if(arDomain > arSector) {\n        xLength2 = xLength;\n        yLength2 = xLength * arSector;\n        gap = (yLength - yLength2) / gs.h / 2;\n        xDomain2 = [xDomain[0], xDomain[1]];\n        yDomain2 = [yDomain[0] + gap, yDomain[1] - gap];\n    } else {\n        xLength2 = yLength / arSector;\n        yLength2 = yLength;\n        gap = (xLength - xLength2) / gs.w / 2;\n        xDomain2 = [xDomain[0] + gap, xDomain[1] - gap];\n        yDomain2 = [yDomain[0], yDomain[1]];\n    }\n    _this.xLength2 = xLength2;\n    _this.yLength2 = yLength2;\n    _this.xDomain2 = xDomain2;\n    _this.yDomain2 = yDomain2;\n    // actual offsets from paper edge to the subplot box top-left corner\n    var xOffset2 = _this.xOffset2 = gs.l + gs.w * xDomain2[0];\n    var yOffset2 = _this.yOffset2 = gs.t + gs.h * (1 - yDomain2[1]);\n    // circle radius in px\n    var radius = _this.radius = xLength2 / dxSectorBBox;\n    // 'inner' radius in px (when polar.hole is set)\n    var innerRadius = _this.innerRadius = polarLayout.hole * radius;\n    // circle center position in px\n    var cx = _this.cx = xOffset2 - radius * sectorBBox[0];\n    var cy = _this.cy = yOffset2 + radius * sectorBBox[3];\n    // circle center in the coordinate system of plot area\n    var cxx = _this.cxx = cx - xOffset2;\n    var cyy = _this.cyy = cy - yOffset2;\n\n    _this.radialAxis = _this.mockAxis(fullLayout, polarLayout, radialLayout, {\n        // make this an 'x' axis to make positioning (especially rotation) easier\n        _id: 'x',\n        // convert to 'x' axis equivalent\n        side: {\n            counterclockwise: 'top',\n            clockwise: 'bottom'\n        }[radialLayout.side],\n        // spans length 1 radius\n        domain: [innerRadius / gs.w, radius / gs.w]\n    });\n\n    _this.angularAxis = _this.mockAxis(fullLayout, polarLayout, angularLayout, {\n        side: 'right',\n        // to get auto nticks right\n        domain: [0, Math.PI],\n        // don't pass through autorange logic\n        autorange: false\n    });\n\n    _this.doAutoRange(fullLayout, polarLayout);\n    // N.B. this sets _this.vangles\n    _this.updateAngularAxis(fullLayout, polarLayout);\n    // N.B. this sets _this.radialAxisAngle\n    _this.updateRadialAxis(fullLayout, polarLayout);\n    _this.updateRadialAxisTitle(fullLayout, polarLayout);\n\n    _this.xaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'x',\n        domain: xDomain2\n    });\n\n    _this.yaxis = _this.mockCartesianAxis(fullLayout, polarLayout, {\n        _id: 'y',\n        domain: yDomain2\n    });\n\n    var dPath = _this.pathSubplot();\n\n    _this.clipPaths.forTraces.select('path')\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cxx, cyy));\n\n    layers.frontplot\n        .attr('transform', strTranslate(xOffset2, yOffset2))\n        .call(Drawing.setClipUrl, _this._hasClipOnAxisFalse ? null : _this.clipIds.forTraces, _this.gd);\n\n    layers.bg\n        .attr('d', dPath)\n        .attr('transform', strTranslate(cx, cy))\n        .call(Color.fill, polarLayout.bgcolor);\n};\n\nproto.mockAxis = function(fullLayout, polarLayout, axLayout, opts) {\n    var commonOpts = {\n        // to get _boundingBox computation right when showticklabels is false\n        anchor: 'free',\n        position: 0\n    };\n\n    var ax = Lib.extendFlat(commonOpts, axLayout, opts);\n    setConvertPolar(ax, polarLayout, fullLayout);\n    return ax;\n};\n\nproto.mockCartesianAxis = function(fullLayout, polarLayout, opts) {\n    var _this = this;\n    var axId = opts._id;\n\n    var ax = Lib.extendFlat({type: 'linear'}, opts);\n    setConvertCartesian(ax, fullLayout);\n\n    var bboxIndices = {\n        x: [0, 2],\n        y: [1, 3]\n    };\n\n    ax.setRange = function() {\n        var sectorBBox = _this.sectorBBox;\n        var ind = bboxIndices[axId];\n        var rl = _this.radialAxis._rl;\n        var drl = (rl[1] - rl[0]) / (1 - polarLayout.hole);\n        ax.range = [sectorBBox[ind[0]] * drl, sectorBBox[ind[1]] * drl];\n    };\n\n    ax.isPtWithinRange = axId === 'x' ?\n        function(d) { return _this.isPtInside(d); } :\n        function() { return true; };\n\n    ax.setRange();\n    ax.setScale();\n    return ax;\n};\n\nproto.doAutoRange = function(fullLayout, polarLayout) {\n    var gd = this.gd;\n    var radialAxis = this.radialAxis;\n    var radialLayout = polarLayout.radialaxis;\n\n    radialAxis.setScale();\n    doAutoRange(gd, radialAxis);\n\n    var rng = radialAxis.range;\n    radialLayout.range = rng.slice();\n    radialLayout._input.range = rng.slice();\n\n    radialAxis._rl = [\n        radialAxis.r2l(rng[0], null, 'gregorian'),\n        radialAxis.r2l(rng[1], null, 'gregorian')\n    ];\n};\n\nproto.updateRadialAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = polarLayout.radialaxis;\n    var a0 = mod(polarLayout.sector[0], 360);\n    var ax = _this.radialAxis;\n    var hasRoomForIt = innerRadius < radius;\n\n    _this.fillViewInitialKey('radialaxis.angle', radialLayout.angle);\n    _this.fillViewInitialKey('radialaxis.range', ax.range.slice());\n\n    ax.setGeometry();\n\n    // rotate auto tick labels by 180 if in quadrant II and III to make them\n    // readable from left-to-right\n    //\n    // TODO try moving deeper in Axes.drawLabels for better results?\n    if(ax.tickangle === 'auto' && (a0 > 90 && a0 <= 270)) {\n        ax.tickangle = 180;\n    }\n\n    // easier to set rotate angle with custom translate function\n    var transFn = function(d) {\n        return 'translate(' + (ax.l2p(d.x) + innerRadius) + ',0)';\n    };\n\n    // set special grid path function\n    var gridPathFn = function(d) {\n        return _this.pathArc(ax.r2p(d.x) + innerRadius);\n    };\n\n    var newTickLayout = strTickLayout(radialLayout);\n    if(_this.radialTickLayout !== newTickLayout) {\n        layers['radial-axis'].selectAll('.xtick').remove();\n        _this.radialTickLayout = newTickLayout;\n    }\n\n    if(hasRoomForIt) {\n        ax.setScale();\n\n        var vals = Axes.calcTicks(ax);\n        var valsClipped = Axes.clipEnds(ax, vals);\n        var labelFns = Axes.makeLabelFns(ax, 0);\n        var tickSign = Axes.getTickSigns(ax)[2];\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            path: Axes.makeTickPath(ax, 0, tickSign),\n            transFn: transFn,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: valsClipped,\n            layer: layers['radial-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['radial-axis'],\n            transFn: transFn,\n            labelXFn: labelFns.labelXFn,\n            labelYFn: labelFns.labelYFn,\n            labelAnchorFn: labelFns.labelAnchorFn\n        });\n    }\n\n    // stash 'actual' radial axis angle for drag handlers (in degrees)\n    var angle = _this.radialAxisAngle = _this.vangles ?\n        rad2deg(snapToVertexAngle(deg2rad(radialLayout.angle), _this.vangles)) :\n        radialLayout.angle;\n\n    var tLayer = strTranslate(cx, cy);\n    var tLayer2 = tLayer + strRotate(-angle);\n\n    updateElement(\n        layers['radial-axis'],\n        hasRoomForIt && (radialLayout.showticklabels || radialLayout.ticks),\n        {transform: tLayer2}\n    );\n\n    updateElement(\n        layers['radial-grid'],\n        hasRoomForIt && radialLayout.showgrid,\n        {transform: tLayer}\n    );\n\n    updateElement(\n        layers['radial-line'].select('line'),\n        hasRoomForIt && radialLayout.showline,\n        {\n            x1: innerRadius,\n            y1: 0,\n            x2: radius,\n            y2: 0,\n            transform: tLayer2\n        }\n    )\n    .attr('stroke-width', radialLayout.linewidth)\n    .call(Color.stroke, radialLayout.linecolor);\n};\n\nproto.updateRadialAxisTitle = function(fullLayout, polarLayout, _angle) {\n    var _this = this;\n    var gd = _this.gd;\n    var radius = _this.radius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialLayout = polarLayout.radialaxis;\n    var titleClass = _this.id + 'title';\n\n    var angle = _angle !== undefined ? _angle : _this.radialAxisAngle;\n    var angleRad = deg2rad(angle);\n    var cosa = Math.cos(angleRad);\n    var sina = Math.sin(angleRad);\n\n    var pad = 0;\n\n    // Hint: no need to check if there is in fact a title.text set\n    // because if plot is editable, pad needs to be calculated anyways\n    // to properly show placeholder text when title is empty.\n    if(radialLayout.title) {\n        var h = Drawing.bBox(_this.layers['radial-axis'].node()).height;\n        var ts = radialLayout.title.font.size;\n        pad = radialLayout.side === 'counterclockwise' ?\n            -h - ts * 0.4 :\n            h + ts * 0.8;\n    }\n\n    _this.layers['radial-axis-title'] = Titles.draw(gd, titleClass, {\n        propContainer: radialLayout,\n        propName: _this.id + '.radialaxis.title',\n        placeholder: _(gd, 'Click to enter radial axis title'),\n        attributes: {\n            x: cx + (radius / 2) * cosa + pad * sina,\n            y: cy - (radius / 2) * sina + pad * cosa,\n            'text-anchor': 'middle'\n        },\n        transform: {rotate: -angle}\n    });\n};\n\nproto.updateAngularAxis = function(fullLayout, polarLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var angularLayout = polarLayout.angularaxis;\n    var ax = _this.angularAxis;\n\n    _this.fillViewInitialKey('angularaxis.rotation', angularLayout.rotation);\n\n    ax.setGeometry();\n    ax.setScale();\n\n    // 't'ick to 'g'eometric radians is used all over the place here\n    var t2g = function(d) { return ax.t2g(d.x); };\n\n    // run rad2deg on tick0 and ditck for thetaunit: 'radians' axes\n    if(ax.type === 'linear' && ax.thetaunit === 'radians') {\n        ax.tick0 = rad2deg(ax.tick0);\n        ax.dtick = rad2deg(ax.dtick);\n    }\n\n    var _transFn = function(rad) {\n        return strTranslate(cx + radius * Math.cos(rad), cy - radius * Math.sin(rad));\n    };\n\n    var transFn = function(d) {\n        return _transFn(t2g(d));\n    };\n\n    var transFn2 = function(d) {\n        var rad = t2g(d);\n        return _transFn(rad) + strRotate(-rad2deg(rad));\n    };\n\n    var gridPathFn = function(d) {\n        var rad = t2g(d);\n        var cosRad = Math.cos(rad);\n        var sinRad = Math.sin(rad);\n        return 'M' + [cx + innerRadius * cosRad, cy - innerRadius * sinRad] +\n            'L' + [cx + radius * cosRad, cy - radius * sinRad];\n    };\n\n    var out = Axes.makeLabelFns(ax, 0);\n    var labelStandoff = out.labelStandoff;\n    var labelShift = out.labelShift;\n    var offset4fontsize = (angularLayout.ticks !== 'outside' ? 0.7 : 0.5);\n    var pad = (ax.linewidth || 1) / 2;\n\n    var labelXFn = function(d) {\n        var rad = t2g(d);\n\n        var offset4tx = signSin(rad) === 0 ?\n            0 :\n            Math.cos(rad) * (labelStandoff + pad + offset4fontsize * d.fontSize);\n        var offset4tick = signCos(rad) * (d.dx + labelStandoff + pad);\n\n        return offset4tx + offset4tick;\n    };\n\n    var labelYFn = function(d) {\n        var rad = t2g(d);\n\n        var offset4tx = d.dy + d.fontSize * MID_SHIFT - labelShift;\n        var offset4tick = -Math.sin(rad) * (labelStandoff + pad + offset4fontsize * d.fontSize);\n\n        return offset4tx + offset4tick;\n    };\n\n    // TODO maybe switch angle, d ordering ??\n    var labelAnchorFn = function(angle, d) {\n        var rad = t2g(d);\n        return signSin(rad) === 0 ?\n            (signCos(rad) > 0 ? 'start' : 'end') :\n            'middle';\n    };\n\n    var newTickLayout = strTickLayout(angularLayout);\n    if(_this.angularTickLayout !== newTickLayout) {\n        layers['angular-axis'].selectAll('.' + ax._id + 'tick').remove();\n        _this.angularTickLayout = newTickLayout;\n    }\n\n    var vals = Axes.calcTicks(ax);\n\n    // angle of polygon vertices in geometric radians (null means circles)\n    // TODO what to do when ax.period > ax._categories ??\n    var vangles;\n    if(polarLayout.gridshape === 'linear') {\n        vangles = vals.map(t2g);\n\n        // ax._vals should be always ordered, make them\n        // always turn counterclockwise for convenience here\n        if(Lib.angleDelta(vangles[0], vangles[1]) < 0) {\n            vangles = vangles.slice().reverse();\n        }\n    } else {\n        vangles = null;\n    }\n    _this.vangles = vangles;\n\n    // Use tickval filter for category axes instead of tweaking\n    // the range w.r.t sector, so that sectors that cross 360 can\n    // show all their ticks.\n    if(ax.type === 'category') {\n        vals = vals.filter(function(d) {\n            return Lib.isAngleInsideSector(t2g(d), _this.sectorInRad);\n        });\n    }\n\n    if(ax.visible) {\n        var tickSign = ax.ticks === 'inside' ? -1 : 1;\n\n        Axes.drawTicks(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            path: 'M' + (tickSign * pad) + ',0h' + (tickSign * ax.ticklen),\n            transFn: transFn2,\n            crisp: false\n        });\n\n        Axes.drawGrid(gd, ax, {\n            vals: vals,\n            layer: layers['angular-grid'],\n            path: gridPathFn,\n            transFn: Lib.noop,\n            crisp: false\n        });\n\n        Axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: layers['angular-axis'],\n            repositionOnUpdate: true,\n            transFn: transFn,\n            labelXFn: labelXFn,\n            labelYFn: labelYFn,\n            labelAnchorFn: labelAnchorFn\n        });\n    }\n\n    // TODO maybe two arcs is better here?\n    // maybe split style attributes between inner and outer angular axes?\n\n    updateElement(layers['angular-line'].select('path'), angularLayout.showline, {\n        d: _this.pathSubplot(),\n        transform: strTranslate(cx, cy)\n    })\n    .attr('stroke-width', angularLayout.linewidth)\n    .call(Color.stroke, angularLayout.linecolor);\n};\n\nproto.updateFx = function(fullLayout, polarLayout) {\n    if(!this.gd._context.staticPlot) {\n        this.updateAngularDrag(fullLayout);\n        this.updateRadialDrag(fullLayout, polarLayout, 0);\n        this.updateRadialDrag(fullLayout, polarLayout, 1);\n        this.updateMainDrag(fullLayout);\n    }\n};\n\nproto.updateMainDrag = function(fullLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var zoomlayer = fullLayout._zoomlayer;\n    var MINZOOM = constants.MINZOOM;\n    var OFFEDGE = constants.OFFEDGE;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var sectorInRad = _this.sectorInRad;\n    var vangles = _this.vangles;\n    var radialAxis = _this.radialAxis;\n    var clampTiny = helpers.clampTiny;\n    var findXYatLength = helpers.findXYatLength;\n    var findEnclosingVertexAngles = helpers.findEnclosingVertexAngles;\n    var chw = constants.cornerHalfWidth;\n    var chl = constants.cornerLen / 2;\n\n    var mainDrag = dragBox.makeDragger(layers, 'path', 'maindrag', 'crosshair');\n\n    d3.select(mainDrag)\n        .attr('d', _this.pathSubplot())\n        .attr('transform', strTranslate(cx, cy));\n\n    var dragOpts = {\n        element: mainDrag,\n        gd: gd,\n        subplot: _this.id,\n        plotinfo: {\n            id: _this.id,\n            xaxis: _this.xaxis,\n            yaxis: _this.yaxis\n        },\n        xaxes: [_this.xaxis],\n        yaxes: [_this.yaxis]\n    };\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // radial distance from circle center at drag start (0), move (1)\n    var r0, r1;\n    // zoombox persistent quantities\n    var path0, dimmed, lum;\n    // zoombox, corners elements\n    var zb, corners;\n\n    function norm(x, y) {\n        return Math.sqrt(x * x + y * y);\n    }\n\n    function xy2r(x, y) {\n        return norm(x - cxx, y - cyy);\n    }\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy - y, x - cxx);\n    }\n\n    function ra2xy(r, a) {\n        return [r * Math.cos(a), r * Math.sin(-a)];\n    }\n\n    function pathCorner(r, a) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var da = chl / r;\n        var am = a - da;\n        var ap = a + da;\n        var rb = Math.max(0, Math.min(r, radius));\n        var rm = rb - chw;\n        var rp = rb + chw;\n\n        return 'M' + ra2xy(rm, am) +\n            'A' + [rm, rm] + ' 0,0,0 ' + ra2xy(rm, ap) +\n            'L' + ra2xy(rp, ap) +\n            'A' + [rp, rp] + ' 0,0,1 ' + ra2xy(rp, am) +\n            'Z';\n    }\n\n    // (x,y) is the pt at middle of the va0 <-> va1 edge\n    //\n    // ... we could eventually add another mode for cursor\n    // angles 'close to' enough to a particular vertex.\n    function pathCornerForPolygons(r, va0, va1) {\n        if(r === 0) return _this.pathSector(2 * chw);\n\n        var xy0 = ra2xy(r, va0);\n        var xy1 = ra2xy(r, va1);\n        var x = clampTiny((xy0[0] + xy1[0]) / 2);\n        var y = clampTiny((xy0[1] + xy1[1]) / 2);\n        var innerPts, outerPts;\n\n        if(x && y) {\n            var m = y / x;\n            var mperp = -1 / m;\n            var midPts = findXYatLength(chw, m, x, y);\n            innerPts = findXYatLength(chl, mperp, midPts[0][0], midPts[0][1]);\n            outerPts = findXYatLength(chl, mperp, midPts[1][0], midPts[1][1]);\n        } else {\n            var dx, dy;\n            if(y) {\n                // horizontal handles\n                dx = chl;\n                dy = chw;\n            } else {\n                // vertical handles\n                dx = chw;\n                dy = chl;\n            }\n            innerPts = [[x - dx, y - dy], [x + dx, y - dy]];\n            outerPts = [[x - dx, y + dy], [x + dx, y + dy]];\n        }\n\n        return 'M' + innerPts.join('L') +\n            'L' + outerPts.reverse().join('L') + 'Z';\n    }\n\n    function zoomPrep() {\n        r0 = null;\n        r1 = null;\n        path0 = _this.pathSubplot();\n        dimmed = false;\n\n        var polarLayoutNow = gd._fullLayout[_this.id];\n        lum = tinycolor(polarLayoutNow.bgcolor).getLuminance();\n\n        zb = dragBox.makeZoombox(zoomlayer, lum, cx, cy, path0);\n        zb.attr('fill-rule', 'evenodd');\n        corners = dragBox.makeCorners(zoomlayer, cx, cy);\n        clearSelect(zoomlayer);\n    }\n\n    // N.B. this sets scoped 'r0' and 'r1'\n    // return true if 'valid' zoom distance, false otherwise\n    function clampAndSetR0R1(rr0, rr1) {\n        rr1 = Math.max(Math.min(rr1, radius), innerRadius);\n\n        // starting or ending drag near center (outer edge),\n        // clamps radial distance at origin (at r=radius)\n        if(rr0 < OFFEDGE) rr0 = 0;\n        else if((radius - rr0) < OFFEDGE) rr0 = radius;\n        else if(rr1 < OFFEDGE) rr1 = 0;\n        else if((radius - rr1) < OFFEDGE) rr1 = radius;\n\n        // make sure r0 < r1,\n        // to get correct fill pattern in path1 below\n        if(Math.abs(rr1 - rr0) > MINZOOM) {\n            if(rr0 < rr1) {\n                r0 = rr0;\n                r1 = rr1;\n            } else {\n                r0 = rr1;\n                r1 = rr0;\n            }\n            return true;\n        } else {\n            r0 = null;\n            r1 = null;\n            return false;\n        }\n    }\n\n    function applyZoomMove(path1, cpath) {\n        path1 = path1 || path0;\n        cpath = cpath || 'M0,0Z';\n\n        zb.attr('d', path1);\n        corners.attr('d', cpath);\n        dragBox.transitionZoombox(zb, corners, dimmed, lum);\n        dimmed = true;\n    }\n\n    function zoomMove(dx, dy) {\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n        var rr0 = xy2r(x0, y0);\n        var rr1 = Math.min(xy2r(x1, y1), radius);\n        var a0 = xy2a(x0, y0);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle\n            cpath = pathCorner(r0, a0) + pathCorner(r1, a0);\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function findPolygonRadius(x, y, va0, va1) {\n        var xy = helpers.findIntersectionXY(va0, va1, va0, [x - cxx, cyy - y]);\n        return norm(xy[0], xy[1]);\n    }\n\n    function zoomMoveForPolygons(dx, dy) {\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n        var a0 = xy2a(x0, y0);\n        var a1 = xy2a(x1, y1);\n        var vangles0 = findEnclosingVertexAngles(a0, vangles);\n        var vangles1 = findEnclosingVertexAngles(a1, vangles);\n        var rr0 = findPolygonRadius(x0, y0, vangles0[0], vangles0[1]);\n        var rr1 = Math.min(findPolygonRadius(x1, y1, vangles1[0], vangles1[1]), radius);\n        var path1;\n        var cpath;\n\n        if(clampAndSetR0R1(rr0, rr1)) {\n            path1 = path0 + _this.pathSector(r1);\n            if(r0) path1 += _this.pathSector(r0);\n            // keep 'starting' angle here too\n            cpath = [\n                pathCornerForPolygons(r0, vangles0[0], vangles0[1]),\n                pathCornerForPolygons(r1, vangles0[0], vangles0[1])\n            ].join(' ');\n        }\n        applyZoomMove(path1, cpath);\n    }\n\n    function zoomDone() {\n        dragBox.removeZoombox(gd);\n\n        if(r0 === null || r1 === null) return;\n\n        dragBox.showDoubleClickNotifier(gd);\n\n        var rl = radialAxis._rl;\n        var m = (rl[1] - rl[0]) / (1 - innerRadius / radius) / radius;\n        var newRng = [\n            rl[0] + (r0 - innerRadius) * m,\n            rl[0] + (r1 - innerRadius) * m\n        ];\n        Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range', newRng);\n    }\n\n    function zoomClick(numClicks, evt) {\n        var clickMode = gd._fullLayout.clickmode;\n\n        dragBox.removeZoombox(gd);\n\n        // TODO double once vs twice logic (autorange vs fixed range)\n        if(numClicks === 2) {\n            var updateObj = {};\n            for(var k in _this.viewInitial) {\n                updateObj[_this.id + '.' + k] = _this.viewInitial[k];\n            }\n\n            gd.emit('plotly_doubleclick', null);\n            Registry.call('_guiRelayout', gd, updateObj);\n        }\n\n        if(clickMode.indexOf('select') > -1 && numClicks === 1) {\n            selectOnClick(evt, gd, [_this.xaxis], [_this.yaxis], _this.id, dragOpts);\n        }\n\n        if(clickMode.indexOf('event') > -1) {\n            Fx.click(gd, evt, _this.id);\n        }\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var dragModeNow = gd._fullLayout.dragmode;\n\n        var bbox = mainDrag.getBoundingClientRect();\n        x0 = startX - bbox.left;\n        y0 = startY - bbox.top;\n\n        // need to offset x/y as bbox center does not\n        // match origin for asymmetric polygons\n        if(vangles) {\n            var offset = helpers.findPolygonOffset(radius, sectorInRad[0], sectorInRad[1], vangles);\n            x0 += cxx + offset[0];\n            y0 += cyy + offset[1];\n        }\n\n        switch(dragModeNow) {\n            case 'zoom':\n                if(vangles) {\n                    dragOpts.moveFn = zoomMoveForPolygons;\n                } else {\n                    dragOpts.moveFn = zoomMove;\n                }\n                dragOpts.clickFn = zoomClick;\n                dragOpts.doneFn = zoomDone;\n                zoomPrep(evt, startX, startY);\n                break;\n            case 'select':\n            case 'lasso':\n                prepSelect(evt, startX, startY, dragOpts, dragModeNow);\n                break;\n        }\n    };\n\n    mainDrag.onmousemove = function(evt) {\n        Fx.hover(gd, evt, _this.id);\n        gd._fullLayout._lasthover = mainDrag;\n        gd._fullLayout._hoversubplot = _this.id;\n    };\n\n    mainDrag.onmouseout = function(evt) {\n        if(gd._dragging) return;\n        dragElement.unhover(gd, evt);\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateRadialDrag = function(fullLayout, polarLayout, rngIndex) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var innerRadius = _this.innerRadius;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var radialAxis = _this.radialAxis;\n    var bl = constants.radialDragBoxSize;\n    var bl2 = bl / 2;\n\n    if(!radialAxis.visible) return;\n\n    var angle0 = deg2rad(_this.radialAxisAngle);\n    var rl = radialAxis._rl;\n    var rl0 = rl[0];\n    var rl1 = rl[1];\n    var rbase = rl[rngIndex];\n    var m = 0.75 * (rl[1] - rl[0]) / (1 - polarLayout.hole) / radius;\n\n    var tx, ty, className;\n    if(rngIndex) {\n        tx = cx + (radius + bl2) * Math.cos(angle0);\n        ty = cy - (radius + bl2) * Math.sin(angle0);\n        className = 'radialdrag';\n    } else {\n        // the 'inner' box can get called:\n        // - when polar.hole>0\n        // - when polar.sector isn't a full circle\n        // otherwise it is hidden behind the main drag.\n        tx = cx + (innerRadius - bl2) * Math.cos(angle0);\n        ty = cy - (innerRadius - bl2) * Math.sin(angle0);\n        className = 'radialdrag-inner';\n    }\n\n    var radialDrag = dragBox.makeRectDragger(layers, className, 'crosshair', -bl2, -bl2, bl, bl);\n    var dragOpts = {element: radialDrag, gd: gd};\n\n    updateElement(d3.select(radialDrag), radialAxis.visible && innerRadius < radius, {\n        transform: strTranslate(tx, ty)\n    });\n\n    // move function (either rotate or re-range flavor)\n    var moveFn2;\n    // rotate angle on done\n    var angle1;\n    // re-range range[1] (or range[0]) on done\n    var rprime;\n\n    function moveFn(dx, dy) {\n        if(moveFn2) {\n            moveFn2(dx, dy);\n        } else {\n            var dvec = [dx, -dy];\n            var rvec = [Math.cos(angle0), Math.sin(angle0)];\n            var comp = Math.abs(Lib.dot(dvec, rvec) / Math.sqrt(Lib.dot(dvec, dvec)));\n\n            // mostly perpendicular motions rotate,\n            // mostly parallel motions re-range\n            if(!isNaN(comp)) {\n                moveFn2 = comp < 0.5 ? rotateMove : rerangeMove;\n            }\n        }\n    }\n\n    function doneFn() {\n        if(angle1 !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.angle', angle1);\n        } else if(rprime !== null) {\n            Registry.call('_guiRelayout', gd, _this.id + '.radialaxis.range[' + rngIndex + ']', rprime);\n        }\n    }\n\n    function rotateMove(dx, dy) {\n        // disable for inner drag boxes\n        if(rngIndex === 0) return;\n\n        var x1 = tx + dx;\n        var y1 = ty + dy;\n\n        angle1 = Math.atan2(cy - y1, x1 - cx);\n        if(_this.vangles) angle1 = snapToVertexAngle(angle1, _this.vangles);\n        angle1 = rad2deg(angle1);\n\n        var transform = strTranslate(cx, cy) + strRotate(-angle1);\n        layers['radial-axis'].attr('transform', transform);\n        layers['radial-line'].select('line').attr('transform', transform);\n\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n        _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, angle1);\n    }\n\n    function rerangeMove(dx, dy) {\n        // project (dx, dy) unto unit radial axis vector\n        var dr = Lib.dot([dx, -dy], [Math.cos(angle0), Math.sin(angle0)]);\n        rprime = rbase - m * dr;\n\n        // make sure rprime does not change the range[0] -> range[1] sign\n        if((m > 0) !== (rngIndex ? rprime > rl0 : rprime < rl1)) {\n            rprime = null;\n            return;\n        }\n\n        var fullLayoutNow = gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        // update radial range -> update c2g -> update _m,_b\n        radialAxis.range[rngIndex] = rprime;\n        radialAxis._rl[rngIndex] = rprime;\n        _this.updateRadialAxis(fullLayoutNow, polarLayoutNow);\n\n        _this.xaxis.setRange();\n        _this.xaxis.setScale();\n        _this.yaxis.setRange();\n        _this.yaxis.setScale();\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            var moduleCalcData = _this.traceHash[traceType];\n            var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n            var _module = moduleCalcData[0][0].trace._module;\n            _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n            if(Registry.traceIs(traceType, 'gl') && moduleCalcDataVisible.length) hasRegl = true;\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n    }\n\n    dragOpts.prepFn = function() {\n        moveFn2 = null;\n        angle1 = null;\n        rprime = null;\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearSelect(fullLayout._zoomlayer);\n    };\n\n    dragOpts.clampFn = function(dx, dy) {\n        if(Math.sqrt(dx * dx + dy * dy) < constants.MINDRAG) {\n            dx = 0;\n            dy = 0;\n        }\n        return [dx, dy];\n    };\n\n    dragElement.init(dragOpts);\n};\n\nproto.updateAngularDrag = function(fullLayout) {\n    var _this = this;\n    var gd = _this.gd;\n    var layers = _this.layers;\n    var radius = _this.radius;\n    var angularAxis = _this.angularAxis;\n    var cx = _this.cx;\n    var cy = _this.cy;\n    var cxx = _this.cxx;\n    var cyy = _this.cyy;\n    var dbs = constants.angularDragBoxSize;\n\n    var angularDrag = dragBox.makeDragger(layers, 'path', 'angulardrag', 'move');\n    var dragOpts = {element: angularDrag, gd: gd};\n\n    d3.select(angularDrag)\n        .attr('d', _this.pathAnnulus(radius, radius + dbs))\n        .attr('transform', strTranslate(cx, cy))\n        .call(setCursor, 'move');\n\n    function xy2a(x, y) {\n        return Math.atan2(cyy + dbs - y, x - cxx - dbs);\n    }\n\n    // scatter trace, points and textpoints selections\n    var scatterTraces = layers.frontplot.select('.scatterlayer').selectAll('.trace');\n    var scatterPoints = scatterTraces.selectAll('.point');\n    var scatterTextPoints = scatterTraces.selectAll('.textpoint');\n\n    // mouse px position at drag start (0), move (1)\n    var x0, y0;\n    // angular axis angle rotation at drag start (0), move (1)\n    var rot0, rot1;\n    // induced radial axis rotation (only used on polygon grids)\n    var rrot1;\n    // angle about circle center at drag start\n    var a0;\n\n    function moveFn(dx, dy) {\n        var fullLayoutNow = _this.gd._fullLayout;\n        var polarLayoutNow = fullLayoutNow[_this.id];\n\n        var x1 = x0 + dx;\n        var y1 = y0 + dy;\n        var a1 = xy2a(x1, y1);\n        var da = rad2deg(a1 - a0);\n        rot1 = rot0 + da;\n\n        layers.frontplot.attr('transform',\n            strTranslate(_this.xOffset2, _this.yOffset2) + strRotate([-da, cxx, cyy])\n        );\n\n        if(_this.vangles) {\n            rrot1 = _this.radialAxisAngle + da;\n\n            var trans = strTranslate(cx, cy) + strRotate(-da);\n            var trans2 = strTranslate(cx, cy) + strRotate(-rrot1);\n\n            layers.bg.attr('transform', trans);\n            layers['radial-grid'].attr('transform', trans);\n            layers['radial-axis'].attr('transform', trans2);\n            layers['radial-line'].select('line').attr('transform', trans2);\n            _this.updateRadialAxisTitle(fullLayoutNow, polarLayoutNow, rrot1);\n        } else {\n            _this.clipPaths.forTraces.select('path').attr('transform',\n                strTranslate(cxx, cyy) + strRotate(da)\n            );\n        }\n\n        // 'un-rotate' marker and text points\n        scatterPoints.each(function() {\n            var sel = d3.select(this);\n            var xy = Drawing.getTranslate(sel);\n            sel.attr('transform', strTranslate(xy.x, xy.y) + strRotate([da]));\n        });\n        scatterTextPoints.each(function() {\n            var sel = d3.select(this);\n            var tx = sel.select('text');\n            var xy = Drawing.getTranslate(sel);\n            // N.B rotate -> translate ordering matters\n            sel.attr('transform', strRotate([da, tx.attr('x'), tx.attr('y')]) + strTranslate(xy.x, xy.y));\n        });\n\n        // update rotation -> range -> _m,_b\n        angularAxis.rotation = Lib.modHalf(rot1, 360);\n        _this.updateAngularAxis(fullLayoutNow, polarLayoutNow);\n\n        if(_this._hasClipOnAxisFalse && !Lib.isFullCircle(_this.sectorInRad)) {\n            scatterTraces.call(Drawing.hideOutsideRangePoints, _this);\n        }\n\n        var hasRegl = false;\n\n        for(var traceType in _this.traceHash) {\n            if(Registry.traceIs(traceType, 'gl')) {\n                var moduleCalcData = _this.traceHash[traceType];\n                var moduleCalcDataVisible = Lib.filterVisible(moduleCalcData);\n                var _module = moduleCalcData[0][0].trace._module;\n                _module.plot(gd, _this, moduleCalcDataVisible, polarLayoutNow);\n                if(moduleCalcDataVisible.length) hasRegl = true;\n            }\n        }\n\n        if(hasRegl) {\n            clearGlCanvases(gd);\n            redrawReglTraces(gd);\n        }\n    }\n\n    function doneFn() {\n        scatterTextPoints.select('text').attr('transform', null);\n\n        var updateObj = {};\n        updateObj[_this.id + '.angularaxis.rotation'] = rot1;\n\n        if(_this.vangles) {\n            updateObj[_this.id + '.radialaxis.angle'] = rrot1;\n        }\n\n        Registry.call('_guiRelayout', gd, updateObj);\n    }\n\n    dragOpts.prepFn = function(evt, startX, startY) {\n        var polarLayoutNow = fullLayout[_this.id];\n        rot0 = polarLayoutNow.angularaxis.rotation;\n\n        var bbox = angularDrag.getBoundingClientRect();\n        x0 = startX - bbox.left;\n        y0 = startY - bbox.top;\n        a0 = xy2a(x0, y0);\n\n        dragOpts.moveFn = moveFn;\n        dragOpts.doneFn = doneFn;\n\n        clearSelect(fullLayout._zoomlayer);\n    };\n\n    // I don't what we should do in this case, skip we now\n    if(_this.vangles && !Lib.isFullCircle(_this.sectorInRad)) {\n        dragOpts.prepFn = Lib.noop;\n        setCursor(d3.select(angularDrag), null);\n    }\n\n    dragElement.init(dragOpts);\n};\n\nproto.isPtInside = function(d) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var thetag = this.angularAxis.c2g(d.theta);\n    var radialAxis = this.radialAxis;\n    var r = radialAxis.c2l(d.r);\n    var rl = radialAxis._rl;\n\n    var fn = vangles ? helpers.isPtInsidePolygon : Lib.isPtInsideSector;\n    return fn(r, thetag, rl, sectorInRad, vangles);\n};\n\nproto.pathArc = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathArc;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSector = function(r) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygon : Lib.pathSector;\n    return fn(r, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathAnnulus = function(r0, r1) {\n    var sectorInRad = this.sectorInRad;\n    var vangles = this.vangles;\n    var fn = vangles ? helpers.pathPolygonAnnulus : Lib.pathAnnulus;\n    return fn(r0, r1, sectorInRad[0], sectorInRad[1], vangles);\n};\n\nproto.pathSubplot = function() {\n    var r0 = this.innerRadius;\n    var r1 = this.radius;\n    return r0 ? this.pathAnnulus(r0, r1) : this.pathSector(r1);\n};\n\nproto.fillViewInitialKey = function(key, val) {\n    if(!(key in this.viewInitial)) {\n        this.viewInitial[key] = val;\n    }\n};\n\nfunction strTickLayout(axLayout) {\n    var out = axLayout.ticks + String(axLayout.ticklen) + String(axLayout.showticklabels);\n    if('side' in axLayout) out += axLayout.side;\n    return out;\n}\n\n// Finds the bounding box of a given circle sector,\n// inspired by https://math.stackexchange.com/q/1852703\n//\n// assumes:\n// - sector[0] < sector[1]\n// - counterclockwise rotation\nfunction computeSectorBBox(sector) {\n    var s0 = sector[0];\n    var s1 = sector[1];\n    var arc = s1 - s0;\n    var a0 = mod(s0, 360);\n    var a1 = a0 + arc;\n\n    var ax0 = Math.cos(deg2rad(a0));\n    var ay0 = Math.sin(deg2rad(a0));\n    var ax1 = Math.cos(deg2rad(a1));\n    var ay1 = Math.sin(deg2rad(a1));\n\n    var x0, y0, x1, y1;\n\n    if((a0 <= 90 && a1 >= 90) || (a0 > 90 && a1 >= 450)) {\n        y1 = 1;\n    } else if(ay0 <= 0 && ay1 <= 0) {\n        y1 = 0;\n    } else {\n        y1 = Math.max(ay0, ay1);\n    }\n\n    if((a0 <= 180 && a1 >= 180) || (a0 > 180 && a1 >= 540)) {\n        x0 = -1;\n    } else if(ax0 >= 0 && ax1 >= 0) {\n        x0 = 0;\n    } else {\n        x0 = Math.min(ax0, ax1);\n    }\n\n    if((a0 <= 270 && a1 >= 270) || (a0 > 270 && a1 >= 630)) {\n        y0 = -1;\n    } else if(ay0 >= 0 && ay1 >= 0) {\n        y0 = 0;\n    } else {\n        y0 = Math.min(ay0, ay1);\n    }\n\n    if(a1 >= 360) {\n        x1 = 1;\n    } else if(ax0 <= 0 && ax1 <= 0) {\n        x1 = 0;\n    } else {\n        x1 = Math.max(ax0, ax1);\n    }\n\n    return [x0, y0, x1, y1];\n}\n\nfunction snapToVertexAngle(a, vangles) {\n    var fn = function(v) { return Lib.angleDist(a, v); };\n    var ind = Lib.findIndexOfMin(vangles, fn);\n    return vangles[ind];\n}\n\nfunction updateElement(sel, showAttr, attrs) {\n    if(showAttr) {\n        sel.attr('display', null);\n        sel.attr(attrs);\n    } else if(sel) {\n        sel.attr('display', 'none');\n    }\n    return sel;\n}\n\nfunction strTranslate(x, y) {\n    return 'translate(' + x + ',' + y + ')';\n}\n\nfunction strRotate(angle) {\n    return 'rotate(' + angle + ')';\n}\n\n// because Math.sign(Math.cos(Math.PI / 2)) === 1\n// oh javascript ;)\nfunction sign(v) {\n    return Math.abs(v) < 1e-10 ? 0 :\n        v > 0 ? 1 : -1;\n}\n\nfunction signCos(v) {\n    return sign(Math.cos(v));\n}\n\nfunction signSin(v) {\n    return sign(Math.sin(v));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}