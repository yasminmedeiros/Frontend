{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\nmodule.exports = function makeComputeError(opts) {\n  var type = opts.type;\n  var symmetric = opts.symmetric;\n  if (type === 'data') {\n    var array = opts.array || [];\n    if (symmetric) {\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        return [val, val];\n      };\n    } else {\n      var arrayminus = opts.arrayminus || [];\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        var valMinus = +arrayminus[index];\n        // in case one is present and the other is missing, fill in 0\n        // so we still see the present one. Mostly useful during manual\n        // data entry.\n        if (!isNaN(val) || !isNaN(valMinus)) {\n          return [valMinus || 0, val || 0];\n        }\n        return [NaN, NaN];\n      };\n    }\n  } else {\n    var computeErrorValue = makeComputeErrorValue(type, opts.value);\n    var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n    if (symmetric || opts.valueminus === undefined) {\n      return function computeError(dataPt) {\n        var val = computeErrorValue(dataPt);\n        return [val, val];\n      };\n    } else {\n      return function computeError(dataPt) {\n        return [computeErrorValueMinus(dataPt), computeErrorValue(dataPt)];\n      };\n    }\n  }\n};\n\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\nfunction makeComputeErrorValue(type, value) {\n  if (type === 'percent') {\n    return function (dataPt) {\n      return Math.abs(dataPt * value / 100);\n    };\n  }\n  if (type === 'constant') {\n    return function () {\n      return Math.abs(value);\n    };\n  }\n  if (type === 'sqrt') {\n    return function (dataPt) {\n      return Math.sqrt(Math.abs(dataPt));\n    };\n  }\n}","map":{"version":3,"names":["module","exports","makeComputeError","opts","type","symmetric","array","computeError","dataPt","index","val","arrayminus","valMinus","isNaN","NaN","computeErrorValue","makeComputeErrorValue","value","computeErrorValueMinus","valueminus","undefined","Math","abs","sqrt"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/components/errorbars/compute_error.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\n\n/**\n * Error bar computing function generator\n *\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\n * entries result in undefined error magnitudes.\n *\n * @param {object} opts error bar attributes\n *\n * @return {function} :\n *      @param {numeric} dataPt data point from where to compute the error magnitude\n *      @param {number} index index of dataPt in its corresponding data array\n *      @return {array}\n *        - error[0] : error magnitude in the negative direction\n *        - error[1] : \" \" \" \" positive \"\n */\nmodule.exports = function makeComputeError(opts) {\n    var type = opts.type;\n    var symmetric = opts.symmetric;\n\n    if(type === 'data') {\n        var array = opts.array || [];\n\n        if(symmetric) {\n            return function computeError(dataPt, index) {\n                var val = +(array[index]);\n                return [val, val];\n            };\n        }\n        else {\n            var arrayminus = opts.arrayminus || [];\n            return function computeError(dataPt, index) {\n                var val = +array[index];\n                var valMinus = +arrayminus[index];\n                // in case one is present and the other is missing, fill in 0\n                // so we still see the present one. Mostly useful during manual\n                // data entry.\n                if(!isNaN(val) || !isNaN(valMinus)) {\n                    return [valMinus || 0, val || 0];\n                }\n                return [NaN, NaN];\n            };\n        }\n    }\n    else {\n        var computeErrorValue = makeComputeErrorValue(type, opts.value);\n        var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n        if(symmetric || opts.valueminus === undefined) {\n            return function computeError(dataPt) {\n                var val = computeErrorValue(dataPt);\n                return [val, val];\n            };\n        }\n        else {\n            return function computeError(dataPt) {\n                return [\n                    computeErrorValueMinus(dataPt),\n                    computeErrorValue(dataPt)\n                ];\n            };\n        }\n    }\n};\n\n/**\n * Compute error bar magnitude (for all types except data)\n *\n * @param {string} type error bar type\n * @param {numeric} value error bar value\n *\n * @return {function} :\n *      @param {numeric} dataPt\n */\nfunction makeComputeErrorValue(type, value) {\n    if(type === 'percent') {\n        return function(dataPt) {\n            return Math.abs(dataPt * value / 100);\n        };\n    }\n    if(type === 'constant') {\n        return function() {\n            return Math.abs(value);\n        };\n    }\n    if(type === 'sqrt') {\n        return function(dataPt) {\n            return Math.sqrt(Math.abs(dataPt));\n        };\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA,YAAY;;AAGZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAO,GAAG,SAASC,gBAAgB,CAACC,IAAI,EAAE;EAC7C,IAAIC,IAAI,GAAGD,IAAI,CAACC,IAAI;EACpB,IAAIC,SAAS,GAAGF,IAAI,CAACE,SAAS;EAE9B,IAAGD,IAAI,KAAK,MAAM,EAAE;IAChB,IAAIE,KAAK,GAAGH,IAAI,CAACG,KAAK,IAAI,EAAE;IAE5B,IAAGD,SAAS,EAAE;MACV,OAAO,SAASE,YAAY,CAACC,MAAM,EAAEC,KAAK,EAAE;QACxC,IAAIC,GAAG,GAAG,CAAEJ,KAAK,CAACG,KAAK,CAAE;QACzB,OAAO,CAACC,GAAG,EAAEA,GAAG,CAAC;MACrB,CAAC;IACL,CAAC,MACI;MACD,IAAIC,UAAU,GAAGR,IAAI,CAACQ,UAAU,IAAI,EAAE;MACtC,OAAO,SAASJ,YAAY,CAACC,MAAM,EAAEC,KAAK,EAAE;QACxC,IAAIC,GAAG,GAAG,CAACJ,KAAK,CAACG,KAAK,CAAC;QACvB,IAAIG,QAAQ,GAAG,CAACD,UAAU,CAACF,KAAK,CAAC;QACjC;QACA;QACA;QACA,IAAG,CAACI,KAAK,CAACH,GAAG,CAAC,IAAI,CAACG,KAAK,CAACD,QAAQ,CAAC,EAAE;UAChC,OAAO,CAACA,QAAQ,IAAI,CAAC,EAAEF,GAAG,IAAI,CAAC,CAAC;QACpC;QACA,OAAO,CAACI,GAAG,EAAEA,GAAG,CAAC;MACrB,CAAC;IACL;EACJ,CAAC,MACI;IACD,IAAIC,iBAAiB,GAAGC,qBAAqB,CAACZ,IAAI,EAAED,IAAI,CAACc,KAAK,CAAC;IAC/D,IAAIC,sBAAsB,GAAGF,qBAAqB,CAACZ,IAAI,EAAED,IAAI,CAACgB,UAAU,CAAC;IAEzE,IAAGd,SAAS,IAAIF,IAAI,CAACgB,UAAU,KAAKC,SAAS,EAAE;MAC3C,OAAO,SAASb,YAAY,CAACC,MAAM,EAAE;QACjC,IAAIE,GAAG,GAAGK,iBAAiB,CAACP,MAAM,CAAC;QACnC,OAAO,CAACE,GAAG,EAAEA,GAAG,CAAC;MACrB,CAAC;IACL,CAAC,MACI;MACD,OAAO,SAASH,YAAY,CAACC,MAAM,EAAE;QACjC,OAAO,CACHU,sBAAsB,CAACV,MAAM,CAAC,EAC9BO,iBAAiB,CAACP,MAAM,CAAC,CAC5B;MACL,CAAC;IACL;EACJ;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASQ,qBAAqB,CAACZ,IAAI,EAAEa,KAAK,EAAE;EACxC,IAAGb,IAAI,KAAK,SAAS,EAAE;IACnB,OAAO,UAASI,MAAM,EAAE;MACpB,OAAOa,IAAI,CAACC,GAAG,CAACd,MAAM,GAAGS,KAAK,GAAG,GAAG,CAAC;IACzC,CAAC;EACL;EACA,IAAGb,IAAI,KAAK,UAAU,EAAE;IACpB,OAAO,YAAW;MACd,OAAOiB,IAAI,CAACC,GAAG,CAACL,KAAK,CAAC;IAC1B,CAAC;EACL;EACA,IAAGb,IAAI,KAAK,MAAM,EAAE;IAChB,OAAO,UAASI,MAAM,EAAE;MACpB,OAAOa,IAAI,CAACE,IAAI,CAACF,IAAI,CAACC,GAAG,CAACd,MAAM,CAAC,CAAC;IACtC,CAAC;EACL;AACJ"},"metadata":{},"sourceType":"script","externalDependencies":[]}