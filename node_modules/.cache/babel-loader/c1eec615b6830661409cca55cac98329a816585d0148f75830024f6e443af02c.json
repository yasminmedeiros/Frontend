{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Loggers = require('./lib/loggers');\nvar noop = require('./lib/noop');\nvar pushUnique = require('./lib/push_unique');\nvar isPlainObject = require('./lib/is_plain_object');\nvar ExtendModule = require('./lib/extend');\nvar basePlotAttributes = require('./plots/attributes');\nvar baseLayoutAttributes = require('./plots/layout_attributes');\nvar extendFlat = ExtendModule.extendFlat;\nvar extendDeepAll = ExtendModule.extendDeepAll;\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\nexports.traceLayoutAttributes = {};\nexports.localeRegistry = {};\nexports.apiMethodRegistry = {};\nexports.collectableSubplotTypes = null;\n\n/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */\nexports.register = function register(_modules) {\n  exports.collectableSubplotTypes = null;\n  if (!_modules) {\n    throw new Error('No argument passed to Plotly.register.');\n  } else if (_modules && !Array.isArray(_modules)) {\n    _modules = [_modules];\n  }\n  for (var i = 0; i < _modules.length; i++) {\n    var newModule = _modules[i];\n    if (!newModule) {\n      throw new Error('Invalid module was attempted to be registered!');\n    }\n    switch (newModule.moduleType) {\n      case 'trace':\n        registerTraceModule(newModule);\n        break;\n      case 'transform':\n        registerTransformModule(newModule);\n        break;\n      case 'component':\n        registerComponentModule(newModule);\n        break;\n      case 'locale':\n        registerLocale(newModule);\n        break;\n      case 'apiMethod':\n        var name = newModule.name;\n        exports.apiMethodRegistry[name] = newModule.fn;\n        break;\n      default:\n        throw new Error('Invalid module was attempted to be registered!');\n    }\n  }\n};\n\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\nexports.getModule = function (trace) {\n  var _module = exports.modules[getTraceType(trace)];\n  if (!_module) return false;\n  return _module._module;\n};\n\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\nexports.traceIs = function (traceType, category) {\n  traceType = getTraceType(traceType);\n\n  // old plot.ly workspace hack, nothing to see here\n  if (traceType === 'various') return false;\n  var _module = exports.modules[traceType];\n  if (!_module) {\n    if (traceType && traceType !== 'area') {\n      Loggers.log('Unrecognized trace type ' + traceType + '.');\n    }\n    _module = exports.modules[basePlotAttributes.type.dflt];\n  }\n  return !!_module.categories[category];\n};\n\n/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */\nexports.getTransformIndices = function (data, type) {\n  var indices = [];\n  var transforms = data.transforms || [];\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      indices.push(i);\n    }\n  }\n  return indices;\n};\n\n/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */\nexports.hasTransform = function (data, type) {\n  var transforms = data.transforms || [];\n  for (var i = 0; i < transforms.length; i++) {\n    if (transforms[i].type === type) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\nexports.getComponentMethod = function (name, method) {\n  var _module = exports.componentsRegistry[name];\n  if (!_module) return noop;\n  return _module[method] || noop;\n};\n\n/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */\nexports.call = function () {\n  var name = arguments[0];\n  var args = [].slice.call(arguments, 1);\n  return exports.apiMethodRegistry[name].apply(null, args);\n};\nfunction registerTraceModule(_module) {\n  var thisType = _module.name;\n  var categoriesIn = _module.categories;\n  var meta = _module.meta;\n  if (exports.modules[thisType]) {\n    Loggers.log('Type ' + thisType + ' already registered');\n    return;\n  }\n  if (!exports.subplotsRegistry[_module.basePlotModule.name]) {\n    registerSubplot(_module.basePlotModule);\n  }\n  var categoryObj = {};\n  for (var i = 0; i < categoriesIn.length; i++) {\n    categoryObj[categoriesIn[i]] = true;\n    exports.allCategories[categoriesIn[i]] = true;\n  }\n  exports.modules[thisType] = {\n    _module: _module,\n    categories: categoryObj\n  };\n  if (meta && Object.keys(meta).length) {\n    exports.modules[thisType].meta = meta;\n  }\n  exports.allTypes.push(thisType);\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTrace(componentName, thisType);\n  }\n\n  /*\n   * Collect all trace layout attributes in one place for easier lookup later\n   * but don't merge them into the base schema as it would confuse the docs\n   * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n   */\n  if (_module.layoutAttributes) {\n    extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);\n  }\n}\nfunction registerSubplot(_module) {\n  var plotType = _module.name;\n  if (exports.subplotsRegistry[plotType]) {\n    Loggers.log('Plot type ' + plotType + ' already registered.');\n    return;\n  }\n\n  // relayout array handling will look for component module methods with this\n  // name and won't find them because this is a subplot module... but that\n  // should be fine, it will just fall back on redrawing the plot.\n  findArrayRegexps(_module);\n\n  // not sure what's best for the 'cartesian' type at this point\n  exports.subplotsRegistry[plotType] = _module;\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToSubplot(componentName, _module.name);\n  }\n}\nfunction registerComponentModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Component module *name* must be a string.');\n  }\n  var name = _module.name;\n  exports.componentsRegistry[name] = _module;\n  if (_module.layoutAttributes) {\n    if (_module.layoutAttributes._isLinkedToArray) {\n      pushUnique(exports.layoutArrayContainers, name);\n    }\n    findArrayRegexps(_module);\n  }\n  for (var traceType in exports.modules) {\n    mergeComponentAttrsToTrace(name, traceType);\n  }\n  for (var subplotName in exports.subplotsRegistry) {\n    mergeComponentAttrsToSubplot(name, subplotName);\n  }\n  for (var transformType in exports.transformsRegistry) {\n    mergeComponentAttrsToTransform(name, transformType);\n  }\n  if (_module.schema && _module.schema.layout) {\n    extendDeepAll(baseLayoutAttributes, _module.schema.layout);\n  }\n}\nfunction registerTransformModule(_module) {\n  if (typeof _module.name !== 'string') {\n    throw new Error('Transform module *name* must be a string.');\n  }\n  var prefix = 'Transform module ' + _module.name;\n  var hasTransform = typeof _module.transform === 'function';\n  var hasCalcTransform = typeof _module.calcTransform === 'function';\n  if (!hasTransform && !hasCalcTransform) {\n    throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n  }\n  if (hasTransform && hasCalcTransform) {\n    Loggers.log([prefix + ' has both a *transform* and *calcTransform* methods.', 'Please note that all *transform* methods are executed', 'before all *calcTransform* methods.'].join(' '));\n  }\n  if (!isPlainObject(_module.attributes)) {\n    Loggers.log(prefix + ' registered without an *attributes* object.');\n  }\n  if (typeof _module.supplyDefaults !== 'function') {\n    Loggers.log(prefix + ' registered without a *supplyDefaults* method.');\n  }\n  exports.transformsRegistry[_module.name] = _module;\n  for (var componentName in exports.componentsRegistry) {\n    mergeComponentAttrsToTransform(componentName, _module.name);\n  }\n}\nfunction registerLocale(_module) {\n  var locale = _module.name;\n  var baseLocale = locale.split('-')[0];\n  var newDict = _module.dictionary;\n  var newFormat = _module.format;\n  var hasDict = newDict && Object.keys(newDict).length;\n  var hasFormat = newFormat && Object.keys(newFormat).length;\n  var locales = exports.localeRegistry;\n  var localeObj = locales[locale];\n  if (!localeObj) locales[locale] = localeObj = {};\n\n  // Should we use this dict for the base locale?\n  // In case we're overwriting a previous dict for this locale, check\n  // whether the base matches the full locale dict now. If we're not\n  // overwriting, locales[locale] is undefined so this just checks if\n  // baseLocale already had a dict or not.\n  // Same logic for dateFormats\n  if (baseLocale !== locale) {\n    var baseLocaleObj = locales[baseLocale];\n    if (!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};\n    if (hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {\n      baseLocaleObj.dictionary = newDict;\n    }\n    if (hasFormat && baseLocaleObj.format === localeObj.format) {\n      baseLocaleObj.format = newFormat;\n    }\n  }\n  if (hasDict) localeObj.dictionary = newDict;\n  if (hasFormat) localeObj.format = newFormat;\n}\nfunction findArrayRegexps(_module) {\n  if (_module.layoutAttributes) {\n    var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n    if (arrayAttrRegexps) {\n      for (var i = 0; i < arrayAttrRegexps.length; i++) {\n        pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n      }\n    }\n  }\n}\nfunction mergeComponentAttrsToTrace(componentName, traceType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.traces) return;\n  var traceAttrs = componentSchema.traces[traceType];\n  if (traceAttrs) {\n    extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);\n  }\n}\nfunction mergeComponentAttrsToTransform(componentName, transformType) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.transforms) return;\n  var transformAttrs = componentSchema.transforms[transformType];\n  if (transformAttrs) {\n    extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);\n  }\n}\nfunction mergeComponentAttrsToSubplot(componentName, subplotName) {\n  var componentSchema = exports.componentsRegistry[componentName].schema;\n  if (!componentSchema || !componentSchema.subplots) return;\n  var subplotModule = exports.subplotsRegistry[subplotName];\n  var subplotAttrs = subplotModule.layoutAttributes;\n  var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;\n  if (Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];\n  var componentLayoutAttrs = componentSchema.subplots[subplotAttr];\n  if (subplotAttrs && componentLayoutAttrs) {\n    extendDeepAll(subplotAttrs, componentLayoutAttrs);\n  }\n}\nfunction getTraceType(traceType) {\n  if (typeof traceType === 'object') traceType = traceType.type;\n  return traceType;\n}","map":{"version":3,"names":["Loggers","require","noop","pushUnique","isPlainObject","ExtendModule","basePlotAttributes","baseLayoutAttributes","extendFlat","extendDeepAll","exports","modules","allCategories","allTypes","subplotsRegistry","transformsRegistry","componentsRegistry","layoutArrayContainers","layoutArrayRegexes","traceLayoutAttributes","localeRegistry","apiMethodRegistry","collectableSubplotTypes","register","_modules","Error","Array","isArray","i","length","newModule","moduleType","registerTraceModule","registerTransformModule","registerComponentModule","registerLocale","name","fn","getModule","trace","_module","getTraceType","traceIs","traceType","category","log","type","dflt","categories","getTransformIndices","data","indices","transforms","push","hasTransform","getComponentMethod","method","call","arguments","args","slice","apply","thisType","categoriesIn","meta","basePlotModule","registerSubplot","categoryObj","Object","keys","componentName","mergeComponentAttrsToTrace","layoutAttributes","plotType","findArrayRegexps","mergeComponentAttrsToSubplot","_isLinkedToArray","subplotName","transformType","mergeComponentAttrsToTransform","schema","layout","prefix","transform","hasCalcTransform","calcTransform","join","attributes","supplyDefaults","locale","baseLocale","split","newDict","dictionary","newFormat","format","hasDict","hasFormat","locales","localeObj","baseLocaleObj","arrayAttrRegexps","_arrayAttrRegexps","componentSchema","traces","traceAttrs","transformAttrs","subplots","subplotModule","subplotAttrs","subplotAttr","attr","componentLayoutAttrs"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/registry.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Loggers = require('./lib/loggers');\nvar noop = require('./lib/noop');\nvar pushUnique = require('./lib/push_unique');\nvar isPlainObject = require('./lib/is_plain_object');\nvar ExtendModule = require('./lib/extend');\n\nvar basePlotAttributes = require('./plots/attributes');\nvar baseLayoutAttributes = require('./plots/layout_attributes');\n\nvar extendFlat = ExtendModule.extendFlat;\nvar extendDeepAll = ExtendModule.extendDeepAll;\n\nexports.modules = {};\nexports.allCategories = {};\nexports.allTypes = [];\nexports.subplotsRegistry = {};\nexports.transformsRegistry = {};\nexports.componentsRegistry = {};\nexports.layoutArrayContainers = [];\nexports.layoutArrayRegexes = [];\nexports.traceLayoutAttributes = {};\nexports.localeRegistry = {};\nexports.apiMethodRegistry = {};\nexports.collectableSubplotTypes = null;\n\n/**\n * Top-level register routine, exported as Plotly.register\n *\n * @param {object array or array of objects} _modules :\n *  module object or list of module object to register.\n *\n *  A valid `moduleType: 'trace'` module has fields:\n *  - name {string} : the trace type\n *  - categories {array} : categories associated with this trace type,\n *                         tested with Register.traceIs()\n *  - meta {object} : meta info (mostly for plot-schema)\n *\n *  A valid `moduleType: 'locale'` module has fields:\n *  - name {string} : the locale name. Should be a 2-digit language string ('en', 'de')\n *                    optionally with a country/region code ('en-GB', 'de-CH'). If a country\n *                    code is used but the base language locale has not yet been supplied,\n *                    we will use this locale for the base as well.\n *  - dictionary {object} : the dictionary mapping input strings to localized strings\n *                          generally the keys should be the literal input strings, but\n *                          if default translations are provided you can use any string as a key.\n *  - format {object} : a `d3.locale` format specifier for this locale\n *                      any omitted keys we'll fall back on en-US.\n *\n *  A valid `moduleType: 'transform'` module has fields:\n *  - name {string} : transform name\n *  - transform {function} : default-level transform function\n *  - calcTransform {function} : calc-level transform function\n *  - attributes {object} : transform attributes declarations\n *  - supplyDefaults {function} : attributes default-supply function\n *\n *  A valid `moduleType: 'component'` module has fields:\n *  - name {string} : the component name, used it with Register.getComponentMethod()\n *                    to employ component method.\n *\n *  A valid `moduleType: 'apiMethod'` module has fields:\n *  - name {string} : the api method name.\n *  - fn {function} : the api method called with Register.call();\n *\n */\nexports.register = function register(_modules) {\n    exports.collectableSubplotTypes = null;\n\n    if(!_modules) {\n        throw new Error('No argument passed to Plotly.register.');\n    } else if(_modules && !Array.isArray(_modules)) {\n        _modules = [_modules];\n    }\n\n    for(var i = 0; i < _modules.length; i++) {\n        var newModule = _modules[i];\n\n        if(!newModule) {\n            throw new Error('Invalid module was attempted to be registered!');\n        }\n\n        switch(newModule.moduleType) {\n            case 'trace':\n                registerTraceModule(newModule);\n                break;\n            case 'transform':\n                registerTransformModule(newModule);\n                break;\n            case 'component':\n                registerComponentModule(newModule);\n                break;\n            case 'locale':\n                registerLocale(newModule);\n                break;\n            case 'apiMethod':\n                var name = newModule.name;\n                exports.apiMethodRegistry[name] = newModule.fn;\n                break;\n            default:\n                throw new Error('Invalid module was attempted to be registered!');\n        }\n    }\n};\n\n/**\n * Get registered module using trace object or trace type\n *\n * @param {object||string} trace\n *  trace object with prop 'type' or trace type as a string\n * @return {object}\n *  module object corresponding to trace type\n */\nexports.getModule = function(trace) {\n    var _module = exports.modules[getTraceType(trace)];\n    if(!_module) return false;\n    return _module._module;\n};\n\n/**\n * Determine if this trace type is in a given category\n *\n * @param {object||string} traceType\n *  a trace (object) or trace type (string)\n * @param {string} category\n *  category in question\n * @return {boolean}\n */\nexports.traceIs = function(traceType, category) {\n    traceType = getTraceType(traceType);\n\n    // old plot.ly workspace hack, nothing to see here\n    if(traceType === 'various') return false;\n\n    var _module = exports.modules[traceType];\n\n    if(!_module) {\n        if(traceType && traceType !== 'area') {\n            Loggers.log('Unrecognized trace type ' + traceType + '.');\n        }\n\n        _module = exports.modules[basePlotAttributes.type.dflt];\n    }\n\n    return !!_module.categories[category];\n};\n\n/**\n * Determine if this trace has a transform of the given type and return\n * array of matching indices.\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {array}\n *  array of matching indices. If none found, returns []\n */\nexports.getTransformIndices = function(data, type) {\n    var indices = [];\n    var transforms = data.transforms || [];\n    for(var i = 0; i < transforms.length; i++) {\n        if(transforms[i].type === type) {\n            indices.push(i);\n        }\n    }\n    return indices;\n};\n\n/**\n * Determine if this trace has a transform of the given type\n *\n * @param {object} data\n *  a trace object (member of data or fullData)\n * @param {string} type\n *  type of trace to test\n * @return {boolean}\n */\nexports.hasTransform = function(data, type) {\n    var transforms = data.transforms || [];\n    for(var i = 0; i < transforms.length; i++) {\n        if(transforms[i].type === type) {\n            return true;\n        }\n    }\n    return false;\n};\n\n/**\n * Retrieve component module method. Falls back on noop if either the\n * module or the method is missing, so the result can always be safely called\n *\n * @param {string} name\n *  name of component (as declared in component module)\n * @param {string} method\n *  name of component module method\n * @return {function}\n */\nexports.getComponentMethod = function(name, method) {\n    var _module = exports.componentsRegistry[name];\n\n    if(!_module) return noop;\n    return _module[method] || noop;\n};\n\n/**\n * Call registered api method.\n *\n * @param {string} name : api method name\n * @param {...array} args : arguments passed to api method\n * @return {any} : returns api method output\n */\nexports.call = function() {\n    var name = arguments[0];\n    var args = [].slice.call(arguments, 1);\n    return exports.apiMethodRegistry[name].apply(null, args);\n};\n\nfunction registerTraceModule(_module) {\n    var thisType = _module.name;\n    var categoriesIn = _module.categories;\n    var meta = _module.meta;\n\n    if(exports.modules[thisType]) {\n        Loggers.log('Type ' + thisType + ' already registered');\n        return;\n    }\n\n    if(!exports.subplotsRegistry[_module.basePlotModule.name]) {\n        registerSubplot(_module.basePlotModule);\n    }\n\n    var categoryObj = {};\n    for(var i = 0; i < categoriesIn.length; i++) {\n        categoryObj[categoriesIn[i]] = true;\n        exports.allCategories[categoriesIn[i]] = true;\n    }\n\n    exports.modules[thisType] = {\n        _module: _module,\n        categories: categoryObj\n    };\n\n    if(meta && Object.keys(meta).length) {\n        exports.modules[thisType].meta = meta;\n    }\n\n    exports.allTypes.push(thisType);\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToTrace(componentName, thisType);\n    }\n\n    /*\n     * Collect all trace layout attributes in one place for easier lookup later\n     * but don't merge them into the base schema as it would confuse the docs\n     * (at least after https://github.com/plotly/documentation/issues/202 gets done!)\n     */\n    if(_module.layoutAttributes) {\n        extendFlat(exports.traceLayoutAttributes, _module.layoutAttributes);\n    }\n}\n\nfunction registerSubplot(_module) {\n    var plotType = _module.name;\n\n    if(exports.subplotsRegistry[plotType]) {\n        Loggers.log('Plot type ' + plotType + ' already registered.');\n        return;\n    }\n\n    // relayout array handling will look for component module methods with this\n    // name and won't find them because this is a subplot module... but that\n    // should be fine, it will just fall back on redrawing the plot.\n    findArrayRegexps(_module);\n\n    // not sure what's best for the 'cartesian' type at this point\n    exports.subplotsRegistry[plotType] = _module;\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToSubplot(componentName, _module.name);\n    }\n}\n\nfunction registerComponentModule(_module) {\n    if(typeof _module.name !== 'string') {\n        throw new Error('Component module *name* must be a string.');\n    }\n\n    var name = _module.name;\n    exports.componentsRegistry[name] = _module;\n\n    if(_module.layoutAttributes) {\n        if(_module.layoutAttributes._isLinkedToArray) {\n            pushUnique(exports.layoutArrayContainers, name);\n        }\n        findArrayRegexps(_module);\n    }\n\n    for(var traceType in exports.modules) {\n        mergeComponentAttrsToTrace(name, traceType);\n    }\n\n    for(var subplotName in exports.subplotsRegistry) {\n        mergeComponentAttrsToSubplot(name, subplotName);\n    }\n\n    for(var transformType in exports.transformsRegistry) {\n        mergeComponentAttrsToTransform(name, transformType);\n    }\n\n    if(_module.schema && _module.schema.layout) {\n        extendDeepAll(baseLayoutAttributes, _module.schema.layout);\n    }\n}\n\nfunction registerTransformModule(_module) {\n    if(typeof _module.name !== 'string') {\n        throw new Error('Transform module *name* must be a string.');\n    }\n\n    var prefix = 'Transform module ' + _module.name;\n    var hasTransform = typeof _module.transform === 'function';\n    var hasCalcTransform = typeof _module.calcTransform === 'function';\n\n    if(!hasTransform && !hasCalcTransform) {\n        throw new Error(prefix + ' is missing a *transform* or *calcTransform* method.');\n    }\n    if(hasTransform && hasCalcTransform) {\n        Loggers.log([\n            prefix + ' has both a *transform* and *calcTransform* methods.',\n            'Please note that all *transform* methods are executed',\n            'before all *calcTransform* methods.'\n        ].join(' '));\n    }\n    if(!isPlainObject(_module.attributes)) {\n        Loggers.log(prefix + ' registered without an *attributes* object.');\n    }\n    if(typeof _module.supplyDefaults !== 'function') {\n        Loggers.log(prefix + ' registered without a *supplyDefaults* method.');\n    }\n\n    exports.transformsRegistry[_module.name] = _module;\n\n    for(var componentName in exports.componentsRegistry) {\n        mergeComponentAttrsToTransform(componentName, _module.name);\n    }\n}\n\nfunction registerLocale(_module) {\n    var locale = _module.name;\n    var baseLocale = locale.split('-')[0];\n\n    var newDict = _module.dictionary;\n    var newFormat = _module.format;\n    var hasDict = newDict && Object.keys(newDict).length;\n    var hasFormat = newFormat && Object.keys(newFormat).length;\n\n    var locales = exports.localeRegistry;\n\n    var localeObj = locales[locale];\n    if(!localeObj) locales[locale] = localeObj = {};\n\n    // Should we use this dict for the base locale?\n    // In case we're overwriting a previous dict for this locale, check\n    // whether the base matches the full locale dict now. If we're not\n    // overwriting, locales[locale] is undefined so this just checks if\n    // baseLocale already had a dict or not.\n    // Same logic for dateFormats\n    if(baseLocale !== locale) {\n        var baseLocaleObj = locales[baseLocale];\n        if(!baseLocaleObj) locales[baseLocale] = baseLocaleObj = {};\n\n        if(hasDict && baseLocaleObj.dictionary === localeObj.dictionary) {\n            baseLocaleObj.dictionary = newDict;\n        }\n        if(hasFormat && baseLocaleObj.format === localeObj.format) {\n            baseLocaleObj.format = newFormat;\n        }\n    }\n\n    if(hasDict) localeObj.dictionary = newDict;\n    if(hasFormat) localeObj.format = newFormat;\n}\n\nfunction findArrayRegexps(_module) {\n    if(_module.layoutAttributes) {\n        var arrayAttrRegexps = _module.layoutAttributes._arrayAttrRegexps;\n        if(arrayAttrRegexps) {\n            for(var i = 0; i < arrayAttrRegexps.length; i++) {\n                pushUnique(exports.layoutArrayRegexes, arrayAttrRegexps[i]);\n            }\n        }\n    }\n}\n\nfunction mergeComponentAttrsToTrace(componentName, traceType) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.traces) return;\n\n    var traceAttrs = componentSchema.traces[traceType];\n    if(traceAttrs) {\n        extendDeepAll(exports.modules[traceType]._module.attributes, traceAttrs);\n    }\n}\n\nfunction mergeComponentAttrsToTransform(componentName, transformType) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.transforms) return;\n\n    var transformAttrs = componentSchema.transforms[transformType];\n    if(transformAttrs) {\n        extendDeepAll(exports.transformsRegistry[transformType].attributes, transformAttrs);\n    }\n}\n\nfunction mergeComponentAttrsToSubplot(componentName, subplotName) {\n    var componentSchema = exports.componentsRegistry[componentName].schema;\n    if(!componentSchema || !componentSchema.subplots) return;\n\n    var subplotModule = exports.subplotsRegistry[subplotName];\n    var subplotAttrs = subplotModule.layoutAttributes;\n    var subplotAttr = subplotModule.attr === 'subplot' ? subplotModule.name : subplotModule.attr;\n    if(Array.isArray(subplotAttr)) subplotAttr = subplotAttr[0];\n\n    var componentLayoutAttrs = componentSchema.subplots[subplotAttr];\n    if(subplotAttrs && componentLayoutAttrs) {\n        extendDeepAll(subplotAttrs, componentLayoutAttrs);\n    }\n}\n\nfunction getTraceType(traceType) {\n    if(typeof traceType === 'object') traceType = traceType.type;\n    return traceType;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}