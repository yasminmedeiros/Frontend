{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\nmodule.exports = {\n  getAutoRange: getAutoRange,\n  makePadFn: makePadFn,\n  doAutoRange: doAutoRange,\n  findExtremes: findExtremes,\n  concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n  var i, j;\n  var newRange = [];\n  var getPad = makePadFn(ax);\n  var extremes = concatExtremes(gd, ax);\n  var minArray = extremes.min;\n  var maxArray = extremes.max;\n  if (minArray.length === 0 || maxArray.length === 0) {\n    return Lib.simpleMap(ax.range, ax.r2l);\n  }\n  var minmin = minArray[0].val;\n  var maxmax = maxArray[0].val;\n  for (i = 1; i < minArray.length; i++) {\n    if (minmin !== maxmax) break;\n    minmin = Math.min(minmin, minArray[i].val);\n  }\n  for (i = 1; i < maxArray.length; i++) {\n    if (minmin !== maxmax) break;\n    maxmax = Math.max(maxmax, maxArray[i].val);\n  }\n  var axReverse = false;\n  if (ax.range) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    axReverse = rng[1] < rng[0];\n  }\n  // one-time setting to easily reverse the axis\n  // when plotting from code\n  if (ax.autorange === 'reversed') {\n    axReverse = true;\n    ax.autorange = true;\n  }\n  var rangeMode = ax.rangemode;\n  var toZero = rangeMode === 'tozero';\n  var nonNegative = rangeMode === 'nonnegative';\n  var axLen = ax._length;\n  // don't allow padding to reduce the data to < 10% of the length\n  var minSpan = axLen / 10;\n  var mbest = 0;\n  var minpt, maxpt, minbest, maxbest, dp, dv;\n  for (i = 0; i < minArray.length; i++) {\n    minpt = minArray[i];\n    for (j = 0; j < maxArray.length; j++) {\n      maxpt = maxArray[j];\n      dv = maxpt.val - minpt.val;\n      if (dv > 0) {\n        dp = axLen - getPad(minpt) - getPad(maxpt);\n        if (dp > minSpan) {\n          if (dv / dp > mbest) {\n            minbest = minpt;\n            maxbest = maxpt;\n            mbest = dv / dp;\n          }\n        } else if (dv / axLen > mbest) {\n          // in case of padding longer than the axis\n          // at least include the unpadded data values.\n          minbest = {\n            val: minpt.val,\n            pad: 0\n          };\n          maxbest = {\n            val: maxpt.val,\n            pad: 0\n          };\n          mbest = dv / axLen;\n        }\n      }\n    }\n  }\n  function getMaxPad(prev, pt) {\n    return Math.max(prev, getPad(pt));\n  }\n  if (minmin === maxmax) {\n    var lower = minmin - 1;\n    var upper = minmin + 1;\n    if (toZero) {\n      if (minmin === 0) {\n        // The only value we have on this axis is 0, and we want to\n        // autorange so zero is one end.\n        // In principle this could be [0, 1] or [-1, 0] but usually\n        // 'tozero' pins 0 to the low end, so follow that.\n        newRange = [0, 1];\n      } else {\n        var maxPad = (minmin > 0 ? maxArray : minArray).reduce(getMaxPad, 0);\n        // we're pushing a single value away from the edge due to its\n        // padding, with the other end clamped at zero\n        // 0.5 means don't push it farther than the center.\n        var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n        newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n      }\n    } else if (nonNegative) {\n      newRange = [Math.max(0, lower), Math.max(1, upper)];\n    } else {\n      newRange = [lower, upper];\n    }\n  } else {\n    if (toZero) {\n      if (minbest.val >= 0) {\n        minbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n    } else if (nonNegative) {\n      if (minbest.val - mbest * getPad(minbest) < 0) {\n        minbest = {\n          val: 0,\n          pad: 0\n        };\n      }\n      if (maxbest.val <= 0) {\n        maxbest = {\n          val: 1,\n          pad: 0\n        };\n      }\n    }\n\n    // in case it changed again...\n    mbest = (maxbest.val - minbest.val) / (axLen - getPad(minbest) - getPad(maxbest));\n    newRange = [minbest.val - mbest * getPad(minbest), maxbest.val + mbest * getPad(maxbest)];\n  }\n\n  // maintain reversal\n  if (axReverse) newRange.reverse();\n  return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(ax) {\n  // 5% padding for points that specify extrapad: true\n  var extrappad = ax._length / 20;\n\n  // domain-constrained axes: base extrappad on the unconstrained\n  // domain so it's consistent as the domain changes\n  if (ax.constrain === 'domain' && ax._inputDomain) {\n    extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) / (ax.domain[1] - ax.domain[0]);\n  }\n  return function getPad(pt) {\n    return pt.pad + (pt.extrapad ? extrappad : 0);\n  };\n}\nfunction concatExtremes(gd, ax) {\n  var axId = ax._id;\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n  var minArray = [];\n  var maxArray = [];\n  var i, j, d;\n  function _concat(cont, indices) {\n    for (i = 0; i < indices.length; i++) {\n      var item = cont[indices[i]];\n      var extremes = (item._extremes || {})[axId];\n      if (item.visible === true && extremes) {\n        for (j = 0; j < extremes.min.length; j++) {\n          d = extremes.min[j];\n          collapseMinArray(minArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n        for (j = 0; j < extremes.max.length; j++) {\n          d = extremes.max[j];\n          collapseMaxArray(maxArray, d.val, d.pad, {\n            extrapad: d.extrapad\n          });\n        }\n      }\n    }\n  }\n  _concat(fullData, ax._traceIndices);\n  _concat(fullLayout.annotations || [], ax._annIndices || []);\n  _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n  return {\n    min: minArray,\n    max: maxArray\n  };\n}\nfunction doAutoRange(gd, ax) {\n  if (ax.autorange) {\n    ax.range = getAutoRange(gd, ax);\n    ax._r = ax.range.slice();\n    ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n    // doAutoRange will get called on fullLayout,\n    // but we want to report its results back to layout\n\n    var axIn = ax._input;\n\n    // before we edit _input, store preGUI values\n    var edits = {};\n    edits[ax._attr + '.range'] = ax.range;\n    edits[ax._attr + '.autorange'] = ax.autorange;\n    Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n    axIn.range = ax.range.slice();\n    axIn.autorange = ax.autorange;\n  }\n  var anchorAx = ax._anchorAxis;\n  if (anchorAx && anchorAx.rangeslider) {\n    var axeRangeOpts = anchorAx.rangeslider[ax._name];\n    if (axeRangeOpts) {\n      if (axeRangeOpts.rangemode === 'auto') {\n        axeRangeOpts.range = getAutoRange(gd, ax);\n      }\n    }\n    anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n  }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n  if (!opts) opts = {};\n  if (!ax._m) ax.setScale();\n  var minArray = [];\n  var maxArray = [];\n  var len = data.length;\n  var extrapad = opts.padded || false;\n  var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n  var isLog = ax.type === 'log';\n  var hasArrayOption = false;\n  var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n  function makePadAccessor(item) {\n    if (Array.isArray(item)) {\n      hasArrayOption = true;\n      return function (i) {\n        return Math.max(Number(item[i] || 0), 0);\n      };\n    } else {\n      var v = Math.max(Number(item || 0), 0);\n      return function () {\n        return v;\n      };\n    }\n  }\n  var ppadplus = makePadAccessor((ax._m > 0 ? opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n  var ppadminus = makePadAccessor((ax._m > 0 ? opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n  var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n  var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n  if (!hasArrayOption) {\n    // with no arrays other than `data` we don't need to consider\n    // every point, only the extreme data points\n    vmin = Infinity;\n    vmax = -Infinity;\n    if (isLog) {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        // data is not linearized yet so we still have to filter out negative logs\n        if (v < vmin && v > 0) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        v = data[i];\n        if (v < vmin && v > -FP_SAFE) vmin = v;\n        if (v > vmax && v < FP_SAFE) vmax = v;\n      }\n    }\n    data = [vmin, vmax];\n    len = 2;\n  }\n  var collapseOpts = {\n    tozero: tozero,\n    extrapad: extrapad\n  };\n  function addItem(i) {\n    di = data[i];\n    if (!isNumeric(di)) return;\n    ppadiplus = ppadplus(i);\n    ppadiminus = ppadminus(i);\n    vmin = di - vpadminus(i);\n    vmax = di + vpadplus(i);\n    // special case for log axes: if vpad makes this object span\n    // more than an order of mag, clip it to one order. This is so\n    // we don't have non-positive errors or absurdly large lower\n    // range due to rounding errors\n    if (isLog && vmin < vmax / 10) vmin = vmax / 10;\n    dmin = ax.c2l(vmin);\n    dmax = ax.c2l(vmax);\n    if (tozero) {\n      dmin = Math.min(0, dmin);\n      dmax = Math.max(0, dmax);\n    }\n    if (goodNumber(dmin)) {\n      collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n    }\n    if (goodNumber(dmax)) {\n      collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n    }\n  }\n\n  // For efficiency covering monotonic or near-monotonic data,\n  // check a few points at both ends first and then sweep\n  // through the middle\n  var iMax = Math.min(6, len);\n  for (i = 0; i < iMax; i++) {\n    addItem(i);\n  }\n  for (i = len - 1; i >= iMax; i--) {\n    addItem(i);\n  }\n  return {\n    min: minArray,\n    max: maxArray,\n    opts: opts\n  };\n}\nfunction collapseMinArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n  collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n  var tozero = opts.tozero;\n  var extrapad = opts.extrapad;\n  var includeThis = true;\n  for (var j = 0; j < array.length && includeThis; j++) {\n    var v = array[j];\n    if (atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n      includeThis = false;\n      break;\n    } else if (atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n      array.splice(j, 1);\n      j--;\n    }\n  }\n  if (includeThis) {\n    var clipAtZero = tozero && newVal === 0;\n    array.push({\n      val: newVal,\n      pad: clipAtZero ? 0 : newPad,\n      extrapad: clipAtZero ? false : extrapad\n    });\n  }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n  return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\nfunction lessOrEqual(v0, v1) {\n  return v0 <= v1;\n}\nfunction greaterOrEqual(v0, v1) {\n  return v0 >= v1;\n}","map":{"version":3,"names":["isNumeric","require","Lib","FP_SAFE","Registry","module","exports","getAutoRange","makePadFn","doAutoRange","findExtremes","concatExtremes","gd","ax","i","j","newRange","getPad","extremes","minArray","min","maxArray","max","length","simpleMap","range","r2l","minmin","val","maxmax","Math","axReverse","rng","autorange","rangeMode","rangemode","toZero","nonNegative","axLen","_length","minSpan","mbest","minpt","maxpt","minbest","maxbest","dp","dv","pad","getMaxPad","prev","pt","lower","upper","maxPad","reduce","rangeEnd","reverse","l2r","Number","extrappad","constrain","_inputDomain","domain","extrapad","axId","_id","fullData","_fullData","fullLayout","_fullLayout","d","_concat","cont","indices","item","_extremes","visible","collapseMinArray","collapseMaxArray","_traceIndices","annotations","_annIndices","shapes","_shapeIndices","_r","slice","_rl","axIn","_input","edits","_attr","call","layout","_preGUI","anchorAx","_anchorAxis","rangeslider","axeRangeOpts","_name","extendFlat","data","opts","_m","setScale","len","padded","tozero","type","isLog","hasArrayOption","v","di","dmin","dmax","ppadiplus","ppadiminus","vmin","vmax","makePadAccessor","Array","isArray","ppadplus","ppadminus","ppad","vpadplus","vpad","vpadminus","Infinity","collapseOpts","addItem","c2l","goodNumber","iMax","array","newVal","newPad","collapseArray","lessOrEqual","greaterOrEqual","atLeastAsExtreme","includeThis","splice","clipAtZero","push","abs","v0","v1"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/plots/cartesian/autorange.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar FP_SAFE = require('../../constants/numerical').FP_SAFE;\nvar Registry = require('../../registry');\n\nmodule.exports = {\n    getAutoRange: getAutoRange,\n    makePadFn: makePadFn,\n    doAutoRange: doAutoRange,\n    findExtremes: findExtremes,\n    concatExtremes: concatExtremes\n};\n\n/**\n * getAutoRange\n *\n * Collects all _extremes values corresponding to a given axis\n * and computes its auto range.\n *\n * Note that getAutoRange uses return values from findExtremes.\n *\n * @param {object} gd:\n *   graph div object with filled-in fullData and fullLayout, in particular\n *   with filled-in '_extremes' containers:\n *   {\n *      val: calcdata value,\n *      pad: extra pixels beyond this value,\n *      extrapad: bool, does this point want 5% extra padding\n *   }\n * @param {object} ax:\n *   full axis object, in particular with filled-in '_traceIndices'\n *   and '_annIndices' / '_shapeIndices' if applicable\n * @return {array}\n *   an array of [min, max]. These are calcdata for log and category axes\n *   and data for linear and date axes.\n *\n * TODO: we want to change log to data as well, but it's hard to do this\n * maintaining backward compatibility. category will always have to use calcdata\n * though, because otherwise values between categories (or outside all categories)\n * would be impossible.\n */\nfunction getAutoRange(gd, ax) {\n    var i, j;\n    var newRange = [];\n\n    var getPad = makePadFn(ax);\n    var extremes = concatExtremes(gd, ax);\n    var minArray = extremes.min;\n    var maxArray = extremes.max;\n\n    if(minArray.length === 0 || maxArray.length === 0) {\n        return Lib.simpleMap(ax.range, ax.r2l);\n    }\n\n    var minmin = minArray[0].val;\n    var maxmax = maxArray[0].val;\n\n    for(i = 1; i < minArray.length; i++) {\n        if(minmin !== maxmax) break;\n        minmin = Math.min(minmin, minArray[i].val);\n    }\n    for(i = 1; i < maxArray.length; i++) {\n        if(minmin !== maxmax) break;\n        maxmax = Math.max(maxmax, maxArray[i].val);\n    }\n\n    var axReverse = false;\n\n    if(ax.range) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        axReverse = rng[1] < rng[0];\n    }\n    // one-time setting to easily reverse the axis\n    // when plotting from code\n    if(ax.autorange === 'reversed') {\n        axReverse = true;\n        ax.autorange = true;\n    }\n\n    var rangeMode = ax.rangemode;\n    var toZero = rangeMode === 'tozero';\n    var nonNegative = rangeMode === 'nonnegative';\n    var axLen = ax._length;\n    // don't allow padding to reduce the data to < 10% of the length\n    var minSpan = axLen / 10;\n\n    var mbest = 0;\n    var minpt, maxpt, minbest, maxbest, dp, dv;\n\n    for(i = 0; i < minArray.length; i++) {\n        minpt = minArray[i];\n        for(j = 0; j < maxArray.length; j++) {\n            maxpt = maxArray[j];\n            dv = maxpt.val - minpt.val;\n            if(dv > 0) {\n                dp = axLen - getPad(minpt) - getPad(maxpt);\n                if(dp > minSpan) {\n                    if(dv / dp > mbest) {\n                        minbest = minpt;\n                        maxbest = maxpt;\n                        mbest = dv / dp;\n                    }\n                }\n                else if(dv / axLen > mbest) {\n                    // in case of padding longer than the axis\n                    // at least include the unpadded data values.\n                    minbest = {val: minpt.val, pad: 0};\n                    maxbest = {val: maxpt.val, pad: 0};\n                    mbest = dv / axLen;\n                }\n            }\n        }\n    }\n\n    function getMaxPad(prev, pt) {\n        return Math.max(prev, getPad(pt));\n    }\n\n    if(minmin === maxmax) {\n        var lower = minmin - 1;\n        var upper = minmin + 1;\n        if(toZero) {\n            if(minmin === 0) {\n                // The only value we have on this axis is 0, and we want to\n                // autorange so zero is one end.\n                // In principle this could be [0, 1] or [-1, 0] but usually\n                // 'tozero' pins 0 to the low end, so follow that.\n                newRange = [0, 1];\n            }\n            else {\n                var maxPad = (minmin > 0 ? maxArray : minArray).reduce(getMaxPad, 0);\n                // we're pushing a single value away from the edge due to its\n                // padding, with the other end clamped at zero\n                // 0.5 means don't push it farther than the center.\n                var rangeEnd = minmin / (1 - Math.min(0.5, maxPad / axLen));\n                newRange = minmin > 0 ? [0, rangeEnd] : [rangeEnd, 0];\n            }\n        } else if(nonNegative) {\n            newRange = [Math.max(0, lower), Math.max(1, upper)];\n        } else {\n            newRange = [lower, upper];\n        }\n    }\n    else {\n        if(toZero) {\n            if(minbest.val >= 0) {\n                minbest = {val: 0, pad: 0};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 0, pad: 0};\n            }\n        }\n        else if(nonNegative) {\n            if(minbest.val - mbest * getPad(minbest) < 0) {\n                minbest = {val: 0, pad: 0};\n            }\n            if(maxbest.val <= 0) {\n                maxbest = {val: 1, pad: 0};\n            }\n        }\n\n        // in case it changed again...\n        mbest = (maxbest.val - minbest.val) /\n            (axLen - getPad(minbest) - getPad(maxbest));\n\n        newRange = [\n            minbest.val - mbest * getPad(minbest),\n            maxbest.val + mbest * getPad(maxbest)\n        ];\n    }\n\n    // maintain reversal\n    if(axReverse) newRange.reverse();\n\n    return Lib.simpleMap(newRange, ax.l2r || Number);\n}\n\n/*\n * calculate the pixel padding for ax._min and ax._max entries with\n * optional extrapad as 5% of the total axis length\n */\nfunction makePadFn(ax) {\n    // 5% padding for points that specify extrapad: true\n    var extrappad = ax._length / 20;\n\n    // domain-constrained axes: base extrappad on the unconstrained\n    // domain so it's consistent as the domain changes\n    if((ax.constrain === 'domain') && ax._inputDomain) {\n        extrappad *= (ax._inputDomain[1] - ax._inputDomain[0]) /\n            (ax.domain[1] - ax.domain[0]);\n    }\n\n    return function getPad(pt) { return pt.pad + (pt.extrapad ? extrappad : 0); };\n}\n\nfunction concatExtremes(gd, ax) {\n    var axId = ax._id;\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var minArray = [];\n    var maxArray = [];\n    var i, j, d;\n\n    function _concat(cont, indices) {\n        for(i = 0; i < indices.length; i++) {\n            var item = cont[indices[i]];\n            var extremes = (item._extremes || {})[axId];\n            if(item.visible === true && extremes) {\n                for(j = 0; j < extremes.min.length; j++) {\n                    d = extremes.min[j];\n                    collapseMinArray(minArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n                for(j = 0; j < extremes.max.length; j++) {\n                    d = extremes.max[j];\n                    collapseMaxArray(maxArray, d.val, d.pad, {extrapad: d.extrapad});\n                }\n            }\n        }\n    }\n\n    _concat(fullData, ax._traceIndices);\n    _concat(fullLayout.annotations || [], ax._annIndices || []);\n    _concat(fullLayout.shapes || [], ax._shapeIndices || []);\n\n    return {min: minArray, max: maxArray};\n}\n\nfunction doAutoRange(gd, ax) {\n    if(ax.autorange) {\n        ax.range = getAutoRange(gd, ax);\n\n        ax._r = ax.range.slice();\n        ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n        // doAutoRange will get called on fullLayout,\n        // but we want to report its results back to layout\n\n        var axIn = ax._input;\n\n        // before we edit _input, store preGUI values\n        var edits = {};\n        edits[ax._attr + '.range'] = ax.range;\n        edits[ax._attr + '.autorange'] = ax.autorange;\n        Registry.call('_storeDirectGUIEdit', gd.layout, gd._fullLayout._preGUI, edits);\n\n        axIn.range = ax.range.slice();\n        axIn.autorange = ax.autorange;\n    }\n\n    var anchorAx = ax._anchorAxis;\n\n    if(anchorAx && anchorAx.rangeslider) {\n        var axeRangeOpts = anchorAx.rangeslider[ax._name];\n        if(axeRangeOpts) {\n            if(axeRangeOpts.rangemode === 'auto') {\n                axeRangeOpts.range = getAutoRange(gd, ax);\n            }\n        }\n        anchorAx._input.rangeslider[ax._name] = Lib.extendFlat({}, axeRangeOpts);\n    }\n}\n\n/**\n * findExtremes\n *\n * Find min/max extremes of an array of coordinates on a given axis.\n *\n * Note that findExtremes is called during `calc`, when we don't yet know the axis\n * length; all the inputs should be based solely on the trace data, nothing\n * about the axis layout.\n *\n * Note that `ppad` and `vpad` as well as their asymmetric variants refer to\n * the before and after padding of the passed `data` array, not to the whole axis.\n *\n * @param {object} ax: full axis object\n *   relies on\n *   - ax.type\n *   - ax._m (just its sign)\n *   - ax.d2l\n * @param {array} data:\n *  array of numbers (i.e. already run though ax.d2c)\n * @param {object} opts:\n *  available keys are:\n *      vpad: (number or number array) pad values (data value +-vpad)\n *      ppad: (number or number array) pad pixels (pixel location +-ppad)\n *      ppadplus, ppadminus, vpadplus, vpadminus:\n *          separate padding for each side, overrides symmetric\n *      padded: (boolean) add 5% padding to both ends\n *          (unless one end is overridden by tozero)\n *      tozero: (boolean) make sure to include zero if axis is linear,\n *          and make it a tight bound if possible\n *\n * @return {object}\n *  - min {array of objects}\n *  - max {array of objects}\n *  each object item has fields:\n *    - val {number}\n *    - pad {number}\n *    - extrappad {number}\n *  - opts {object}: a ref to the passed \"options\" object\n */\nfunction findExtremes(ax, data, opts) {\n    if(!opts) opts = {};\n    if(!ax._m) ax.setScale();\n\n    var minArray = [];\n    var maxArray = [];\n\n    var len = data.length;\n    var extrapad = opts.padded || false;\n    var tozero = opts.tozero && (ax.type === 'linear' || ax.type === '-');\n    var isLog = ax.type === 'log';\n    var hasArrayOption = false;\n    var i, v, di, dmin, dmax, ppadiplus, ppadiminus, vmin, vmax;\n\n    function makePadAccessor(item) {\n        if(Array.isArray(item)) {\n            hasArrayOption = true;\n            return function(i) { return Math.max(Number(item[i]||0), 0); };\n        }\n        else {\n            var v = Math.max(Number(item||0), 0);\n            return function() { return v; };\n        }\n    }\n\n    var ppadplus = makePadAccessor((ax._m > 0 ?\n        opts.ppadplus : opts.ppadminus) || opts.ppad || 0);\n    var ppadminus = makePadAccessor((ax._m > 0 ?\n        opts.ppadminus : opts.ppadplus) || opts.ppad || 0);\n    var vpadplus = makePadAccessor(opts.vpadplus || opts.vpad);\n    var vpadminus = makePadAccessor(opts.vpadminus || opts.vpad);\n\n    if(!hasArrayOption) {\n        // with no arrays other than `data` we don't need to consider\n        // every point, only the extreme data points\n        vmin = Infinity;\n        vmax = -Infinity;\n\n        if(isLog) {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                // data is not linearized yet so we still have to filter out negative logs\n                if(v < vmin && v > 0) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        } else {\n            for(i = 0; i < len; i++) {\n                v = data[i];\n                if(v < vmin && v > -FP_SAFE) vmin = v;\n                if(v > vmax && v < FP_SAFE) vmax = v;\n            }\n        }\n\n        data = [vmin, vmax];\n        len = 2;\n    }\n\n    var collapseOpts = {tozero: tozero, extrapad: extrapad};\n\n    function addItem(i) {\n        di = data[i];\n        if(!isNumeric(di)) return;\n        ppadiplus = ppadplus(i);\n        ppadiminus = ppadminus(i);\n        vmin = di - vpadminus(i);\n        vmax = di + vpadplus(i);\n        // special case for log axes: if vpad makes this object span\n        // more than an order of mag, clip it to one order. This is so\n        // we don't have non-positive errors or absurdly large lower\n        // range due to rounding errors\n        if(isLog && vmin < vmax / 10) vmin = vmax / 10;\n\n        dmin = ax.c2l(vmin);\n        dmax = ax.c2l(vmax);\n\n        if(tozero) {\n            dmin = Math.min(0, dmin);\n            dmax = Math.max(0, dmax);\n        }\n        if(goodNumber(dmin)) {\n            collapseMinArray(minArray, dmin, ppadiminus, collapseOpts);\n        }\n        if(goodNumber(dmax)) {\n            collapseMaxArray(maxArray, dmax, ppadiplus, collapseOpts);\n        }\n    }\n\n    // For efficiency covering monotonic or near-monotonic data,\n    // check a few points at both ends first and then sweep\n    // through the middle\n    var iMax = Math.min(6, len);\n    for(i = 0; i < iMax; i++) addItem(i);\n    for(i = len - 1; i >= iMax; i--) addItem(i);\n\n    return {\n        min: minArray,\n        max: maxArray,\n        opts: opts\n    };\n}\n\nfunction collapseMinArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, lessOrEqual);\n}\n\nfunction collapseMaxArray(array, newVal, newPad, opts) {\n    collapseArray(array, newVal, newPad, opts, greaterOrEqual);\n}\n\n/**\n * collapseArray\n *\n * Takes items from 'array' and compares them to 'newVal', 'newPad'.\n *\n * @param {array} array:\n *  current set of min or max extremes\n * @param {number} newVal:\n *  new value to compare against\n * @param {number} newPad:\n *  pad value associated with 'newVal'\n * @param {object} opts:\n *  - tozero {boolean}\n *  - extrapad {number}\n * @param {function} atLeastAsExtreme:\n *  comparison function, use\n *  - lessOrEqual for min 'array' and\n *  - greaterOrEqual for max 'array'\n *\n * In practice, 'array' is either\n *  - 'extremes[ax._id].min' or\n *  - 'extremes[ax._id].max\n *  found in traces and layout items that affect autorange.\n *\n * Since we don't yet know the relationship between pixels and values\n * (that's what we're trying to figure out!) AND we don't yet know how\n * many pixels `extrapad` represents (it's going to be 5% of the length,\n * but we don't want to have to redo calc just because length changed)\n * two point must satisfy three criteria simultaneously for one to supersede the other:\n *  - at least as extreme a `val`\n *  - at least as big a `pad`\n *  - an unpadded point cannot supersede a padded point, but any other combination can\n *\n * Then:\n * - If the item supersedes the new point, set includeThis false\n * - If the new pt supersedes the item, delete it from 'array'\n */\nfunction collapseArray(array, newVal, newPad, opts, atLeastAsExtreme) {\n    var tozero = opts.tozero;\n    var extrapad = opts.extrapad;\n    var includeThis = true;\n\n    for(var j = 0; j < array.length && includeThis; j++) {\n        var v = array[j];\n        if(atLeastAsExtreme(v.val, newVal) && v.pad >= newPad && (v.extrapad || !extrapad)) {\n            includeThis = false;\n            break;\n        } else if(atLeastAsExtreme(newVal, v.val) && v.pad <= newPad && (extrapad || !v.extrapad)) {\n            array.splice(j, 1);\n            j--;\n        }\n    }\n    if(includeThis) {\n        var clipAtZero = (tozero && newVal === 0);\n        array.push({\n            val: newVal,\n            pad: clipAtZero ? 0 : newPad,\n            extrapad: clipAtZero ? false : extrapad\n        });\n    }\n}\n\n// In order to stop overflow errors, don't consider points\n// too close to the limits of js floating point\nfunction goodNumber(v) {\n    return isNumeric(v) && Math.abs(v) < FP_SAFE;\n}\n\nfunction lessOrEqual(v0, v1) { return v0 <= v1; }\nfunction greaterOrEqual(v0, v1) { return v0 >= v1; }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}