{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\nvar SHOWISOLATETIP = true;\nmodule.exports = function handleClick(g, gd, numClicks) {\n  if (gd._dragged || gd._editing) return;\n  var hiddenSlices = gd._fullLayout.hiddenlabels ? gd._fullLayout.hiddenlabels.slice() : [];\n  var legendItem = g.data()[0][0];\n  var fullData = gd._fullData;\n  var fullTrace = legendItem.trace;\n  var legendgroup = fullTrace.legendgroup;\n  var i, j, kcont, key, keys, val;\n  var attrUpdate = {};\n  var attrIndices = [];\n  var carrs = [];\n  var carrIdx = [];\n  function insertUpdate(traceIndex, key, value) {\n    var attrIndex = attrIndices.indexOf(traceIndex);\n    var valueArray = attrUpdate[key];\n    if (!valueArray) {\n      valueArray = attrUpdate[key] = [];\n    }\n    if (attrIndices.indexOf(traceIndex) === -1) {\n      attrIndices.push(traceIndex);\n      attrIndex = attrIndices.length - 1;\n    }\n    valueArray[attrIndex] = value;\n    return attrIndex;\n  }\n  function setVisibility(fullTrace, visibility) {\n    var fullInput = fullTrace._fullInput;\n    if (Registry.hasTransform(fullInput, 'groupby')) {\n      var kcont = carrs[fullInput.index];\n      if (!kcont) {\n        var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n        var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n        kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n        carrs[fullInput.index] = kcont;\n      }\n      var curState = kcont.get(fullTrace._group);\n\n      // If not specified, assume visible. This happens if there are other style\n      // properties set for a group but not the visibility. There are many similar\n      // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n      // answer is: because it breaks other things like groupby trace names in\n      // subtle ways.)\n      if (curState === undefined) {\n        curState = true;\n      }\n      if (curState !== false) {\n        // true -> legendonly. All others toggle to true:\n        kcont.set(fullTrace._group, visibility);\n      }\n      carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n    } else {\n      // false -> false (not possible since will not be visible in legend)\n      // true -> legendonly\n      // legendonly -> true\n      var nextVisibility = fullInput.visible === false ? false : visibility;\n      insertUpdate(fullInput.index, 'visible', nextVisibility);\n    }\n  }\n  if (numClicks === 1 && SHOWISOLATETIP && gd.data && gd._context.showTips) {\n    Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n    SHOWISOLATETIP = false;\n  } else {\n    SHOWISOLATETIP = false;\n  }\n  if (Registry.traceIs(fullTrace, 'pie')) {\n    var thisLabel = legendItem.label;\n    var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n    if (numClicks === 1) {\n      if (thisLabelIndex === -1) hiddenSlices.push(thisLabel);else hiddenSlices.splice(thisLabelIndex, 1);\n    } else if (numClicks === 2) {\n      hiddenSlices = [];\n      gd.calcdata[0].forEach(function (d) {\n        if (thisLabel !== d.label) {\n          hiddenSlices.push(d.label);\n        }\n      });\n      if (gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n        hiddenSlices = [];\n      }\n    }\n    Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n  } else {\n    var hasLegendgroup = legendgroup && legendgroup.length;\n    var traceIndicesInGroup = [];\n    var tracei;\n    if (hasLegendgroup) {\n      for (i = 0; i < fullData.length; i++) {\n        tracei = fullData[i];\n        if (!tracei.visible) continue;\n        if (tracei.legendgroup === legendgroup) {\n          traceIndicesInGroup.push(i);\n        }\n      }\n    }\n    if (numClicks === 1) {\n      var nextVisibility;\n      switch (fullTrace.visible) {\n        case true:\n          nextVisibility = 'legendonly';\n          break;\n        case false:\n          nextVisibility = false;\n          break;\n        case 'legendonly':\n          nextVisibility = true;\n          break;\n      }\n      if (hasLegendgroup) {\n        for (i = 0; i < fullData.length; i++) {\n          if (fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n            setVisibility(fullData[i], nextVisibility);\n          }\n        }\n      } else {\n        setVisibility(fullTrace, nextVisibility);\n      }\n    } else if (numClicks === 2) {\n      // Compute the clicked index. expandedIndex does what we want for expanded traces\n      // but also culls hidden traces. That means we have some work to do.\n      var isClicked, isInGroup, otherState;\n      var isIsolated = true;\n      for (i = 0; i < fullData.length; i++) {\n        isClicked = fullData[i] === fullTrace;\n        if (isClicked) continue;\n        isInGroup = hasLegendgroup && fullData[i].legendgroup === legendgroup;\n        if (!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          isIsolated = false;\n          break;\n        }\n      }\n      for (i = 0; i < fullData.length; i++) {\n        // False is sticky; we don't change it.\n        if (fullData[i].visible === false) continue;\n        if (Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n          continue;\n        }\n        switch (fullTrace.visible) {\n          case 'legendonly':\n            setVisibility(fullData[i], true);\n            break;\n          case true:\n            otherState = isIsolated ? true : 'legendonly';\n            isClicked = fullData[i] === fullTrace;\n            isInGroup = isClicked || hasLegendgroup && fullData[i].legendgroup === legendgroup;\n            setVisibility(fullData[i], isInGroup ? true : otherState);\n            break;\n        }\n      }\n    }\n    for (i = 0; i < carrs.length; i++) {\n      kcont = carrs[i];\n      if (!kcont) continue;\n      var update = kcont.constructUpdate();\n      var updateKeys = Object.keys(update);\n      for (j = 0; j < updateKeys.length; j++) {\n        key = updateKeys[j];\n        val = attrUpdate[key] = attrUpdate[key] || [];\n        val[carrIdx[i]] = update[key];\n      }\n    }\n\n    // The length of the value arrays should be equal and any unspecified\n    // values should be explicitly undefined for them to get properly culled\n    // as updates and not accidentally reset to the default value. This fills\n    // out sparse arrays with the required number of undefined values:\n    keys = Object.keys(attrUpdate);\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      for (j = 0; j < attrIndices.length; j++) {\n        // Use hasOwnPropety to protect against falsey values:\n        if (!attrUpdate[key].hasOwnProperty(j)) {\n          attrUpdate[key][j] = undefined;\n        }\n      }\n    }\n    Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n  }\n};","map":{"version":3,"names":["Lib","require","Registry","SHOWISOLATETIP","module","exports","handleClick","g","gd","numClicks","_dragged","_editing","hiddenSlices","_fullLayout","hiddenlabels","slice","legendItem","data","fullData","_fullData","fullTrace","trace","legendgroup","i","j","kcont","key","keys","val","attrUpdate","attrIndices","carrs","carrIdx","insertUpdate","traceIndex","value","attrIndex","indexOf","valueArray","push","length","setVisibility","visibility","fullInput","_fullInput","hasTransform","index","groupbyIndices","getTransformIndices","lastGroupbyIndex","keyedContainer","curState","get","_group","undefined","set","visible","nextVisibility","_context","showTips","notifier","_","traceIs","thisLabel","label","thisLabelIndex","splice","calcdata","forEach","d","call","hasLegendgroup","traceIndicesInGroup","tracei","isClicked","isInGroup","otherState","isIsolated","update","constructUpdate","updateKeys","Object","hasOwnProperty"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/components/legend/handle_click.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Registry = require('../../registry');\n\nvar SHOWISOLATETIP = true;\n\nmodule.exports = function handleClick(g, gd, numClicks) {\n    if(gd._dragged || gd._editing) return;\n\n    var hiddenSlices = gd._fullLayout.hiddenlabels ?\n        gd._fullLayout.hiddenlabels.slice() :\n        [];\n\n    var legendItem = g.data()[0][0];\n    var fullData = gd._fullData;\n    var fullTrace = legendItem.trace;\n    var legendgroup = fullTrace.legendgroup;\n\n    var i, j, kcont, key, keys, val;\n    var attrUpdate = {};\n    var attrIndices = [];\n    var carrs = [];\n    var carrIdx = [];\n\n    function insertUpdate(traceIndex, key, value) {\n        var attrIndex = attrIndices.indexOf(traceIndex);\n        var valueArray = attrUpdate[key];\n        if(!valueArray) {\n            valueArray = attrUpdate[key] = [];\n        }\n\n        if(attrIndices.indexOf(traceIndex) === -1) {\n            attrIndices.push(traceIndex);\n            attrIndex = attrIndices.length - 1;\n        }\n\n        valueArray[attrIndex] = value;\n\n        return attrIndex;\n    }\n\n    function setVisibility(fullTrace, visibility) {\n        var fullInput = fullTrace._fullInput;\n        if(Registry.hasTransform(fullInput, 'groupby')) {\n            var kcont = carrs[fullInput.index];\n            if(!kcont) {\n                var groupbyIndices = Registry.getTransformIndices(fullInput, 'groupby');\n                var lastGroupbyIndex = groupbyIndices[groupbyIndices.length - 1];\n                kcont = Lib.keyedContainer(fullInput, 'transforms[' + lastGroupbyIndex + '].styles', 'target', 'value.visible');\n                carrs[fullInput.index] = kcont;\n            }\n\n            var curState = kcont.get(fullTrace._group);\n\n            // If not specified, assume visible. This happens if there are other style\n            // properties set for a group but not the visibility. There are many similar\n            // ways to do this (e.g. why not just `curState = fullTrace.visible`??? The\n            // answer is: because it breaks other things like groupby trace names in\n            // subtle ways.)\n            if(curState === undefined) {\n                curState = true;\n            }\n\n            if(curState !== false) {\n                // true -> legendonly. All others toggle to true:\n                kcont.set(fullTrace._group, visibility);\n            }\n            carrIdx[fullInput.index] = insertUpdate(fullInput.index, 'visible', fullInput.visible === false ? false : true);\n        } else {\n            // false -> false (not possible since will not be visible in legend)\n            // true -> legendonly\n            // legendonly -> true\n            var nextVisibility = fullInput.visible === false ? false : visibility;\n\n            insertUpdate(fullInput.index, 'visible', nextVisibility);\n        }\n    }\n\n    if(numClicks === 1 && SHOWISOLATETIP && gd.data && gd._context.showTips) {\n        Lib.notifier(Lib._(gd, 'Double-click on legend to isolate one trace'), 'long');\n        SHOWISOLATETIP = false;\n    } else {\n        SHOWISOLATETIP = false;\n    }\n\n    if(Registry.traceIs(fullTrace, 'pie')) {\n        var thisLabel = legendItem.label;\n        var thisLabelIndex = hiddenSlices.indexOf(thisLabel);\n\n        if(numClicks === 1) {\n            if(thisLabelIndex === -1) hiddenSlices.push(thisLabel);\n            else hiddenSlices.splice(thisLabelIndex, 1);\n        } else if(numClicks === 2) {\n            hiddenSlices = [];\n            gd.calcdata[0].forEach(function(d) {\n                if(thisLabel !== d.label) {\n                    hiddenSlices.push(d.label);\n                }\n            });\n            if(gd._fullLayout.hiddenlabels && gd._fullLayout.hiddenlabels.length === hiddenSlices.length && thisLabelIndex === -1) {\n                hiddenSlices = [];\n            }\n        }\n\n        Registry.call('_guiRelayout', gd, 'hiddenlabels', hiddenSlices);\n    } else {\n        var hasLegendgroup = legendgroup && legendgroup.length;\n        var traceIndicesInGroup = [];\n        var tracei;\n        if(hasLegendgroup) {\n            for(i = 0; i < fullData.length; i++) {\n                tracei = fullData[i];\n                if(!tracei.visible) continue;\n                if(tracei.legendgroup === legendgroup) {\n                    traceIndicesInGroup.push(i);\n                }\n            }\n        }\n\n        if(numClicks === 1) {\n            var nextVisibility;\n\n            switch(fullTrace.visible) {\n                case true:\n                    nextVisibility = 'legendonly';\n                    break;\n                case false:\n                    nextVisibility = false;\n                    break;\n                case 'legendonly':\n                    nextVisibility = true;\n                    break;\n            }\n\n            if(hasLegendgroup) {\n                for(i = 0; i < fullData.length; i++) {\n                    if(fullData[i].visible !== false && fullData[i].legendgroup === legendgroup) {\n                        setVisibility(fullData[i], nextVisibility);\n                    }\n                }\n            } else {\n                setVisibility(fullTrace, nextVisibility);\n            }\n        } else if(numClicks === 2) {\n            // Compute the clicked index. expandedIndex does what we want for expanded traces\n            // but also culls hidden traces. That means we have some work to do.\n            var isClicked, isInGroup, otherState;\n            var isIsolated = true;\n            for(i = 0; i < fullData.length; i++) {\n                isClicked = fullData[i] === fullTrace;\n                if(isClicked) continue;\n\n                isInGroup = (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n\n                if(!isInGroup && fullData[i].visible === true && !Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    isIsolated = false;\n                    break;\n                }\n            }\n\n            for(i = 0; i < fullData.length; i++) {\n                // False is sticky; we don't change it.\n                if(fullData[i].visible === false) continue;\n\n                if(Registry.traceIs(fullData[i], 'notLegendIsolatable')) {\n                    continue;\n                }\n\n                switch(fullTrace.visible) {\n                    case 'legendonly':\n                        setVisibility(fullData[i], true);\n                        break;\n                    case true:\n                        otherState = isIsolated ? true : 'legendonly';\n                        isClicked = fullData[i] === fullTrace;\n                        isInGroup = isClicked || (hasLegendgroup && fullData[i].legendgroup === legendgroup);\n                        setVisibility(fullData[i], isInGroup ? true : otherState);\n                        break;\n                }\n            }\n        }\n\n        for(i = 0; i < carrs.length; i++) {\n            kcont = carrs[i];\n            if(!kcont) continue;\n            var update = kcont.constructUpdate();\n\n            var updateKeys = Object.keys(update);\n            for(j = 0; j < updateKeys.length; j++) {\n                key = updateKeys[j];\n                val = attrUpdate[key] = attrUpdate[key] || [];\n                val[carrIdx[i]] = update[key];\n            }\n        }\n\n        // The length of the value arrays should be equal and any unspecified\n        // values should be explicitly undefined for them to get properly culled\n        // as updates and not accidentally reset to the default value. This fills\n        // out sparse arrays with the required number of undefined values:\n        keys = Object.keys(attrUpdate);\n        for(i = 0; i < keys.length; i++) {\n            key = keys[i];\n            for(j = 0; j < attrIndices.length; j++) {\n                // Use hasOwnPropety to protect against falsey values:\n                if(!attrUpdate[key].hasOwnProperty(j)) {\n                    attrUpdate[key][j] = undefined;\n                }\n            }\n        }\n\n        Registry.call('_guiRestyle', gd, attrUpdate, attrIndices);\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}