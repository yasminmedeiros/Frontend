{"ast":null,"code":"/** @module  color-normalize */\n\n'use strict';\n\nvar rgba = require('color-rgba');\nvar clamp = require('clamp');\nvar dtype = require('dtype');\nmodule.exports = function normalize(color, type) {\n  if (type === 'float' || !type) type = 'array';\n  if (type === 'uint') type = 'uint8';\n  if (type === 'uint_clamped') type = 'uint8_clamped';\n  var Ctor = dtype(type);\n  var output = new Ctor(4);\n  var normalize = type !== 'uint8' && type !== 'uint8_clamped';\n\n  // attempt to parse non-array arguments\n  if (!color.length || typeof color === 'string') {\n    color = rgba(color);\n    color[0] /= 255;\n    color[1] /= 255;\n    color[2] /= 255;\n  }\n\n  // 0, 1 are possible contradictory values for Arrays:\n  // [1,1,1] input gives [1,1,1] output instead of [1/255,1/255,1/255], which may be collision if input is meant to be uint.\n  // converting [1,1,1] to [1/255,1/255,1/255] in case of float input gives larger mistake since [1,1,1] float is frequent edge value, whereas [0,1,1], [1,1,1] etc. uint inputs are relatively rare\n  if (isInt(color)) {\n    output[0] = color[0];\n    output[1] = color[1];\n    output[2] = color[2];\n    output[3] = color[3] != null ? color[3] : 255;\n    if (normalize) {\n      output[0] /= 255;\n      output[1] /= 255;\n      output[2] /= 255;\n      output[3] /= 255;\n    }\n    return output;\n  }\n  if (!normalize) {\n    output[0] = clamp(Math.floor(color[0] * 255), 0, 255);\n    output[1] = clamp(Math.floor(color[1] * 255), 0, 255);\n    output[2] = clamp(Math.floor(color[2] * 255), 0, 255);\n    output[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255);\n  } else {\n    output[0] = color[0];\n    output[1] = color[1];\n    output[2] = color[2];\n    output[3] = color[3] != null ? color[3] : 1;\n  }\n  return output;\n};\nfunction isInt(color) {\n  if (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true;\n  if (Array.isArray(color) && (color[0] > 1 || color[0] === 0) && (color[1] > 1 || color[1] === 0) && (color[2] > 1 || color[2] === 0) && (!color[3] || color[3] > 1)) return true;\n  return false;\n}","map":{"version":3,"names":["rgba","require","clamp","dtype","module","exports","normalize","color","type","Ctor","output","length","isInt","Math","floor","Uint8Array","Uint8ClampedArray","Array","isArray"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/color-normalize/index.js"],"sourcesContent":["/** @module  color-normalize */\r\n\r\n'use strict'\r\n\r\nvar rgba = require('color-rgba')\r\nvar clamp = require('clamp')\r\nvar dtype = require('dtype')\r\n\r\nmodule.exports = function normalize (color, type) {\r\n\tif (type === 'float' || !type) type = 'array'\r\n\tif (type === 'uint') type = 'uint8'\r\n\tif (type === 'uint_clamped') type = 'uint8_clamped'\r\n\tvar Ctor = dtype(type)\r\n\tvar output = new Ctor(4)\r\n\r\n\tvar normalize = type !== 'uint8' && type !== 'uint8_clamped'\r\n\r\n\t// attempt to parse non-array arguments\r\n\tif (!color.length || typeof color === 'string') {\r\n\t\tcolor = rgba(color)\r\n\t\tcolor[0] /= 255\r\n\t\tcolor[1] /= 255\r\n\t\tcolor[2] /= 255\r\n\t}\r\n\r\n\t// 0, 1 are possible contradictory values for Arrays:\r\n\t// [1,1,1] input gives [1,1,1] output instead of [1/255,1/255,1/255], which may be collision if input is meant to be uint.\r\n\t// converting [1,1,1] to [1/255,1/255,1/255] in case of float input gives larger mistake since [1,1,1] float is frequent edge value, whereas [0,1,1], [1,1,1] etc. uint inputs are relatively rare\r\n\tif (isInt(color)) {\r\n\t\toutput[0] = color[0]\r\n\t\toutput[1] = color[1]\r\n\t\toutput[2] = color[2]\r\n\t\toutput[3] = color[3] != null ? color[3] : 255\r\n\r\n\t\tif (normalize) {\r\n\t\t\toutput[0] /= 255\r\n\t\t\toutput[1] /= 255\r\n\t\t\toutput[2] /= 255\r\n\t\t\toutput[3] /= 255\r\n\t\t}\r\n\r\n\t\treturn output\r\n\t}\r\n\r\n\tif (!normalize) {\r\n\t\toutput[0] = clamp(Math.floor(color[0] * 255), 0, 255)\r\n\t\toutput[1] = clamp(Math.floor(color[1] * 255), 0, 255)\r\n\t\toutput[2] = clamp(Math.floor(color[2] * 255), 0, 255)\r\n\t\toutput[3] = color[3] == null ? 255 : clamp(Math.floor(color[3] * 255), 0, 255)\r\n\t} else {\r\n\t\toutput[0] = color[0]\r\n\t\toutput[1] = color[1]\r\n\t\toutput[2] = color[2]\r\n\t\toutput[3] = color[3] != null ? color[3] : 1\r\n\t}\r\n\r\n\treturn output\r\n}\r\n\r\nfunction isInt(color) {\r\n\tif (color instanceof Uint8Array || color instanceof Uint8ClampedArray) return true\r\n\r\n\tif (Array.isArray(color) &&\r\n\t\t(color[0] > 1 || color[0] === 0) &&\r\n\t\t(color[1] > 1 || color[1] === 0) &&\r\n\t\t(color[2] > 1 || color[2] === 0) &&\r\n\t\t(!color[3] || color[3] > 1)\r\n\t) return true\r\n\r\n\treturn false\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}