{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar numConstants = require('../../constants/numerical');\nvar oneYear = numConstants.ONEAVGYEAR;\nvar oneMonth = numConstants.ONEAVGMONTH;\nvar oneDay = numConstants.ONEDAY;\nvar oneHour = numConstants.ONEHOUR;\nvar oneMin = numConstants.ONEMIN;\nvar oneSec = numConstants.ONESEC;\nvar tickIncrement = require('../../plots/cartesian/axes').tickIncrement;\n\n/*\n * make a function that will find rounded bin edges\n * @param {number} leftGap: how far from the left edge of any bin is the closest data value?\n * @param {number} rightGap: how far from the right edge of any bin is the closest data value?\n * @param {Array[number]} binEdges: the actual edge values used in binning\n * @param {object} pa: the position axis\n * @param {string} calendar: the data calendar\n *\n * @return {function(v, isRightEdge)}:\n *   find the start (isRightEdge is falsy) or end (truthy) label value for a bin edge `v`\n */\nmodule.exports = function getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar) {\n  // the rounding digit is the largest digit that changes in *all* of 4 regions:\n  // - inside the rightGap before binEdges[0] (shifted 10% to the left)\n  // - inside the leftGap after binEdges[0] (expanded by 10% of rightGap on each end)\n  // - same for binEdges[1]\n  var dv0 = -1.1 * rightGap;\n  var dv1 = -0.1 * rightGap;\n  var dv2 = leftGap - dv1;\n  var edge0 = binEdges[0];\n  var edge1 = binEdges[1];\n  var leftDigit = Math.min(biggestDigitChanged(edge0 + dv1, edge0 + dv2, pa, calendar), biggestDigitChanged(edge1 + dv1, edge1 + dv2, pa, calendar));\n  var rightDigit = Math.min(biggestDigitChanged(edge0 + dv0, edge0 + dv1, pa, calendar), biggestDigitChanged(edge1 + dv0, edge1 + dv1, pa, calendar));\n\n  // normally we try to make the label for the right edge different from\n  // the left edge label, so it's unambiguous which bin gets data on the edge.\n  // but if this results in more than 3 extra digits (or for dates, more than\n  // 2 fields ie hr&min or min&sec, which is 3600x), it'll be more clutter than\n  // useful so keep the label cleaner instead\n  var digit, disambiguateEdges;\n  if (leftDigit > rightDigit && rightDigit < Math.abs(edge1 - edge0) / 4000) {\n    digit = leftDigit;\n    disambiguateEdges = false;\n  } else {\n    digit = Math.min(leftDigit, rightDigit);\n    disambiguateEdges = true;\n  }\n  if (pa.type === 'date' && digit > oneDay) {\n    var dashExclude = digit === oneYear ? 1 : 6;\n    var increment = digit === oneYear ? 'M12' : 'M1';\n    return function (v, isRightEdge) {\n      var dateStr = pa.c2d(v, oneYear, calendar);\n      var dashPos = dateStr.indexOf('-', dashExclude);\n      if (dashPos > 0) dateStr = dateStr.substr(0, dashPos);\n      var roundedV = pa.d2c(dateStr, 0, calendar);\n      if (roundedV < v) {\n        var nextV = tickIncrement(roundedV, increment, false, calendar);\n        if ((roundedV + nextV) / 2 < v + leftGap) roundedV = nextV;\n      }\n      if (isRightEdge && disambiguateEdges) {\n        return tickIncrement(roundedV, increment, true, calendar);\n      }\n      return roundedV;\n    };\n  }\n  return function (v, isRightEdge) {\n    var roundedV = digit * Math.round(v / digit);\n    // if we rounded down and we could round up and still be < leftGap\n    // (or what leftGap values round to), do that\n    if (roundedV + digit / 10 < v && roundedV + digit * 0.9 < v + leftGap) {\n      roundedV += digit;\n    }\n    // finally for the right edge back off one digit - but only if we can do that\n    // and not clip off any data that's potentially in the bin\n    if (isRightEdge && disambiguateEdges) {\n      roundedV -= digit;\n    }\n    return roundedV;\n  };\n};\n\n/*\n * Find the largest digit that changes within a (calcdata) region [v1, v2]\n * if dates, \"digit\" means date/time part when it's bigger than a second\n * returns the unit value to round to this digit, eg 0.01 to round to hundredths, or\n * 100 to round to hundreds. returns oneMonth or oneYear for month or year rounding,\n * so that Math.min will work, rather than 'M1' and 'M12'\n */\nfunction biggestDigitChanged(v1, v2, pa, calendar) {\n  // are we crossing zero? can't say anything.\n  // in principle this doesn't apply to dates but turns out this doesn't matter.\n  if (v1 * v2 <= 0) return Infinity;\n  var dv = Math.abs(v2 - v1);\n  var isDate = pa.type === 'date';\n  var digit = biggestGuaranteedDigitChanged(dv, isDate);\n  // see if a larger digit also changed\n  for (var i = 0; i < 10; i++) {\n    // numbers: next digit needs to be >10x but <100x then gets rounded down.\n    // dates: next digit can be as much as 60x (then rounded down)\n    var nextDigit = biggestGuaranteedDigitChanged(digit * 80, isDate);\n    // if we get to years, the chain stops\n    if (digit === nextDigit) break;\n    if (didDigitChange(nextDigit, v1, v2, isDate, pa, calendar)) digit = nextDigit;else break;\n  }\n  return digit;\n}\n\n/*\n * Find the largest digit that *definitely* changes in a region [v, v + dv] for any v\n * for nonuniform date regions (months/years) pick the largest\n */\nfunction biggestGuaranteedDigitChanged(dv, isDate) {\n  if (isDate && dv > oneSec) {\n    // this is supposed to be the biggest *guaranteed* change\n    // so compare to the longest month and year across any calendar,\n    // and we'll iterate back up later\n    // note: does not support rounding larger than one year. We could add\n    // that if anyone wants it, but seems unusual and not strictly necessary.\n    if (dv > oneDay) {\n      if (dv > oneYear * 1.1) return oneYear;\n      if (dv > oneMonth * 1.1) return oneMonth;\n      return oneDay;\n    }\n    if (dv > oneHour) return oneHour;\n    if (dv > oneMin) return oneMin;\n    return oneSec;\n  }\n  return Math.pow(10, Math.floor(Math.log(dv) / Math.LN10));\n}\nfunction didDigitChange(digit, v1, v2, isDate, pa, calendar) {\n  if (isDate && digit > oneDay) {\n    var dateParts1 = dateParts(v1, pa, calendar);\n    var dateParts2 = dateParts(v2, pa, calendar);\n    var parti = digit === oneYear ? 0 : 1;\n    return dateParts1[parti] !== dateParts2[parti];\n  }\n  return Math.floor(v2 / digit) - Math.floor(v1 / digit) > 0.1;\n}\nfunction dateParts(v, pa, calendar) {\n  var parts = pa.c2d(v, oneYear, calendar).split('-');\n  if (parts[0] === '') {\n    parts.unshift();\n    parts[0] = '-' + parts[0];\n  }\n  return parts;\n}","map":{"version":3,"names":["numConstants","require","oneYear","ONEAVGYEAR","oneMonth","ONEAVGMONTH","oneDay","ONEDAY","oneHour","ONEHOUR","oneMin","ONEMIN","oneSec","ONESEC","tickIncrement","module","exports","getBinSpanLabelRound","leftGap","rightGap","binEdges","pa","calendar","dv0","dv1","dv2","edge0","edge1","leftDigit","Math","min","biggestDigitChanged","rightDigit","digit","disambiguateEdges","abs","type","dashExclude","increment","v","isRightEdge","dateStr","c2d","dashPos","indexOf","substr","roundedV","d2c","nextV","round","v1","v2","Infinity","dv","isDate","biggestGuaranteedDigitChanged","i","nextDigit","didDigitChange","pow","floor","log","LN10","dateParts1","dateParts","dateParts2","parti","parts","split","unshift"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/histogram/bin_label_vals.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar numConstants = require('../../constants/numerical');\nvar oneYear = numConstants.ONEAVGYEAR;\nvar oneMonth = numConstants.ONEAVGMONTH;\nvar oneDay = numConstants.ONEDAY;\nvar oneHour = numConstants.ONEHOUR;\nvar oneMin = numConstants.ONEMIN;\nvar oneSec = numConstants.ONESEC;\nvar tickIncrement = require('../../plots/cartesian/axes').tickIncrement;\n\n\n/*\n * make a function that will find rounded bin edges\n * @param {number} leftGap: how far from the left edge of any bin is the closest data value?\n * @param {number} rightGap: how far from the right edge of any bin is the closest data value?\n * @param {Array[number]} binEdges: the actual edge values used in binning\n * @param {object} pa: the position axis\n * @param {string} calendar: the data calendar\n *\n * @return {function(v, isRightEdge)}:\n *   find the start (isRightEdge is falsy) or end (truthy) label value for a bin edge `v`\n */\nmodule.exports = function getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar) {\n    // the rounding digit is the largest digit that changes in *all* of 4 regions:\n    // - inside the rightGap before binEdges[0] (shifted 10% to the left)\n    // - inside the leftGap after binEdges[0] (expanded by 10% of rightGap on each end)\n    // - same for binEdges[1]\n    var dv0 = -1.1 * rightGap;\n    var dv1 = -0.1 * rightGap;\n    var dv2 = leftGap - dv1;\n    var edge0 = binEdges[0];\n    var edge1 = binEdges[1];\n    var leftDigit = Math.min(\n        biggestDigitChanged(edge0 + dv1, edge0 + dv2, pa, calendar),\n        biggestDigitChanged(edge1 + dv1, edge1 + dv2, pa, calendar)\n    );\n    var rightDigit = Math.min(\n        biggestDigitChanged(edge0 + dv0, edge0 + dv1, pa, calendar),\n        biggestDigitChanged(edge1 + dv0, edge1 + dv1, pa, calendar)\n    );\n\n    // normally we try to make the label for the right edge different from\n    // the left edge label, so it's unambiguous which bin gets data on the edge.\n    // but if this results in more than 3 extra digits (or for dates, more than\n    // 2 fields ie hr&min or min&sec, which is 3600x), it'll be more clutter than\n    // useful so keep the label cleaner instead\n    var digit, disambiguateEdges;\n    if(leftDigit > rightDigit && rightDigit < Math.abs(edge1 - edge0) / 4000) {\n        digit = leftDigit;\n        disambiguateEdges = false;\n    }\n    else {\n        digit = Math.min(leftDigit, rightDigit);\n        disambiguateEdges = true;\n    }\n\n    if(pa.type === 'date' && digit > oneDay) {\n        var dashExclude = (digit === oneYear) ? 1 : 6;\n        var increment = (digit === oneYear) ? 'M12' : 'M1';\n\n        return function(v, isRightEdge) {\n            var dateStr = pa.c2d(v, oneYear, calendar);\n            var dashPos = dateStr.indexOf('-', dashExclude);\n            if(dashPos > 0) dateStr = dateStr.substr(0, dashPos);\n            var roundedV = pa.d2c(dateStr, 0, calendar);\n\n            if(roundedV < v) {\n                var nextV = tickIncrement(roundedV, increment, false, calendar);\n                if((roundedV + nextV) / 2 < v + leftGap) roundedV = nextV;\n            }\n\n            if(isRightEdge && disambiguateEdges) {\n                return tickIncrement(roundedV, increment, true, calendar);\n            }\n\n            return roundedV;\n        };\n    }\n\n    return function(v, isRightEdge) {\n        var roundedV = digit * Math.round(v / digit);\n        // if we rounded down and we could round up and still be < leftGap\n        // (or what leftGap values round to), do that\n        if(roundedV + (digit / 10) < v && roundedV + (digit * 0.9) < v + leftGap) {\n            roundedV += digit;\n        }\n        // finally for the right edge back off one digit - but only if we can do that\n        // and not clip off any data that's potentially in the bin\n        if(isRightEdge && disambiguateEdges) {\n            roundedV -= digit;\n        }\n        return roundedV;\n    };\n};\n\n/*\n * Find the largest digit that changes within a (calcdata) region [v1, v2]\n * if dates, \"digit\" means date/time part when it's bigger than a second\n * returns the unit value to round to this digit, eg 0.01 to round to hundredths, or\n * 100 to round to hundreds. returns oneMonth or oneYear for month or year rounding,\n * so that Math.min will work, rather than 'M1' and 'M12'\n */\nfunction biggestDigitChanged(v1, v2, pa, calendar) {\n    // are we crossing zero? can't say anything.\n    // in principle this doesn't apply to dates but turns out this doesn't matter.\n    if(v1 * v2 <= 0) return Infinity;\n\n    var dv = Math.abs(v2 - v1);\n    var isDate = pa.type === 'date';\n    var digit = biggestGuaranteedDigitChanged(dv, isDate);\n    // see if a larger digit also changed\n    for(var i = 0; i < 10; i++) {\n        // numbers: next digit needs to be >10x but <100x then gets rounded down.\n        // dates: next digit can be as much as 60x (then rounded down)\n        var nextDigit = biggestGuaranteedDigitChanged(digit * 80, isDate);\n        // if we get to years, the chain stops\n        if(digit === nextDigit) break;\n        if(didDigitChange(nextDigit, v1, v2, isDate, pa, calendar)) digit = nextDigit;\n        else break;\n    }\n    return digit;\n}\n\n/*\n * Find the largest digit that *definitely* changes in a region [v, v + dv] for any v\n * for nonuniform date regions (months/years) pick the largest\n */\nfunction biggestGuaranteedDigitChanged(dv, isDate) {\n    if(isDate && dv > oneSec) {\n        // this is supposed to be the biggest *guaranteed* change\n        // so compare to the longest month and year across any calendar,\n        // and we'll iterate back up later\n        // note: does not support rounding larger than one year. We could add\n        // that if anyone wants it, but seems unusual and not strictly necessary.\n        if(dv > oneDay) {\n            if(dv > oneYear * 1.1) return oneYear;\n            if(dv > oneMonth * 1.1) return oneMonth;\n            return oneDay;\n        }\n\n        if(dv > oneHour) return oneHour;\n        if(dv > oneMin) return oneMin;\n        return oneSec;\n    }\n    return Math.pow(10, Math.floor(Math.log(dv) / Math.LN10));\n}\n\nfunction didDigitChange(digit, v1, v2, isDate, pa, calendar) {\n    if(isDate && digit > oneDay) {\n        var dateParts1 = dateParts(v1, pa, calendar);\n        var dateParts2 = dateParts(v2, pa, calendar);\n        var parti = (digit === oneYear) ? 0 : 1;\n        return dateParts1[parti] !== dateParts2[parti];\n\n    }\n    return Math.floor(v2 / digit) - Math.floor(v1 / digit) > 0.1;\n}\n\nfunction dateParts(v, pa, calendar) {\n    var parts = pa.c2d(v, oneYear, calendar).split('-');\n    if(parts[0] === '') {\n        parts.unshift();\n        parts[0] = '-' + parts[0];\n    }\n    return parts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}