{"ast":null,"code":"// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\nfunction Intersecter(selfIntersection, eps, buildLog) {\n  // selfIntersection is true/false depending on the phase of the overall algorithm\n\n  //\n  // segment creation\n  //\n\n  function segmentNew(start, end) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: null,\n        // is there fill above us?\n        below: null // is there fill below us?\n      },\n\n      otherFill: null\n    };\n  }\n  function segmentCopy(start, end, seg) {\n    return {\n      id: buildLog ? buildLog.segmentId() : -1,\n      start: start,\n      end: end,\n      myFill: {\n        above: seg.myFill.above,\n        below: seg.myFill.below\n      },\n      otherFill: null\n    };\n  }\n\n  //\n  // event logic\n  //\n\n  var event_root = LinkedList.create();\n  function eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2) {\n    // compare the selected points first\n    var comp = eps.pointsCompare(p1_1, p2_1);\n    if (comp !== 0) return comp;\n    // the selected points are the same\n\n    if (eps.pointsSame(p1_2, p2_2))\n      // if the non-selected points are the same too...\n      return 0; // then the segments are equal\n\n    if (p1_isStart !== p2_isStart)\n      // if one is a start and the other isn't...\n      return p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n    // otherwise, we'll have to calculate which one is below the other manually\n    return eps.pointAboveOrOnLine(p1_2, p2_isStart ? p2_1 : p2_2,\n    // order matters\n    p2_isStart ? p2_2 : p2_1) ? 1 : -1;\n  }\n  function eventAdd(ev, other_pt) {\n    event_root.insertBefore(ev, function (here) {\n      // should ev be inserted before here?\n      var comp = eventCompare(ev.isStart, ev.pt, other_pt, here.isStart, here.pt, here.other.pt);\n      return comp < 0;\n    });\n  }\n  function eventAddSegmentStart(seg, primary) {\n    var ev_start = LinkedList.node({\n      isStart: true,\n      pt: seg.start,\n      seg: seg,\n      primary: primary,\n      other: null,\n      status: null\n    });\n    eventAdd(ev_start, seg.end);\n    return ev_start;\n  }\n  function eventAddSegmentEnd(ev_start, seg, primary) {\n    var ev_end = LinkedList.node({\n      isStart: false,\n      pt: seg.end,\n      seg: seg,\n      primary: primary,\n      other: ev_start,\n      status: null\n    });\n    ev_start.other = ev_end;\n    eventAdd(ev_end, ev_start.pt);\n  }\n  function eventAddSegment(seg, primary) {\n    var ev_start = eventAddSegmentStart(seg, primary);\n    eventAddSegmentEnd(ev_start, seg, primary);\n    return ev_start;\n  }\n  function eventUpdateEnd(ev, end) {\n    // slides an end backwards\n    //   (start)------------(end)    to:\n    //   (start)---(end)\n\n    if (buildLog) buildLog.segmentChop(ev.seg, end);\n    ev.other.remove();\n    ev.seg.end = end;\n    ev.other.pt = end;\n    eventAdd(ev.other, ev.pt);\n  }\n  function eventDivide(ev, pt) {\n    var ns = segmentCopy(pt, ev.seg.end, ev.seg);\n    eventUpdateEnd(ev, pt);\n    return eventAddSegment(ns, ev.primary);\n  }\n  function _calculate(primaryPolyInverted, secondaryPolyInverted) {\n    // if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n    //\n    // status logic\n    //\n\n    var status_root = LinkedList.create();\n    function statusCompare(ev1, ev2) {\n      var a1 = ev1.seg.start;\n      var a2 = ev1.seg.end;\n      var b1 = ev2.seg.start;\n      var b2 = ev2.seg.end;\n      if (eps.pointsCollinear(a1, b1, b2)) {\n        if (eps.pointsCollinear(a2, b1, b2)) return 1; //eventCompare(true, a1, a2, true, b1, b2);\n        return eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n      }\n      return eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n    }\n    function statusFindSurrounding(ev) {\n      return status_root.findTransition(function (here) {\n        var comp = statusCompare(ev, here.ev);\n        return comp > 0;\n      });\n    }\n    function checkIntersection(ev1, ev2) {\n      // returns the segment equal to ev1, or false if nothing equal\n\n      var seg1 = ev1.seg;\n      var seg2 = ev2.seg;\n      var a1 = seg1.start;\n      var a2 = seg1.end;\n      var b1 = seg2.start;\n      var b2 = seg2.end;\n      if (buildLog) buildLog.checkIntersection(seg1, seg2);\n      var i = eps.linesIntersect(a1, a2, b1, b2);\n      if (i === false) {\n        // segments are parallel or coincident\n\n        // if points aren't collinear, then the segments are parallel, so no intersections\n        if (!eps.pointsCollinear(a1, a2, b1)) return false;\n        // otherwise, segments are on top of each other somehow (aka coincident)\n\n        if (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1)) return false; // segments touch at endpoints... no intersection\n\n        var a1_equ_b1 = eps.pointsSame(a1, b1);\n        var a2_equ_b2 = eps.pointsSame(a2, b2);\n        if (a1_equ_b1 && a2_equ_b2) return ev2; // segments are exactly equal\n\n        var a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n        var a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n        // handy for debugging:\n        // buildLog.log({\n        //\ta1_equ_b1: a1_equ_b1,\n        //\ta2_equ_b2: a2_equ_b2,\n        //\ta1_between: a1_between,\n        //\ta2_between: a2_between\n        // });\n\n        if (a1_equ_b1) {\n          if (a2_between) {\n            //  (a1)---(a2)\n            //  (b1)----------(b2)\n            eventDivide(ev2, a2);\n          } else {\n            //  (a1)----------(a2)\n            //  (b1)---(b2)\n            eventDivide(ev1, b2);\n          }\n          return ev2;\n        } else if (a1_between) {\n          if (!a2_equ_b2) {\n            // make a2 equal to b2\n            if (a2_between) {\n              //         (a1)---(a2)\n              //  (b1)-----------------(b2)\n              eventDivide(ev2, a2);\n            } else {\n              //         (a1)----------(a2)\n              //  (b1)----------(b2)\n              eventDivide(ev1, b2);\n            }\n          }\n\n          //         (a1)---(a2)\n          //  (b1)----------(b2)\n          eventDivide(ev2, a1);\n        }\n      } else {\n        // otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n        // is A divided between its endpoints? (exclusive)\n        if (i.alongA === 0) {\n          if (i.alongB === -1)\n            // yes, at exactly b1\n            eventDivide(ev1, b1);else if (i.alongB === 0)\n            // yes, somewhere between B's endpoints\n            eventDivide(ev1, i.pt);else if (i.alongB === 1)\n            // yes, at exactly b2\n            eventDivide(ev1, b2);\n        }\n\n        // is B divided between its endpoints? (exclusive)\n        if (i.alongB === 0) {\n          if (i.alongA === -1)\n            // yes, at exactly a1\n            eventDivide(ev2, a1);else if (i.alongA === 0)\n            // yes, somewhere between A's endpoints (exclusive)\n            eventDivide(ev2, i.pt);else if (i.alongA === 1)\n            // yes, at exactly a2\n            eventDivide(ev2, a2);\n        }\n      }\n      return false;\n    }\n\n    //\n    // main event loop\n    //\n    var segments = [];\n    while (!event_root.isEmpty()) {\n      var ev = event_root.getHead();\n      if (buildLog) buildLog.vert(ev.pt[0]);\n      if (ev.isStart) {\n        var checkBothIntersections = function checkBothIntersections() {\n          if (above) {\n            var eve = checkIntersection(ev, above);\n            if (eve) return eve;\n          }\n          if (below) return checkIntersection(ev, below);\n          return false;\n        };\n        if (buildLog) buildLog.segmentNew(ev.seg, ev.primary);\n        var surrounding = statusFindSurrounding(ev);\n        var above = surrounding.before ? surrounding.before.ev : null;\n        var below = surrounding.after ? surrounding.after.ev : null;\n        if (buildLog) {\n          buildLog.tempStatus(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        }\n        var eve = checkBothIntersections();\n        if (eve) {\n          // ev and eve are equal\n          // we'll keep eve and throw away ev\n\n          // merge ev.seg's fill information into eve.seg\n\n          if (selfIntersection) {\n            var toggle; // are we a toggling edge?\n            if (ev.seg.myFill.below === null) toggle = true;else toggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n            // merge two segments that belong to the same polygon\n            // think of this as sandwiching two segments together, where `eve.seg` is\n            // the bottom -- this will cause the above fill flag to toggle\n            if (toggle) eve.seg.myFill.above = !eve.seg.myFill.above;\n          } else {\n            // merge two segments that belong to different polygons\n            // each segment has distinct knowledge, so no special logic is needed\n            // note that this can only happen once per segment in this phase, because we\n            // are guaranteed that all self-intersections are gone\n            eve.seg.otherFill = ev.seg.myFill;\n          }\n          if (buildLog) buildLog.segmentUpdate(eve.seg);\n          ev.other.remove();\n          ev.remove();\n        }\n        if (event_root.getHead() !== ev) {\n          // something was inserted before us in the event queue, so loop back around and\n          // process it before continuing\n          if (buildLog) buildLog.rewind(ev.seg);\n          continue;\n        }\n\n        //\n        // calculate fill flags\n        //\n        if (selfIntersection) {\n          var toggle; // are we a toggling edge?\n          if (ev.seg.myFill.below === null)\n            // if we are a new segment...\n            toggle = true; // then we toggle\n          else\n            // we are a segment that has previous knowledge from a division\n            toggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n          // next, calculate whether we are filled below us\n          if (!below) {\n            // if nothing is below us...\n            // we are filled below us if the polygon is inverted\n            ev.seg.myFill.below = primaryPolyInverted;\n          } else {\n            // otherwise, we know the answer -- it's the same if whatever is below\n            // us is filled above it\n            ev.seg.myFill.below = below.seg.myFill.above;\n          }\n\n          // since now we know if we're filled below us, we can calculate whether\n          // we're filled above us by applying toggle to whatever is below us\n          if (toggle) ev.seg.myFill.above = !ev.seg.myFill.below;else ev.seg.myFill.above = ev.seg.myFill.below;\n        } else {\n          // now we fill in any missing transition information, since we are all-knowing\n          // at this point\n\n          if (ev.seg.otherFill === null) {\n            // if we don't have other information, then we need to figure out if we're\n            // inside the other polygon\n            var inside;\n            if (!below) {\n              // if nothing is below us, then we're inside if the other polygon is\n              // inverted\n              inside = ev.primary ? secondaryPolyInverted : primaryPolyInverted;\n            } else {\n              // otherwise, something is below us\n              // so copy the below segment's other polygon's above\n              if (ev.primary === below.primary) inside = below.seg.otherFill.above;else inside = below.seg.myFill.above;\n            }\n            ev.seg.otherFill = {\n              above: inside,\n              below: inside\n            };\n          }\n        }\n        if (buildLog) {\n          buildLog.status(ev.seg, above ? above.seg : false, below ? below.seg : false);\n        }\n\n        // insert the status and remember it for later removal\n        ev.other.status = surrounding.insert(LinkedList.node({\n          ev: ev\n        }));\n      } else {\n        var st = ev.status;\n        if (st === null) {\n          throw new Error('PolyBool: Zero-length segment detected; your epsilon is ' + 'probably too small or too large');\n        }\n\n        // removing the status will create two new adjacent edges, so we'll need to check\n        // for those\n        if (status_root.exists(st.prev) && status_root.exists(st.next)) checkIntersection(st.prev.ev, st.next.ev);\n        if (buildLog) buildLog.statusRemove(st.ev.seg);\n\n        // remove the status\n        st.remove();\n\n        // if we've reached this point, we've calculated everything there is to know, so\n        // save the segment for reporting\n        if (!ev.primary) {\n          // make sure `seg.myFill` actually points to the primary polygon though\n          var s = ev.seg.myFill;\n          ev.seg.myFill = ev.seg.otherFill;\n          ev.seg.otherFill = s;\n        }\n        segments.push(ev.seg);\n      }\n\n      // remove the event and continue\n      event_root.getHead().remove();\n    }\n    if (buildLog) buildLog.done();\n    return segments;\n  }\n\n  // return the appropriate API depending on what we're doing\n  if (!selfIntersection) {\n    // performing combination of polygons, so only deal with already-processed segments\n    return {\n      calculate: function calculate(segments1, inverted1, segments2, inverted2) {\n        // segmentsX come from the self-intersection API, or this API\n        // invertedX is whether we treat that list of segments as an inverted polygon or not\n        // returns segments that can be used for further operations\n        segments1.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n        });\n        segments2.forEach(function (seg) {\n          eventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n        });\n        return _calculate(inverted1, inverted2);\n      }\n    };\n  }\n\n  // otherwise, performing self-intersection, so deal with regions\n  return {\n    addRegion: function addRegion(region) {\n      // regions are a list of points:\n      //  [ [0, 0], [100, 0], [50, 100] ]\n      // you can add multiple regions before running calculate\n      var pt1;\n      var pt2 = region[region.length - 1];\n      for (var i = 0; i < region.length; i++) {\n        pt1 = pt2;\n        pt2 = region[i];\n        var forward = eps.pointsCompare(pt1, pt2);\n        if (forward === 0)\n          // points are equal, so we have a zero-length segment\n          continue; // just skip it\n\n        eventAddSegment(segmentNew(forward < 0 ? pt1 : pt2, forward < 0 ? pt2 : pt1), true);\n      }\n    },\n    calculate: function calculate(inverted) {\n      // is the polygon inverted?\n      // returns segments\n      return _calculate(inverted, false);\n    }\n  };\n}\nmodule.exports = Intersecter;","map":{"version":3,"names":["LinkedList","require","Intersecter","selfIntersection","eps","buildLog","segmentNew","start","end","id","segmentId","myFill","above","below","otherFill","segmentCopy","seg","event_root","create","eventCompare","p1_isStart","p1_1","p1_2","p2_isStart","p2_1","p2_2","comp","pointsCompare","pointsSame","pointAboveOrOnLine","eventAdd","ev","other_pt","insertBefore","here","isStart","pt","other","eventAddSegmentStart","primary","ev_start","node","status","eventAddSegmentEnd","ev_end","eventAddSegment","eventUpdateEnd","segmentChop","remove","eventDivide","ns","calculate","primaryPolyInverted","secondaryPolyInverted","status_root","statusCompare","ev1","ev2","a1","a2","b1","b2","pointsCollinear","statusFindSurrounding","findTransition","checkIntersection","seg1","seg2","i","linesIntersect","a1_equ_b1","a2_equ_b2","a1_between","pointBetween","a2_between","alongA","alongB","segments","isEmpty","getHead","vert","checkBothIntersections","eve","surrounding","before","after","tempStatus","toggle","segmentUpdate","rewind","inside","insert","st","Error","exists","prev","next","statusRemove","s","push","done","segments1","inverted1","segments2","inverted2","forEach","addRegion","region","pt1","pt2","length","forward","inverted","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/polybooljs/lib/intersecter.js"],"sourcesContent":["// (c) Copyright 2016, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// this is the core work-horse\n//\n\nvar LinkedList = require('./linked-list');\n\nfunction Intersecter(selfIntersection, eps, buildLog){\n\t// selfIntersection is true/false depending on the phase of the overall algorithm\n\n\t//\n\t// segment creation\n\t//\n\n\tfunction segmentNew(start, end){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: null, // is there fill above us?\n\t\t\t\tbelow: null  // is there fill below us?\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\tfunction segmentCopy(start, end, seg){\n\t\treturn {\n\t\t\tid: buildLog ? buildLog.segmentId() : -1,\n\t\t\tstart: start,\n\t\t\tend: end,\n\t\t\tmyFill: {\n\t\t\t\tabove: seg.myFill.above,\n\t\t\t\tbelow: seg.myFill.below\n\t\t\t},\n\t\t\totherFill: null\n\t\t};\n\t}\n\n\t//\n\t// event logic\n\t//\n\n\tvar event_root = LinkedList.create();\n\n\tfunction eventCompare(p1_isStart, p1_1, p1_2, p2_isStart, p2_1, p2_2){\n\t\t// compare the selected points first\n\t\tvar comp = eps.pointsCompare(p1_1, p2_1);\n\t\tif (comp !== 0)\n\t\t\treturn comp;\n\t\t// the selected points are the same\n\n\t\tif (eps.pointsSame(p1_2, p2_2)) // if the non-selected points are the same too...\n\t\t\treturn 0; // then the segments are equal\n\n\t\tif (p1_isStart !== p2_isStart) // if one is a start and the other isn't...\n\t\t\treturn p1_isStart ? 1 : -1; // favor the one that isn't the start\n\n\t\t// otherwise, we'll have to calculate which one is below the other manually\n\t\treturn eps.pointAboveOrOnLine(p1_2,\n\t\t\tp2_isStart ? p2_1 : p2_2, // order matters\n\t\t\tp2_isStart ? p2_2 : p2_1\n\t\t) ? 1 : -1;\n\t}\n\n\tfunction eventAdd(ev, other_pt){\n\t\tevent_root.insertBefore(ev, function(here){\n\t\t\t// should ev be inserted before here?\n\t\t\tvar comp = eventCompare(\n\t\t\t\tev  .isStart, ev  .pt,      other_pt,\n\t\t\t\there.isStart, here.pt, here.other.pt\n\t\t\t);\n\t\t\treturn comp < 0;\n\t\t});\n\t}\n\n\tfunction eventAddSegmentStart(seg, primary){\n\t\tvar ev_start = LinkedList.node({\n\t\t\tisStart: true,\n\t\t\tpt: seg.start,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: null,\n\t\t\tstatus: null\n\t\t});\n\t\teventAdd(ev_start, seg.end);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventAddSegmentEnd(ev_start, seg, primary){\n\t\tvar ev_end = LinkedList.node({\n\t\t\tisStart: false,\n\t\t\tpt: seg.end,\n\t\t\tseg: seg,\n\t\t\tprimary: primary,\n\t\t\tother: ev_start,\n\t\t\tstatus: null\n\t\t});\n\t\tev_start.other = ev_end;\n\t\teventAdd(ev_end, ev_start.pt);\n\t}\n\n\tfunction eventAddSegment(seg, primary){\n\t\tvar ev_start = eventAddSegmentStart(seg, primary);\n\t\teventAddSegmentEnd(ev_start, seg, primary);\n\t\treturn ev_start;\n\t}\n\n\tfunction eventUpdateEnd(ev, end){\n\t\t// slides an end backwards\n\t\t//   (start)------------(end)    to:\n\t\t//   (start)---(end)\n\n\t\tif (buildLog)\n\t\t\tbuildLog.segmentChop(ev.seg, end);\n\n\t\tev.other.remove();\n\t\tev.seg.end = end;\n\t\tev.other.pt = end;\n\t\teventAdd(ev.other, ev.pt);\n\t}\n\n\tfunction eventDivide(ev, pt){\n\t\tvar ns = segmentCopy(pt, ev.seg.end, ev.seg);\n\t\teventUpdateEnd(ev, pt);\n\t\treturn eventAddSegment(ns, ev.primary);\n\t}\n\n\tfunction calculate(primaryPolyInverted, secondaryPolyInverted){\n\t\t// if selfIntersection is true then there is no secondary polygon, so that isn't used\n\n\t\t//\n\t\t// status logic\n\t\t//\n\n\t\tvar status_root = LinkedList.create();\n\n\t\tfunction statusCompare(ev1, ev2){\n\t\t\tvar a1 = ev1.seg.start;\n\t\t\tvar a2 = ev1.seg.end;\n\t\t\tvar b1 = ev2.seg.start;\n\t\t\tvar b2 = ev2.seg.end;\n\n\t\t\tif (eps.pointsCollinear(a1, b1, b2)){\n\t\t\t\tif (eps.pointsCollinear(a2, b1, b2))\n\t\t\t\t\treturn 1;//eventCompare(true, a1, a2, true, b1, b2);\n\t\t\t\treturn eps.pointAboveOrOnLine(a2, b1, b2) ? 1 : -1;\n\t\t\t}\n\t\t\treturn eps.pointAboveOrOnLine(a1, b1, b2) ? 1 : -1;\n\t\t}\n\n\t\tfunction statusFindSurrounding(ev){\n\t\t\treturn status_root.findTransition(function(here){\n\t\t\t\tvar comp = statusCompare(ev, here.ev);\n\t\t\t\treturn comp > 0;\n\t\t\t});\n\t\t}\n\n\t\tfunction checkIntersection(ev1, ev2){\n\t\t\t// returns the segment equal to ev1, or false if nothing equal\n\n\t\t\tvar seg1 = ev1.seg;\n\t\t\tvar seg2 = ev2.seg;\n\t\t\tvar a1 = seg1.start;\n\t\t\tvar a2 = seg1.end;\n\t\t\tvar b1 = seg2.start;\n\t\t\tvar b2 = seg2.end;\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.checkIntersection(seg1, seg2);\n\n\t\t\tvar i = eps.linesIntersect(a1, a2, b1, b2);\n\n\t\t\tif (i === false){\n\t\t\t\t// segments are parallel or coincident\n\n\t\t\t\t// if points aren't collinear, then the segments are parallel, so no intersections\n\t\t\t\tif (!eps.pointsCollinear(a1, a2, b1))\n\t\t\t\t\treturn false;\n\t\t\t\t// otherwise, segments are on top of each other somehow (aka coincident)\n\n\t\t\t\tif (eps.pointsSame(a1, b2) || eps.pointsSame(a2, b1))\n\t\t\t\t\treturn false; // segments touch at endpoints... no intersection\n\n\t\t\t\tvar a1_equ_b1 = eps.pointsSame(a1, b1);\n\t\t\t\tvar a2_equ_b2 = eps.pointsSame(a2, b2);\n\n\t\t\t\tif (a1_equ_b1 && a2_equ_b2)\n\t\t\t\t\treturn ev2; // segments are exactly equal\n\n\t\t\t\tvar a1_between = !a1_equ_b1 && eps.pointBetween(a1, b1, b2);\n\t\t\t\tvar a2_between = !a2_equ_b2 && eps.pointBetween(a2, b1, b2);\n\n\t\t\t\t// handy for debugging:\n\t\t\t\t// buildLog.log({\n\t\t\t\t//\ta1_equ_b1: a1_equ_b1,\n\t\t\t\t//\ta2_equ_b2: a2_equ_b2,\n\t\t\t\t//\ta1_between: a1_between,\n\t\t\t\t//\ta2_between: a2_between\n\t\t\t\t// });\n\n\t\t\t\tif (a1_equ_b1){\n\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t//  (a1)---(a2)\n\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t//  (a1)----------(a2)\n\t\t\t\t\t\t//  (b1)---(b2)\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t}\n\t\t\t\t\treturn ev2;\n\t\t\t\t}\n\t\t\t\telse if (a1_between){\n\t\t\t\t\tif (!a2_equ_b2){\n\t\t\t\t\t\t// make a2 equal to b2\n\t\t\t\t\t\tif (a2_between){\n\t\t\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t\t\t//  (b1)-----------------(b2)\n\t\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t//         (a1)----------(a2)\n\t\t\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//         (a1)---(a2)\n\t\t\t\t\t//  (b1)----------(b2)\n\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// otherwise, lines intersect at i.pt, which may or may not be between the endpoints\n\n\t\t\t\t// is A divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongA === 0){\n\t\t\t\t\tif (i.alongB === -1) // yes, at exactly b1\n\t\t\t\t\t\teventDivide(ev1, b1);\n\t\t\t\t\telse if (i.alongB === 0) // yes, somewhere between B's endpoints\n\t\t\t\t\t\teventDivide(ev1, i.pt);\n\t\t\t\t\telse if (i.alongB === 1) // yes, at exactly b2\n\t\t\t\t\t\teventDivide(ev1, b2);\n\t\t\t\t}\n\n\t\t\t\t// is B divided between its endpoints? (exclusive)\n\t\t\t\tif (i.alongB === 0){\n\t\t\t\t\tif (i.alongA === -1) // yes, at exactly a1\n\t\t\t\t\t\teventDivide(ev2, a1);\n\t\t\t\t\telse if (i.alongA === 0) // yes, somewhere between A's endpoints (exclusive)\n\t\t\t\t\t\teventDivide(ev2, i.pt);\n\t\t\t\t\telse if (i.alongA === 1) // yes, at exactly a2\n\t\t\t\t\t\teventDivide(ev2, a2);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t//\n\t\t// main event loop\n\t\t//\n\t\tvar segments = [];\n\t\twhile (!event_root.isEmpty()){\n\t\t\tvar ev = event_root.getHead();\n\n\t\t\tif (buildLog)\n\t\t\t\tbuildLog.vert(ev.pt[0]);\n\n\t\t\tif (ev.isStart){\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.segmentNew(ev.seg, ev.primary);\n\n\t\t\t\tvar surrounding = statusFindSurrounding(ev);\n\t\t\t\tvar above = surrounding.before ? surrounding.before.ev : null;\n\t\t\t\tvar below = surrounding.after ? surrounding.after.ev : null;\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.tempStatus(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tfunction checkBothIntersections(){\n\t\t\t\t\tif (above){\n\t\t\t\t\t\tvar eve = checkIntersection(ev, above);\n\t\t\t\t\t\tif (eve)\n\t\t\t\t\t\t\treturn eve;\n\t\t\t\t\t}\n\t\t\t\t\tif (below)\n\t\t\t\t\t\treturn checkIntersection(ev, below);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tvar eve = checkBothIntersections();\n\t\t\t\tif (eve){\n\t\t\t\t\t// ev and eve are equal\n\t\t\t\t\t// we'll keep eve and throw away ev\n\n\t\t\t\t\t// merge ev.seg's fill information into eve.seg\n\n\t\t\t\t\tif (selfIntersection){\n\t\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\t\tif (ev.seg.myFill.below === null)\n\t\t\t\t\t\t\ttoggle = true;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below;\n\n\t\t\t\t\t\t// merge two segments that belong to the same polygon\n\t\t\t\t\t\t// think of this as sandwiching two segments together, where `eve.seg` is\n\t\t\t\t\t\t// the bottom -- this will cause the above fill flag to toggle\n\t\t\t\t\t\tif (toggle)\n\t\t\t\t\t\t\teve.seg.myFill.above = !eve.seg.myFill.above;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// merge two segments that belong to different polygons\n\t\t\t\t\t\t// each segment has distinct knowledge, so no special logic is needed\n\t\t\t\t\t\t// note that this can only happen once per segment in this phase, because we\n\t\t\t\t\t\t// are guaranteed that all self-intersections are gone\n\t\t\t\t\t\teve.seg.otherFill = ev.seg.myFill;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.segmentUpdate(eve.seg);\n\n\t\t\t\t\tev.other.remove();\n\t\t\t\t\tev.remove();\n\t\t\t\t}\n\n\t\t\t\tif (event_root.getHead() !== ev){\n\t\t\t\t\t// something was inserted before us in the event queue, so loop back around and\n\t\t\t\t\t// process it before continuing\n\t\t\t\t\tif (buildLog)\n\t\t\t\t\t\tbuildLog.rewind(ev.seg);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t//\n\t\t\t\t// calculate fill flags\n\t\t\t\t//\n\t\t\t\tif (selfIntersection){\n\t\t\t\t\tvar toggle; // are we a toggling edge?\n\t\t\t\t\tif (ev.seg.myFill.below === null) // if we are a new segment...\n\t\t\t\t\t\ttoggle = true; // then we toggle\n\t\t\t\t\telse // we are a segment that has previous knowledge from a division\n\t\t\t\t\t\ttoggle = ev.seg.myFill.above !== ev.seg.myFill.below; // calculate toggle\n\n\t\t\t\t\t// next, calculate whether we are filled below us\n\t\t\t\t\tif (!below){ // if nothing is below us...\n\t\t\t\t\t\t// we are filled below us if the polygon is inverted\n\t\t\t\t\t\tev.seg.myFill.below = primaryPolyInverted;\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\t// otherwise, we know the answer -- it's the same if whatever is below\n\t\t\t\t\t\t// us is filled above it\n\t\t\t\t\t\tev.seg.myFill.below = below.seg.myFill.above;\n\t\t\t\t\t}\n\n\t\t\t\t\t// since now we know if we're filled below us, we can calculate whether\n\t\t\t\t\t// we're filled above us by applying toggle to whatever is below us\n\t\t\t\t\tif (toggle)\n\t\t\t\t\t\tev.seg.myFill.above = !ev.seg.myFill.below;\n\t\t\t\t\telse\n\t\t\t\t\t\tev.seg.myFill.above = ev.seg.myFill.below;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\t// now we fill in any missing transition information, since we are all-knowing\n\t\t\t\t\t// at this point\n\n\t\t\t\t\tif (ev.seg.otherFill === null){\n\t\t\t\t\t\t// if we don't have other information, then we need to figure out if we're\n\t\t\t\t\t\t// inside the other polygon\n\t\t\t\t\t\tvar inside;\n\t\t\t\t\t\tif (!below){\n\t\t\t\t\t\t\t// if nothing is below us, then we're inside if the other polygon is\n\t\t\t\t\t\t\t// inverted\n\t\t\t\t\t\t\tinside =\n\t\t\t\t\t\t\t\tev.primary ? secondaryPolyInverted : primaryPolyInverted;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{ // otherwise, something is below us\n\t\t\t\t\t\t\t// so copy the below segment's other polygon's above\n\t\t\t\t\t\t\tif (ev.primary === below.primary)\n\t\t\t\t\t\t\t\tinside = below.seg.otherFill.above;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tinside = below.seg.myFill.above;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tev.seg.otherFill = {\n\t\t\t\t\t\t\tabove: inside,\n\t\t\t\t\t\t\tbelow: inside\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (buildLog){\n\t\t\t\t\tbuildLog.status(\n\t\t\t\t\t\tev.seg,\n\t\t\t\t\t\tabove ? above.seg : false,\n\t\t\t\t\t\tbelow ? below.seg : false\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// insert the status and remember it for later removal\n\t\t\t\tev.other.status = surrounding.insert(LinkedList.node({ ev: ev }));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tvar st = ev.status;\n\n\t\t\t\tif (st === null){\n\t\t\t\t\tthrow new Error('PolyBool: Zero-length segment detected; your epsilon is ' +\n\t\t\t\t\t\t'probably too small or too large');\n\t\t\t\t}\n\n\t\t\t\t// removing the status will create two new adjacent edges, so we'll need to check\n\t\t\t\t// for those\n\t\t\t\tif (status_root.exists(st.prev) && status_root.exists(st.next))\n\t\t\t\t\tcheckIntersection(st.prev.ev, st.next.ev);\n\n\t\t\t\tif (buildLog)\n\t\t\t\t\tbuildLog.statusRemove(st.ev.seg);\n\n\t\t\t\t// remove the status\n\t\t\t\tst.remove();\n\n\t\t\t\t// if we've reached this point, we've calculated everything there is to know, so\n\t\t\t\t// save the segment for reporting\n\t\t\t\tif (!ev.primary){\n\t\t\t\t\t// make sure `seg.myFill` actually points to the primary polygon though\n\t\t\t\t\tvar s = ev.seg.myFill;\n\t\t\t\t\tev.seg.myFill = ev.seg.otherFill;\n\t\t\t\t\tev.seg.otherFill = s;\n\t\t\t\t}\n\t\t\t\tsegments.push(ev.seg);\n\t\t\t}\n\n\t\t\t// remove the event and continue\n\t\t\tevent_root.getHead().remove();\n\t\t}\n\n\t\tif (buildLog)\n\t\t\tbuildLog.done();\n\n\t\treturn segments;\n\t}\n\n\t// return the appropriate API depending on what we're doing\n\tif (!selfIntersection){\n\t\t// performing combination of polygons, so only deal with already-processed segments\n\t\treturn {\n\t\t\tcalculate: function(segments1, inverted1, segments2, inverted2){\n\t\t\t\t// segmentsX come from the self-intersection API, or this API\n\t\t\t\t// invertedX is whether we treat that list of segments as an inverted polygon or not\n\t\t\t\t// returns segments that can be used for further operations\n\t\t\t\tsegments1.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), true);\n\t\t\t\t});\n\t\t\t\tsegments2.forEach(function(seg){\n\t\t\t\t\teventAddSegment(segmentCopy(seg.start, seg.end, seg), false);\n\t\t\t\t});\n\t\t\t\treturn calculate(inverted1, inverted2);\n\t\t\t}\n\t\t};\n\t}\n\n\t// otherwise, performing self-intersection, so deal with regions\n\treturn {\n\t\taddRegion: function(region){\n\t\t\t// regions are a list of points:\n\t\t\t//  [ [0, 0], [100, 0], [50, 100] ]\n\t\t\t// you can add multiple regions before running calculate\n\t\t\tvar pt1;\n\t\t\tvar pt2 = region[region.length - 1];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tpt1 = pt2;\n\t\t\t\tpt2 = region[i];\n\n\t\t\t\tvar forward = eps.pointsCompare(pt1, pt2);\n\t\t\t\tif (forward === 0) // points are equal, so we have a zero-length segment\n\t\t\t\t\tcontinue; // just skip it\n\n\t\t\t\teventAddSegment(\n\t\t\t\t\tsegmentNew(\n\t\t\t\t\t\tforward < 0 ? pt1 : pt2,\n\t\t\t\t\t\tforward < 0 ? pt2 : pt1\n\t\t\t\t\t),\n\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t}\n\t\t},\n\t\tcalculate: function(inverted){\n\t\t\t// is the polygon inverted?\n\t\t\t// returns segments\n\t\t\treturn calculate(inverted, false);\n\t\t}\n\t};\n}\n\nmodule.exports = Intersecter;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}