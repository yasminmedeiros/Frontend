{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne\n};\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n\n  // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n  fullLayout._shapeUpperLayer.selectAll('path').remove();\n  fullLayout._shapeLowerLayer.selectAll('path').remove();\n  for (var k in fullLayout._plots) {\n    var shapelayer = fullLayout._plots[k].shapelayer;\n    if (shapelayer) shapelayer.selectAll('path').remove();\n  }\n  for (var i = 0; i < fullLayout.shapes.length; i++) {\n    if (fullLayout.shapes[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n\n  // may need to resurrect this if we put text (LaTeX) in shapes\n  // return Plots.previousPromises(gd);\n}\n\nfunction drawOne(gd, index) {\n  // remove the existing shape if there is one.\n  // because indices can change, we need to look in all shape layers\n  gd._fullLayout._paperdiv.selectAll('.shapelayer [data-index=\"' + index + '\"]').remove();\n  var options = gd._fullLayout.shapes[index] || {};\n\n  // this shape is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n  if (!options._input || options.visible === false) return;\n  if (options.layer !== 'below') {\n    drawShape(gd._fullLayout._shapeUpperLayer);\n  } else if (options.xref === 'paper' || options.yref === 'paper') {\n    drawShape(gd._fullLayout._shapeLowerLayer);\n  } else {\n    var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n    if (plotinfo) {\n      var mainPlot = plotinfo.mainplotinfo || plotinfo;\n      drawShape(mainPlot.shapelayer);\n    } else {\n      // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n      // This can happen if you reference the shape to an x / y axis combination\n      // that doesn't have any data on it (and layer is below)\n      drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n  }\n  function drawShape(shapeLayer) {\n    var attrs = {\n      'data-index': index,\n      'fill-rule': 'evenodd',\n      d: getPathString(gd, options)\n    };\n    var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n    var path = shapeLayer.append('path').attr(attrs).style('opacity', options.opacity).call(Color.stroke, lineColor).call(Color.fill, options.fillcolor).call(Drawing.dashLine, options.line.dash, options.line.width);\n    setClipPath(path, gd, options);\n    if (gd._context.edits.shapePosition) setupDragElement(gd, path, options, index, shapeLayer);\n  }\n}\nfunction setClipPath(shapePath, gd, shapeOptions) {\n  // note that for layer=\"below\" the clipAxes can be different from the\n  // subplot we're drawing this in. This could cause problems if the shape\n  // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n  var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n  Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n}\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer) {\n  var MINWIDTH = 10;\n  var MINHEIGHT = 10;\n  var xPixelSized = shapeOptions.xsizemode === 'pixel';\n  var yPixelSized = shapeOptions.ysizemode === 'pixel';\n  var isLine = shapeOptions.type === 'line';\n  var isPath = shapeOptions.type === 'path';\n  var editHelpers = arrayEditor(gd.layout, 'shapes', shapeOptions);\n  var modifyItem = editHelpers.modifyItem;\n  var x0, y0, x1, y1, xAnchor, yAnchor;\n  var n0, s0, w0, e0, optN, optS, optW, optE;\n  var pathIn;\n\n  // setup conversion functions\n  var xa = Axes.getFromId(gd, shapeOptions.xref);\n  var ya = Axes.getFromId(gd, shapeOptions.yref);\n  var x2p = helpers.getDataToPixel(gd, xa);\n  var y2p = helpers.getDataToPixel(gd, ya, true);\n  var p2x = helpers.getPixelToData(gd, xa);\n  var p2y = helpers.getPixelToData(gd, ya, true);\n  var sensoryElement = obtainSensoryElement();\n  var dragOptions = {\n    element: sensoryElement.node(),\n    gd: gd,\n    prepFn: startDrag,\n    doneFn: endDrag,\n    clickFn: abortDrag\n  };\n  var dragMode;\n  dragElement.init(dragOptions);\n  sensoryElement.node().onmousemove = updateDragMode;\n  function obtainSensoryElement() {\n    return isLine ? createLineDragHandles() : shapePath;\n  }\n  function createLineDragHandles() {\n    var minSensoryWidth = 10;\n    var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n    // Helper shapes group\n    // Note that by setting the `data-index` attr, it is ensured that\n    // the helper group is purged in this modules `draw` function\n    var g = shapeLayer.append('g').attr('data-index', index);\n\n    // Helper path for moving\n    g.append('path').attr('d', shapePath.attr('d')).style({\n      'cursor': 'move',\n      'stroke-width': sensoryWidth,\n      'stroke-opacity': '0' // ensure not visible\n    });\n\n    // Helper circles for resizing\n    var circleStyle = {\n      'fill-opacity': '0' // ensure not visible\n    };\n\n    var circleRadius = sensoryWidth / 2 > minSensoryWidth ? sensoryWidth / 2 : minSensoryWidth;\n    g.append('circle').attr({\n      'data-line-point': 'start-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    g.append('circle').attr({\n      'data-line-point': 'end-point',\n      'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n      'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n      'r': circleRadius\n    }).style(circleStyle).classed('cursor-grab', true);\n    return g;\n  }\n  function updateDragMode(evt) {\n    if (isLine) {\n      if (evt.target.tagName === 'path') {\n        dragMode = 'move';\n      } else {\n        dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ? 'resize-over-start-point' : 'resize-over-end-point';\n      }\n    } else {\n      // element might not be on screen at time of setup,\n      // so obtain bounding box here\n      var dragBBox = dragOptions.element.getBoundingClientRect();\n\n      // choose 'move' or 'resize'\n      // based on initial position of cursor within the drag element\n      var w = dragBBox.right - dragBBox.left;\n      var h = dragBBox.bottom - dragBBox.top;\n      var x = evt.clientX - dragBBox.left;\n      var y = evt.clientY - dragBBox.top;\n      var cursor = !isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey ? dragElement.getCursor(x / w, 1 - y / h) : 'move';\n      setCursor(shapePath, cursor);\n\n      // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n      dragMode = cursor.split('-')[0];\n    }\n  }\n  function startDrag(evt) {\n    // setup update strings and initial values\n    if (xPixelSized) {\n      xAnchor = x2p(shapeOptions.xanchor);\n    }\n    if (yPixelSized) {\n      yAnchor = y2p(shapeOptions.yanchor);\n    }\n    if (shapeOptions.type === 'path') {\n      pathIn = shapeOptions.path;\n    } else {\n      x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n      y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n      x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n      y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n    }\n    if (x0 < x1) {\n      w0 = x0;\n      optW = 'x0';\n      e0 = x1;\n      optE = 'x1';\n    } else {\n      w0 = x1;\n      optW = 'x1';\n      e0 = x0;\n      optE = 'x0';\n    }\n\n    // For fixed size shapes take opposing direction of y-axis into account.\n    // Hint: For data sized shapes this is done by the y2p function.\n    if (!yPixelSized && y0 < y1 || yPixelSized && y0 > y1) {\n      n0 = y0;\n      optN = 'y0';\n      s0 = y1;\n      optS = 'y1';\n    } else {\n      n0 = y1;\n      optN = 'y1';\n      s0 = y0;\n      optS = 'y0';\n    }\n\n    // setup dragMode and the corresponding handler\n    updateDragMode(evt);\n    renderVisualCues(shapeLayer, shapeOptions);\n    deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n    dragOptions.moveFn = dragMode === 'move' ? moveShape : resizeShape;\n  }\n  function endDrag() {\n    setCursor(shapePath);\n    removeVisualCues(shapeLayer);\n\n    // Don't rely on clipPath being activated during re-layout\n    setClipPath(shapePath, gd, shapeOptions);\n    Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n  }\n  function abortDrag() {\n    removeVisualCues(shapeLayer);\n  }\n  function moveShape(dx, dy) {\n    if (shapeOptions.type === 'path') {\n      var noOp = function noOp(coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else {\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n        modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n        modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n  function resizeShape(dx, dy) {\n    if (isPath) {\n      // TODO: implement path resize, don't forget to update dragMode code\n      var noOp = function noOp(coord) {\n        return coord;\n      };\n      var moveX = noOp;\n      var moveY = noOp;\n      if (xPixelSized) {\n        modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n      } else {\n        moveX = function moveX(x) {\n          return p2x(x2p(x) + dx);\n        };\n        if (xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n      }\n      if (yPixelSized) {\n        modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n      } else {\n        moveY = function moveY(y) {\n          return p2y(y2p(y) + dy);\n        };\n        if (ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n      }\n      modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n    } else if (isLine) {\n      if (dragMode === 'resize-over-start-point') {\n        var newX0 = x0 + dx;\n        var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n        modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n        modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n      } else if (dragMode === 'resize-over-end-point') {\n        var newX1 = x1 + dx;\n        var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n        modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n        modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n      }\n    } else {\n      var newN = ~dragMode.indexOf('n') ? n0 + dy : n0;\n      var newS = ~dragMode.indexOf('s') ? s0 + dy : s0;\n      var newW = ~dragMode.indexOf('w') ? w0 + dx : w0;\n      var newE = ~dragMode.indexOf('e') ? e0 + dx : e0;\n\n      // Do things in opposing direction for y-axis.\n      // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n      if (~dragMode.indexOf('n') && yPixelSized) newN = n0 - dy;\n      if (~dragMode.indexOf('s') && yPixelSized) newS = s0 - dy;\n\n      // Update shape eventually. Again, be aware of the\n      // opposing direction of the y-axis of fixed size shapes.\n      if (!yPixelSized && newS - newN > MINHEIGHT || yPixelSized && newN - newS > MINHEIGHT) {\n        modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n        modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n      }\n      if (newE - newW > MINWIDTH) {\n        modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n        modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n      }\n    }\n    shapePath.attr('d', getPathString(gd, shapeOptions));\n    renderVisualCues(shapeLayer, shapeOptions);\n  }\n  function renderVisualCues(shapeLayer, shapeOptions) {\n    if (xPixelSized || yPixelSized) {\n      renderAnchor();\n    }\n    function renderAnchor() {\n      var isNotPath = shapeOptions.type !== 'path';\n\n      // d3 join with dummy data to satisfy d3 data-binding\n      var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n      // Enter\n      var strokeWidth = 1;\n      visualCues.enter().append('path').attr({\n        'fill': '#fff',\n        'fill-rule': 'evenodd',\n        'stroke': '#000',\n        'stroke-width': strokeWidth\n      }).classed('visual-cue', true);\n\n      // Update\n      var posX = x2p(xPixelSized ? shapeOptions.xanchor : Lib.midRange(isNotPath ? [shapeOptions.x0, shapeOptions.x1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsX)));\n      var posY = y2p(yPixelSized ? shapeOptions.yanchor : Lib.midRange(isNotPath ? [shapeOptions.y0, shapeOptions.y1] : helpers.extractPathCoords(shapeOptions.path, constants.paramIsY)));\n      posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n      posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n      if (xPixelSized && yPixelSized) {\n        var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n        visualCues.attr('d', crossPath);\n      } else if (xPixelSized) {\n        var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) + 'v18 h2 v-18 Z';\n        visualCues.attr('d', vBarPath);\n      } else {\n        var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) + 'h18 v2 h-18 Z';\n        visualCues.attr('d', hBarPath);\n      }\n    }\n  }\n  function removeVisualCues(shapeLayer) {\n    shapeLayer.selectAll('.visual-cue').remove();\n  }\n  function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n    var xref = shapeOptions.xref;\n    var yref = shapeOptions.yref;\n    var xa = Axes.getFromId(gd, xref);\n    var ya = Axes.getFromId(gd, yref);\n    var clipAxes = '';\n    if (xref !== 'paper' && !xa.autorange) clipAxes += xref;\n    if (yref !== 'paper' && !ya.autorange) clipAxes += yref;\n    Drawing.setClipUrl(shapePath, clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null, gd);\n  }\n}\nfunction getPathString(gd, options) {\n  var type = options.type;\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  var gs = gd._fullLayout._size;\n  var x2r, x2p, y2r, y2p;\n  var x0, x1, y0, y1;\n  if (xa) {\n    x2r = helpers.shapePositionToRange(xa);\n    x2p = function x2p(v) {\n      return xa._offset + xa.r2p(x2r(v, true));\n    };\n  } else {\n    x2p = function x2p(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  if (ya) {\n    y2r = helpers.shapePositionToRange(ya);\n    y2p = function y2p(v) {\n      return ya._offset + ya.r2p(y2r(v, true));\n    };\n  } else {\n    y2p = function y2p(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  }\n  if (type === 'path') {\n    if (xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n    if (ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n    return convertPath(options, x2p, y2p);\n  }\n  if (options.xsizemode === 'pixel') {\n    var xAnchorPos = x2p(options.xanchor);\n    x0 = xAnchorPos + options.x0;\n    x1 = xAnchorPos + options.x1;\n  } else {\n    x0 = x2p(options.x0);\n    x1 = x2p(options.x1);\n  }\n  if (options.ysizemode === 'pixel') {\n    var yAnchorPos = y2p(options.yanchor);\n    y0 = yAnchorPos - options.y0;\n    y1 = yAnchorPos - options.y1;\n  } else {\n    y0 = y2p(options.y0);\n    y1 = y2p(options.y1);\n  }\n  if (type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n  if (type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n  // circle\n  var cx = (x0 + x1) / 2;\n  var cy = (y0 + y1) / 2;\n  var rx = Math.abs(cx - x0);\n  var ry = Math.abs(cy - y0);\n  var rArc = 'A' + rx + ',' + ry;\n  var rightPt = cx + rx + ',' + cy;\n  var topPt = cx + ',' + (cy - ry);\n  return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt + rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\nfunction convertPath(options, x2p, y2p) {\n  var pathIn = options.path;\n  var xSizemode = options.xsizemode;\n  var ySizemode = options.ysizemode;\n  var xAnchor = options.xanchor;\n  var yAnchor = options.yanchor;\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (xParams[paramNumber]) {\n        if (xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);else param = x2p(param);\n      } else if (yParams[paramNumber]) {\n        if (ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);else param = y2p(param);\n      }\n      paramNumber++;\n      if (paramNumber > nParams) param = 'X';\n      return param;\n    });\n    if (paramNumber > nParams) {\n      paramString = paramString.replace(/[\\s,]*X.*/, '');\n      Lib.log('Ignoring extra params in segment ' + segment);\n    }\n    return segmentType + paramString;\n  });\n}\nfunction movePath(pathIn, moveX, moveY) {\n  return pathIn.replace(constants.segmentRE, function (segment) {\n    var paramNumber = 0;\n    var segmentType = segment.charAt(0);\n    var xParams = constants.paramIsX[segmentType];\n    var yParams = constants.paramIsY[segmentType];\n    var nParams = constants.numParams[segmentType];\n    var paramString = segment.substr(1).replace(constants.paramRE, function (param) {\n      if (paramNumber >= nParams) return param;\n      if (xParams[paramNumber]) param = moveX(param);else if (yParams[paramNumber]) param = moveY(param);\n      paramNumber++;\n      return param;\n    });\n    return segmentType + paramString;\n  });\n}","map":{"version":3,"names":["Registry","require","Lib","Axes","Color","Drawing","arrayEditor","dragElement","setCursor","constants","helpers","module","exports","draw","drawOne","gd","fullLayout","_fullLayout","_shapeUpperLayer","selectAll","remove","_shapeLowerLayer","k","_plots","shapelayer","i","shapes","length","visible","index","_paperdiv","options","_input","layer","drawShape","xref","yref","plotinfo","mainPlot","mainplotinfo","shapeLayer","attrs","d","getPathString","lineColor","line","width","color","path","append","attr","style","opacity","call","stroke","fill","fillcolor","dashLine","dash","setClipPath","_context","edits","shapePosition","setupDragElement","shapePath","shapeOptions","clipAxes","replace","setClipUrl","_uid","MINWIDTH","MINHEIGHT","xPixelSized","xsizemode","yPixelSized","ysizemode","isLine","type","isPath","editHelpers","layout","modifyItem","x0","y0","x1","y1","xAnchor","yAnchor","n0","s0","w0","e0","optN","optS","optW","optE","pathIn","xa","getFromId","ya","x2p","getDataToPixel","y2p","p2x","getPixelToData","p2y","sensoryElement","obtainSensoryElement","dragOptions","element","node","prepFn","startDrag","doneFn","endDrag","clickFn","abortDrag","dragMode","init","onmousemove","updateDragMode","createLineDragHandles","minSensoryWidth","sensoryWidth","Math","max","g","circleStyle","circleRadius","xanchor","yanchor","classed","evt","target","tagName","attributes","value","dragBBox","getBoundingClientRect","w","right","left","h","bottom","top","x","clientX","y","clientY","cursor","shiftKey","getCursor","split","renderVisualCues","deactivateClipPathTemporarily","moveFn","moveShape","resizeShape","removeVisualCues","getUpdateObj","dx","dy","noOp","coord","moveX","moveY","encodeDate","movePath","newX0","newY0","newX1","newY1","newN","indexOf","newS","newW","newE","renderAnchor","isNotPath","visualCues","data","strokeWidth","enter","posX","midRange","extractPathCoords","paramIsX","posY","paramIsY","roundPositionForSharpStrokeRendering","crossPath","vBarPath","hBarPath","autorange","gs","_size","x2r","y2r","shapePositionToRange","v","_offset","r2p","l","t","decodeDate","convertPath","xAnchorPos","yAnchorPos","cx","cy","rx","abs","ry","rArc","rightPt","topPt","xSizemode","ySizemode","segmentRE","segment","paramNumber","segmentType","charAt","xParams","yParams","nParams","numParams","paramString","substr","paramRE","param","Number","log"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/components/shapes/draw.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar dragElement = require('../dragelement');\nvar setCursor = require('../../lib/setcursor');\n\nvar constants = require('./constants');\nvar helpers = require('./helpers');\n\n\n// Shapes are stored in gd.layout.shapes, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne\n};\n\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // Remove previous shapes before drawing new in shapes in fullLayout.shapes\n    fullLayout._shapeUpperLayer.selectAll('path').remove();\n    fullLayout._shapeLowerLayer.selectAll('path').remove();\n\n    for(var k in fullLayout._plots) {\n        var shapelayer = fullLayout._plots[k].shapelayer;\n        if(shapelayer) shapelayer.selectAll('path').remove();\n    }\n\n    for(var i = 0; i < fullLayout.shapes.length; i++) {\n        if(fullLayout.shapes[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    // may need to resurrect this if we put text (LaTeX) in shapes\n    // return Plots.previousPromises(gd);\n}\n\nfunction drawOne(gd, index) {\n    // remove the existing shape if there is one.\n    // because indices can change, we need to look in all shape layers\n    gd._fullLayout._paperdiv\n        .selectAll('.shapelayer [data-index=\"' + index + '\"]')\n        .remove();\n\n    var options = gd._fullLayout.shapes[index] || {};\n\n    // this shape is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) return;\n\n    if(options.layer !== 'below') {\n        drawShape(gd._fullLayout._shapeUpperLayer);\n    }\n    else if(options.xref === 'paper' || options.yref === 'paper') {\n        drawShape(gd._fullLayout._shapeLowerLayer);\n    }\n    else {\n        var plotinfo = gd._fullLayout._plots[options.xref + options.yref];\n        if(plotinfo) {\n            var mainPlot = plotinfo.mainplotinfo || plotinfo;\n            drawShape(mainPlot.shapelayer);\n        }\n        else {\n            // Fall back to _shapeLowerLayer in case the requested subplot doesn't exist.\n            // This can happen if you reference the shape to an x / y axis combination\n            // that doesn't have any data on it (and layer is below)\n            drawShape(gd._fullLayout._shapeLowerLayer);\n        }\n    }\n\n    function drawShape(shapeLayer) {\n        var attrs = {\n            'data-index': index,\n            'fill-rule': 'evenodd',\n            d: getPathString(gd, options)\n        };\n        var lineColor = options.line.width ? options.line.color : 'rgba(0,0,0,0)';\n\n        var path = shapeLayer.append('path')\n            .attr(attrs)\n            .style('opacity', options.opacity)\n            .call(Color.stroke, lineColor)\n            .call(Color.fill, options.fillcolor)\n            .call(Drawing.dashLine, options.line.dash, options.line.width);\n\n        setClipPath(path, gd, options);\n\n        if(gd._context.edits.shapePosition) setupDragElement(gd, path, options, index, shapeLayer);\n    }\n}\n\nfunction setClipPath(shapePath, gd, shapeOptions) {\n    // note that for layer=\"below\" the clipAxes can be different from the\n    // subplot we're drawing this in. This could cause problems if the shape\n    // spans two subplots. See https://github.com/plotly/plotly.js/issues/1452\n    var clipAxes = (shapeOptions.xref + shapeOptions.yref).replace(/paper/g, '');\n\n    Drawing.setClipUrl(\n        shapePath,\n        clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n        gd\n    );\n}\n\nfunction setupDragElement(gd, shapePath, shapeOptions, index, shapeLayer) {\n    var MINWIDTH = 10;\n    var MINHEIGHT = 10;\n\n    var xPixelSized = shapeOptions.xsizemode === 'pixel';\n    var yPixelSized = shapeOptions.ysizemode === 'pixel';\n    var isLine = shapeOptions.type === 'line';\n    var isPath = shapeOptions.type === 'path';\n\n    var editHelpers = arrayEditor(gd.layout, 'shapes', shapeOptions);\n    var modifyItem = editHelpers.modifyItem;\n\n    var x0, y0, x1, y1, xAnchor, yAnchor;\n    var n0, s0, w0, e0, optN, optS, optW, optE;\n    var pathIn;\n\n    // setup conversion functions\n    var xa = Axes.getFromId(gd, shapeOptions.xref);\n    var ya = Axes.getFromId(gd, shapeOptions.yref);\n    var x2p = helpers.getDataToPixel(gd, xa);\n    var y2p = helpers.getDataToPixel(gd, ya, true);\n    var p2x = helpers.getPixelToData(gd, xa);\n    var p2y = helpers.getPixelToData(gd, ya, true);\n\n    var sensoryElement = obtainSensoryElement();\n    var dragOptions = {\n        element: sensoryElement.node(),\n        gd: gd,\n        prepFn: startDrag,\n        doneFn: endDrag,\n        clickFn: abortDrag\n    };\n    var dragMode;\n\n    dragElement.init(dragOptions);\n\n    sensoryElement.node().onmousemove = updateDragMode;\n\n    function obtainSensoryElement() {\n        return isLine ? createLineDragHandles() : shapePath;\n    }\n\n    function createLineDragHandles() {\n        var minSensoryWidth = 10;\n        var sensoryWidth = Math.max(shapeOptions.line.width, minSensoryWidth);\n\n        // Helper shapes group\n        // Note that by setting the `data-index` attr, it is ensured that\n        // the helper group is purged in this modules `draw` function\n        var g = shapeLayer.append('g')\n          .attr('data-index', index);\n\n        // Helper path for moving\n        g.append('path')\n          .attr('d', shapePath.attr('d'))\n          .style({\n              'cursor': 'move',\n              'stroke-width': sensoryWidth,\n              'stroke-opacity': '0' // ensure not visible\n          });\n\n        // Helper circles for resizing\n        var circleStyle = {\n            'fill-opacity': '0' // ensure not visible\n        };\n        var circleRadius = sensoryWidth / 2 > minSensoryWidth ? sensoryWidth / 2 : minSensoryWidth;\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'start-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x0 : x2p(shapeOptions.x0),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y0 : y2p(shapeOptions.y0),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        g.append('circle')\n          .attr({\n              'data-line-point': 'end-point',\n              'cx': xPixelSized ? x2p(shapeOptions.xanchor) + shapeOptions.x1 : x2p(shapeOptions.x1),\n              'cy': yPixelSized ? y2p(shapeOptions.yanchor) - shapeOptions.y1 : y2p(shapeOptions.y1),\n              'r': circleRadius\n          })\n          .style(circleStyle)\n          .classed('cursor-grab', true);\n\n        return g;\n    }\n\n    function updateDragMode(evt) {\n        if(isLine) {\n            if(evt.target.tagName === 'path') {\n                dragMode = 'move';\n            } else {\n                dragMode = evt.target.attributes['data-line-point'].value === 'start-point' ?\n                  'resize-over-start-point' : 'resize-over-end-point';\n            }\n        } else {\n            // element might not be on screen at time of setup,\n            // so obtain bounding box here\n            var dragBBox = dragOptions.element.getBoundingClientRect();\n\n            // choose 'move' or 'resize'\n            // based on initial position of cursor within the drag element\n            var w = dragBBox.right - dragBBox.left;\n            var h = dragBBox.bottom - dragBBox.top;\n            var x = evt.clientX - dragBBox.left;\n            var y = evt.clientY - dragBBox.top;\n            var cursor = (!isPath && w > MINWIDTH && h > MINHEIGHT && !evt.shiftKey) ?\n                dragElement.getCursor(x / w, 1 - y / h) :\n                'move';\n\n            setCursor(shapePath, cursor);\n\n            // possible values 'move', 'sw', 'w', 'se', 'e', 'ne', 'n', 'nw' and 'w'\n            dragMode = cursor.split('-')[0];\n        }\n    }\n\n    function startDrag(evt) {\n        // setup update strings and initial values\n        if(xPixelSized) {\n            xAnchor = x2p(shapeOptions.xanchor);\n        }\n        if(yPixelSized) {\n            yAnchor = y2p(shapeOptions.yanchor);\n        }\n\n        if(shapeOptions.type === 'path') {\n            pathIn = shapeOptions.path;\n        }\n        else {\n            x0 = xPixelSized ? shapeOptions.x0 : x2p(shapeOptions.x0);\n            y0 = yPixelSized ? shapeOptions.y0 : y2p(shapeOptions.y0);\n            x1 = xPixelSized ? shapeOptions.x1 : x2p(shapeOptions.x1);\n            y1 = yPixelSized ? shapeOptions.y1 : y2p(shapeOptions.y1);\n        }\n\n        if(x0 < x1) {\n            w0 = x0;\n            optW = 'x0';\n            e0 = x1;\n            optE = 'x1';\n        }\n        else {\n            w0 = x1;\n            optW = 'x1';\n            e0 = x0;\n            optE = 'x0';\n        }\n\n        // For fixed size shapes take opposing direction of y-axis into account.\n        // Hint: For data sized shapes this is done by the y2p function.\n        if((!yPixelSized && y0 < y1) || (yPixelSized && y0 > y1)) {\n            n0 = y0;\n            optN = 'y0';\n            s0 = y1;\n            optS = 'y1';\n        }\n        else {\n            n0 = y1;\n            optN = 'y1';\n            s0 = y0;\n            optS = 'y0';\n        }\n\n        // setup dragMode and the corresponding handler\n        updateDragMode(evt);\n        renderVisualCues(shapeLayer, shapeOptions);\n        deactivateClipPathTemporarily(shapePath, shapeOptions, gd);\n        dragOptions.moveFn = (dragMode === 'move') ? moveShape : resizeShape;\n    }\n\n    function endDrag() {\n        setCursor(shapePath);\n        removeVisualCues(shapeLayer);\n\n        // Don't rely on clipPath being activated during re-layout\n        setClipPath(shapePath, gd, shapeOptions);\n        Registry.call('_guiRelayout', gd, editHelpers.getUpdateObj());\n    }\n\n    function abortDrag() {\n        removeVisualCues(shapeLayer);\n    }\n\n    function moveShape(dx, dy) {\n        if(shapeOptions.type === 'path') {\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        }\n        else {\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                modifyItem('x0', shapeOptions.x0 = p2x(x0 + dx));\n                modifyItem('x1', shapeOptions.x1 = p2x(x1 + dx));\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                modifyItem('y0', shapeOptions.y0 = p2y(y0 + dy));\n                modifyItem('y1', shapeOptions.y1 = p2y(y1 + dy));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function resizeShape(dx, dy) {\n        if(isPath) {\n            // TODO: implement path resize, don't forget to update dragMode code\n            var noOp = function(coord) { return coord; };\n            var moveX = noOp;\n            var moveY = noOp;\n\n            if(xPixelSized) {\n                modifyItem('xanchor', shapeOptions.xanchor = p2x(xAnchor + dx));\n            } else {\n                moveX = function moveX(x) { return p2x(x2p(x) + dx); };\n                if(xa && xa.type === 'date') moveX = helpers.encodeDate(moveX);\n            }\n\n            if(yPixelSized) {\n                modifyItem('yanchor', shapeOptions.yanchor = p2y(yAnchor + dy));\n            } else {\n                moveY = function moveY(y) { return p2y(y2p(y) + dy); };\n                if(ya && ya.type === 'date') moveY = helpers.encodeDate(moveY);\n            }\n\n            modifyItem('path', shapeOptions.path = movePath(pathIn, moveX, moveY));\n        }\n        else if(isLine) {\n            if(dragMode === 'resize-over-start-point') {\n                var newX0 = x0 + dx;\n                var newY0 = yPixelSized ? y0 - dy : y0 + dy;\n                modifyItem('x0', shapeOptions.x0 = xPixelSized ? newX0 : p2x(newX0));\n                modifyItem('y0', shapeOptions.y0 = yPixelSized ? newY0 : p2y(newY0));\n            } else if(dragMode === 'resize-over-end-point') {\n                var newX1 = x1 + dx;\n                var newY1 = yPixelSized ? y1 - dy : y1 + dy;\n                modifyItem('x1', shapeOptions.x1 = xPixelSized ? newX1 : p2x(newX1));\n                modifyItem('y1', shapeOptions.y1 = yPixelSized ? newY1 : p2y(newY1));\n            }\n        }\n        else {\n            var newN = (~dragMode.indexOf('n')) ? n0 + dy : n0;\n            var newS = (~dragMode.indexOf('s')) ? s0 + dy : s0;\n            var newW = (~dragMode.indexOf('w')) ? w0 + dx : w0;\n            var newE = (~dragMode.indexOf('e')) ? e0 + dx : e0;\n\n            // Do things in opposing direction for y-axis.\n            // Hint: for data-sized shapes the reversal of axis direction is done in p2y.\n            if(~dragMode.indexOf('n') && yPixelSized) newN = n0 - dy;\n            if(~dragMode.indexOf('s') && yPixelSized) newS = s0 - dy;\n\n            // Update shape eventually. Again, be aware of the\n            // opposing direction of the y-axis of fixed size shapes.\n            if((!yPixelSized && newS - newN > MINHEIGHT) ||\n              (yPixelSized && newN - newS > MINHEIGHT)) {\n                modifyItem(optN, shapeOptions[optN] = yPixelSized ? newN : p2y(newN));\n                modifyItem(optS, shapeOptions[optS] = yPixelSized ? newS : p2y(newS));\n            }\n            if(newE - newW > MINWIDTH) {\n                modifyItem(optW, shapeOptions[optW] = xPixelSized ? newW : p2x(newW));\n                modifyItem(optE, shapeOptions[optE] = xPixelSized ? newE : p2x(newE));\n            }\n        }\n\n        shapePath.attr('d', getPathString(gd, shapeOptions));\n        renderVisualCues(shapeLayer, shapeOptions);\n    }\n\n    function renderVisualCues(shapeLayer, shapeOptions) {\n        if(xPixelSized || yPixelSized) {\n            renderAnchor();\n        }\n\n        function renderAnchor() {\n            var isNotPath = shapeOptions.type !== 'path';\n\n            // d3 join with dummy data to satisfy d3 data-binding\n            var visualCues = shapeLayer.selectAll('.visual-cue').data([0]);\n\n            // Enter\n            var strokeWidth = 1;\n            visualCues.enter()\n              .append('path')\n              .attr({\n                  'fill': '#fff',\n                  'fill-rule': 'evenodd',\n                  'stroke': '#000',\n                  'stroke-width': strokeWidth\n              })\n              .classed('visual-cue', true);\n\n            // Update\n            var posX = x2p(\n              xPixelSized ?\n                shapeOptions.xanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.x0, shapeOptions.x1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsX))\n            );\n            var posY = y2p(\n              yPixelSized ?\n                shapeOptions.yanchor :\n                Lib.midRange(\n                  isNotPath ?\n                    [shapeOptions.y0, shapeOptions.y1] :\n                    helpers.extractPathCoords(shapeOptions.path, constants.paramIsY))\n            );\n\n            posX = helpers.roundPositionForSharpStrokeRendering(posX, strokeWidth);\n            posY = helpers.roundPositionForSharpStrokeRendering(posY, strokeWidth);\n\n            if(xPixelSized && yPixelSized) {\n                var crossPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h-8v2h8 v8h2v-8 h8v-2h-8 v-8h-2 Z';\n                visualCues.attr('d', crossPath);\n            } else if(xPixelSized) {\n                var vBarPath = 'M' + (posX - 1 - strokeWidth) + ',' + (posY - 9 - strokeWidth) +\n                  'v18 h2 v-18 Z';\n                visualCues.attr('d', vBarPath);\n            } else {\n                var hBarPath = 'M' + (posX - 9 - strokeWidth) + ',' + (posY - 1 - strokeWidth) +\n                  'h18 v2 h-18 Z';\n                visualCues.attr('d', hBarPath);\n            }\n        }\n    }\n\n    function removeVisualCues(shapeLayer) {\n        shapeLayer.selectAll('.visual-cue').remove();\n    }\n\n    function deactivateClipPathTemporarily(shapePath, shapeOptions, gd) {\n        var xref = shapeOptions.xref;\n        var yref = shapeOptions.yref;\n        var xa = Axes.getFromId(gd, xref);\n        var ya = Axes.getFromId(gd, yref);\n\n        var clipAxes = '';\n        if(xref !== 'paper' && !xa.autorange) clipAxes += xref;\n        if(yref !== 'paper' && !ya.autorange) clipAxes += yref;\n\n        Drawing.setClipUrl(\n            shapePath,\n            clipAxes ? 'clip' + gd._fullLayout._uid + clipAxes : null,\n            gd\n        );\n    }\n}\n\nfunction getPathString(gd, options) {\n    var type = options.type;\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n    var gs = gd._fullLayout._size;\n    var x2r, x2p, y2r, y2p;\n    var x0, x1, y0, y1;\n\n    if(xa) {\n        x2r = helpers.shapePositionToRange(xa);\n        x2p = function(v) { return xa._offset + xa.r2p(x2r(v, true)); };\n    }\n    else {\n        x2p = function(v) { return gs.l + gs.w * v; };\n    }\n\n    if(ya) {\n        y2r = helpers.shapePositionToRange(ya);\n        y2p = function(v) { return ya._offset + ya.r2p(y2r(v, true)); };\n    }\n    else {\n        y2p = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n\n    if(type === 'path') {\n        if(xa && xa.type === 'date') x2p = helpers.decodeDate(x2p);\n        if(ya && ya.type === 'date') y2p = helpers.decodeDate(y2p);\n        return convertPath(options, x2p, y2p);\n    }\n\n    if(options.xsizemode === 'pixel') {\n        var xAnchorPos = x2p(options.xanchor);\n        x0 = xAnchorPos + options.x0;\n        x1 = xAnchorPos + options.x1;\n    }\n    else {\n        x0 = x2p(options.x0);\n        x1 = x2p(options.x1);\n    }\n\n    if(options.ysizemode === 'pixel') {\n        var yAnchorPos = y2p(options.yanchor);\n        y0 = yAnchorPos - options.y0;\n        y1 = yAnchorPos - options.y1;\n    }\n    else {\n        y0 = y2p(options.y0);\n        y1 = y2p(options.y1);\n    }\n\n    if(type === 'line') return 'M' + x0 + ',' + y0 + 'L' + x1 + ',' + y1;\n    if(type === 'rect') return 'M' + x0 + ',' + y0 + 'H' + x1 + 'V' + y1 + 'H' + x0 + 'Z';\n\n    // circle\n    var cx = (x0 + x1) / 2;\n    var cy = (y0 + y1) / 2;\n    var rx = Math.abs(cx - x0);\n    var ry = Math.abs(cy - y0);\n    var rArc = 'A' + rx + ',' + ry;\n    var rightPt = (cx + rx) + ',' + cy;\n    var topPt = cx + ',' + (cy - ry);\n    return 'M' + rightPt + rArc + ' 0 1,1 ' + topPt +\n        rArc + ' 0 0,1 ' + rightPt + 'Z';\n}\n\n\nfunction convertPath(options, x2p, y2p) {\n    var pathIn = options.path;\n    var xSizemode = options.xsizemode;\n    var ySizemode = options.ysizemode;\n    var xAnchor = options.xanchor;\n    var yAnchor = options.yanchor;\n\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(xParams[paramNumber]) {\n                if(xSizemode === 'pixel') param = x2p(xAnchor) + Number(param);\n                else param = x2p(param);\n            }\n            else if(yParams[paramNumber]) {\n                if(ySizemode === 'pixel') param = y2p(yAnchor) - Number(param);\n                else param = y2p(param);\n            }\n            paramNumber++;\n\n            if(paramNumber > nParams) param = 'X';\n            return param;\n        });\n\n        if(paramNumber > nParams) {\n            paramString = paramString.replace(/[\\s,]*X.*/, '');\n            Lib.log('Ignoring extra params in segment ' + segment);\n        }\n\n        return segmentType + paramString;\n    });\n}\n\nfunction movePath(pathIn, moveX, moveY) {\n    return pathIn.replace(constants.segmentRE, function(segment) {\n        var paramNumber = 0;\n        var segmentType = segment.charAt(0);\n        var xParams = constants.paramIsX[segmentType];\n        var yParams = constants.paramIsY[segmentType];\n        var nParams = constants.numParams[segmentType];\n\n        var paramString = segment.substr(1).replace(constants.paramRE, function(param) {\n            if(paramNumber >= nParams) return param;\n\n            if(xParams[paramNumber]) param = moveX(param);\n            else if(yParams[paramNumber]) param = moveY(param);\n\n            paramNumber++;\n\n            return param;\n        });\n\n        return segmentType + paramString;\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}