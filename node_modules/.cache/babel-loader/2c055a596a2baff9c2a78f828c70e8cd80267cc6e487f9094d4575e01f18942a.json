{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = Sieve;\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n * @param {Array}   traces\n *                  Array of calculated traces\n * @param {boolean} [separateNegativeValues]\n *                  If true, then split data at the same position into a bar\n *                  for positive values and another for negative values\n * @param {boolean} [dontMergeOverlappingData]\n *                  If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {\n  this.traces = traces;\n  this.separateNegativeValues = separateNegativeValues;\n  this.dontMergeOverlappingData = dontMergeOverlappingData;\n\n  // for single-bin histograms - see histogram/calc\n  var width1 = Infinity;\n  var positions = [];\n  for (var i = 0; i < traces.length; i++) {\n    var trace = traces[i];\n    for (var j = 0; j < trace.length; j++) {\n      var bar = trace[j];\n      if (bar.p !== BADNUM) positions.push(bar.p);\n    }\n    if (trace[0] && trace[0].width1) {\n      width1 = Math.min(trace[0].width1, width1);\n    }\n  }\n  this.positions = positions;\n  var dv = Lib.distinctVals(positions);\n  this.distinctPositions = dv.vals;\n  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);\n  this.binWidth = this.minDiff;\n  this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n  var label = this.getLabel(position, value);\n  var oldValue = this.bins[label] || 0;\n  this.bins[label] = oldValue + value;\n  return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function put(position, value) {\n  var label = this.getLabel(position, value);\n  return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.separateNegativeValues is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n  var prefix = value < 0 && this.separateNegativeValues ? 'v' : '^';\n  var label = this.dontMergeOverlappingData ? position : Math.round(position / this.binWidth);\n  return prefix + label;\n};","map":{"version":3,"names":["module","exports","Sieve","Lib","require","BADNUM","traces","separateNegativeValues","dontMergeOverlappingData","width1","Infinity","positions","i","length","trace","j","bar","p","push","Math","min","dv","distinctVals","distinctPositions","vals","minDiff","binWidth","bins","prototype","put","position","value","label","getLabel","oldValue","get","prefix","round"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/bar/sieve.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nmodule.exports = Sieve;\n\nvar Lib = require('../../lib');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\n/**\n * Helper class to sieve data from traces into bins\n *\n * @class\n * @param {Array}   traces\n *                  Array of calculated traces\n * @param {boolean} [separateNegativeValues]\n *                  If true, then split data at the same position into a bar\n *                  for positive values and another for negative values\n * @param {boolean} [dontMergeOverlappingData]\n *                  If true, then don't merge overlapping bars into a single bar\n */\nfunction Sieve(traces, separateNegativeValues, dontMergeOverlappingData) {\n    this.traces = traces;\n    this.separateNegativeValues = separateNegativeValues;\n    this.dontMergeOverlappingData = dontMergeOverlappingData;\n\n    // for single-bin histograms - see histogram/calc\n    var width1 = Infinity;\n\n    var positions = [];\n    for(var i = 0; i < traces.length; i++) {\n        var trace = traces[i];\n        for(var j = 0; j < trace.length; j++) {\n            var bar = trace[j];\n            if(bar.p !== BADNUM) positions.push(bar.p);\n        }\n        if(trace[0] && trace[0].width1) {\n            width1 = Math.min(trace[0].width1, width1);\n        }\n    }\n    this.positions = positions;\n\n    var dv = Lib.distinctVals(positions);\n    this.distinctPositions = dv.vals;\n    if(dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;\n    else this.minDiff = Math.min(dv.minDiff, width1);\n\n    this.binWidth = this.minDiff;\n\n    this.bins = {};\n}\n\n/**\n * Sieve datum\n *\n * @method\n * @param {number} position\n * @param {number} value\n * @returns {number} Previous bin value\n */\nSieve.prototype.put = function put(position, value) {\n    var label = this.getLabel(position, value);\n    var oldValue = this.bins[label] || 0;\n\n    this.bins[label] = oldValue + value;\n\n    return oldValue;\n};\n\n/**\n * Get current bin value for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {number} Current bin value\n */\nSieve.prototype.get = function put(position, value) {\n    var label = this.getLabel(position, value);\n    return this.bins[label] || 0;\n};\n\n/**\n * Get bin label for a given datum\n *\n * @method\n * @param {number} position  Position of datum\n * @param {number} [value]   Value of datum\n *                           (required if this.separateNegativeValues is true)\n * @returns {string} Bin label\n * (prefixed with a 'v' if value is negative and this.separateNegativeValues is\n * true; otherwise prefixed with '^')\n */\nSieve.prototype.getLabel = function getLabel(position, value) {\n    var prefix = (value < 0 && this.separateNegativeValues) ? 'v' : '^';\n    var label = (this.dontMergeOverlappingData) ?\n        position :\n        Math.round(position / this.binWidth);\n    return prefix + label;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}