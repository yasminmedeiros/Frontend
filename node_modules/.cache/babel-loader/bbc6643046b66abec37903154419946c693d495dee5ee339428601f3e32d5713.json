{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillHoverText = require('../scatter/fill_hover_text');\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var hoveron = trace.hoveron;\n  var closeBoxData = [];\n  var closePtData;\n  if (hoveron.indexOf('boxes') !== -1) {\n    closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n  }\n  if (hoveron.indexOf('points') !== -1) {\n    closePtData = hoverOnPoints(pointData, xval, yval);\n  }\n\n  // If there's a point in range and hoveron has points, show the best single point only.\n  // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n  if (hovermode === 'closest') {\n    if (closePtData) return [closePtData];\n    return closeBoxData;\n  }\n\n  // Otherwise in compare mode, allow a point AND the box stats to be labeled\n  // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n  if (closePtData) {\n    closeBoxData.push(closePtData);\n    return closeBoxData;\n  }\n  return closeBoxData;\n}\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isViolin = trace.type === 'violin';\n  var closeBoxData = [];\n  var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos, hoverPseudoDistance, spikePseudoDistance;\n  var boxDelta = t.bdPos;\n  var posAcceptance = t.wHover;\n  var shiftPos = function shiftPos(di) {\n    return di.pos + t.bPos - pVal;\n  };\n  if (isViolin && trace.side !== 'both') {\n    if (trace.side === 'positive') {\n      dPos = function dPos(di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n      };\n    }\n    if (trace.side === 'negative') {\n      dPos = function dPos(di) {\n        var pos = shiftPos(di);\n        return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n      };\n    }\n  } else {\n    dPos = function dPos(di) {\n      var pos = shiftPos(di);\n      return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n    };\n  }\n  var dVal;\n  if (isViolin) {\n    dVal = function dVal(di) {\n      return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n    };\n  } else {\n    dVal = function dVal(di) {\n      return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n    };\n  }\n  if (trace.orientation === 'h') {\n    vVal = xval;\n    pVal = yval;\n    dx = dVal;\n    dy = dPos;\n    pLetter = 'y';\n    pAxis = ya;\n    vLetter = 'x';\n    vAxis = xa;\n  } else {\n    vVal = yval;\n    pVal = xval;\n    dx = dPos;\n    dy = dVal;\n    pLetter = 'x';\n    pAxis = xa;\n    vLetter = 'y';\n    vAxis = ya;\n  }\n\n  // if two boxes are overlaying, let the narrowest one win\n  var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n  hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n  spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n\n  // skip the rest (for this trace) if we didn't find a close point\n  // and create the item(s) in closedata for this point\n  if (pointData.index === false) return [];\n  var di = cd[pointData.index];\n  var lc = trace.line.color;\n  var mc = (trace.marker || {}).color;\n  if (Color.opacity(lc) && trace.line.width) pointData.color = lc;else if (Color.opacity(mc) && trace.boxpoints) pointData.color = mc;else pointData.color = trace.fillcolor;\n  pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDelta, true);\n  pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDelta, true);\n  pointData[pLetter + 'LabelVal'] = di.pos;\n  var spikePosAttr = pLetter + 'Spike';\n  pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n  pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n\n  // box plots: each \"point\" gets many labels\n  var usedVals = {};\n  var attrs = ['med', 'min', 'q1', 'q3', 'max'];\n  if (trace.boxmean || (trace.meanline || {}).visible) {\n    attrs.push('mean');\n  }\n  if (trace.boxpoints || trace.points) {\n    attrs.push('lf', 'uf');\n  }\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (!(attr in di) || di[attr] in usedVals) continue;\n    usedVals[di[attr]] = true;\n\n    // copy out to a new object for each value to label\n    var val = di[attr];\n    var valPx = vAxis.c2p(val, true);\n    var pointData2 = Lib.extendFlat({}, pointData);\n    pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n    pointData2[vLetter + 'LabelVal'] = val;\n    pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val);\n\n    // Note: introduced to be able to distinguish a\n    // clicked point from a box during click-to-select\n    pointData2.hoverOnBox = true;\n    if (attr === 'mean' && 'sd' in di && trace.boxmean === 'sd') {\n      pointData2[vLetter + 'err'] = di.sd;\n    }\n    // only keep name and spikes on the first item (median)\n    pointData.name = '';\n    pointData.spikeDistance = undefined;\n    pointData[spikePosAttr] = undefined;\n    closeBoxData.push(pointData2);\n  }\n  return closeBoxData;\n}\nfunction hoverOnPoints(pointData, xval, yval) {\n  var cd = pointData.cd;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var trace = cd[0].trace;\n  var xPx = xa.c2p(xval);\n  var yPx = ya.c2p(yval);\n  var closePtData;\n  var dx = function dx(di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n  };\n  var dy = function dy(di) {\n    var rad = Math.max(3, di.mrc || 0);\n    return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n  };\n  var distfn = Fx.quadrature(dx, dy);\n\n  // show one point per trace\n  var ijClosest = false;\n  var di, pt;\n  for (var i = 0; i < cd.length; i++) {\n    di = cd[i];\n    for (var j = 0; j < (di.pts || []).length; j++) {\n      pt = di.pts[j];\n      var newDistance = distfn(pt);\n      if (newDistance <= pointData.distance) {\n        pointData.distance = newDistance;\n        ijClosest = [i, j];\n      }\n    }\n  }\n  if (!ijClosest) return false;\n  di = cd[ijClosest[0]];\n  pt = di.pts[ijClosest[1]];\n  var xc = xa.c2p(pt.x, true);\n  var yc = ya.c2p(pt.y, true);\n  var rad = pt.mrc || 1;\n  closePtData = Lib.extendFlat({}, pointData, {\n    // corresponds to index in x/y input data array\n    index: pt.i,\n    color: (trace.marker || {}).color,\n    name: trace.name,\n    x0: xc - rad,\n    x1: xc + rad,\n    y0: yc - rad,\n    y1: yc + rad,\n    spikeDistance: pointData.distance\n  });\n  var pa;\n  if (trace.orientation === 'h') {\n    pa = ya;\n    closePtData.xLabelVal = pt.x;\n    closePtData.yLabelVal = di.pos;\n  } else {\n    pa = xa;\n    closePtData.xLabelVal = di.pos;\n    closePtData.yLabelVal = pt.y;\n  }\n  var pLetter = pa._id.charAt(0);\n  closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n  fillHoverText(pt, trace, closePtData);\n  return closePtData;\n}\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBoxes: hoverOnBoxes,\n  hoverOnPoints: hoverOnPoints\n};","map":{"version":3,"names":["Axes","require","Lib","Fx","Color","fillHoverText","hoverPoints","pointData","xval","yval","hovermode","cd","trace","hoveron","closeBoxData","closePtData","indexOf","concat","hoverOnBoxes","hoverOnPoints","push","xa","ya","t","isViolin","type","pLetter","vLetter","pAxis","vAxis","vVal","pVal","dx","dy","dPos","hoverPseudoDistance","spikePseudoDistance","boxDelta","bdPos","posAcceptance","wHover","shiftPos","di","pos","bPos","side","inbox","dVal","span","min","max","orientation","pseudoDistance","Math","abs","r2c","range","maxHoverDistance","maxSpikeDistance","dxy","distfn","getDistanceFunction","getClosest","index","lc","line","color","mc","marker","opacity","width","boxpoints","fillcolor","c2p","spikePosAttr","spikeDistance","usedVals","attrs","boxmean","meanline","visible","points","i","length","attr","val","valPx","pointData2","extendFlat","labels","hoverLabelText","hoverOnBox","sd","name","undefined","xPx","yPx","rad","mrc","x","y","quadrature","ijClosest","pt","j","pts","newDistance","distance","xc","yc","x0","x1","y0","y1","pa","xLabelVal","yLabelVal","_id","charAt","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/box/hover.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Axes = require('../../plots/cartesian/axes');\nvar Lib = require('../../lib');\nvar Fx = require('../../components/fx');\nvar Color = require('../../components/color');\nvar fillHoverText = require('../scatter/fill_hover_text');\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var hoveron = trace.hoveron;\n    var closeBoxData = [];\n    var closePtData;\n\n    if(hoveron.indexOf('boxes') !== -1) {\n        closeBoxData = closeBoxData.concat(hoverOnBoxes(pointData, xval, yval, hovermode));\n    }\n\n    if(hoveron.indexOf('points') !== -1) {\n        closePtData = hoverOnPoints(pointData, xval, yval);\n    }\n\n    // If there's a point in range and hoveron has points, show the best single point only.\n    // If hoveron has boxes and there's no point in range (or hoveron doesn't have points), show the box stats.\n    if(hovermode === 'closest') {\n        if(closePtData) return [closePtData];\n        return closeBoxData;\n    }\n\n    // Otherwise in compare mode, allow a point AND the box stats to be labeled\n    // If there are multiple boxes in range (ie boxmode = 'overlay') we'll see stats for all of them.\n    if(closePtData) {\n        closeBoxData.push(closePtData);\n        return closeBoxData;\n    }\n    return closeBoxData;\n}\n\nfunction hoverOnBoxes(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isViolin = trace.type === 'violin';\n    var closeBoxData = [];\n\n    var pLetter, vLetter, pAxis, vAxis, vVal, pVal, dx, dy, dPos,\n        hoverPseudoDistance, spikePseudoDistance;\n\n    var boxDelta = t.bdPos;\n    var posAcceptance = t.wHover;\n    var shiftPos = function(di) { return di.pos + t.bPos - pVal; };\n\n    if(isViolin && trace.side !== 'both') {\n        if(trace.side === 'positive') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos, pos + posAcceptance, hoverPseudoDistance);\n            };\n        }\n        if(trace.side === 'negative') {\n            dPos = function(di) {\n                var pos = shiftPos(di);\n                return Fx.inbox(pos - posAcceptance, pos, hoverPseudoDistance);\n            };\n        }\n    } else {\n        dPos = function(di) {\n            var pos = shiftPos(di);\n            return Fx.inbox(pos - posAcceptance, pos + posAcceptance, hoverPseudoDistance);\n        };\n    }\n\n    var dVal;\n\n    if(isViolin) {\n        dVal = function(di) {\n            return Fx.inbox(di.span[0] - vVal, di.span[1] - vVal, hoverPseudoDistance);\n        };\n    } else {\n        dVal = function(di) {\n            return Fx.inbox(di.min - vVal, di.max - vVal, hoverPseudoDistance);\n        };\n    }\n\n    if(trace.orientation === 'h') {\n        vVal = xval;\n        pVal = yval;\n        dx = dVal;\n        dy = dPos;\n        pLetter = 'y';\n        pAxis = ya;\n        vLetter = 'x';\n        vAxis = xa;\n    } else {\n        vVal = yval;\n        pVal = xval;\n        dx = dPos;\n        dy = dVal;\n        pLetter = 'x';\n        pAxis = xa;\n        vLetter = 'y';\n        vAxis = ya;\n    }\n\n    // if two boxes are overlaying, let the narrowest one win\n    var pseudoDistance = Math.min(1, boxDelta / Math.abs(pAxis.r2c(pAxis.range[1]) - pAxis.r2c(pAxis.range[0])));\n    hoverPseudoDistance = pointData.maxHoverDistance - pseudoDistance;\n    spikePseudoDistance = pointData.maxSpikeDistance - pseudoDistance;\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    // and create the item(s) in closedata for this point\n    if(pointData.index === false) return [];\n\n    var di = cd[pointData.index];\n    var lc = trace.line.color;\n    var mc = (trace.marker || {}).color;\n\n    if(Color.opacity(lc) && trace.line.width) pointData.color = lc;\n    else if(Color.opacity(mc) && trace.boxpoints) pointData.color = mc;\n    else pointData.color = trace.fillcolor;\n\n    pointData[pLetter + '0'] = pAxis.c2p(di.pos + t.bPos - boxDelta, true);\n    pointData[pLetter + '1'] = pAxis.c2p(di.pos + t.bPos + boxDelta, true);\n\n    pointData[pLetter + 'LabelVal'] = di.pos;\n\n    var spikePosAttr = pLetter + 'Spike';\n    pointData.spikeDistance = dxy(di) * spikePseudoDistance / hoverPseudoDistance;\n    pointData[spikePosAttr] = pAxis.c2p(di.pos, true);\n\n    // box plots: each \"point\" gets many labels\n    var usedVals = {};\n    var attrs = ['med', 'min', 'q1', 'q3', 'max'];\n\n    if(trace.boxmean || (trace.meanline || {}).visible) {\n        attrs.push('mean');\n    }\n    if(trace.boxpoints || trace.points) {\n        attrs.push('lf', 'uf');\n    }\n\n    for(var i = 0; i < attrs.length; i++) {\n        var attr = attrs[i];\n\n        if(!(attr in di) || (di[attr] in usedVals)) continue;\n        usedVals[di[attr]] = true;\n\n        // copy out to a new object for each value to label\n        var val = di[attr];\n        var valPx = vAxis.c2p(val, true);\n        var pointData2 = Lib.extendFlat({}, pointData);\n\n        pointData2[vLetter + '0'] = pointData2[vLetter + '1'] = valPx;\n        pointData2[vLetter + 'LabelVal'] = val;\n        pointData2[vLetter + 'Label'] = (t.labels ? t.labels[attr] + ' ' : '') + Axes.hoverLabelText(vAxis, val);\n\n        // Note: introduced to be able to distinguish a\n        // clicked point from a box during click-to-select\n        pointData2.hoverOnBox = true;\n\n        if(attr === 'mean' && ('sd' in di) && trace.boxmean === 'sd') {\n            pointData2[vLetter + 'err'] = di.sd;\n        }\n        // only keep name and spikes on the first item (median)\n        pointData.name = '';\n        pointData.spikeDistance = undefined;\n        pointData[spikePosAttr] = undefined;\n\n        closeBoxData.push(pointData2);\n    }\n\n    return closeBoxData;\n}\n\nfunction hoverOnPoints(pointData, xval, yval) {\n    var cd = pointData.cd;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var trace = cd[0].trace;\n    var xPx = xa.c2p(xval);\n    var yPx = ya.c2p(yval);\n    var closePtData;\n\n    var dx = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(xa.c2p(di.x) - xPx) - rad, 1 - 3 / rad);\n    };\n    var dy = function(di) {\n        var rad = Math.max(3, di.mrc || 0);\n        return Math.max(Math.abs(ya.c2p(di.y) - yPx) - rad, 1 - 3 / rad);\n    };\n    var distfn = Fx.quadrature(dx, dy);\n\n    // show one point per trace\n    var ijClosest = false;\n    var di, pt;\n\n    for(var i = 0; i < cd.length; i++) {\n        di = cd[i];\n\n        for(var j = 0; j < (di.pts || []).length; j++) {\n            pt = di.pts[j];\n\n            var newDistance = distfn(pt);\n            if(newDistance <= pointData.distance) {\n                pointData.distance = newDistance;\n                ijClosest = [i, j];\n            }\n        }\n    }\n\n    if(!ijClosest) return false;\n\n    di = cd[ijClosest[0]];\n    pt = di.pts[ijClosest[1]];\n\n    var xc = xa.c2p(pt.x, true);\n    var yc = ya.c2p(pt.y, true);\n    var rad = pt.mrc || 1;\n\n    closePtData = Lib.extendFlat({}, pointData, {\n        // corresponds to index in x/y input data array\n        index: pt.i,\n        color: (trace.marker || {}).color,\n        name: trace.name,\n        x0: xc - rad,\n        x1: xc + rad,\n        y0: yc - rad,\n        y1: yc + rad,\n        spikeDistance: pointData.distance\n    });\n\n    var pa;\n    if(trace.orientation === 'h') {\n        pa = ya;\n        closePtData.xLabelVal = pt.x;\n        closePtData.yLabelVal = di.pos;\n    } else {\n        pa = xa;\n        closePtData.xLabelVal = di.pos;\n        closePtData.yLabelVal = pt.y;\n    }\n\n    var pLetter = pa._id.charAt(0);\n    closePtData[pLetter + 'Spike'] = pa.c2p(di.pos, true);\n\n    fillHoverText(pt, trace, closePtData);\n\n    return closePtData;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverOnBoxes: hoverOnBoxes,\n    hoverOnPoints: hoverOnPoints\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}