{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\nvar constants = require('../../constants/numerical');\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEDAY = constants.ONEDAY;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar LINE_SPACING = require('../../constants/alignment').LINE_SPACING;\nvar axes = module.exports = {};\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\nvar axisIds = require('./axis_ids');\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function (containerIn, containerOut, gd, attr, dflt, extraOption) {\n  var axLetter = attr.charAt(attr.length - 1);\n  var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n  var refAttr = attr + 'ref';\n  var attrDef = {};\n  if (!dflt) dflt = axlist[0] || extraOption;\n  if (!extraOption) extraOption = dflt;\n\n  // data-ref annotations are not supported in gl2d yet\n\n  attrDef[refAttr] = {\n    valType: 'enumerated',\n    values: axlist.concat(extraOption ? [extraOption] : []),\n    dflt: dflt\n  };\n\n  // xref, yref\n  return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function (containerOut, gd, coerce, axRef, attr, dflt) {\n  var cleanPos, pos;\n  if (axRef === 'paper' || axRef === 'pixel') {\n    cleanPos = Lib.ensureNumber;\n    pos = coerce(attr, dflt);\n  } else {\n    var ax = axes.getFromId(gd, axRef);\n    dflt = ax.fraction2r(dflt);\n    pos = coerce(attr, dflt);\n    cleanPos = ax.cleanPos;\n  }\n  containerOut[attr] = cleanPos(pos);\n};\naxes.cleanPosition = function (pos, gd, axRef) {\n  var cleanPos = axRef === 'paper' || axRef === 'pixel' ? Lib.ensureNumber : axes.getFromId(gd, axRef).cleanPos;\n  return cleanPos(pos);\n};\naxes.redrawComponents = function (gd, axIds) {\n  axIds = axIds ? axIds : axes.listIds(gd);\n  var fullLayout = gd._fullLayout;\n  function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n    var method = Registry.getComponentMethod(moduleName, methodName);\n    var stash = {};\n    for (var i = 0; i < axIds.length; i++) {\n      var ax = fullLayout[axes.id2name(axIds[i])];\n      var indices = ax[stashName];\n      for (var j = 0; j < indices.length; j++) {\n        var ind = indices[j];\n        if (!stash[ind]) {\n          method(gd, ind);\n          stash[ind] = 1;\n          // once is enough for images (which doesn't use the `i` arg anyway)\n          if (shortCircuit) return;\n        }\n      }\n    }\n  }\n\n  // annotations and shapes 'draw' method is slow,\n  // use the finer-grained 'drawOne' method instead\n  _redrawOneComp('annotations', 'drawOne', '_annIndices');\n  _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n  _redrawOneComp('images', 'draw', '_imgIndices', true);\n};\nvar getDataConversions = axes.getDataConversions = function (gd, trace, target, targetArray) {\n  var ax;\n\n  // If target points to an axis, use the type we already have for that\n  // axis to find the data type. Otherwise use the values to autotype.\n  var d2cTarget = target === 'x' || target === 'y' || target === 'z' ? target : targetArray;\n\n  // In the case of an array target, make a mock data array\n  // and call supplyDefaults to the data type and\n  // setup the data-to-calc method.\n  if (Array.isArray(d2cTarget)) {\n    ax = {\n      type: autoType(targetArray),\n      _categories: []\n    };\n    axes.setConvert(ax);\n\n    // build up ax._categories (usually done during ax.makeCalcdata()\n    if (ax.type === 'category') {\n      for (var i = 0; i < targetArray.length; i++) {\n        ax.d2c(targetArray[i]);\n      }\n    }\n    // TODO what to do for transforms?\n  } else {\n    ax = axes.getFromTrace(gd, trace, d2cTarget);\n  }\n\n  // if 'target' has corresponding axis\n  // -> use setConvert method\n  if (ax) return {\n    d2c: ax.d2c,\n    c2d: ax.c2d\n  };\n\n  // special case for 'ids'\n  // -> cast to String\n  if (d2cTarget === 'ids') return {\n    d2c: toString,\n    c2d: toString\n  };\n\n  // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n  // -> cast to Number\n\n  return {\n    d2c: toNum,\n    c2d: toNum\n  };\n};\nfunction toNum(v) {\n  return +v;\n}\nfunction toString(v) {\n  return String(v);\n}\naxes.getDataToCoordFunc = function (gd, trace, target, targetArray) {\n  return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function (id) {\n  var axLetter = id.charAt(0);\n  if (axLetter === 'x') return 'y';\n  if (axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function (ax, newDiff, newFirst, allow) {\n  // doesn't make sense to do forced min dTick on log or category axes,\n  // and the plot itself may decide to cancel (ie non-grouped bars)\n  if (['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n    ax._minDtick = 0;\n  }\n  // undefined means there's nothing there yet\n  else if (ax._minDtick === undefined) {\n    ax._minDtick = newDiff;\n    ax._forceTick0 = newFirst;\n  } else if (ax._minDtick) {\n    // existing minDtick is an integer multiple of newDiff\n    // (within rounding err)\n    // and forceTick0 can be shifted to newFirst\n    if ((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 && ((newFirst - ax._forceTick0) / newDiff % 1 + 1.000001) % 1 < 2e-6) {\n      ax._minDtick = newDiff;\n      ax._forceTick0 = newFirst;\n    }\n    // if the converse is true (newDiff is a multiple of minDtick and\n    // newFirst can be shifted to forceTick0) then do nothing - same\n    // forcing stands. Otherwise, cancel forced minimum\n    else if ((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 || ((newFirst - ax._forceTick0) / ax._minDtick % 1 + 1.000001) % 1 > 2e-6) {\n      ax._minDtick = 0;\n    }\n  }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._rangeInitial === undefined;\n    var hasChanged = isNew || !(ax.range[0] === ax._rangeInitial[0] && ax.range[1] === ax._rangeInitial[1]);\n    if (isNew && ax.autorange === false || overwrite && hasChanged) {\n      ax._rangeInitial = ax.range.slice();\n      hasOneAxisChanged = true;\n    }\n  }\n  return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function (gd, overwrite) {\n  var axList = axes.list(gd, '', true);\n  var hasOneAxisChanged = false;\n  var allSpikesEnabled = 'on';\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    var isNew = ax._showSpikeInitial === undefined;\n    var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n    if (isNew || overwrite && hasChanged) {\n      ax._showSpikeInitial = ax.showspikes;\n      hasOneAxisChanged = true;\n    }\n    if (allSpikesEnabled === 'on' && !ax.showspikes) {\n      allSpikesEnabled = 'off';\n    }\n  }\n  gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n  return hasOneAxisChanged;\n};\naxes.autoBin = function (data, ax, nbins, is2d, calendar, size) {\n  var dataMin = Lib.aggNums(Math.min, null, data);\n  var dataMax = Lib.aggNums(Math.max, null, data);\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    return {\n      start: dataMin - 0.5,\n      end: dataMax + 0.5,\n      size: Math.max(1, Math.round(size) || 1),\n      _dataSpan: dataMax - dataMin\n    };\n  }\n  if (!calendar) calendar = ax.calendar;\n\n  // piggyback off tick code to make \"nice\" bin sizes and edges\n  var dummyAx;\n  if (ax.type === 'log') {\n    dummyAx = {\n      type: 'linear',\n      range: [dataMin, dataMax]\n    };\n  } else {\n    dummyAx = {\n      type: ax.type,\n      range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n      calendar: calendar\n    };\n  }\n  axes.setConvert(dummyAx);\n  size = size && cleanTicks.dtick(size, dummyAx.type);\n  if (size) {\n    dummyAx.dtick = size;\n    dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n  } else {\n    var size0;\n    if (nbins) size0 = (dataMax - dataMin) / nbins;else {\n      // totally auto: scale off std deviation so the highest bin is\n      // somewhat taller than the total number of bins, but don't let\n      // the size get smaller than the 'nice' rounded down minimum\n      // difference between values\n      var distinctData = Lib.distinctVals(data);\n      var msexp = Math.pow(10, Math.floor(Math.log(distinctData.minDiff) / Math.LN10));\n      var minSize = msexp * Lib.roundUp(distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n      size0 = Math.max(minSize, 2 * Lib.stdev(data) / Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n      // fallback if ax.d2c output BADNUMs\n      // e.g. when user try to plot categorical bins\n      // on a layout.xaxis.type: 'linear'\n      if (!isNumeric(size0)) size0 = 1;\n    }\n    axes.autoTicks(dummyAx, size0);\n  }\n  var finalSize = dummyAx.dtick;\n  var binStart = axes.tickIncrement(axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n  var binEnd, bincount;\n\n  // check for too many data points right at the edges of bins\n  // (>50% within 1% of bin edges) or all data points integral\n  // and offset the bins accordingly\n  if (typeof finalSize === 'number') {\n    binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n    bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n    binEnd = binStart + bincount * finalSize;\n  } else {\n    // month ticks - should be the only nonlinear kind we have at this point.\n    // dtick (as supplied by axes.autoTick) only has nonlinear values on\n    // date and log axes, but even if you display a histogram on a log axis\n    // we bin it on a linear axis (which one could argue against, but that's\n    // a separate issue)\n    if (dummyAx.dtick.charAt(0) === 'M') {\n      binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n    }\n\n    // calculate the endpoint for nonlinear ticks - you have to\n    // just increment until you're done\n    binEnd = binStart;\n    bincount = 0;\n    while (binEnd <= dataMax) {\n      binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n      bincount++;\n    }\n  }\n  return {\n    start: ax.c2r(binStart, 0, calendar),\n    end: ax.c2r(binEnd, 0, calendar),\n    size: finalSize,\n    _dataSpan: dataMax - dataMin\n  };\n};\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n  var edgecount = 0;\n  var midcount = 0;\n  var intcount = 0;\n  var blankCount = 0;\n  function nearEdge(v) {\n    // is a value within 1% of a bin edge?\n    return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n  }\n  for (var i = 0; i < data.length; i++) {\n    if (data[i] % 1 === 0) intcount++;else if (!isNumeric(data[i])) blankCount++;\n    if (nearEdge(data[i])) edgecount++;\n    if (nearEdge(data[i] + ax.dtick / 2)) midcount++;\n  }\n  var dataCount = data.length - blankCount;\n  if (intcount === dataCount && ax.type !== 'date') {\n    // all integers: if bin size is <1, it's because\n    // that was specifically requested (large nbins)\n    // so respect that... but center the bins containing\n    // integers on those integers\n    if (ax.dtick < 1) {\n      binStart = dataMin - 0.5 * ax.dtick;\n    }\n    // otherwise start half an integer down regardless of\n    // the bin size, just enough to clear up endpoint\n    // ambiguity about which integers are in which bins.\n    else {\n      binStart -= 0.5;\n      if (binStart + ax.dtick < dataMin) binStart += ax.dtick;\n    }\n  } else if (midcount < dataCount * 0.1) {\n    if (edgecount > dataCount * 0.3 || nearEdge(dataMin) || nearEdge(dataMax)) {\n      // lots of points at the edge, not many in the middle\n      // shift half a bin\n      var binshift = ax.dtick / 2;\n      binStart += binStart + binshift < dataMin ? binshift : -binshift;\n    }\n  }\n  return binStart;\n}\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n  var stats = Lib.findExactDates(data, calendar);\n  // number of data points that needs to be an exact value\n  // to shift that increment to (near) the bin center\n  var threshold = 0.8;\n  if (stats.exactDays > threshold) {\n    var numMonths = Number(dtick.substr(1));\n    if (stats.exactYears > threshold && numMonths % 12 === 0) {\n      // The exact middle of a non-leap-year is 1.5 days into July\n      // so if we start the bins here, all but leap years will\n      // get hover-labeled as exact years.\n      binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n    } else if (stats.exactMonths > threshold) {\n      // Months are not as clean, but if we shift half the *longest*\n      // month (31/2 days) then 31-day months will get labeled exactly\n      // and shorter months will get labeled with the correct month\n      // but shifted 12-36 hours into it.\n      binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n    } else {\n      // Shifting half a day is exact, but since these are month bins it\n      // will always give a somewhat odd-looking label, until we do something\n      // smarter like showing the bin boundaries (or the bounds of the actual\n      // data in each bin)\n      binStart -= ONEDAY / 2;\n    }\n    var nextBinStart = axes.tickIncrement(binStart, dtick);\n    if (nextBinStart <= dataMin) return nextBinStart;\n  }\n  return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function (ax) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n  // calculate max number of (auto) ticks to display based on plot size\n  if (ax.tickmode === 'auto' || !ax.dtick) {\n    var nt = ax.nticks;\n    var minPx;\n    if (!nt) {\n      if (ax.type === 'category' || ax.type === 'multicategory') {\n        minPx = ax.tickfont ? (ax.tickfont.size || 12) * 1.2 : 15;\n        nt = ax._length / minPx;\n      } else {\n        minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n        nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n      }\n\n      // radial axes span half their domain,\n      // multiply nticks value by two to get correct number of auto ticks.\n      if (ax._name === 'radialaxis') nt *= 2;\n    }\n\n    // add a couple of extra digits for filling in ticks when we\n    // have explicit tickvals without tick text\n    if (ax.tickmode === 'array') nt *= 100;\n    axes.autoTicks(ax, Math.abs(rng[1] - rng[0]) / nt);\n    // check for a forced minimum dtick\n    if (ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n      ax.dtick = ax._minDtick;\n      ax.tick0 = ax.l2r(ax._forceTick0);\n    }\n  }\n\n  // check for missing tick0\n  if (!ax.tick0) {\n    ax.tick0 = ax.type === 'date' ? '2000-01-01' : 0;\n  }\n\n  // ensure we don't try to make ticks below our minimum precision\n  // see https://github.com/plotly/plotly.js/issues/2892\n  if (ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n  // now figure out rounding of tick values\n  autoTickRound(ax);\n};\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax) {\n  axes.prepTicks(ax);\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n  // now that we've figured out the auto values for formatting\n  // in case we're missing some ticktext, we can break out for array ticks\n  if (ax.tickmode === 'array') return arrayTicks(ax);\n\n  // find the first tick\n  ax._tmin = axes.tickFirst(ax);\n\n  // add a tiny bit so we get ticks which may have rounded out\n  var startTick = rng[0] * 1.0001 - rng[1] * 0.0001;\n  var endTick = rng[1] * 1.0001 - rng[0] * 0.0001;\n  // check for reversed axis\n  var axrev = rng[1] < rng[0];\n\n  // No visible ticks? Quit.\n  // I've only seen this on category axes with all categories off the edge.\n  if (ax._tmin < startTick !== axrev) return [];\n\n  // return the full set of tick vals\n  var vals = [];\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    endTick = axrev ? Math.max(-0.5, endTick) : Math.min(ax._categories.length - 0.5, endTick);\n  }\n  var xPrevious = null;\n  var maxTicks = Math.max(1000, ax._length || 0);\n  for (var x = ax._tmin; axrev ? x >= endTick : x <= endTick; x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)) {\n    // prevent infinite loops - no more than one tick per pixel,\n    // and make sure each value is different from the previous\n    if (vals.length > maxTicks || x === xPrevious) break;\n    xPrevious = x;\n    vals.push(x);\n  }\n\n  // If same angle over a full circle, the last tick vals is a duplicate.\n  // TODO must do something similar for angular date axes.\n  if (isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n    vals.pop();\n  }\n\n  // save the last tick as well as first, so we can\n  // show the exponent only on the last one\n  ax._tmax = vals[vals.length - 1];\n\n  // for showing the rest of a date when the main tick label is only the\n  // latter part: ax._prevDateHead holds what we showed most recently.\n  // Start with it cleared and mark that we're in calcTicks (ie calculating a\n  // whole string of these so we should care what the previous date head was!)\n  ax._prevDateHead = '';\n  ax._inCalcTicks = true;\n  var ticksOut = new Array(vals.length);\n  for (var i = 0; i < vals.length; i++) {\n    ticksOut[i] = axes.tickText(ax, vals[i]);\n  }\n  ax._inCalcTicks = false;\n  return ticksOut;\n};\nfunction arrayTicks(ax) {\n  var vals = ax.tickvals;\n  var text = ax.ticktext;\n  var ticksOut = new Array(vals.length);\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  var r0expanded = rng[0] * 1.0001 - rng[1] * 0.0001;\n  var r1expanded = rng[1] * 1.0001 - rng[0] * 0.0001;\n  var tickMin = Math.min(r0expanded, r1expanded);\n  var tickMax = Math.max(r0expanded, r1expanded);\n  var j = 0;\n\n  // without a text array, just format the given values as any other ticks\n  // except with more precision to the numbers\n  if (!Array.isArray(text)) text = [];\n\n  // make sure showing ticks doesn't accidentally add new categories\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n  // array ticks on log axes always show the full number\n  // (if no explicit ticktext overrides it)\n  if (ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n    ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n  }\n  for (var i = 0; i < vals.length; i++) {\n    var vali = tickVal2l(vals[i]);\n    if (vali > tickMin && vali < tickMax) {\n      if (text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));\n      j++;\n    }\n  }\n  if (j < vals.length) ticksOut.splice(j, vals.length - j);\n  return ticksOut;\n}\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\nfunction roundDTick(roughDTick, base, roundingSet) {\n  return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function (ax, roughDTick) {\n  var base;\n  function getBase(v) {\n    return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n  }\n  if (ax.type === 'date') {\n    ax.tick0 = Lib.dateTick0(ax.calendar);\n    // the criteria below are all based on the rough spacing we calculate\n    // being > half of the final unit - so precalculate twice the rough val\n    var roughX2 = 2 * roughDTick;\n    if (roughX2 > ONEAVGYEAR) {\n      roughDTick /= ONEAVGYEAR;\n      base = getBase(10);\n      ax.dtick = 'M' + 12 * roundDTick(roughDTick, base, roundBase10);\n    } else if (roughX2 > ONEAVGMONTH) {\n      roughDTick /= ONEAVGMONTH;\n      ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n    } else if (roughX2 > ONEDAY) {\n      ax.dtick = roundDTick(roughDTick, ONEDAY, roundDays);\n      // get week ticks on sunday\n      // this will also move the base tick off 2000-01-01 if dtick is\n      // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n      ax.tick0 = Lib.dateTick0(ax.calendar, true);\n    } else if (roughX2 > ONEHOUR) {\n      ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n    } else if (roughX2 > ONEMIN) {\n      ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n    } else if (roughX2 > ONESEC) {\n      ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n    } else {\n      // milliseconds\n      base = getBase(10);\n      ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n  } else if (ax.type === 'log') {\n    ax.tick0 = 0;\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    if (roughDTick > 0.7) {\n      // only show powers of 10\n      ax.dtick = Math.ceil(roughDTick);\n    } else if (Math.abs(rng[1] - rng[0]) < 1) {\n      // span is less than one power of 10\n      var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n      // ticks on a linear scale, labeled fully\n      roughDTick = Math.abs(Math.pow(10, rng[1]) - Math.pow(10, rng[0])) / nt;\n      base = getBase(10);\n      ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n    } else {\n      // include intermediates between powers of 10,\n      // labeled with small digits\n      // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n      ax.dtick = roughDTick > 0.3 ? 'D2' : 'D1';\n    }\n  } else if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax.tick0 = 0;\n    ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n  } else if (isAngular(ax)) {\n    ax.tick0 = 0;\n    base = 1;\n    ax.dtick = roundDTick(roughDTick, base, roundAngles);\n  } else {\n    // auto ticks always start at 0\n    ax.tick0 = 0;\n    base = getBase(10);\n    ax.dtick = roundDTick(roughDTick, base, roundBase10);\n  }\n\n  // prevent infinite loops\n  if (ax.dtick === 0) ax.dtick = 1;\n\n  // TODO: this is from log axis histograms with autorange off\n  if (!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n    var olddtick = ax.dtick;\n    ax.dtick = 1;\n    throw 'ax.dtick error: ' + String(olddtick);\n  }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n  var dtick = ax.dtick;\n  ax._tickexponent = 0;\n  if (!isNumeric(dtick) && typeof dtick !== 'string') {\n    dtick = 1;\n  }\n  if (ax.type === 'category' || ax.type === 'multicategory') {\n    ax._tickround = null;\n  }\n  if (ax.type === 'date') {\n    // If tick0 is unusual, give tickround a bit more information\n    // not necessarily *all* the information in tick0 though, if it's really odd\n    // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n    // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n    var tick0ms = ax.r2l(ax.tick0);\n    var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n    var tick0len = tick0str.length;\n    if (String(dtick).charAt(0) === 'M') {\n      // any tick0 more specific than a year: alway show the full date\n      if (tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n      // show the month unless ticks are full multiples of a year\n      else ax._tickround = +dtick.substr(1) % 12 === 0 ? 'y' : 'm';\n    } else if (dtick >= ONEDAY && tick0len <= 10 || dtick >= ONEDAY * 15) ax._tickround = 'd';else if (dtick >= ONEMIN && tick0len <= 16 || dtick >= ONEHOUR) ax._tickround = 'M';else if (dtick >= ONESEC && tick0len <= 19 || dtick >= ONEMIN) ax._tickround = 'S';else {\n      // tickround is a number of digits of fractional seconds\n      // of any two adjacent ticks, at least one will have the maximum fractional digits\n      // of all possible ticks - so take the max. length of tick0 and the next one\n      var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n      ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n      // We shouldn't get here... but in case there's a situation I'm\n      // not thinking of where tick0str and tick1str are identical or\n      // something, fall back on maximum precision\n      if (ax._tickround < 0) ax._tickround = 4;\n    }\n  } else if (isNumeric(dtick) || dtick.charAt(0) === 'L') {\n    // linear or log (except D1, D2)\n    var rng = ax.range.map(ax.r2d || Number);\n    if (!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n    // 2 digits past largest digit of dtick\n    ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n    var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n    var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n    if (Math.abs(rangeexp) > 3) {\n      if (isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n        ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n      } else ax._tickexponent = rangeexp;\n    }\n  }\n  // D1 or D2 (log)\n  else ax._tickround = null;\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function (x, dtick, axrev, calendar) {\n  var axSign = axrev ? -1 : 1;\n\n  // includes linear, all dates smaller than month, and pure 10^n in log\n  if (isNumeric(dtick)) return x + axSign * dtick;\n\n  // everything else is a string, one character plus a number\n  var tType = dtick.charAt(0);\n  var dtSigned = axSign * Number(dtick.substr(1));\n\n  // Dates: months (or years - see Lib.incrementMonth)\n  if (tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n  // Log scales: Linear, Digits\n  else if (tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n  // log10 of 2,5,10, or all digits (logs just have to be\n  // close enough to round)\n  else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var x2 = x + axSign * 0.01;\n    var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n    return Math.floor(x2) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function (ax) {\n  var r2l = ax.r2l || Number;\n  var rng = Lib.simpleMap(ax.range, r2l);\n  var axrev = rng[1] < rng[0];\n  var sRound = axrev ? Math.floor : Math.ceil;\n  // add a tiny extra bit to make sure we get ticks\n  // that may have been rounded out\n  var r0 = rng[0] * 1.0001 - rng[1] * 0.0001;\n  var dtick = ax.dtick;\n  var tick0 = r2l(ax.tick0);\n  if (isNumeric(dtick)) {\n    var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n    // make sure no ticks outside the category list\n    if (ax.type === 'category' || ax.type === 'multicategory') {\n      tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n    }\n    return tmin;\n  }\n  var tType = dtick.charAt(0);\n  var dtNum = Number(dtick.substr(1));\n\n  // Dates: months (or years)\n  if (tType === 'M') {\n    var cnt = 0;\n    var t0 = tick0;\n    var t1, mult, newDTick;\n\n    // This algorithm should work for *any* nonlinear (but close to linear!)\n    // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n    while (cnt < 10) {\n      t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n      if ((t1 - r0) * (t0 - r0) <= 0) {\n        // t1 and t0 are on opposite sides of r0! we've succeeded!\n        if (axrev) return Math.min(t0, t1);\n        return Math.max(t0, t1);\n      }\n      mult = (r0 - (t0 + t1) / 2) / (t1 - t0);\n      newDTick = tType + (Math.abs(Math.round(mult)) || 1) * dtNum;\n      t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n      cnt++;\n    }\n    Lib.error('tickFirst did not converge', ax);\n    return t0;\n  }\n\n  // Log scales: Linear, Digits\n  else if (tType === 'L') {\n    return Math.log(sRound((Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n  } else if (tType === 'D') {\n    var tickset = dtick === 'D2' ? roundLog2 : roundLog1;\n    var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n    return Math.floor(r0) + Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n  } else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function (ax, x, hover) {\n  var out = tickTextObj(ax, x);\n  var arrayMode = ax.tickmode === 'array';\n  var extraPrecision = hover || arrayMode;\n  var axType = ax.type;\n  // TODO multicategory, if we allow ticktext / tickvals\n  var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n  var i;\n  if (arrayMode && Array.isArray(ax.ticktext)) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var minDiff = Math.abs(rng[1] - rng[0]) / 10000;\n    for (i = 0; i < ax.ticktext.length; i++) {\n      if (Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n    }\n    if (i < ax.ticktext.length) {\n      out.text = String(ax.ticktext[i]);\n      return out;\n    }\n  }\n  function isHidden(showAttr) {\n    if (showAttr === undefined) return true;\n    if (hover) return showAttr === 'none';\n    var firstOrLast = {\n      first: ax._tmin,\n      last: ax._tmax\n    }[showAttr];\n    return showAttr !== 'all' && x !== firstOrLast;\n  }\n  var hideexp = hover ? 'never' : ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n  if (axType === 'date') formatDate(ax, out, hover, extraPrecision);else if (axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);else if (axType === 'category') formatCategory(ax, out);else if (axType === 'multicategory') formatMultiCategory(ax, out, hover);else if (isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n  // add prefix and suffix\n  if (ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n  if (ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n\n  // Setup ticks and grid lines boundaries\n  // at 1/2 a 'category' to the left/bottom\n  if (ax.tickson === 'boundaries' || ax.showdividers) {\n    var inbounds = function inbounds(v) {\n      var p = ax.l2p(v);\n      return p >= 0 && p <= ax._length ? v : null;\n    };\n    out.xbnd = [inbounds(out.x - 0.5), inbounds(out.x + ax.dtick - 0.5)];\n  }\n  return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number} val: calcdata value to format\n * @param {Optional(number)} val2: a second value to display\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     `val` and `val2` as a range (ie '<val> - <val2>') if `val2` is provided and\n *     it's different from `val`.\n */\naxes.hoverLabelText = function (ax, val, val2) {\n  if (val2 !== BADNUM && val2 !== val) {\n    return axes.hoverLabelText(ax, val) + ' - ' + axes.hoverLabelText(ax, val2);\n  }\n  var logOffScale = ax.type === 'log' && val <= 0;\n  var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n  if (logOffScale) {\n    return val === 0 ? '0' : MINUS_SIGN + tx;\n  }\n\n  // TODO: should we do something special if the axis calendar and\n  // the data calendar are different? Somehow display both dates with\n  // their system names? Right now it will just display in the axis calendar\n  // but users could add the other one as text.\n  return tx;\n};\nfunction tickTextObj(ax, x, text) {\n  var tf = ax.tickfont || {};\n  return {\n    x: x,\n    dx: 0,\n    dy: 0,\n    text: text || '',\n    fontSize: tf.size,\n    font: tf.family,\n    fontColor: tf.color\n  };\n}\nfunction formatDate(ax, out, hover, extraPrecision) {\n  var tr = ax._tickround;\n  var fmt = hover && ax.hoverformat || axes.getTickFormat(ax);\n  if (extraPrecision) {\n    // second or sub-second precision: extra always shows max digits.\n    // for other fields, extra precision just adds one field.\n    if (isNumeric(tr)) tr = 4;else tr = {\n      y: 'm',\n      m: 'd',\n      d: 'M',\n      M: 'S',\n      S: 4\n    }[tr];\n  }\n  var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n  var headStr;\n  var splitIndex = dateStr.indexOf('\\n');\n  if (splitIndex !== -1) {\n    headStr = dateStr.substr(splitIndex + 1);\n    dateStr = dateStr.substr(0, splitIndex);\n  }\n  if (extraPrecision) {\n    // if extraPrecision led to trailing zeros, strip them off\n    // actually, this can lead to removing even more zeros than\n    // in the original rounding, but that's fine because in these\n    // contexts uniformity is not so important (if there's even\n    // anything to be uniform with!)\n\n    // can we remove the whole time part?\n    if (dateStr === '00:00:00' || dateStr === '00:00') {\n      dateStr = headStr;\n      headStr = '';\n    } else if (dateStr.length === 8) {\n      // strip off seconds if they're zero (zero fractional seconds\n      // are already omitted)\n      // but we never remove minutes and leave just hours\n      dateStr = dateStr.replace(/:00$/, '');\n    }\n  }\n  if (headStr) {\n    if (hover) {\n      // hover puts it all on one line, so headPart works best up front\n      // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n      if (tr === 'd') dateStr += ', ' + headStr;else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n    } else if (!ax._inCalcTicks || headStr !== ax._prevDateHead) {\n      dateStr += '<br>' + headStr;\n      ax._prevDateHead = headStr;\n    }\n  }\n  out.text = dateStr;\n}\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n  var dtick = ax.dtick;\n  var x = out.x;\n  var tickformat = ax.tickformat;\n  var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  }\n  if (extraPrecision && dtChar0 !== 'L') {\n    dtick = 'L3';\n    dtChar0 = 'L';\n  }\n  if (tickformat || dtChar0 === 'L') {\n    out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n  } else if (isNumeric(dtick) || dtChar0 === 'D' && Lib.mod(x + 0.01, 1) < 0.1) {\n    var p = Math.round(x);\n    var absP = Math.abs(p);\n    var exponentFormat = ax.exponentformat;\n    if (exponentFormat === 'power' || isSIFormat(exponentFormat) && beyondSI(p)) {\n      if (p === 0) out.text = 1;else if (p === 1) out.text = '10';else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n      out.fontSize *= 1.25;\n    } else if ((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n      out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n    } else {\n      out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n      if (dtick === 'D1' && ax._id.charAt(0) === 'y') {\n        out.dy -= out.fontSize / 6;\n      }\n    }\n  } else if (dtChar0 === 'D') {\n    out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n    out.fontSize *= 0.75;\n  } else throw 'unrecognized dtick ' + String(dtick);\n\n  // if 9's are printed on log scale, move the 10's away a bit\n  if (ax.dtick === 'D1') {\n    var firstChar = String(out.text).charAt(0);\n    if (firstChar === '0' || firstChar === '1') {\n      if (ax._id.charAt(0) === 'y') {\n        out.dx -= out.fontSize / 4;\n      } else {\n        out.dy += out.fontSize / 2;\n        out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) * out.fontSize * (x < 0 ? 0.5 : 0.25);\n      }\n    }\n  }\n}\nfunction formatCategory(ax, out) {\n  var tt = ax._categories[Math.round(out.x)];\n  if (tt === undefined) tt = '';\n  out.text = String(tt);\n}\nfunction formatMultiCategory(ax, out, hover) {\n  var v = Math.round(out.x);\n  var cats = ax._categories[v] || [];\n  var tt = cats[1] === undefined ? '' : String(cats[1]);\n  var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n  if (hover) {\n    // TODO is this what we want?\n    out.text = tt2 + ' - ' + tt;\n  } else {\n    // setup for secondary labels\n    out.text = tt;\n    out.text2 = tt2;\n  }\n}\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n  if (hideexp === 'never') {\n    // If this is a hover label, then we must *never* hide the exponent\n    // for the sake of display, which could give the wrong value by\n    // potentially many orders of magnitude. If hideexp was 'never', then\n    // it's now succeeded by preventing the other condition from automating\n    // this choice. Thus we can unset it so that the axis formatting takes\n    // precedence.\n    hideexp = '';\n  } else if (ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n    // don't add an exponent to zero if we're showing all exponents\n    // so the only reason you'd show an exponent on zero is if it's the\n    // ONLY tick to get an exponent (first or last)\n    hideexp = 'hide';\n  }\n  out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n  if (ax.thetaunit === 'radians' && !hover) {\n    var num = out.x / 180;\n    if (num === 0) {\n      out.text = '0';\n    } else {\n      var frac = num2frac(num);\n      if (frac[1] >= 100) {\n        out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n      } else {\n        var isNeg = out.x < 0;\n        if (frac[1] === 1) {\n          if (frac[0] === 1) out.text = 'π';else out.text = frac[0] + 'π';\n        } else {\n          out.text = ['<sup>', frac[0], '</sup>', '⁄', '<sub>', frac[1], '</sub>', 'π'].join('');\n        }\n        if (isNeg) out.text = MINUS_SIGN + out.text;\n      }\n    }\n  } else {\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n  }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n  function almostEq(a, b) {\n    return Math.abs(a - b) <= 1e-6;\n  }\n  function findGCD(a, b) {\n    return almostEq(b, 0) ? a : findGCD(b, a % b);\n  }\n  function findPrecision(n) {\n    var e = 1;\n    while (!almostEq(Math.round(n * e) / e, n)) {\n      e *= 10;\n    }\n    return e;\n  }\n  var precision = findPrecision(num);\n  var number = num * precision;\n  var gcd = Math.abs(findGCD(number, precision));\n  return [\n  // numerator\n  Math.round(number / gcd),\n  // denominator\n  Math.round(precision / gcd)];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\nfunction isSIFormat(exponentFormat) {\n  return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n  return exponent > 14 || exponent < -15;\n}\nfunction numFormat(v, ax, fmtoverride, hover) {\n  var isNeg = v < 0;\n  // max number of digits past decimal point to show\n  var tickRound = ax._tickround;\n  var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n  var exponent = ax._tickexponent;\n  var tickformat = axes.getTickFormat(ax);\n  var separatethousands = ax.separatethousands;\n\n  // special case for hover: set exponent just for this value, and\n  // add a couple more digits of precision over tick labels\n  if (hover) {\n    // make a dummy axis obj to get the auto rounding and exponent\n    var ah = {\n      exponentformat: exponentFormat,\n      dtick: ax.showexponent === 'none' ? ax.dtick : isNumeric(v) ? Math.abs(v) || 1 : 1,\n      // if not showing any exponents, don't change the exponent\n      // from what we calculate\n      range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n    };\n    autoTickRound(ah);\n    tickRound = (Number(ah._tickround) || 0) + 4;\n    exponent = ah._tickexponent;\n    if (ax.hoverformat) tickformat = ax.hoverformat;\n  }\n  if (tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n  // 'epsilon' - rounding increment\n  var e = Math.pow(10, -tickRound) / 2;\n\n  // exponentFormat codes:\n  // 'e' (1.2e+6, default)\n  // 'E' (1.2E+6)\n  // 'SI' (1.2M)\n  // 'B' (same as SI except 10^9=B not G)\n  // 'none' (1200000)\n  // 'power' (1.2x10^6)\n  // 'hide' (1.2, use 3rd argument=='hide' to eg\n  //      only show exponent on last tick)\n  if (exponentFormat === 'none') exponent = 0;\n\n  // take the sign out, put it back manually at the end\n  // - makes cases easier\n  v = Math.abs(v);\n  if (v < e) {\n    // 0 is just 0, but may get exponent if it's the last tick\n    v = '0';\n    isNeg = false;\n  } else {\n    v += e;\n    // take out a common exponent, if any\n    if (exponent) {\n      v *= Math.pow(10, -exponent);\n      tickRound += exponent;\n    }\n    // round the mantissa\n    if (tickRound === 0) v = String(Math.floor(v));else if (tickRound < 0) {\n      v = String(Math.round(v));\n      v = v.substr(0, v.length + tickRound);\n      for (var i = tickRound; i < 0; i++) {\n        v += '0';\n      }\n    } else {\n      v = String(v);\n      var dp = v.indexOf('.') + 1;\n      if (dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n    }\n    // insert appropriate decimal point and thousands separator\n    v = Lib.numSeparate(v, ax._separators, separatethousands);\n  }\n\n  // add exponent\n  if (exponent && exponentFormat !== 'hide') {\n    if (isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n    var signedExponent;\n    if (exponent < 0) signedExponent = MINUS_SIGN + -exponent;else if (exponentFormat !== 'power') signedExponent = '+' + exponent;else signedExponent = String(exponent);\n    if (exponentFormat === 'e' || exponentFormat === 'E') {\n      v += exponentFormat + signedExponent;\n    } else if (exponentFormat === 'power') {\n      v += '×10<sup>' + signedExponent + '</sup>';\n    } else if (exponentFormat === 'B' && exponent === 9) {\n      v += 'B';\n    } else if (isSIFormat(exponentFormat)) {\n      v += SIPREFIXES[exponent / 3 + 5];\n    }\n  }\n\n  // put sign back in and return\n  // replace standard minus character (which is technically a hyphen)\n  // with a true minus sign\n  if (isNeg) return MINUS_SIGN + v;\n  return v;\n}\naxes.getTickFormat = function (ax) {\n  var i;\n  function convertToMs(dtick) {\n    return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n  }\n  function compareLogTicks(left, right) {\n    var priority = ['L', 'D'];\n    if (typeof left === typeof right) {\n      if (typeof left === 'number') {\n        return left - right;\n      } else {\n        var leftPriority = priority.indexOf(left.charAt(0));\n        var rightPriority = priority.indexOf(right.charAt(0));\n        if (leftPriority === rightPriority) {\n          return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n        } else {\n          return leftPriority - rightPriority;\n        }\n      }\n    } else {\n      return typeof left === 'number' ? 1 : -1;\n    }\n  }\n  function isProperStop(dtick, range, convert) {\n    var convertFn = convert || function (x) {\n      return x;\n    };\n    var leftDtick = range[0];\n    var rightDtick = range[1];\n    return (!leftDtick && typeof leftDtick !== 'number' || convertFn(leftDtick) <= convertFn(dtick)) && (!rightDtick && typeof rightDtick !== 'number' || convertFn(rightDtick) >= convertFn(dtick));\n  }\n  function isProperLogStop(dtick, range) {\n    var isLeftDtickNull = range[0] === null;\n    var isRightDtickNull = range[1] === null;\n    var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n    var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n    return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n  }\n  var tickstop, stopi;\n  if (ax.tickformatstops && ax.tickformatstops.length > 0) {\n    switch (ax.type) {\n      case 'date':\n      case 'linear':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      case 'log':\n        {\n          for (i = 0; i < ax.tickformatstops.length; i++) {\n            stopi = ax.tickformatstops[i];\n            if (stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n              tickstop = stopi;\n              break;\n            }\n          }\n          break;\n        }\n      default:\n    }\n  }\n  return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function (gd, ax) {\n  var subplotObj = gd._fullLayout._subplots;\n  var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n  var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n  out.sort(function (a, b) {\n    var aParts = a.substr(1).split('y');\n    var bParts = b.substr(1).split('y');\n    if (aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n    return +aParts[0] - +bParts[0];\n  });\n  return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function (subplots, ax) {\n  var axMatch = new RegExp(ax._id.charAt(0) === 'x' ? '^' + ax._id + 'y' : ax._id + '$');\n  var subplotsWithAx = [];\n  for (var i = 0; i < subplots.length; i++) {\n    var sp = subplots[i];\n    if (axMatch.test(sp)) subplotsWithAx.push(sp);\n  }\n  return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function (gd) {\n  var fullLayout = gd._fullLayout;\n\n  // for more info: https://github.com/plotly/plotly.js/issues/2595\n  if (fullLayout._hasOnlyLargeSploms) return;\n  var fullWidth = {\n    _offset: 0,\n    _length: fullLayout.width,\n    _id: ''\n  };\n  var fullHeight = {\n    _offset: 0,\n    _length: fullLayout.height,\n    _id: ''\n  };\n  var xaList = axes.list(gd, 'x', true);\n  var yaList = axes.list(gd, 'y', true);\n  var clipList = [];\n  var i, j;\n  for (i = 0; i < xaList.length; i++) {\n    clipList.push({\n      x: xaList[i],\n      y: fullHeight\n    });\n    for (j = 0; j < yaList.length; j++) {\n      if (i === 0) clipList.push({\n        x: fullWidth,\n        y: yaList[j]\n      });\n      clipList.push({\n        x: xaList[i],\n        y: yaList[j]\n      });\n    }\n  }\n\n  // selectors don't work right with camelCase tags,\n  // have to use class instead\n  // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n  var axClips = fullLayout._clips.selectAll('.axesclip').data(clipList, function (d) {\n    return d.x._id + d.y._id;\n  });\n  axClips.enter().append('clipPath').classed('axesclip', true).attr('id', function (d) {\n    return 'clip' + fullLayout._uid + d.x._id + d.y._id;\n  }).append('rect');\n  axClips.exit().remove();\n  axClips.each(function (d) {\n    d3.select(this).select('rect').attr({\n      x: d.x._offset || 0,\n      y: d.y._offset || 0,\n      width: d.x._length || 1,\n      height: d.y._length || 1\n    });\n  });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function (gd, arg, opts) {\n  var fullLayout = gd._fullLayout;\n  if (arg === 'redraw') {\n    fullLayout._paper.selectAll('g.subplot').each(function (d) {\n      var id = d[0];\n      var plotinfo = fullLayout._plots[id];\n      var xa = plotinfo.xaxis;\n      var ya = plotinfo.yaxis;\n      plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n      plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n      plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n      plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n      plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n      plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n      if (plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n      if (plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n      fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n      fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n    });\n  }\n  var axList = !arg || arg === 'redraw' ? axes.listIds(gd) : arg;\n  return Lib.syncOrAsync(axList.map(function (axId) {\n    return function () {\n      if (!axId) return;\n      var ax = axes.getFromId(gd, axId);\n      var axDone = axes.drawOne(gd, ax, opts);\n      ax._r = ax.range.slice();\n      ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n      return axDone;\n    };\n  }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n */\naxes.drawOne = function (gd, ax, opts) {\n  opts = opts || {};\n  var i, sp, plotinfo;\n  ax.setScale();\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var counterLetter = axes.counterLetter(axId);\n  var mainSubplot = ax._mainSubplot;\n  var mainLinePosition = ax._mainLinePosition;\n  var mainMirrorPosition = ax._mainMirrorPosition;\n  var mainPlotinfo = fullLayout._plots[mainSubplot];\n  var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n  var subplotsWithAx = ax._subplotsWith;\n  var vals = ax._vals = axes.calcTicks(ax);\n\n  // Add a couple of axis properties that should cause us to recreate\n  // elements. Used in d3 data function.\n  var axInfo = [ax.mirror, mainLinePosition, mainMirrorPosition].join('_');\n  for (i = 0; i < vals.length; i++) {\n    vals[i].axInfo = axInfo;\n  }\n  if (!ax.visible) return;\n\n  // stash selections to avoid DOM queries e.g.\n  // - stash tickLabels selection, so that drawTitle can use it to scoot title\n  ax._selections = {};\n  // stash tick angle (including the computed 'auto' values) per tick-label class\n  ax._tickAngles = {};\n  var transFn = axes.makeTransFn(ax);\n  var tickVals;\n  // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n  // The key case here is removing zero lines when the axis bound is zero\n  var valsClipped;\n  if (ax.tickson === 'boundaries') {\n    var boundaryVals = getBoundaryVals(ax, vals);\n    valsClipped = axes.clipEnds(ax, boundaryVals);\n    tickVals = ax.ticks === 'inside' ? valsClipped : boundaryVals;\n  } else {\n    valsClipped = axes.clipEnds(ax, vals);\n    tickVals = ax.ticks === 'inside' ? valsClipped : vals;\n  }\n  var gridVals = ax._gridVals = valsClipped;\n  var dividerVals = getDividerVals(ax, vals);\n  if (!fullLayout._hasOnlyLargeSploms) {\n    // keep track of which subplots (by main conteraxis) we've already\n    // drawn grids for, so we don't overdraw overlaying subplots\n    var finishedGrids = {};\n    for (i = 0; i < subplotsWithAx.length; i++) {\n      sp = subplotsWithAx[i];\n      plotinfo = fullLayout._plots[sp];\n      var counterAxis = plotinfo[counterLetter + 'axis'];\n      var mainCounterID = counterAxis._mainAxis._id;\n      if (finishedGrids[mainCounterID]) continue;\n      finishedGrids[mainCounterID] = 1;\n      var gridPath = axLetter === 'x' ? 'M0,' + counterAxis._offset + 'v' + counterAxis._length : 'M' + counterAxis._offset + ',0h' + counterAxis._length;\n      axes.drawGrid(gd, ax, {\n        vals: gridVals,\n        counterAxis: counterAxis,\n        layer: plotinfo.gridlayer.select('.' + axId),\n        path: gridPath,\n        transFn: transFn\n      });\n      axes.drawZeroLine(gd, ax, {\n        counterAxis: counterAxis,\n        layer: plotinfo.zerolinelayer,\n        path: gridPath,\n        transFn: transFn\n      });\n    }\n  }\n  var tickSigns = axes.getTickSigns(ax);\n  var tickSubplots = [];\n  if (ax.ticks) {\n    var mainTickPath = axes.makeTickPath(ax, mainLinePosition, tickSigns[2]);\n    var mirrorTickPath;\n    var fullTickPath;\n    if (ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n      mirrorTickPath = axes.makeTickPath(ax, mainMirrorPosition, tickSigns[3]);\n      fullTickPath = mainTickPath + mirrorTickPath;\n    } else {\n      mirrorTickPath = '';\n      fullTickPath = mainTickPath;\n    }\n    var tickPath;\n    if (ax.showdividers && ax.ticks === 'outside' && ax.tickson === 'boundaries') {\n      var dividerLookup = {};\n      for (i = 0; i < dividerVals.length; i++) {\n        dividerLookup[dividerVals[i].x] = 1;\n      }\n      tickPath = function tickPath(d) {\n        return dividerLookup[d.x] ? mirrorTickPath : fullTickPath;\n      };\n    } else {\n      tickPath = fullTickPath;\n    }\n    axes.drawTicks(gd, ax, {\n      vals: tickVals,\n      layer: mainAxLayer,\n      path: tickPath,\n      transFn: transFn\n    });\n    tickSubplots = Object.keys(ax._linepositions || {});\n  }\n  for (i = 0; i < tickSubplots.length; i++) {\n    sp = tickSubplots[i];\n    plotinfo = fullLayout._plots[sp];\n    // [bottom or left, top or right], free and main are handled above\n    var linepositions = ax._linepositions[sp] || [];\n    var spTickPath = axes.makeTickPath(ax, linepositions[0], tickSigns[0]) + axes.makeTickPath(ax, linepositions[1], tickSigns[1]);\n    axes.drawTicks(gd, ax, {\n      vals: tickVals,\n      layer: plotinfo[axLetter + 'axislayer'],\n      path: spTickPath,\n      transFn: transFn\n    });\n  }\n  var seq = [];\n\n  // tick labels - for now just the main labels.\n  // TODO: mirror labels, esp for subplots\n\n  seq.push(function () {\n    var labelFns = axes.makeLabelFns(ax, mainLinePosition);\n    return axes.drawLabels(gd, ax, {\n      vals: vals,\n      layer: mainAxLayer,\n      transFn: transFn,\n      labelXFn: labelFns.labelXFn,\n      labelYFn: labelFns.labelYFn,\n      labelAnchorFn: labelFns.labelAnchorFn\n    });\n  });\n  if (ax.type === 'multicategory') {\n    var labelLength = 0;\n    var pad = {\n      x: 2,\n      y: 10\n    }[axLetter];\n    var sgn = tickSigns[2] * (ax.ticks === 'inside' ? -1 : 1);\n    seq.push(function () {\n      labelLength += getLabelLevelSpan(ax, axId + 'tick') + pad;\n      labelLength += ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0;\n      var secondaryPosition = mainLinePosition + labelLength * sgn;\n      var secondaryLabelFns = axes.makeLabelFns(ax, secondaryPosition);\n      return axes.drawLabels(gd, ax, {\n        vals: getSecondaryLabelVals(ax, vals),\n        layer: mainAxLayer,\n        cls: axId + 'tick2',\n        repositionOnUpdate: true,\n        secondary: true,\n        transFn: transFn,\n        labelXFn: secondaryLabelFns.labelXFn,\n        labelYFn: secondaryLabelFns.labelYFn,\n        labelAnchorFn: secondaryLabelFns.labelAnchorFn\n      });\n    });\n    seq.push(function () {\n      labelLength += getLabelLevelSpan(ax, axId + 'tick2');\n      ax._labelLength = labelLength;\n      return drawDividers(gd, ax, {\n        vals: dividerVals,\n        layer: mainAxLayer,\n        path: axes.makeTickPath(ax, mainLinePosition, sgn, labelLength),\n        transFn: transFn\n      });\n    });\n  }\n  function extendRange(range, newRange) {\n    range[0] = Math.min(range[0], newRange[0]);\n    range[1] = Math.max(range[1], newRange[1]);\n  }\n  function calcBoundingBox() {\n    if (ax.showticklabels) {\n      var gdBB = gd.getBoundingClientRect();\n      var bBox = mainAxLayer.node().getBoundingClientRect();\n\n      /*\n       * the way we're going to use this, the positioning that matters\n       * is relative to the origin of gd. This is important particularly\n       * if gd is scrollable, and may have been scrolled between the time\n       * we calculate this and the time we use it\n       */\n\n      ax._boundingBox = {\n        width: bBox.width,\n        height: bBox.height,\n        left: bBox.left - gdBB.left,\n        right: bBox.right - gdBB.left,\n        top: bBox.top - gdBB.top,\n        bottom: bBox.bottom - gdBB.top\n      };\n    } else {\n      var gs = fullLayout._size;\n      var pos;\n\n      // set dummy bbox for ticklabel-less axes\n\n      if (axLetter === 'x') {\n        pos = ax.anchor === 'free' ? gs.t + gs.h * (1 - ax.position) : gs.t + gs.h * (1 - ax._anchorAxis.domain[{\n          bottom: 0,\n          top: 1\n        }[ax.side]]);\n        ax._boundingBox = {\n          top: pos,\n          bottom: pos,\n          left: ax._offset,\n          right: ax._offset + ax._length,\n          width: ax._length,\n          height: 0\n        };\n      } else {\n        pos = ax.anchor === 'free' ? gs.l + gs.w * ax.position : gs.l + gs.w * ax._anchorAxis.domain[{\n          left: 0,\n          right: 1\n        }[ax.side]];\n        ax._boundingBox = {\n          left: pos,\n          right: pos,\n          bottom: ax._offset + ax._length,\n          top: ax._offset,\n          height: ax._length,\n          width: 0\n        };\n      }\n    }\n\n    /*\n     * for spikelines: what's the full domain of positions in the\n     * opposite direction that are associated with this axis?\n     * This means any axes that we make a subplot with, plus the\n     * position of the axis itself if it's free.\n     */\n    if (subplotsWithAx) {\n      var fullRange = ax._counterSpan = [Infinity, -Infinity];\n      for (var i = 0; i < subplotsWithAx.length; i++) {\n        var plotinfo = fullLayout._plots[subplotsWithAx[i]];\n        var counterAxis = plotinfo[axLetter === 'x' ? 'yaxis' : 'xaxis'];\n        extendRange(fullRange, [counterAxis._offset, counterAxis._offset + counterAxis._length]);\n      }\n      if (ax.anchor === 'free') {\n        extendRange(fullRange, axLetter === 'x' ? [ax._boundingBox.bottom, ax._boundingBox.top] : [ax._boundingBox.right, ax._boundingBox.left]);\n      }\n    }\n  }\n  var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n  function doAutoMargins() {\n    var s = ax.side.charAt(0);\n    var push;\n    var rangeSliderPush;\n    if (hasRangeSlider) {\n      rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n    }\n    Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n    if (ax.automargin && (!hasRangeSlider || s !== 'b')) {\n      push = {\n        x: 0,\n        y: 0,\n        r: 0,\n        l: 0,\n        t: 0,\n        b: 0\n      };\n      var bbox = ax._boundingBox;\n      var counterAx = mainPlotinfo[counterLetter + 'axis'];\n      var anchorAxDomainIndex;\n      var offset;\n      switch (axLetter + s) {\n        case 'xb':\n          anchorAxDomainIndex = 0;\n          offset = bbox.top - counterAx._length - counterAx._offset;\n          push[s] = bbox.height;\n          break;\n        case 'xt':\n          anchorAxDomainIndex = 1;\n          offset = counterAx._offset - bbox.bottom;\n          push[s] = bbox.height;\n          break;\n        case 'yl':\n          anchorAxDomainIndex = 0;\n          offset = counterAx._offset - bbox.right;\n          push[s] = bbox.width;\n          break;\n        case 'yr':\n          anchorAxDomainIndex = 1;\n          offset = bbox.left - counterAx._length - counterAx._offset;\n          push[s] = bbox.width;\n          break;\n      }\n      push[counterLetter] = ax.anchor === 'free' ? ax.position : ax._anchorAxis.domain[anchorAxDomainIndex];\n      if (push[s] > 0) {\n        push[s] += offset;\n      }\n      if (ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n        push[s] += ax.title.font.size;\n      }\n    }\n    Plots.autoMargin(gd, axAutoMarginID(ax), push);\n  }\n  seq.push(calcBoundingBox, doAutoMargins);\n  if (!opts.skipTitle && !(hasRangeSlider && ax._boundingBox && ax.side === 'bottom')) {\n    seq.push(function () {\n      return drawTitle(gd, ax);\n    });\n  }\n  return Lib.syncOrAsync(seq);\n};\nfunction getBoundaryVals(ax, vals) {\n  var out = [];\n  var i;\n\n  // boundaryVals are never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function _push(d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      _push(vals[i], 0);\n    }\n    _push(vals[i - 1], 1);\n  }\n  return out;\n}\nfunction getSecondaryLabelVals(ax, vals) {\n  var out = [];\n  var lookup = {};\n  for (var i = 0; i < vals.length; i++) {\n    var d = vals[i];\n    if (lookup[d.text2]) {\n      lookup[d.text2].push(d.x);\n    } else {\n      lookup[d.text2] = [d.x];\n    }\n  }\n  for (var k in lookup) {\n    out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n  }\n  return out;\n}\nfunction getDividerVals(ax, vals) {\n  var out = [];\n  var i, current;\n\n  // never used for labels;\n  // no need to worry about the other tickTextObj keys\n  var _push = function _push(d, bndIndex) {\n    var xb = d.xbnd[bndIndex];\n    if (xb !== null) {\n      out.push(Lib.extendFlat({}, d, {\n        x: xb\n      }));\n    }\n  };\n  if (ax.showdividers && vals.length) {\n    for (i = 0; i < vals.length; i++) {\n      var d = vals[i];\n      if (d.text2 !== current) {\n        _push(d, 0);\n      }\n      current = d.text2;\n    }\n    _push(vals[i - 1], 1);\n  }\n  return out;\n}\nfunction getLabelLevelSpan(ax, cls) {\n  var axLetter = ax._id.charAt(0);\n  var angle = ax._tickAngles[cls] || 0;\n  var rad = Lib.deg2rad(angle);\n  var sinA = Math.sin(rad);\n  var cosA = Math.cos(rad);\n  var maxX = 0;\n  var maxY = 0;\n\n  // N.B. Drawing.bBox does not take into account rotate transforms\n\n  ax._selections[cls].each(function () {\n    var thisLabel = selectTickLabel(this);\n    var bb = Drawing.bBox(thisLabel.node());\n    var w = bb.width;\n    var h = bb.height;\n    maxX = Math.max(maxX, cosA * w, sinA * h);\n    maxY = Math.max(maxY, sinA * w, cosA * h);\n  });\n  return {\n    x: maxY,\n    y: maxX\n  }[axLetter];\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n */\naxes.getTickSigns = function (ax) {\n  var axLetter = ax._id.charAt(0);\n  var sideOpposite = {\n    x: 'top',\n    y: 'right'\n  }[axLetter];\n  var main = ax.side === sideOpposite ? 1 : -1;\n  var out = [-1, 1, main, -main];\n  // then we flip if outside XOR y axis\n  if (ax.ticks !== 'inside' === (axLetter === 'x')) {\n    out = out.map(function (v) {\n      return -v;\n    });\n  }\n  return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransFn = function (ax) {\n  var axLetter = ax._id.charAt(0);\n  var offset = ax._offset;\n  return axLetter === 'x' ? function (d) {\n    return 'translate(' + (offset + ax.l2p(d.x)) + ',0)';\n  } : function (d) {\n    return 'translate(0,' + (offset + ax.l2p(d.x)) + ')';\n  };\n};\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sng tick sign\n * @param {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function (ax, shift, sgn, len) {\n  len = len !== undefined ? len : ax.ticklen;\n  var axLetter = ax._id.charAt(0);\n  var pad = (ax.linewidth || 1) / 2;\n  return axLetter === 'x' ? 'M0,' + (shift + pad * sgn) + 'v' + len * sgn : 'M' + (shift + pad * sgn) + ',0h' + len * sgn;\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} labelXFn\n *  - {fn} labelYFn\n *  - {fn} labelAnchorFn\n *  - {number} labelStandoff\n *  - {number} labelShift\n */\naxes.makeLabelFns = function (ax, shift, angle) {\n  var axLetter = ax._id.charAt(0);\n  var pad = (ax.linewidth || 1) / 2;\n  var ticksOnOutsideLabels = ax.tickson !== 'boundaries' && ax.ticks === 'outside';\n  var labelStandoff = ticksOnOutsideLabels ? ax.ticklen : 0;\n  var labelShift = 0;\n  if (angle && ax.ticks === 'outside') {\n    var rad = Lib.deg2rad(angle);\n    labelStandoff = ax.ticklen * Math.cos(rad) + 1;\n    labelShift = ax.ticklen * Math.sin(rad);\n  }\n  if (ax.showticklabels && (ticksOnOutsideLabels || ax.showline)) {\n    labelStandoff += 0.2 * ax.tickfont.size;\n  }\n\n  // Used in polar angular label x/y functions\n  // TODO generalize makeLabelFns so that it just work for angular axes\n  var out = {\n    labelStandoff: labelStandoff,\n    labelShift: labelShift\n  };\n  var x0, y0, ff, flipIt;\n  if (axLetter === 'x') {\n    flipIt = ax.side === 'bottom' ? 1 : -1;\n    x0 = labelShift * flipIt;\n    y0 = shift + (labelStandoff + pad) * flipIt;\n    ff = ax.side === 'bottom' ? 1 : -0.2;\n    out.labelXFn = function (d) {\n      return d.dx + x0;\n    };\n    out.labelYFn = function (d) {\n      return d.dy + y0 + d.fontSize * ff;\n    };\n    out.labelAnchorFn = function (a) {\n      if (!isNumeric(a) || a === 0 || a === 180) {\n        return 'middle';\n      }\n      return a * flipIt < 0 ? 'end' : 'start';\n    };\n  } else if (axLetter === 'y') {\n    flipIt = ax.side === 'right' ? 1 : -1;\n    x0 = labelStandoff + pad;\n    y0 = -labelShift * flipIt;\n    ff = Math.abs(ax.tickangle) === 90 ? 0.5 : 0;\n    out.labelXFn = function (d) {\n      return d.dx + shift + (x0 + d.fontSize * ff) * flipIt;\n    };\n    out.labelYFn = function (d) {\n      return d.dy + y0 + d.fontSize * MID_SHIFT;\n    };\n    out.labelAnchorFn = function (a) {\n      if (isNumeric(a) && Math.abs(a) === 90) {\n        return 'middle';\n      }\n      return ax.side === 'right' ? 'start' : 'end';\n    };\n  }\n  return out;\n};\nfunction tickDataFn(d) {\n  return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'tick';\n  var ticks = opts.layer.selectAll('path.' + cls).data(ax.ticks ? opts.vals : [], tickDataFn);\n  ticks.exit().remove();\n  ticks.enter().append('path').classed(cls, 1).classed('ticks', 1).classed('crisp', opts.crisp !== false).call(Color.stroke, ax.tickcolor).style('stroke-width', Drawing.crispRound(gd, ax.tickwidth, 1) + 'px').attr('d', opts.path);\n  ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function (gd, ax, opts) {\n  opts = opts || {};\n  var cls = ax._id + 'grid';\n  var vals = opts.vals;\n  var counterAx = opts.counterAxis;\n  if (ax.showgrid === false) {\n    vals = [];\n  } else if (counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n    var isArrayMode = ax.tickmode === 'array';\n    for (var i = 0; i < vals.length; i++) {\n      var xi = vals[i].x;\n      if (isArrayMode ? !xi : Math.abs(xi) < ax.dtick / 100) {\n        vals = vals.slice(0, i).concat(vals.slice(i + 1));\n        // In array mode you can in principle have multiple\n        // ticks at 0, so test them all. Otherwise once we found\n        // one we can stop.\n        if (isArrayMode) i--;else break;\n      }\n    }\n  }\n  var grid = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  grid.exit().remove();\n  grid.enter().append('path').classed(cls, 1).classed('crisp', opts.crisp !== false);\n  ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n  grid.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.gridcolor || '#ddd').style('stroke-width', ax._gw + 'px');\n  if (typeof opts.path === 'function') grid.attr('d', opts.path);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function (gd, ax, opts) {\n  opts = opts || opts;\n  var cls = ax._id + 'zl';\n  var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n  var zl = opts.layer.selectAll('path.' + cls).data(show ? [{\n    x: 0,\n    id: ax._id\n  }] : []);\n  zl.exit().remove();\n  zl.enter().append('path').classed(cls, 1).classed('zl', 1).classed('crisp', opts.crisp !== false).each(function () {\n    // use the fact that only one element can enter to trigger a sort.\n    // If several zerolines enter at the same time we will sort once per,\n    // but generally this should be a minimal overhead.\n    opts.layer.selectAll('path').sort(function (da, db) {\n      return axisIds.idSort(da.id, db.id);\n    });\n  });\n  zl.attr('transform', opts.transFn).attr('d', opts.path).call(Color.stroke, ax.zerolinecolor || Color.defaultLine).style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px');\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {fn} labelXFn\n * - {fn} labelYFn\n * - {fn} labelAnchorFn\n */\naxes.drawLabels = function (gd, ax, opts) {\n  opts = opts || {};\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var cls = opts.cls || axId + 'tick';\n  var vals = opts.vals;\n  var labelXFn = opts.labelXFn;\n  var labelYFn = opts.labelYFn;\n  var labelAnchorFn = opts.labelAnchorFn;\n  var tickAngle = opts.secondary ? 0 : ax.tickangle;\n  var lastAngle = (ax._tickAngles || {})[cls];\n  var tickLabels = opts.layer.selectAll('g.' + cls).data(ax.showticklabels ? vals : [], tickDataFn);\n  var labelsReady = [];\n  tickLabels.enter().append('g').classed(cls, 1).append('text')\n  // only so tex has predictable alignment that we can\n  // alter later\n  .attr('text-anchor', 'middle').each(function (d) {\n    var thisLabel = d3.select(this);\n    var newPromise = gd._promises.length;\n    thisLabel.call(svgTextUtils.positionText, labelXFn(d), labelYFn(d)).call(Drawing.font, d.font, d.fontSize, d.fontColor).text(d.text).call(svgTextUtils.convertToTspans, gd);\n    if (gd._promises[newPromise]) {\n      // if we have an async label, we'll deal with that\n      // all here so take it out of gd._promises and\n      // instead position the label and promise this in\n      // labelsReady\n      labelsReady.push(gd._promises.pop().then(function () {\n        positionLabels(thisLabel, tickAngle);\n      }));\n    } else {\n      // sync label: just position it now.\n      positionLabels(thisLabel, tickAngle);\n    }\n  });\n  tickLabels.exit().remove();\n  if (opts.repositionOnUpdate) {\n    tickLabels.each(function (d) {\n      d3.select(this).select('text').call(svgTextUtils.positionText, labelXFn(d), labelYFn(d));\n    });\n  }\n\n  // How much to shift a multi-line label to center it vertically.\n  function getAnchorHeight(lineCount, lineHeight, angle) {\n    var h = (lineCount - 1) * lineHeight;\n    if (axLetter === 'x') {\n      if (angle < -60 || 60 < angle) {\n        return -0.5 * h;\n      } else if (ax.side === 'top') {\n        return -h;\n      }\n    } else {\n      angle *= ax.side === 'left' ? 1 : -1;\n      if (angle < -30) {\n        return -h;\n      } else if (angle < 30) {\n        return -0.5 * h;\n      }\n    }\n    return 0;\n  }\n  function positionLabels(s, angle) {\n    s.each(function (d) {\n      var thisLabel = d3.select(this);\n      var mathjaxGroup = thisLabel.select('.text-math-group');\n      var anchor = labelAnchorFn(angle, d);\n      var transform = opts.transFn.call(thisLabel.node(), d) + (isNumeric(angle) && +angle !== 0 ? ' rotate(' + angle + ',' + labelXFn(d) + ',' + (labelYFn(d) - d.fontSize / 2) + ')' : '');\n      var anchorHeight = getAnchorHeight(svgTextUtils.lineCount(thisLabel), LINE_SPACING * d.fontSize, isNumeric(angle) ? +angle : 0);\n      if (anchorHeight) {\n        transform += ' translate(0, ' + anchorHeight + ')';\n      }\n      if (mathjaxGroup.empty()) {\n        thisLabel.select('text').attr({\n          transform: transform,\n          'text-anchor': anchor\n        });\n      } else {\n        var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n        var mjShift = mjWidth * {\n          end: -0.5,\n          start: 0.5\n        }[anchor];\n        mathjaxGroup.attr('transform', transform + (mjShift ? 'translate(' + mjShift + ',0)' : ''));\n      }\n    });\n  }\n\n  // make sure all labels are correctly positioned at their base angle\n  // the positionLabels call above is only for newly drawn labels.\n  // do this without waiting, using the last calculated angle to\n  // minimize flicker, then do it again when we know all labels are\n  // there, putting back the prescribed angle to check for overlaps.\n  positionLabels(tickLabels, lastAngle || tickAngle);\n  function allLabelsReady() {\n    return labelsReady.length && Promise.all(labelsReady);\n  }\n  function fixLabelOverlaps() {\n    positionLabels(tickLabels, tickAngle);\n    var autoangle = null;\n\n    // check for auto-angling if x labels overlap\n    // don't auto-angle at all for log axes with\n    // base and digit format\n    if (vals.length && axLetter === 'x' && !isNumeric(tickAngle) && (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')) {\n      autoangle = 0;\n      var maxFontSize = 0;\n      var lbbArray = [];\n      var i;\n      tickLabels.each(function (d) {\n        maxFontSize = Math.max(maxFontSize, d.fontSize);\n        var x = ax.l2p(d.x);\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        lbbArray.push({\n          // ignore about y, just deal with x overlaps\n          top: 0,\n          bottom: 10,\n          height: 10,\n          left: x - bb.width / 2,\n          // impose a 2px gap\n          right: x + bb.width / 2 + 2,\n          width: bb.width + 2\n        });\n      });\n      if ((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n        var gap = 2;\n        if (ax.ticks) gap += ax.tickwidth / 2;\n\n        // TODO should secondary labels also fall into this fix-overlap regime?\n\n        for (i = 0; i < lbbArray.length; i++) {\n          var xbnd = vals[i].xbnd;\n          var lbb = lbbArray[i];\n          if (xbnd[0] !== null && lbb.left - ax.l2p(xbnd[0]) < gap || xbnd[1] !== null && ax.l2p(xbnd[1]) - lbb.right < gap) {\n            autoangle = 90;\n            break;\n          }\n        }\n      } else {\n        var vLen = vals.length;\n        var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n        var rotate90 = tickSpacing < maxFontSize * 2.5 || ax.type === 'multicategory';\n\n        // any overlap at all - set 30 degrees or 90 degrees\n        for (i = 0; i < lbbArray.length - 1; i++) {\n          if (Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1])) {\n            autoangle = rotate90 ? 90 : 30;\n            break;\n          }\n        }\n      }\n      if (autoangle) {\n        positionLabels(tickLabels, autoangle);\n      }\n    }\n    if (ax._tickAngles) {\n      ax._tickAngles[cls] = autoangle === null ? isNumeric(tickAngle) ? tickAngle : 0 : autoangle;\n    }\n  }\n  if (ax._selections) {\n    ax._selections[cls] = tickLabels;\n  }\n  var done = Lib.syncOrAsync([allLabelsReady, fixLabelOverlaps]);\n  if (done && done.then) gd._promises.push(done);\n  return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n  var cls = ax._id + 'divider';\n  var vals = opts.vals;\n  var dividers = opts.layer.selectAll('path.' + cls).data(vals, tickDataFn);\n  dividers.exit().remove();\n  dividers.enter().insert('path', ':first-child').classed(cls, 1).classed('crisp', 1).call(Color.stroke, ax.dividercolor).style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n  dividers.attr('transform', opts.transFn).attr('d', opts.path);\n}\nfunction drawTitle(gd, ax) {\n  var fullLayout = gd._fullLayout;\n  var axId = ax._id;\n  var axLetter = axId.charAt(0);\n  var gs = fullLayout._size;\n  var fontSize = ax.title.font.size;\n  var titleStandoff;\n  if (ax.type === 'multicategory') {\n    titleStandoff = ax._labelLength;\n  } else {\n    var offsetBase = 1.5;\n    titleStandoff = 10 + fontSize * offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n  }\n  var transform, counterAxis, x, y;\n  if (axLetter === 'x') {\n    counterAxis = ax.anchor === 'free' ? {\n      _offset: gs.t + (1 - (ax.position || 0)) * gs.h,\n      _length: 0\n    } : axisIds.getFromId(gd, ax.anchor);\n    x = ax._offset + ax._length / 2;\n    if (ax.side === 'top') {\n      y = -titleStandoff - fontSize * (ax.showticklabels ? 1 : 0);\n    } else {\n      y = counterAxis._length + titleStandoff + fontSize * (ax.showticklabels ? 1.5 : 0.5);\n    }\n    y += counterAxis._offset;\n  } else {\n    counterAxis = ax.anchor === 'free' ? {\n      _offset: gs.l + (ax.position || 0) * gs.w,\n      _length: 0\n    } : axisIds.getFromId(gd, ax.anchor);\n    y = ax._offset + ax._length / 2;\n    if (ax.side === 'right') {\n      x = counterAxis._length + titleStandoff + fontSize * (ax.showticklabels ? 1 : 0.5);\n    } else {\n      x = -titleStandoff - fontSize * (ax.showticklabels ? 0.5 : 0);\n    }\n    x += counterAxis._offset;\n    transform = {\n      rotate: '-90',\n      offset: 0\n    };\n  }\n  var avoid;\n  if (ax.type !== 'multicategory') {\n    var tickLabels = ax._selections[ax._id + 'tick'];\n    avoid = {\n      selection: tickLabels,\n      side: ax.side\n    };\n    if (tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n      var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n      avoid.offsetLeft = translation.x;\n      avoid.offsetTop = translation.y;\n    }\n  }\n  return Titles.draw(gd, axId + 'title', {\n    propContainer: ax,\n    propName: ax._name + '.title.text',\n    placeholder: fullLayout._dfltTitle[axLetter],\n    avoid: avoid,\n    transform: transform,\n    attributes: {\n      x: x,\n      y: y,\n      'text-anchor': 'middle'\n    }\n  });\n}\naxes.shouldShowZeroLine = function (gd, ax, counterAxis) {\n  var rng = Lib.simpleMap(ax.range, ax.r2l);\n  return rng[0] * rng[1] <= 0 && ax.zeroline && (ax.type === 'linear' || ax.type === '-') && ax._gridVals.length && (clipEnds(ax, 0) || !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) || hasBarsOrFill(gd, ax));\n};\naxes.clipEnds = function (ax, vals) {\n  return vals.filter(function (d) {\n    return clipEnds(ax, d.x);\n  });\n};\nfunction clipEnds(ax, l) {\n  var p = ax.l2p(l);\n  return p > 1 && p < ax._length - 1;\n}\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n  var mainCounterAxis = counterAxis._mainAxis;\n  if (!mainCounterAxis) return;\n  var fullLayout = gd._fullLayout;\n  var axLetter = ax._id.charAt(0);\n  var counterLetter = axes.counterLetter(ax._id);\n  var zeroPosition = ax._offset + (Math.abs(rng[0]) < Math.abs(rng[1]) === (axLetter === 'x') ? 0 : ax._length);\n  function lineNearZero(ax2) {\n    if (!ax2.showline || !ax2.linewidth) return false;\n    var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n    function closeEnough(pos2) {\n      return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n    }\n    if (closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n      return true;\n    }\n    var linePositions = ax2._linepositions || {};\n    for (var k in linePositions) {\n      if (closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n        return true;\n      }\n    }\n  }\n  var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n  if (!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n    return lineNearZero(counterAxis, zeroPosition);\n  }\n  var counterLetterAxes = axes.list(gd, counterLetter);\n  for (var i = 0; i < counterLetterAxes.length; i++) {\n    var counterAxis2 = counterLetterAxes[i];\n    if (counterAxis2._mainAxis === mainCounterAxis && lineNearZero(counterAxis2, zeroPosition)) {\n      return true;\n    }\n  }\n}\nfunction hasBarsOrFill(gd, ax) {\n  var fullData = gd._fullData;\n  var subplot = ax._mainSubplot;\n  var axLetter = ax._id.charAt(0);\n  for (var i = 0; i < fullData.length; i++) {\n    var trace = fullData[i];\n    if (trace.visible === true && trace.xaxis + trace.yaxis === subplot && (Registry.traceIs(trace, 'bar') && trace.orientation === {\n      x: 'h',\n      y: 'v'\n    }[axLetter] || trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction selectTickLabel(gTick) {\n  var s = d3.select(gTick);\n  var mj = s.select('.text-math-group');\n  return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function (gd) {\n  var axList = axes.list(gd, '', true);\n  for (var i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.automargin) {\n      Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n    }\n    if (Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n      Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n    }\n  }\n};\nfunction axAutoMarginID(ax) {\n  return ax._id + '.automargin';\n}\nfunction rangeSliderAutoMarginID(ax) {\n  return ax._id + '.rangeslider';\n}\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function (gd, traces) {\n  var axGroups = makeAxisGroups(gd, traces);\n  for (var i = 0; i < axGroups.length; i++) {\n    swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n  }\n};\nfunction makeAxisGroups(gd, traces) {\n  var groups = [];\n  var i, j;\n  for (i = 0; i < traces.length; i++) {\n    var groupsi = [];\n    var xi = gd._fullData[traces[i]].xaxis;\n    var yi = gd._fullData[traces[i]].yaxis;\n    if (!xi || !yi) continue; // not a 2D cartesian trace?\n\n    for (j = 0; j < groups.length; j++) {\n      if (groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n        groupsi.push(j);\n      }\n    }\n    if (!groupsi.length) {\n      groups.push({\n        x: [xi],\n        y: [yi]\n      });\n      continue;\n    }\n    var group0 = groups[groupsi[0]];\n    var groupj;\n    if (groupsi.length > 1) {\n      for (j = 1; j < groupsi.length; j++) {\n        groupj = groups[groupsi[j]];\n        mergeAxisGroups(group0.x, groupj.x);\n        mergeAxisGroups(group0.y, groupj.y);\n      }\n    }\n    mergeAxisGroups(group0.x, [xi]);\n    mergeAxisGroups(group0.y, [yi]);\n  }\n  return groups;\n}\nfunction mergeAxisGroups(intoSet, fromSet) {\n  for (var i = 0; i < fromSet.length; i++) {\n    if (intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n  }\n}\nfunction swapAxisGroup(gd, xIds, yIds) {\n  var xFullAxes = [];\n  var yFullAxes = [];\n  var layout = gd.layout;\n  var i, j;\n  for (i = 0; i < xIds.length; i++) {\n    xFullAxes.push(axes.getFromId(gd, xIds[i]));\n  }\n  for (i = 0; i < yIds.length; i++) {\n    yFullAxes.push(axes.getFromId(gd, yIds[i]));\n  }\n  var allAxKeys = Object.keys(axAttrs);\n  var noSwapAttrs = ['anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'];\n  var numericTypes = ['linear', 'log'];\n  for (i = 0; i < allAxKeys.length; i++) {\n    var keyi = allAxKeys[i];\n    var xVal = xFullAxes[0][keyi];\n    var yVal = yFullAxes[0][keyi];\n    var allEqual = true;\n    var coerceLinearX = false;\n    var coerceLinearY = false;\n    if (keyi.charAt(0) === '_' || typeof xVal === 'function' || noSwapAttrs.indexOf(keyi) !== -1) {\n      continue;\n    }\n    for (j = 1; j < xFullAxes.length && allEqual; j++) {\n      var xVali = xFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(xVal) !== -1 && numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearX = true;\n      } else if (xVali !== xVal) allEqual = false;\n    }\n    for (j = 1; j < yFullAxes.length && allEqual; j++) {\n      var yVali = yFullAxes[j][keyi];\n      if (keyi === 'type' && numericTypes.indexOf(yVal) !== -1 && numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n        // type is special - if we find a mixture of linear and log,\n        // coerce them all to linear on flipping\n        coerceLinearY = true;\n      } else if (yFullAxes[j][keyi] !== yVal) allEqual = false;\n    }\n    if (allEqual) {\n      if (coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n      if (coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n      swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n    }\n  }\n\n  // now swap x&y for any annotations anchored to these x & y\n  for (i = 0; i < gd._fullLayout.annotations.length; i++) {\n    var ann = gd._fullLayout.annotations[i];\n    if (xIds.indexOf(ann.xref) !== -1 && yIds.indexOf(ann.yref) !== -1) {\n      Lib.swapAttrs(layout.annotations[i], ['?']);\n    }\n  }\n}\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n  // in case the value is the default for either axis,\n  // look at the first axis in each list and see if\n  // this key's value is undefined\n  var np = Lib.nestedProperty;\n  var xVal = np(layout[xFullAxes[0]._name], key).get();\n  var yVal = np(layout[yFullAxes[0]._name], key).get();\n  var i;\n  if (key === 'title') {\n    // special handling of placeholder titles\n    if (xVal && xVal.text === dfltTitle.x) {\n      xVal.text = dfltTitle.y;\n    }\n    if (yVal && yVal.text === dfltTitle.y) {\n      yVal.text = dfltTitle.x;\n    }\n  }\n  for (i = 0; i < xFullAxes.length; i++) {\n    np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n  }\n  for (i = 0; i < yFullAxes.length; i++) {\n    np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n  }\n}\nfunction isAngular(ax) {\n  return ax._id === 'angularaxis';\n}","map":{"version":3,"names":["d3","require","isNumeric","Plots","Registry","Lib","svgTextUtils","Titles","Color","Drawing","axAttrs","cleanTicks","constants","ONEAVGYEAR","ONEAVGMONTH","ONEDAY","ONEHOUR","ONEMIN","ONESEC","MINUS_SIGN","BADNUM","MID_SHIFT","LINE_SPACING","axes","module","exports","setConvert","autoType","axisIds","id2name","name2id","cleanId","list","listIds","getFromId","getFromTrace","autorange","getAutoRange","findExtremes","coerceRef","containerIn","containerOut","gd","attr","dflt","extraOption","axLetter","charAt","length","axlist","_fullLayout","_subplots","refAttr","attrDef","valType","values","concat","coerce","coercePosition","axRef","cleanPos","pos","ensureNumber","ax","fraction2r","cleanPosition","redrawComponents","axIds","fullLayout","_redrawOneComp","moduleName","methodName","stashName","shortCircuit","method","getComponentMethod","stash","i","indices","j","ind","getDataConversions","trace","target","targetArray","d2cTarget","Array","isArray","type","_categories","d2c","c2d","toString","toNum","v","String","getDataToCoordFunc","counterLetter","id","minDtick","newDiff","newFirst","allow","indexOf","_minDtick","undefined","_forceTick0","saveRangeInitial","overwrite","axList","hasOneAxisChanged","isNew","_rangeInitial","hasChanged","range","slice","saveShowSpikeInitial","allSpikesEnabled","_showSpikeInitial","showspikes","_showspikes","_cartesianSpikesEnabled","autoBin","data","nbins","is2d","calendar","size","dataMin","aggNums","Math","min","dataMax","max","start","end","round","_dataSpan","dummyAx","simpleMap","c2r","dtick","tick0","size0","distinctData","distinctVals","msexp","pow","floor","log","minDiff","LN10","minSize","roundUp","stdev","autoTicks","finalSize","binStart","tickIncrement","tickFirst","binEnd","bincount","autoShiftNumericBins","autoShiftMonthBins","edgecount","midcount","intcount","blankCount","nearEdge","dataCount","binshift","stats","findExactDates","threshold","exactDays","numMonths","Number","substr","exactYears","exactMonths","nextBinStart","prepTicks","rng","r2l","tickmode","nt","nticks","minPx","tickfont","_length","_id","constrain","_name","abs","l2r","autoTickRound","calcTicks","arrayTicks","_tmin","startTick","endTick","axrev","vals","xPrevious","maxTicks","x","push","isAngular","pop","_tmax","_prevDateHead","_inCalcTicks","ticksOut","tickText","tickvals","text","ticktext","r0expanded","r1expanded","tickMin","tickMax","tickVal2l","d2l_noadd","d2l","vali","tickTextObj","splice","roundBase10","roundBase24","roundBase60","roundDays","roundLog1","roundLog2","roundAngles","roundDTick","roughDTick","base","roundingSet","getBase","dateTick0","roughX2","ceil","olddtick","_tickexponent","_tickround","tick0ms","tick0str","replace","tick0len","tick1len","map","r2d","maxend","rangeexp","isSIFormat","exponentformat","beyondSI","axSign","tType","dtSigned","incrementMonth","tickset","x2","frac","mod","sRound","r0","tmin","dtNum","cnt","t0","t1","mult","newDTick","error","hover","out","arrayMode","extraPrecision","axType","isHidden","showAttr","firstOrLast","first","last","hideexp","showexponent","formatDate","formatLog","formatCategory","formatMultiCategory","formatAngle","formatLinear","tickprefix","showtickprefix","ticksuffix","showticksuffix","tickson","showdividers","inbounds","p","l2p","xbnd","hoverLabelText","val","val2","logOffScale","tx","c2l","tf","dx","dy","fontSize","font","family","fontColor","color","tr","fmt","hoverformat","getTickFormat","y","m","d","M","S","dateStr","_dateFormat","_extraFormat","headStr","splitIndex","tickformat","dtChar0","numFormat","absP","exponentFormat","firstChar","tt","cats","tt2","text2","thetaunit","num","num2frac","deg2rad","isNeg","join","almostEq","a","b","findGCD","findPrecision","n","e","precision","number","gcd","SIPREFIXES","exponent","fmtoverride","tickRound","separatethousands","ah","_numFormat","dp","numSeparate","_separators","signedExponent","convertToMs","compareLogTicks","left","right","priority","leftPriority","rightPriority","isProperStop","convert","convertFn","leftDtick","rightDtick","isProperLogStop","isLeftDtickNull","isRightDtickNull","isDtickInRangeLeft","isDtickInRangeRight","tickstop","stopi","tickformatstops","enabled","dtickrange","value","getSubplots","subplotObj","allSubplots","cartesian","gl2d","findSubplotsWithAxis","sort","aParts","split","bParts","subplots","axMatch","RegExp","subplotsWithAx","sp","test","makeClipPaths","_hasOnlyLargeSploms","fullWidth","_offset","width","fullHeight","height","xaList","yaList","clipList","axClips","_clips","selectAll","enter","append","classed","_uid","exit","remove","each","select","draw","arg","opts","_paper","plotinfo","_plots","xa","xaxis","ya","yaxis","xaxislayer","yaxislayer","gridlayer","zerolinelayer","_infolayer","syncOrAsync","axId","axDone","drawOne","_r","_rl","setScale","mainSubplot","_mainSubplot","mainLinePosition","_mainLinePosition","mainMirrorPosition","_mainMirrorPosition","mainPlotinfo","mainAxLayer","_subplotsWith","_vals","axInfo","mirror","visible","_selections","_tickAngles","transFn","makeTransFn","tickVals","valsClipped","boundaryVals","getBoundaryVals","clipEnds","ticks","gridVals","_gridVals","dividerVals","getDividerVals","finishedGrids","counterAxis","mainCounterID","_mainAxis","gridPath","drawGrid","layer","path","drawZeroLine","tickSigns","getTickSigns","tickSubplots","mainTickPath","makeTickPath","mirrorTickPath","fullTickPath","_anchorAxis","tickPath","dividerLookup","drawTicks","Object","keys","_linepositions","linepositions","spTickPath","seq","labelFns","makeLabelFns","drawLabels","labelXFn","labelYFn","labelAnchorFn","labelLength","pad","sgn","getLabelLevelSpan","secondaryPosition","secondaryLabelFns","getSecondaryLabelVals","cls","repositionOnUpdate","secondary","_labelLength","drawDividers","extendRange","newRange","calcBoundingBox","showticklabels","gdBB","getBoundingClientRect","bBox","node","_boundingBox","top","bottom","gs","_size","anchor","t","h","position","domain","side","l","w","fullRange","_counterSpan","Infinity","hasRangeSlider","doAutoMargins","s","rangeSliderPush","autoMargin","rangeSliderAutoMarginID","automargin","r","bbox","counterAx","anchorAxDomainIndex","offset","title","_dfltTitle","axAutoMarginID","skipTitle","drawTitle","_push","bndIndex","xb","extendFlat","lookup","k","interp","current","angle","rad","sinA","sin","cosA","cos","maxX","maxY","thisLabel","selectTickLabel","bb","sideOpposite","main","shift","len","ticklen","linewidth","ticksOnOutsideLabels","labelStandoff","labelShift","showline","x0","y0","ff","flipIt","tickangle","tickDataFn","crisp","call","stroke","tickcolor","style","crispRound","tickwidth","showgrid","shouldShowZeroLine","isArrayMode","xi","grid","_gw","gridwidth","gridcolor","show","zl","da","db","idSort","zerolinecolor","defaultLine","zerolinewidth","tickAngle","lastAngle","tickLabels","labelsReady","newPromise","_promises","positionText","convertToTspans","then","positionLabels","getAnchorHeight","lineCount","lineHeight","mathjaxGroup","transform","anchorHeight","empty","mjWidth","mjShift","allLabelsReady","Promise","all","fixLabelOverlaps","autoangle","maxFontSize","lbbArray","gap","lbb","vLen","tickSpacing","_m","rotate90","bBoxIntersect","done","dividers","insert","dividercolor","dividerwidth","titleStandoff","offsetBase","rotate","avoid","selection","parentNode","translation","getTranslate","offsetLeft","offsetTop","propContainer","propName","placeholder","attributes","zeroline","anyCounterAxLineAtZero","hasBarsOrFill","filter","mainCounterAxis","zeroPosition","lineNearZero","ax2","tolerance","closeEnough","pos2","linePositions","mainplotinfo","overlays","counterLetterAxes","counterAxis2","fullData","_fullData","subplot","traceIs","orientation","fill","gTick","mj","allowAutoMargin","swap","traces","axGroups","makeAxisGroups","swapAxisGroup","groups","groupsi","yi","group0","groupj","mergeAxisGroups","intoSet","fromSet","xIds","yIds","xFullAxes","yFullAxes","layout","allAxKeys","noSwapAttrs","numericTypes","keyi","xVal","yVal","allEqual","coerceLinearX","coerceLinearY","xVali","yVali","swapAxisAttrs","annotations","ann","xref","yref","swapAttrs","key","dfltTitle","np","nestedProperty","get","set"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plots/cartesian/axes.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar Plots = require('../../plots/plots');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar Titles = require('../../components/titles');\nvar Color = require('../../components/color');\nvar Drawing = require('../../components/drawing');\n\nvar axAttrs = require('./layout_attributes');\nvar cleanTicks = require('./clean_ticks');\n\nvar constants = require('../../constants/numerical');\nvar ONEAVGYEAR = constants.ONEAVGYEAR;\nvar ONEAVGMONTH = constants.ONEAVGMONTH;\nvar ONEDAY = constants.ONEDAY;\nvar ONEHOUR = constants.ONEHOUR;\nvar ONEMIN = constants.ONEMIN;\nvar ONESEC = constants.ONESEC;\nvar MINUS_SIGN = constants.MINUS_SIGN;\nvar BADNUM = constants.BADNUM;\n\nvar MID_SHIFT = require('../../constants/alignment').MID_SHIFT;\nvar LINE_SPACING = require('../../constants/alignment').LINE_SPACING;\n\nvar axes = module.exports = {};\n\naxes.setConvert = require('./set_convert');\nvar autoType = require('./axis_autotype');\n\nvar axisIds = require('./axis_ids');\naxes.id2name = axisIds.id2name;\naxes.name2id = axisIds.name2id;\naxes.cleanId = axisIds.cleanId;\naxes.list = axisIds.list;\naxes.listIds = axisIds.listIds;\naxes.getFromId = axisIds.getFromId;\naxes.getFromTrace = axisIds.getFromTrace;\n\nvar autorange = require('./autorange');\naxes.getAutoRange = autorange.getAutoRange;\naxes.findExtremes = autorange.findExtremes;\n\n/*\n * find the list of possible axes to reference with an xref or yref attribute\n * and coerce it to that list\n *\n * attr: the attribute we're generating a reference for. Should end in 'x' or 'y'\n *     but can be prefixed, like 'ax' for annotation's arrow x\n * dflt: the default to coerce to, or blank to use the first axis (falling back on\n *     extraOption if there is no axis)\n * extraOption: aside from existing axes with this letter, what non-axis value is allowed?\n *     Only required if it's different from `dflt`\n */\naxes.coerceRef = function(containerIn, containerOut, gd, attr, dflt, extraOption) {\n    var axLetter = attr.charAt(attr.length - 1);\n    var axlist = gd._fullLayout._subplots[axLetter + 'axis'];\n    var refAttr = attr + 'ref';\n    var attrDef = {};\n\n    if(!dflt) dflt = axlist[0] || extraOption;\n    if(!extraOption) extraOption = dflt;\n\n    // data-ref annotations are not supported in gl2d yet\n\n    attrDef[refAttr] = {\n        valType: 'enumerated',\n        values: axlist.concat(extraOption ? [extraOption] : []),\n        dflt: dflt\n    };\n\n    // xref, yref\n    return Lib.coerce(containerIn, containerOut, attrDef, refAttr);\n};\n\n/*\n * coerce position attributes (range-type) that can be either on axes or absolute\n * (paper or pixel) referenced. The biggest complication here is that we don't know\n * before looking at the axis whether the value must be a number or not (it may be\n * a date string), so we can't use the regular valType='number' machinery\n *\n * axRef (string): the axis this position is referenced to, or:\n *     paper: fraction of the plot area\n *     pixel: pixels relative to some starting position\n * attr (string): the attribute in containerOut we are coercing\n * dflt (number): the default position, as a fraction or pixels. If the attribute\n *     is to be axis-referenced, this will be converted to an axis data value\n *\n * Also cleans the values, since the attribute definition itself has to say\n * valType: 'any' to handle date axes. This allows us to accept:\n * - for category axes: category names, and convert them here into serial numbers.\n *   Note that this will NOT work for axis range endpoints, because we don't know\n *   the category list yet (it's set by ax.makeCalcdata during calc)\n *   but it works for component (note, shape, images) positions.\n * - for date axes: JS Dates or milliseconds, and convert to date strings\n * - for other types: coerce them to numbers\n */\naxes.coercePosition = function(containerOut, gd, coerce, axRef, attr, dflt) {\n    var cleanPos, pos;\n\n    if(axRef === 'paper' || axRef === 'pixel') {\n        cleanPos = Lib.ensureNumber;\n        pos = coerce(attr, dflt);\n    } else {\n        var ax = axes.getFromId(gd, axRef);\n        dflt = ax.fraction2r(dflt);\n        pos = coerce(attr, dflt);\n        cleanPos = ax.cleanPos;\n    }\n\n    containerOut[attr] = cleanPos(pos);\n};\n\naxes.cleanPosition = function(pos, gd, axRef) {\n    var cleanPos = (axRef === 'paper' || axRef === 'pixel') ?\n        Lib.ensureNumber :\n        axes.getFromId(gd, axRef).cleanPos;\n\n    return cleanPos(pos);\n};\n\naxes.redrawComponents = function(gd, axIds) {\n    axIds = axIds ? axIds : axes.listIds(gd);\n\n    var fullLayout = gd._fullLayout;\n\n    function _redrawOneComp(moduleName, methodName, stashName, shortCircuit) {\n        var method = Registry.getComponentMethod(moduleName, methodName);\n        var stash = {};\n\n        for(var i = 0; i < axIds.length; i++) {\n            var ax = fullLayout[axes.id2name(axIds[i])];\n            var indices = ax[stashName];\n\n            for(var j = 0; j < indices.length; j++) {\n                var ind = indices[j];\n\n                if(!stash[ind]) {\n                    method(gd, ind);\n                    stash[ind] = 1;\n                    // once is enough for images (which doesn't use the `i` arg anyway)\n                    if(shortCircuit) return;\n                }\n            }\n        }\n    }\n\n    // annotations and shapes 'draw' method is slow,\n    // use the finer-grained 'drawOne' method instead\n    _redrawOneComp('annotations', 'drawOne', '_annIndices');\n    _redrawOneComp('shapes', 'drawOne', '_shapeIndices');\n    _redrawOneComp('images', 'draw', '_imgIndices', true);\n};\n\nvar getDataConversions = axes.getDataConversions = function(gd, trace, target, targetArray) {\n    var ax;\n\n    // If target points to an axis, use the type we already have for that\n    // axis to find the data type. Otherwise use the values to autotype.\n    var d2cTarget = (target === 'x' || target === 'y' || target === 'z') ?\n        target :\n        targetArray;\n\n    // In the case of an array target, make a mock data array\n    // and call supplyDefaults to the data type and\n    // setup the data-to-calc method.\n    if(Array.isArray(d2cTarget)) {\n        ax = {\n            type: autoType(targetArray),\n            _categories: []\n        };\n        axes.setConvert(ax);\n\n        // build up ax._categories (usually done during ax.makeCalcdata()\n        if(ax.type === 'category') {\n            for(var i = 0; i < targetArray.length; i++) {\n                ax.d2c(targetArray[i]);\n            }\n        }\n        // TODO what to do for transforms?\n    } else {\n        ax = axes.getFromTrace(gd, trace, d2cTarget);\n    }\n\n    // if 'target' has corresponding axis\n    // -> use setConvert method\n    if(ax) return {d2c: ax.d2c, c2d: ax.c2d};\n\n    // special case for 'ids'\n    // -> cast to String\n    if(d2cTarget === 'ids') return {d2c: toString, c2d: toString};\n\n    // otherwise (e.g. numeric-array of 'marker.color' or 'marker.size')\n    // -> cast to Number\n\n    return {d2c: toNum, c2d: toNum};\n};\n\nfunction toNum(v) { return +v; }\nfunction toString(v) { return String(v); }\n\naxes.getDataToCoordFunc = function(gd, trace, target, targetArray) {\n    return getDataConversions(gd, trace, target, targetArray).d2c;\n};\n\n// get counteraxis letter for this axis (name or id)\n// this can also be used as the id for default counter axis\naxes.counterLetter = function(id) {\n    var axLetter = id.charAt(0);\n    if(axLetter === 'x') return 'y';\n    if(axLetter === 'y') return 'x';\n};\n\n// incorporate a new minimum difference and first tick into\n// forced\n// note that _forceTick0 is linearized, so needs to be turned into\n// a range value for setting tick0\naxes.minDtick = function(ax, newDiff, newFirst, allow) {\n    // doesn't make sense to do forced min dTick on log or category axes,\n    // and the plot itself may decide to cancel (ie non-grouped bars)\n    if(['log', 'category', 'multicategory'].indexOf(ax.type) !== -1 || !allow) {\n        ax._minDtick = 0;\n    }\n    // undefined means there's nothing there yet\n    else if(ax._minDtick === undefined) {\n        ax._minDtick = newDiff;\n        ax._forceTick0 = newFirst;\n    }\n    else if(ax._minDtick) {\n        // existing minDtick is an integer multiple of newDiff\n        // (within rounding err)\n        // and forceTick0 can be shifted to newFirst\n        if((ax._minDtick / newDiff + 1e-6) % 1 < 2e-6 &&\n                (((newFirst - ax._forceTick0) / newDiff % 1) +\n                    1.000001) % 1 < 2e-6) {\n            ax._minDtick = newDiff;\n            ax._forceTick0 = newFirst;\n        }\n        // if the converse is true (newDiff is a multiple of minDtick and\n        // newFirst can be shifted to forceTick0) then do nothing - same\n        // forcing stands. Otherwise, cancel forced minimum\n        else if((newDiff / ax._minDtick + 1e-6) % 1 > 2e-6 ||\n                (((newFirst - ax._forceTick0) / ax._minDtick % 1) +\n                    1.000001) % 1 > 2e-6) {\n            ax._minDtick = 0;\n        }\n    }\n};\n\n// save a copy of the initial axis ranges in fullLayout\n// use them in mode bar and dblclick events\naxes.saveRangeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._rangeInitial === undefined);\n        var hasChanged = isNew || !(\n            ax.range[0] === ax._rangeInitial[0] &&\n            ax.range[1] === ax._rangeInitial[1]\n        );\n\n        if((isNew && ax.autorange === false) || (overwrite && hasChanged)) {\n            ax._rangeInitial = ax.range.slice();\n            hasOneAxisChanged = true;\n        }\n    }\n\n    return hasOneAxisChanged;\n};\n\n// save a copy of the initial spike visibility\naxes.saveShowSpikeInitial = function(gd, overwrite) {\n    var axList = axes.list(gd, '', true);\n    var hasOneAxisChanged = false;\n    var allSpikesEnabled = 'on';\n\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        var isNew = (ax._showSpikeInitial === undefined);\n        var hasChanged = isNew || !(ax.showspikes === ax._showspikes);\n\n        if(isNew || (overwrite && hasChanged)) {\n            ax._showSpikeInitial = ax.showspikes;\n            hasOneAxisChanged = true;\n        }\n\n        if(allSpikesEnabled === 'on' && !ax.showspikes) {\n            allSpikesEnabled = 'off';\n        }\n    }\n    gd._fullLayout._cartesianSpikesEnabled = allSpikesEnabled;\n    return hasOneAxisChanged;\n};\n\naxes.autoBin = function(data, ax, nbins, is2d, calendar, size) {\n    var dataMin = Lib.aggNums(Math.min, null, data);\n    var dataMax = Lib.aggNums(Math.max, null, data);\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        return {\n            start: dataMin - 0.5,\n            end: dataMax + 0.5,\n            size: Math.max(1, Math.round(size) || 1),\n            _dataSpan: dataMax - dataMin,\n        };\n    }\n\n    if(!calendar) calendar = ax.calendar;\n\n    // piggyback off tick code to make \"nice\" bin sizes and edges\n    var dummyAx;\n    if(ax.type === 'log') {\n        dummyAx = {\n            type: 'linear',\n            range: [dataMin, dataMax]\n        };\n    } else {\n        dummyAx = {\n            type: ax.type,\n            range: Lib.simpleMap([dataMin, dataMax], ax.c2r, 0, calendar),\n            calendar: calendar\n        };\n    }\n    axes.setConvert(dummyAx);\n\n    size = size && cleanTicks.dtick(size, dummyAx.type);\n\n    if(size) {\n        dummyAx.dtick = size;\n        dummyAx.tick0 = cleanTicks.tick0(undefined, dummyAx.type, calendar);\n    }\n    else {\n        var size0;\n        if(nbins) size0 = ((dataMax - dataMin) / nbins);\n        else {\n            // totally auto: scale off std deviation so the highest bin is\n            // somewhat taller than the total number of bins, but don't let\n            // the size get smaller than the 'nice' rounded down minimum\n            // difference between values\n            var distinctData = Lib.distinctVals(data);\n            var msexp = Math.pow(10, Math.floor(\n                Math.log(distinctData.minDiff) / Math.LN10));\n            var minSize = msexp * Lib.roundUp(\n                distinctData.minDiff / msexp, [0.9, 1.9, 4.9, 9.9], true);\n            size0 = Math.max(minSize, 2 * Lib.stdev(data) /\n                Math.pow(data.length, is2d ? 0.25 : 0.4));\n\n            // fallback if ax.d2c output BADNUMs\n            // e.g. when user try to plot categorical bins\n            // on a layout.xaxis.type: 'linear'\n            if(!isNumeric(size0)) size0 = 1;\n        }\n\n        axes.autoTicks(dummyAx, size0);\n    }\n\n\n    var finalSize = dummyAx.dtick;\n    var binStart = axes.tickIncrement(\n            axes.tickFirst(dummyAx), finalSize, 'reverse', calendar);\n    var binEnd, bincount;\n\n    // check for too many data points right at the edges of bins\n    // (>50% within 1% of bin edges) or all data points integral\n    // and offset the bins accordingly\n    if(typeof finalSize === 'number') {\n        binStart = autoShiftNumericBins(binStart, data, dummyAx, dataMin, dataMax);\n\n        bincount = 1 + Math.floor((dataMax - binStart) / finalSize);\n        binEnd = binStart + bincount * finalSize;\n    }\n    else {\n        // month ticks - should be the only nonlinear kind we have at this point.\n        // dtick (as supplied by axes.autoTick) only has nonlinear values on\n        // date and log axes, but even if you display a histogram on a log axis\n        // we bin it on a linear axis (which one could argue against, but that's\n        // a separate issue)\n        if(dummyAx.dtick.charAt(0) === 'M') {\n            binStart = autoShiftMonthBins(binStart, data, finalSize, dataMin, calendar);\n        }\n\n        // calculate the endpoint for nonlinear ticks - you have to\n        // just increment until you're done\n        binEnd = binStart;\n        bincount = 0;\n        while(binEnd <= dataMax) {\n            binEnd = axes.tickIncrement(binEnd, finalSize, false, calendar);\n            bincount++;\n        }\n    }\n\n    return {\n        start: ax.c2r(binStart, 0, calendar),\n        end: ax.c2r(binEnd, 0, calendar),\n        size: finalSize,\n        _dataSpan: dataMax - dataMin\n    };\n};\n\n\nfunction autoShiftNumericBins(binStart, data, ax, dataMin, dataMax) {\n    var edgecount = 0;\n    var midcount = 0;\n    var intcount = 0;\n    var blankCount = 0;\n\n    function nearEdge(v) {\n        // is a value within 1% of a bin edge?\n        return (1 + (v - binStart) * 100 / ax.dtick) % 100 < 2;\n    }\n\n    for(var i = 0; i < data.length; i++) {\n        if(data[i] % 1 === 0) intcount++;\n        else if(!isNumeric(data[i])) blankCount++;\n\n        if(nearEdge(data[i])) edgecount++;\n        if(nearEdge(data[i] + ax.dtick / 2)) midcount++;\n    }\n    var dataCount = data.length - blankCount;\n\n    if(intcount === dataCount && ax.type !== 'date') {\n        // all integers: if bin size is <1, it's because\n        // that was specifically requested (large nbins)\n        // so respect that... but center the bins containing\n        // integers on those integers\n        if(ax.dtick < 1) {\n            binStart = dataMin - 0.5 * ax.dtick;\n        }\n        // otherwise start half an integer down regardless of\n        // the bin size, just enough to clear up endpoint\n        // ambiguity about which integers are in which bins.\n        else {\n            binStart -= 0.5;\n            if(binStart + ax.dtick < dataMin) binStart += ax.dtick;\n        }\n    }\n    else if(midcount < dataCount * 0.1) {\n        if(edgecount > dataCount * 0.3 ||\n                nearEdge(dataMin) || nearEdge(dataMax)) {\n            // lots of points at the edge, not many in the middle\n            // shift half a bin\n            var binshift = ax.dtick / 2;\n            binStart += (binStart + binshift < dataMin) ? binshift : -binshift;\n        }\n    }\n    return binStart;\n}\n\n\nfunction autoShiftMonthBins(binStart, data, dtick, dataMin, calendar) {\n    var stats = Lib.findExactDates(data, calendar);\n    // number of data points that needs to be an exact value\n    // to shift that increment to (near) the bin center\n    var threshold = 0.8;\n\n    if(stats.exactDays > threshold) {\n        var numMonths = Number(dtick.substr(1));\n\n        if((stats.exactYears > threshold) && (numMonths % 12 === 0)) {\n            // The exact middle of a non-leap-year is 1.5 days into July\n            // so if we start the bins here, all but leap years will\n            // get hover-labeled as exact years.\n            binStart = axes.tickIncrement(binStart, 'M6', 'reverse') + ONEDAY * 1.5;\n        }\n        else if(stats.exactMonths > threshold) {\n            // Months are not as clean, but if we shift half the *longest*\n            // month (31/2 days) then 31-day months will get labeled exactly\n            // and shorter months will get labeled with the correct month\n            // but shifted 12-36 hours into it.\n            binStart = axes.tickIncrement(binStart, 'M1', 'reverse') + ONEDAY * 15.5;\n        }\n        else {\n            // Shifting half a day is exact, but since these are month bins it\n            // will always give a somewhat odd-looking label, until we do something\n            // smarter like showing the bin boundaries (or the bounds of the actual\n            // data in each bin)\n            binStart -= ONEDAY / 2;\n        }\n        var nextBinStart = axes.tickIncrement(binStart, dtick);\n\n        if(nextBinStart <= dataMin) return nextBinStart;\n    }\n    return binStart;\n}\n\n// ----------------------------------------------------\n// Ticks and grids\n// ----------------------------------------------------\n\n// ensure we have tick0, dtick, and tick rounding calculated\naxes.prepTicks = function(ax) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n    // calculate max number of (auto) ticks to display based on plot size\n    if(ax.tickmode === 'auto' || !ax.dtick) {\n        var nt = ax.nticks;\n        var minPx;\n\n        if(!nt) {\n            if(ax.type === 'category' || ax.type === 'multicategory') {\n                minPx = ax.tickfont ? (ax.tickfont.size || 12) * 1.2 : 15;\n                nt = ax._length / minPx;\n            } else {\n                minPx = ax._id.charAt(0) === 'y' ? 40 : 80;\n                nt = Lib.constrain(ax._length / minPx, 4, 9) + 1;\n            }\n\n            // radial axes span half their domain,\n            // multiply nticks value by two to get correct number of auto ticks.\n            if(ax._name === 'radialaxis') nt *= 2;\n        }\n\n        // add a couple of extra digits for filling in ticks when we\n        // have explicit tickvals without tick text\n        if(ax.tickmode === 'array') nt *= 100;\n\n        axes.autoTicks(ax, Math.abs(rng[1] - rng[0]) / nt);\n        // check for a forced minimum dtick\n        if(ax._minDtick > 0 && ax.dtick < ax._minDtick * 2) {\n            ax.dtick = ax._minDtick;\n            ax.tick0 = ax.l2r(ax._forceTick0);\n        }\n    }\n\n    // check for missing tick0\n    if(!ax.tick0) {\n        ax.tick0 = (ax.type === 'date') ? '2000-01-01' : 0;\n    }\n\n    // ensure we don't try to make ticks below our minimum precision\n    // see https://github.com/plotly/plotly.js/issues/2892\n    if(ax.type === 'date' && ax.dtick < 0.1) ax.dtick = 0.1;\n\n    // now figure out rounding of tick values\n    autoTickRound(ax);\n};\n\n// calculate the ticks: text, values, positioning\n// if ticks are set to automatic, determine the right values (tick0,dtick)\n// in any case, set tickround to # of digits to round tick labels to,\n// or codes to this effect for log and date scales\naxes.calcTicks = function calcTicks(ax) {\n    axes.prepTicks(ax);\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n    // now that we've figured out the auto values for formatting\n    // in case we're missing some ticktext, we can break out for array ticks\n    if(ax.tickmode === 'array') return arrayTicks(ax);\n\n    // find the first tick\n    ax._tmin = axes.tickFirst(ax);\n\n    // add a tiny bit so we get ticks which may have rounded out\n    var startTick = rng[0] * 1.0001 - rng[1] * 0.0001;\n    var endTick = rng[1] * 1.0001 - rng[0] * 0.0001;\n    // check for reversed axis\n    var axrev = (rng[1] < rng[0]);\n\n    // No visible ticks? Quit.\n    // I've only seen this on category axes with all categories off the edge.\n    if((ax._tmin < startTick) !== axrev) return [];\n\n    // return the full set of tick vals\n    var vals = [];\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        endTick = (axrev) ? Math.max(-0.5, endTick) :\n            Math.min(ax._categories.length - 0.5, endTick);\n    }\n\n    var xPrevious = null;\n    var maxTicks = Math.max(1000, ax._length || 0);\n    for(var x = ax._tmin;\n            (axrev) ? (x >= endTick) : (x <= endTick);\n            x = axes.tickIncrement(x, ax.dtick, axrev, ax.calendar)) {\n        // prevent infinite loops - no more than one tick per pixel,\n        // and make sure each value is different from the previous\n        if(vals.length > maxTicks || x === xPrevious) break;\n        xPrevious = x;\n\n        vals.push(x);\n    }\n\n    // If same angle over a full circle, the last tick vals is a duplicate.\n    // TODO must do something similar for angular date axes.\n    if(isAngular(ax) && Math.abs(rng[1] - rng[0]) === 360) {\n        vals.pop();\n    }\n\n    // save the last tick as well as first, so we can\n    // show the exponent only on the last one\n    ax._tmax = vals[vals.length - 1];\n\n    // for showing the rest of a date when the main tick label is only the\n    // latter part: ax._prevDateHead holds what we showed most recently.\n    // Start with it cleared and mark that we're in calcTicks (ie calculating a\n    // whole string of these so we should care what the previous date head was!)\n    ax._prevDateHead = '';\n    ax._inCalcTicks = true;\n\n    var ticksOut = new Array(vals.length);\n    for(var i = 0; i < vals.length; i++) ticksOut[i] = axes.tickText(ax, vals[i]);\n\n    ax._inCalcTicks = false;\n\n    return ticksOut;\n};\n\nfunction arrayTicks(ax) {\n    var vals = ax.tickvals;\n    var text = ax.ticktext;\n    var ticksOut = new Array(vals.length);\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    var r0expanded = rng[0] * 1.0001 - rng[1] * 0.0001;\n    var r1expanded = rng[1] * 1.0001 - rng[0] * 0.0001;\n    var tickMin = Math.min(r0expanded, r1expanded);\n    var tickMax = Math.max(r0expanded, r1expanded);\n    var j = 0;\n\n    // without a text array, just format the given values as any other ticks\n    // except with more precision to the numbers\n    if(!Array.isArray(text)) text = [];\n\n    // make sure showing ticks doesn't accidentally add new categories\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = ax.type === 'category' ? ax.d2l_noadd : ax.d2l;\n\n    // array ticks on log axes always show the full number\n    // (if no explicit ticktext overrides it)\n    if(ax.type === 'log' && String(ax.dtick).charAt(0) !== 'L') {\n        ax.dtick = 'L' + Math.pow(10, Math.floor(Math.min(ax.range[0], ax.range[1])) - 1);\n    }\n\n    for(var i = 0; i < vals.length; i++) {\n        var vali = tickVal2l(vals[i]);\n        if(vali > tickMin && vali < tickMax) {\n            if(text[i] === undefined) ticksOut[j] = axes.tickText(ax, vali);\n            else ticksOut[j] = tickTextObj(ax, vali, String(text[i]));\n            j++;\n        }\n    }\n\n    if(j < vals.length) ticksOut.splice(j, vals.length - j);\n\n    return ticksOut;\n}\n\nvar roundBase10 = [2, 5, 10];\nvar roundBase24 = [1, 2, 3, 6, 12];\nvar roundBase60 = [1, 2, 5, 10, 15, 30];\n// 2&3 day ticks are weird, but need something btwn 1&7\nvar roundDays = [1, 2, 3, 7, 14];\n// approx. tick positions for log axes, showing all (1) and just 1, 2, 5 (2)\n// these don't have to be exact, just close enough to round to the right value\nvar roundLog1 = [-0.046, 0, 0.301, 0.477, 0.602, 0.699, 0.778, 0.845, 0.903, 0.954, 1];\nvar roundLog2 = [-0.301, 0, 0.301, 0.699, 1];\n// N.B. `thetaunit; 'radians' angular axes must be converted to degrees\nvar roundAngles = [15, 30, 45, 90, 180];\n\nfunction roundDTick(roughDTick, base, roundingSet) {\n    return base * Lib.roundUp(roughDTick / base, roundingSet);\n}\n\n// autoTicks: calculate best guess at pleasant ticks for this axis\n// inputs:\n//      ax - an axis object\n//      roughDTick - rough tick spacing (to be turned into a nice round number)\n// outputs (into ax):\n//   tick0: starting point for ticks (not necessarily on the graph)\n//      usually 0 for numeric (=10^0=1 for log) or jan 1, 2000 for dates\n//   dtick: the actual, nice round tick spacing, usually a little larger than roughDTick\n//      if the ticks are spaced linearly (linear scale, categories,\n//          log with only full powers, date ticks < month),\n//          this will just be a number\n//      months: M#\n//      years: M# where # is 12*number of years\n//      log with linear ticks: L# where # is the linear tick spacing\n//      log showing powers plus some intermediates:\n//          D1 shows all digits, D2 shows 2 and 5\naxes.autoTicks = function(ax, roughDTick) {\n    var base;\n\n    function getBase(v) {\n        return Math.pow(v, Math.floor(Math.log(roughDTick) / Math.LN10));\n    }\n\n    if(ax.type === 'date') {\n        ax.tick0 = Lib.dateTick0(ax.calendar);\n        // the criteria below are all based on the rough spacing we calculate\n        // being > half of the final unit - so precalculate twice the rough val\n        var roughX2 = 2 * roughDTick;\n\n        if(roughX2 > ONEAVGYEAR) {\n            roughDTick /= ONEAVGYEAR;\n            base = getBase(10);\n            ax.dtick = 'M' + (12 * roundDTick(roughDTick, base, roundBase10));\n        }\n        else if(roughX2 > ONEAVGMONTH) {\n            roughDTick /= ONEAVGMONTH;\n            ax.dtick = 'M' + roundDTick(roughDTick, 1, roundBase24);\n        }\n        else if(roughX2 > ONEDAY) {\n            ax.dtick = roundDTick(roughDTick, ONEDAY, roundDays);\n            // get week ticks on sunday\n            // this will also move the base tick off 2000-01-01 if dtick is\n            // 2 or 3 days... but that's a weird enough case that we'll ignore it.\n            ax.tick0 = Lib.dateTick0(ax.calendar, true);\n        }\n        else if(roughX2 > ONEHOUR) {\n            ax.dtick = roundDTick(roughDTick, ONEHOUR, roundBase24);\n        }\n        else if(roughX2 > ONEMIN) {\n            ax.dtick = roundDTick(roughDTick, ONEMIN, roundBase60);\n        }\n        else if(roughX2 > ONESEC) {\n            ax.dtick = roundDTick(roughDTick, ONESEC, roundBase60);\n        }\n        else {\n            // milliseconds\n            base = getBase(10);\n            ax.dtick = roundDTick(roughDTick, base, roundBase10);\n        }\n    }\n    else if(ax.type === 'log') {\n        ax.tick0 = 0;\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n\n        if(roughDTick > 0.7) {\n            // only show powers of 10\n            ax.dtick = Math.ceil(roughDTick);\n        }\n        else if(Math.abs(rng[1] - rng[0]) < 1) {\n            // span is less than one power of 10\n            var nt = 1.5 * Math.abs((rng[1] - rng[0]) / roughDTick);\n\n            // ticks on a linear scale, labeled fully\n            roughDTick = Math.abs(Math.pow(10, rng[1]) -\n                Math.pow(10, rng[0])) / nt;\n            base = getBase(10);\n            ax.dtick = 'L' + roundDTick(roughDTick, base, roundBase10);\n        }\n        else {\n            // include intermediates between powers of 10,\n            // labeled with small digits\n            // ax.dtick = \"D2\" (show 2 and 5) or \"D1\" (show all digits)\n            ax.dtick = (roughDTick > 0.3) ? 'D2' : 'D1';\n        }\n    }\n    else if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax.tick0 = 0;\n        ax.dtick = Math.ceil(Math.max(roughDTick, 1));\n    }\n    else if(isAngular(ax)) {\n        ax.tick0 = 0;\n        base = 1;\n        ax.dtick = roundDTick(roughDTick, base, roundAngles);\n    }\n    else {\n        // auto ticks always start at 0\n        ax.tick0 = 0;\n        base = getBase(10);\n        ax.dtick = roundDTick(roughDTick, base, roundBase10);\n    }\n\n    // prevent infinite loops\n    if(ax.dtick === 0) ax.dtick = 1;\n\n    // TODO: this is from log axis histograms with autorange off\n    if(!isNumeric(ax.dtick) && typeof ax.dtick !== 'string') {\n        var olddtick = ax.dtick;\n        ax.dtick = 1;\n        throw 'ax.dtick error: ' + String(olddtick);\n    }\n};\n\n// after dtick is already known, find tickround = precision\n// to display in tick labels\n//   for numeric ticks, integer # digits after . to round to\n//   for date ticks, the last date part to show (y,m,d,H,M,S)\n//      or an integer # digits past seconds\nfunction autoTickRound(ax) {\n    var dtick = ax.dtick;\n\n    ax._tickexponent = 0;\n    if(!isNumeric(dtick) && typeof dtick !== 'string') {\n        dtick = 1;\n    }\n\n    if(ax.type === 'category' || ax.type === 'multicategory') {\n        ax._tickround = null;\n    }\n    if(ax.type === 'date') {\n        // If tick0 is unusual, give tickround a bit more information\n        // not necessarily *all* the information in tick0 though, if it's really odd\n        // minimal string length for tick0: 'd' is 10, 'M' is 16, 'S' is 19\n        // take off a leading minus (year < 0) and i (intercalary month) so length is consistent\n        var tick0ms = ax.r2l(ax.tick0);\n        var tick0str = ax.l2r(tick0ms).replace(/(^-|i)/g, '');\n        var tick0len = tick0str.length;\n\n        if(String(dtick).charAt(0) === 'M') {\n            // any tick0 more specific than a year: alway show the full date\n            if(tick0len > 10 || tick0str.substr(5) !== '01-01') ax._tickround = 'd';\n            // show the month unless ticks are full multiples of a year\n            else ax._tickround = (+(dtick.substr(1)) % 12 === 0) ? 'y' : 'm';\n        }\n        else if((dtick >= ONEDAY && tick0len <= 10) || (dtick >= ONEDAY * 15)) ax._tickround = 'd';\n        else if((dtick >= ONEMIN && tick0len <= 16) || (dtick >= ONEHOUR)) ax._tickround = 'M';\n        else if((dtick >= ONESEC && tick0len <= 19) || (dtick >= ONEMIN)) ax._tickround = 'S';\n        else {\n            // tickround is a number of digits of fractional seconds\n            // of any two adjacent ticks, at least one will have the maximum fractional digits\n            // of all possible ticks - so take the max. length of tick0 and the next one\n            var tick1len = ax.l2r(tick0ms + dtick).replace(/^-/, '').length;\n            ax._tickround = Math.max(tick0len, tick1len) - 20;\n\n            // We shouldn't get here... but in case there's a situation I'm\n            // not thinking of where tick0str and tick1str are identical or\n            // something, fall back on maximum precision\n            if(ax._tickround < 0) ax._tickround = 4;\n        }\n    }\n    else if(isNumeric(dtick) || dtick.charAt(0) === 'L') {\n        // linear or log (except D1, D2)\n        var rng = ax.range.map(ax.r2d || Number);\n        if(!isNumeric(dtick)) dtick = Number(dtick.substr(1));\n        // 2 digits past largest digit of dtick\n        ax._tickround = 2 - Math.floor(Math.log(dtick) / Math.LN10 + 0.01);\n\n        var maxend = Math.max(Math.abs(rng[0]), Math.abs(rng[1]));\n\n        var rangeexp = Math.floor(Math.log(maxend) / Math.LN10 + 0.01);\n        if(Math.abs(rangeexp) > 3) {\n            if(isSIFormat(ax.exponentformat) && !beyondSI(rangeexp)) {\n                ax._tickexponent = 3 * Math.round((rangeexp - 1) / 3);\n            }\n            else ax._tickexponent = rangeexp;\n        }\n    }\n    // D1 or D2 (log)\n    else ax._tickround = null;\n}\n\n// months and years don't have constant millisecond values\n// (but a year is always 12 months so we only need months)\n// log-scale ticks are also not consistently spaced, except\n// for pure powers of 10\n// numeric ticks always have constant differences, other datetime ticks\n// can all be calculated as constant number of milliseconds\naxes.tickIncrement = function(x, dtick, axrev, calendar) {\n    var axSign = axrev ? -1 : 1;\n\n    // includes linear, all dates smaller than month, and pure 10^n in log\n    if(isNumeric(dtick)) return x + axSign * dtick;\n\n    // everything else is a string, one character plus a number\n    var tType = dtick.charAt(0);\n    var dtSigned = axSign * Number(dtick.substr(1));\n\n    // Dates: months (or years - see Lib.incrementMonth)\n    if(tType === 'M') return Lib.incrementMonth(x, dtSigned, calendar);\n\n    // Log scales: Linear, Digits\n    else if(tType === 'L') return Math.log(Math.pow(10, x) + dtSigned) / Math.LN10;\n\n    // log10 of 2,5,10, or all digits (logs just have to be\n    // close enough to round)\n    else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var x2 = x + axSign * 0.01;\n        var frac = Lib.roundUp(Lib.mod(x2, 1), tickset, axrev);\n\n        return Math.floor(x2) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// calculate the first tick on an axis\naxes.tickFirst = function(ax) {\n    var r2l = ax.r2l || Number;\n    var rng = Lib.simpleMap(ax.range, r2l);\n    var axrev = rng[1] < rng[0];\n    var sRound = axrev ? Math.floor : Math.ceil;\n    // add a tiny extra bit to make sure we get ticks\n    // that may have been rounded out\n    var r0 = rng[0] * 1.0001 - rng[1] * 0.0001;\n    var dtick = ax.dtick;\n    var tick0 = r2l(ax.tick0);\n\n    if(isNumeric(dtick)) {\n        var tmin = sRound((r0 - tick0) / dtick) * dtick + tick0;\n\n        // make sure no ticks outside the category list\n        if(ax.type === 'category' || ax.type === 'multicategory') {\n            tmin = Lib.constrain(tmin, 0, ax._categories.length - 1);\n        }\n        return tmin;\n    }\n\n    var tType = dtick.charAt(0);\n    var dtNum = Number(dtick.substr(1));\n\n    // Dates: months (or years)\n    if(tType === 'M') {\n        var cnt = 0;\n        var t0 = tick0;\n        var t1, mult, newDTick;\n\n        // This algorithm should work for *any* nonlinear (but close to linear!)\n        // tick spacing. Limit to 10 iterations, for gregorian months it's normally <=3.\n        while(cnt < 10) {\n            t1 = axes.tickIncrement(t0, dtick, axrev, ax.calendar);\n            if((t1 - r0) * (t0 - r0) <= 0) {\n                // t1 and t0 are on opposite sides of r0! we've succeeded!\n                if(axrev) return Math.min(t0, t1);\n                return Math.max(t0, t1);\n            }\n            mult = (r0 - ((t0 + t1) / 2)) / (t1 - t0);\n            newDTick = tType + ((Math.abs(Math.round(mult)) || 1) * dtNum);\n            t0 = axes.tickIncrement(t0, newDTick, mult < 0 ? !axrev : axrev, ax.calendar);\n            cnt++;\n        }\n        Lib.error('tickFirst did not converge', ax);\n        return t0;\n    }\n\n    // Log scales: Linear, Digits\n    else if(tType === 'L') {\n        return Math.log(sRound(\n            (Math.pow(10, r0) - tick0) / dtNum) * dtNum + tick0) / Math.LN10;\n    }\n    else if(tType === 'D') {\n        var tickset = (dtick === 'D2') ? roundLog2 : roundLog1;\n        var frac = Lib.roundUp(Lib.mod(r0, 1), tickset, axrev);\n\n        return Math.floor(r0) +\n            Math.log(d3.round(Math.pow(10, frac), 1)) / Math.LN10;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n};\n\n// draw the text for one tick.\n// px,py are the location on gd.paper\n// prefix is there so the x axis ticks can be dropped a line\n// ax is the axis layout, x is the tick value\n// hover is a (truthy) flag for whether to show numbers with a bit\n// more precision for hovertext\naxes.tickText = function(ax, x, hover) {\n    var out = tickTextObj(ax, x);\n    var arrayMode = ax.tickmode === 'array';\n    var extraPrecision = hover || arrayMode;\n    var axType = ax.type;\n    // TODO multicategory, if we allow ticktext / tickvals\n    var tickVal2l = axType === 'category' ? ax.d2l_noadd : ax.d2l;\n    var i;\n\n    if(arrayMode && Array.isArray(ax.ticktext)) {\n        var rng = Lib.simpleMap(ax.range, ax.r2l);\n        var minDiff = Math.abs(rng[1] - rng[0]) / 10000;\n\n        for(i = 0; i < ax.ticktext.length; i++) {\n            if(Math.abs(x - tickVal2l(ax.tickvals[i])) < minDiff) break;\n        }\n        if(i < ax.ticktext.length) {\n            out.text = String(ax.ticktext[i]);\n            return out;\n        }\n    }\n\n    function isHidden(showAttr) {\n        if(showAttr === undefined) return true;\n        if(hover) return showAttr === 'none';\n\n        var firstOrLast = {\n            first: ax._tmin,\n            last: ax._tmax\n        }[showAttr];\n\n        return showAttr !== 'all' && x !== firstOrLast;\n    }\n\n    var hideexp = hover ?\n        'never' :\n        ax.exponentformat !== 'none' && isHidden(ax.showexponent) ? 'hide' : '';\n\n    if(axType === 'date') formatDate(ax, out, hover, extraPrecision);\n    else if(axType === 'log') formatLog(ax, out, hover, extraPrecision, hideexp);\n    else if(axType === 'category') formatCategory(ax, out);\n    else if(axType === 'multicategory') formatMultiCategory(ax, out, hover);\n    else if(isAngular(ax)) formatAngle(ax, out, hover, extraPrecision, hideexp);\n    else formatLinear(ax, out, hover, extraPrecision, hideexp);\n\n    // add prefix and suffix\n    if(ax.tickprefix && !isHidden(ax.showtickprefix)) out.text = ax.tickprefix + out.text;\n    if(ax.ticksuffix && !isHidden(ax.showticksuffix)) out.text += ax.ticksuffix;\n\n    // Setup ticks and grid lines boundaries\n    // at 1/2 a 'category' to the left/bottom\n    if(ax.tickson === 'boundaries' || ax.showdividers) {\n        var inbounds = function(v) {\n            var p = ax.l2p(v);\n            return p >= 0 && p <= ax._length ? v : null;\n        };\n\n        out.xbnd = [\n            inbounds(out.x - 0.5),\n            inbounds(out.x + ax.dtick - 0.5)\n        ];\n    }\n\n    return out;\n};\n\n/**\n * create text for a hover label on this axis, with special handling of\n * log axes (where negative values can't be displayed but can appear in hover text)\n *\n * @param {object} ax: the axis to format text for\n * @param {number} val: calcdata value to format\n * @param {Optional(number)} val2: a second value to display\n *\n * @returns {string} `val` formatted as a string appropriate to this axis, or\n *     `val` and `val2` as a range (ie '<val> - <val2>') if `val2` is provided and\n *     it's different from `val`.\n */\naxes.hoverLabelText = function(ax, val, val2) {\n    if(val2 !== BADNUM && val2 !== val) {\n        return axes.hoverLabelText(ax, val) + ' - ' + axes.hoverLabelText(ax, val2);\n    }\n\n    var logOffScale = (ax.type === 'log' && val <= 0);\n    var tx = axes.tickText(ax, ax.c2l(logOffScale ? -val : val), 'hover').text;\n\n    if(logOffScale) {\n        return val === 0 ? '0' : MINUS_SIGN + tx;\n    }\n\n    // TODO: should we do something special if the axis calendar and\n    // the data calendar are different? Somehow display both dates with\n    // their system names? Right now it will just display in the axis calendar\n    // but users could add the other one as text.\n    return tx;\n};\n\nfunction tickTextObj(ax, x, text) {\n    var tf = ax.tickfont || {};\n\n    return {\n        x: x,\n        dx: 0,\n        dy: 0,\n        text: text || '',\n        fontSize: tf.size,\n        font: tf.family,\n        fontColor: tf.color\n    };\n}\n\nfunction formatDate(ax, out, hover, extraPrecision) {\n    var tr = ax._tickround;\n    var fmt = (hover && ax.hoverformat) || axes.getTickFormat(ax);\n\n    if(extraPrecision) {\n        // second or sub-second precision: extra always shows max digits.\n        // for other fields, extra precision just adds one field.\n        if(isNumeric(tr)) tr = 4;\n        else tr = {y: 'm', m: 'd', d: 'M', M: 'S', S: 4}[tr];\n    }\n\n    var dateStr = Lib.formatDate(out.x, fmt, tr, ax._dateFormat, ax.calendar, ax._extraFormat);\n    var headStr;\n\n    var splitIndex = dateStr.indexOf('\\n');\n    if(splitIndex !== -1) {\n        headStr = dateStr.substr(splitIndex + 1);\n        dateStr = dateStr.substr(0, splitIndex);\n    }\n\n    if(extraPrecision) {\n        // if extraPrecision led to trailing zeros, strip them off\n        // actually, this can lead to removing even more zeros than\n        // in the original rounding, but that's fine because in these\n        // contexts uniformity is not so important (if there's even\n        // anything to be uniform with!)\n\n        // can we remove the whole time part?\n        if(dateStr === '00:00:00' || dateStr === '00:00') {\n            dateStr = headStr;\n            headStr = '';\n        }\n        else if(dateStr.length === 8) {\n            // strip off seconds if they're zero (zero fractional seconds\n            // are already omitted)\n            // but we never remove minutes and leave just hours\n            dateStr = dateStr.replace(/:00$/, '');\n        }\n    }\n\n    if(headStr) {\n        if(hover) {\n            // hover puts it all on one line, so headPart works best up front\n            // except for year headPart: turn this into \"Jan 1, 2000\" etc.\n            if(tr === 'd') dateStr += ', ' + headStr;\n            else dateStr = headStr + (dateStr ? ', ' + dateStr : '');\n        }\n        else if(!ax._inCalcTicks || (headStr !== ax._prevDateHead)) {\n            dateStr += '<br>' + headStr;\n            ax._prevDateHead = headStr;\n        }\n    }\n\n    out.text = dateStr;\n}\n\nfunction formatLog(ax, out, hover, extraPrecision, hideexp) {\n    var dtick = ax.dtick;\n    var x = out.x;\n    var tickformat = ax.tickformat;\n    var dtChar0 = typeof dtick === 'string' && dtick.charAt(0);\n\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    }\n\n    if(extraPrecision && (dtChar0 !== 'L')) {\n        dtick = 'L3';\n        dtChar0 = 'L';\n    }\n\n    if(tickformat || (dtChar0 === 'L')) {\n        out.text = numFormat(Math.pow(10, x), ax, hideexp, extraPrecision);\n    }\n    else if(isNumeric(dtick) || ((dtChar0 === 'D') && (Lib.mod(x + 0.01, 1) < 0.1))) {\n        var p = Math.round(x);\n        var absP = Math.abs(p);\n        var exponentFormat = ax.exponentformat;\n        if(exponentFormat === 'power' || (isSIFormat(exponentFormat) && beyondSI(p))) {\n            if(p === 0) out.text = 1;\n            else if(p === 1) out.text = '10';\n            else out.text = '10<sup>' + (p > 1 ? '' : MINUS_SIGN) + absP + '</sup>';\n\n            out.fontSize *= 1.25;\n        }\n        else if((exponentFormat === 'e' || exponentFormat === 'E') && absP > 2) {\n            out.text = '1' + exponentFormat + (p > 0 ? '+' : MINUS_SIGN) + absP;\n        }\n        else {\n            out.text = numFormat(Math.pow(10, x), ax, '', 'fakehover');\n            if(dtick === 'D1' && ax._id.charAt(0) === 'y') {\n                out.dy -= out.fontSize / 6;\n            }\n        }\n    }\n    else if(dtChar0 === 'D') {\n        out.text = String(Math.round(Math.pow(10, Lib.mod(x, 1))));\n        out.fontSize *= 0.75;\n    }\n    else throw 'unrecognized dtick ' + String(dtick);\n\n    // if 9's are printed on log scale, move the 10's away a bit\n    if(ax.dtick === 'D1') {\n        var firstChar = String(out.text).charAt(0);\n        if(firstChar === '0' || firstChar === '1') {\n            if(ax._id.charAt(0) === 'y') {\n                out.dx -= out.fontSize / 4;\n            }\n            else {\n                out.dy += out.fontSize / 2;\n                out.dx += (ax.range[1] > ax.range[0] ? 1 : -1) *\n                    out.fontSize * (x < 0 ? 0.5 : 0.25);\n            }\n        }\n    }\n}\n\nfunction formatCategory(ax, out) {\n    var tt = ax._categories[Math.round(out.x)];\n    if(tt === undefined) tt = '';\n    out.text = String(tt);\n}\n\nfunction formatMultiCategory(ax, out, hover) {\n    var v = Math.round(out.x);\n    var cats = ax._categories[v] || [];\n    var tt = cats[1] === undefined ? '' : String(cats[1]);\n    var tt2 = cats[0] === undefined ? '' : String(cats[0]);\n\n    if(hover) {\n        // TODO is this what we want?\n        out.text = tt2 + ' - ' + tt;\n    } else {\n        // setup for secondary labels\n        out.text = tt;\n        out.text2 = tt2;\n    }\n}\n\nfunction formatLinear(ax, out, hover, extraPrecision, hideexp) {\n    if(hideexp === 'never') {\n        // If this is a hover label, then we must *never* hide the exponent\n        // for the sake of display, which could give the wrong value by\n        // potentially many orders of magnitude. If hideexp was 'never', then\n        // it's now succeeded by preventing the other condition from automating\n        // this choice. Thus we can unset it so that the axis formatting takes\n        // precedence.\n        hideexp = '';\n    } else if(ax.showexponent === 'all' && Math.abs(out.x / ax.dtick) < 1e-6) {\n        // don't add an exponent to zero if we're showing all exponents\n        // so the only reason you'd show an exponent on zero is if it's the\n        // ONLY tick to get an exponent (first or last)\n        hideexp = 'hide';\n    }\n    out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n}\n\nfunction formatAngle(ax, out, hover, extraPrecision, hideexp) {\n    if(ax.thetaunit === 'radians' && !hover) {\n        var num = out.x / 180;\n\n        if(num === 0) {\n            out.text = '0';\n        } else {\n            var frac = num2frac(num);\n\n            if(frac[1] >= 100) {\n                out.text = numFormat(Lib.deg2rad(out.x), ax, hideexp, extraPrecision);\n            } else {\n                var isNeg = out.x < 0;\n\n                if(frac[1] === 1) {\n                    if(frac[0] === 1) out.text = 'π';\n                    else out.text = frac[0] + 'π';\n                } else {\n                    out.text = [\n                        '<sup>', frac[0], '</sup>',\n                        '⁄',\n                        '<sub>', frac[1], '</sub>',\n                        'π'\n                    ].join('');\n                }\n\n                if(isNeg) out.text = MINUS_SIGN + out.text;\n            }\n        }\n    } else {\n        out.text = numFormat(out.x, ax, hideexp, extraPrecision);\n    }\n}\n\n// inspired by\n// https://github.com/yisibl/num2fraction/blob/master/index.js\nfunction num2frac(num) {\n    function almostEq(a, b) {\n        return Math.abs(a - b) <= 1e-6;\n    }\n\n    function findGCD(a, b) {\n        return almostEq(b, 0) ? a : findGCD(b, a % b);\n    }\n\n    function findPrecision(n) {\n        var e = 1;\n        while(!almostEq(Math.round(n * e) / e, n)) {\n            e *= 10;\n        }\n        return e;\n    }\n\n    var precision = findPrecision(num);\n    var number = num * precision;\n    var gcd = Math.abs(findGCD(number, precision));\n\n    return [\n        // numerator\n        Math.round(number / gcd),\n        // denominator\n        Math.round(precision / gcd)\n    ];\n}\n\n// format a number (tick value) according to the axis settings\n// new, more reliable procedure than d3.round or similar:\n// add half the rounding increment, then stringify and truncate\n// also automatically switch to sci. notation\nvar SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];\n\nfunction isSIFormat(exponentFormat) {\n    return exponentFormat === 'SI' || exponentFormat === 'B';\n}\n\n// are we beyond the range of common SI prefixes?\n// 10^-16 -> 1x10^-16\n// 10^-15 -> 1f\n// ...\n// 10^14 -> 100T\n// 10^15 -> 1x10^15\n// 10^16 -> 1x10^16\nfunction beyondSI(exponent) {\n    return exponent > 14 || exponent < -15;\n}\n\nfunction numFormat(v, ax, fmtoverride, hover) {\n    var isNeg = v < 0;\n    // max number of digits past decimal point to show\n    var tickRound = ax._tickround;\n    var exponentFormat = fmtoverride || ax.exponentformat || 'B';\n    var exponent = ax._tickexponent;\n    var tickformat = axes.getTickFormat(ax);\n    var separatethousands = ax.separatethousands;\n\n    // special case for hover: set exponent just for this value, and\n    // add a couple more digits of precision over tick labels\n    if(hover) {\n        // make a dummy axis obj to get the auto rounding and exponent\n        var ah = {\n            exponentformat: exponentFormat,\n            dtick: ax.showexponent === 'none' ? ax.dtick :\n                (isNumeric(v) ? Math.abs(v) || 1 : 1),\n            // if not showing any exponents, don't change the exponent\n            // from what we calculate\n            range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]\n        };\n        autoTickRound(ah);\n        tickRound = (Number(ah._tickround) || 0) + 4;\n        exponent = ah._tickexponent;\n        if(ax.hoverformat) tickformat = ax.hoverformat;\n    }\n\n    if(tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);\n\n    // 'epsilon' - rounding increment\n    var e = Math.pow(10, -tickRound) / 2;\n\n    // exponentFormat codes:\n    // 'e' (1.2e+6, default)\n    // 'E' (1.2E+6)\n    // 'SI' (1.2M)\n    // 'B' (same as SI except 10^9=B not G)\n    // 'none' (1200000)\n    // 'power' (1.2x10^6)\n    // 'hide' (1.2, use 3rd argument=='hide' to eg\n    //      only show exponent on last tick)\n    if(exponentFormat === 'none') exponent = 0;\n\n    // take the sign out, put it back manually at the end\n    // - makes cases easier\n    v = Math.abs(v);\n    if(v < e) {\n        // 0 is just 0, but may get exponent if it's the last tick\n        v = '0';\n        isNeg = false;\n    }\n    else {\n        v += e;\n        // take out a common exponent, if any\n        if(exponent) {\n            v *= Math.pow(10, -exponent);\n            tickRound += exponent;\n        }\n        // round the mantissa\n        if(tickRound === 0) v = String(Math.floor(v));\n        else if(tickRound < 0) {\n            v = String(Math.round(v));\n            v = v.substr(0, v.length + tickRound);\n            for(var i = tickRound; i < 0; i++) v += '0';\n        }\n        else {\n            v = String(v);\n            var dp = v.indexOf('.') + 1;\n            if(dp) v = v.substr(0, dp + tickRound).replace(/\\.?0+$/, '');\n        }\n        // insert appropriate decimal point and thousands separator\n        v = Lib.numSeparate(v, ax._separators, separatethousands);\n    }\n\n    // add exponent\n    if(exponent && exponentFormat !== 'hide') {\n        if(isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';\n\n        var signedExponent;\n        if(exponent < 0) signedExponent = MINUS_SIGN + -exponent;\n        else if(exponentFormat !== 'power') signedExponent = '+' + exponent;\n        else signedExponent = String(exponent);\n\n        if(exponentFormat === 'e' || exponentFormat === 'E') {\n            v += exponentFormat + signedExponent;\n        }\n        else if(exponentFormat === 'power') {\n            v += '×10<sup>' + signedExponent + '</sup>';\n        }\n        else if(exponentFormat === 'B' && exponent === 9) {\n            v += 'B';\n        }\n        else if(isSIFormat(exponentFormat)) {\n            v += SIPREFIXES[exponent / 3 + 5];\n        }\n    }\n\n    // put sign back in and return\n    // replace standard minus character (which is technically a hyphen)\n    // with a true minus sign\n    if(isNeg) return MINUS_SIGN + v;\n    return v;\n}\n\naxes.getTickFormat = function(ax) {\n    var i;\n\n    function convertToMs(dtick) {\n        return typeof dtick !== 'string' ? dtick : Number(dtick.replace('M', '')) * ONEAVGMONTH;\n    }\n\n    function compareLogTicks(left, right) {\n        var priority = ['L', 'D'];\n        if(typeof left === typeof right) {\n            if(typeof left === 'number') {\n                return left - right;\n            } else {\n                var leftPriority = priority.indexOf(left.charAt(0));\n                var rightPriority = priority.indexOf(right.charAt(0));\n                if(leftPriority === rightPriority) {\n                    return Number(left.replace(/(L|D)/g, '')) - Number(right.replace(/(L|D)/g, ''));\n                } else {\n                    return leftPriority - rightPriority;\n                }\n            }\n        } else {\n            return typeof left === 'number' ? 1 : -1;\n        }\n    }\n\n    function isProperStop(dtick, range, convert) {\n        var convertFn = convert || function(x) { return x;};\n        var leftDtick = range[0];\n        var rightDtick = range[1];\n        return ((!leftDtick && typeof leftDtick !== 'number') || convertFn(leftDtick) <= convertFn(dtick)) &&\n               ((!rightDtick && typeof rightDtick !== 'number') || convertFn(rightDtick) >= convertFn(dtick));\n    }\n\n    function isProperLogStop(dtick, range) {\n        var isLeftDtickNull = range[0] === null;\n        var isRightDtickNull = range[1] === null;\n        var isDtickInRangeLeft = compareLogTicks(dtick, range[0]) >= 0;\n        var isDtickInRangeRight = compareLogTicks(dtick, range[1]) <= 0;\n        return (isLeftDtickNull || isDtickInRangeLeft) && (isRightDtickNull || isDtickInRangeRight);\n    }\n\n    var tickstop, stopi;\n    if(ax.tickformatstops && ax.tickformatstops.length > 0) {\n        switch(ax.type) {\n            case 'date':\n            case 'linear': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperStop(ax.dtick, stopi.dtickrange, convertToMs)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            case 'log': {\n                for(i = 0; i < ax.tickformatstops.length; i++) {\n                    stopi = ax.tickformatstops[i];\n                    if(stopi.enabled && isProperLogStop(ax.dtick, stopi.dtickrange)) {\n                        tickstop = stopi;\n                        break;\n                    }\n                }\n                break;\n            }\n            default:\n        }\n    }\n    return tickstop ? tickstop.value : ax.tickformat;\n};\n\n// getSubplots - extract all subplot IDs we need\n// as an array of items like 'xy', 'x2y', 'x2y2'...\n// sorted by x (x,x2,x3...) then y\n// optionally restrict to only subplots containing axis object ax\n//\n// NOTE: this is currently only used OUTSIDE plotly.js (toolpanel, webapp)\n// ideally we get rid of it there (or just copy this there) and remove it here\naxes.getSubplots = function(gd, ax) {\n    var subplotObj = gd._fullLayout._subplots;\n    var allSubplots = subplotObj.cartesian.concat(subplotObj.gl2d || []);\n\n    var out = ax ? axes.findSubplotsWithAxis(allSubplots, ax) : allSubplots;\n\n    out.sort(function(a, b) {\n        var aParts = a.substr(1).split('y');\n        var bParts = b.substr(1).split('y');\n\n        if(aParts[0] === bParts[0]) return +aParts[1] - +bParts[1];\n        return +aParts[0] - +bParts[0];\n    });\n\n    return out;\n};\n\n// find all subplots with axis 'ax'\n// NOTE: this is only used in axes.getSubplots (only used outside plotly.js) and\n// gl2d/convert (where it restricts axis subplots to only those with gl2d)\naxes.findSubplotsWithAxis = function(subplots, ax) {\n    var axMatch = new RegExp(\n        (ax._id.charAt(0) === 'x') ? ('^' + ax._id + 'y') : (ax._id + '$')\n    );\n    var subplotsWithAx = [];\n\n    for(var i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        if(axMatch.test(sp)) subplotsWithAx.push(sp);\n    }\n\n    return subplotsWithAx;\n};\n\n// makeClipPaths: prepare clipPaths for all single axes and all possible xy pairings\naxes.makeClipPaths = function(gd) {\n    var fullLayout = gd._fullLayout;\n\n    // for more info: https://github.com/plotly/plotly.js/issues/2595\n    if(fullLayout._hasOnlyLargeSploms) return;\n\n    var fullWidth = {_offset: 0, _length: fullLayout.width, _id: ''};\n    var fullHeight = {_offset: 0, _length: fullLayout.height, _id: ''};\n    var xaList = axes.list(gd, 'x', true);\n    var yaList = axes.list(gd, 'y', true);\n    var clipList = [];\n    var i, j;\n\n    for(i = 0; i < xaList.length; i++) {\n        clipList.push({x: xaList[i], y: fullHeight});\n        for(j = 0; j < yaList.length; j++) {\n            if(i === 0) clipList.push({x: fullWidth, y: yaList[j]});\n            clipList.push({x: xaList[i], y: yaList[j]});\n        }\n    }\n\n    // selectors don't work right with camelCase tags,\n    // have to use class instead\n    // https://groups.google.com/forum/#!topic/d3-js/6EpAzQ2gU9I\n    var axClips = fullLayout._clips.selectAll('.axesclip')\n        .data(clipList, function(d) { return d.x._id + d.y._id; });\n\n    axClips.enter().append('clipPath')\n        .classed('axesclip', true)\n        .attr('id', function(d) { return 'clip' + fullLayout._uid + d.x._id + d.y._id; })\n      .append('rect');\n\n    axClips.exit().remove();\n\n    axClips.each(function(d) {\n        d3.select(this).select('rect').attr({\n            x: d.x._offset || 0,\n            y: d.y._offset || 0,\n            width: d.x._length || 1,\n            height: d.y._length || 1\n        });\n    });\n};\n\n/**\n * Main multi-axis drawing routine!\n *\n * @param {DOM element} gd : graph div\n * @param {string or array of strings} arg : polymorphic argument\n * @param {object} opts:\n * - @param {boolean} skipTitle : optional flag to skip axis title draw/update\n *\n * Signature 1: Axes.draw(gd, 'redraw')\n *   use this to clear and redraw all axes on graph\n *\n * Signature 2: Axes.draw(gd, '')\n *   use this to draw all axes on graph w/o the selectAll().remove()\n *   of the 'redraw' signature\n *\n * Signature 3: Axes.draw(gd, [axId, axId2, ...])\n *   where the items are axis id string,\n *   use this to update multiple axes in one call\n *\n * N.B draw updates:\n * - ax._r (stored range for use by zoom/pan)\n * - ax._rl (stored linearized range for use by zoom/pan)\n */\naxes.draw = function(gd, arg, opts) {\n    var fullLayout = gd._fullLayout;\n\n    if(arg === 'redraw') {\n        fullLayout._paper.selectAll('g.subplot').each(function(d) {\n            var id = d[0];\n            var plotinfo = fullLayout._plots[id];\n            var xa = plotinfo.xaxis;\n            var ya = plotinfo.yaxis;\n\n            plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick').remove();\n            plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick').remove();\n            plotinfo.xaxislayer.selectAll('.' + xa._id + 'tick2').remove();\n            plotinfo.yaxislayer.selectAll('.' + ya._id + 'tick2').remove();\n            plotinfo.xaxislayer.selectAll('.' + xa._id + 'divider').remove();\n            plotinfo.yaxislayer.selectAll('.' + ya._id + 'divider').remove();\n\n            if(plotinfo.gridlayer) plotinfo.gridlayer.selectAll('path').remove();\n            if(plotinfo.zerolinelayer) plotinfo.zerolinelayer.selectAll('path').remove();\n\n            fullLayout._infolayer.select('.g-' + xa._id + 'title').remove();\n            fullLayout._infolayer.select('.g-' + ya._id + 'title').remove();\n        });\n    }\n\n    var axList = (!arg || arg === 'redraw') ? axes.listIds(gd) : arg;\n\n    return Lib.syncOrAsync(axList.map(function(axId) {\n        return function() {\n            if(!axId) return;\n\n            var ax = axes.getFromId(gd, axId);\n            var axDone = axes.drawOne(gd, ax, opts);\n\n            ax._r = ax.range.slice();\n            ax._rl = Lib.simpleMap(ax._r, ax.r2l);\n\n            return axDone;\n        };\n    }));\n};\n\n/**\n * Draw one cartesian axis\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n * @param {object} opts\n * - @param {boolean} skipTitle (set to true to skip axis title draw call)\n */\naxes.drawOne = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var i, sp, plotinfo;\n\n    ax.setScale();\n\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var counterLetter = axes.counterLetter(axId);\n    var mainSubplot = ax._mainSubplot;\n    var mainLinePosition = ax._mainLinePosition;\n    var mainMirrorPosition = ax._mainMirrorPosition;\n    var mainPlotinfo = fullLayout._plots[mainSubplot];\n    var mainAxLayer = mainPlotinfo[axLetter + 'axislayer'];\n    var subplotsWithAx = ax._subplotsWith;\n\n    var vals = ax._vals = axes.calcTicks(ax);\n\n    // Add a couple of axis properties that should cause us to recreate\n    // elements. Used in d3 data function.\n    var axInfo = [ax.mirror, mainLinePosition, mainMirrorPosition].join('_');\n    for(i = 0; i < vals.length; i++) {\n        vals[i].axInfo = axInfo;\n    }\n\n    if(!ax.visible) return;\n\n    // stash selections to avoid DOM queries e.g.\n    // - stash tickLabels selection, so that drawTitle can use it to scoot title\n    ax._selections = {};\n    // stash tick angle (including the computed 'auto' values) per tick-label class\n    ax._tickAngles = {};\n\n    var transFn = axes.makeTransFn(ax);\n    var tickVals;\n    // We remove zero lines, grid lines, and inside ticks if they're within 1px of the end\n    // The key case here is removing zero lines when the axis bound is zero\n    var valsClipped;\n\n    if(ax.tickson === 'boundaries') {\n        var boundaryVals = getBoundaryVals(ax, vals);\n        valsClipped = axes.clipEnds(ax, boundaryVals);\n        tickVals = ax.ticks === 'inside' ? valsClipped : boundaryVals;\n    } else {\n        valsClipped = axes.clipEnds(ax, vals);\n        tickVals = ax.ticks === 'inside' ? valsClipped : vals;\n    }\n\n    var gridVals = ax._gridVals = valsClipped;\n    var dividerVals = getDividerVals(ax, vals);\n\n    if(!fullLayout._hasOnlyLargeSploms) {\n        // keep track of which subplots (by main conteraxis) we've already\n        // drawn grids for, so we don't overdraw overlaying subplots\n        var finishedGrids = {};\n\n        for(i = 0; i < subplotsWithAx.length; i++) {\n            sp = subplotsWithAx[i];\n            plotinfo = fullLayout._plots[sp];\n\n            var counterAxis = plotinfo[counterLetter + 'axis'];\n            var mainCounterID = counterAxis._mainAxis._id;\n            if(finishedGrids[mainCounterID]) continue;\n            finishedGrids[mainCounterID] = 1;\n\n            var gridPath = axLetter === 'x' ?\n                'M0,' + counterAxis._offset + 'v' + counterAxis._length :\n                'M' + counterAxis._offset + ',0h' + counterAxis._length;\n\n            axes.drawGrid(gd, ax, {\n                vals: gridVals,\n                counterAxis: counterAxis,\n                layer: plotinfo.gridlayer.select('.' + axId),\n                path: gridPath,\n                transFn: transFn\n            });\n            axes.drawZeroLine(gd, ax, {\n                counterAxis: counterAxis,\n                layer: plotinfo.zerolinelayer,\n                path: gridPath,\n                transFn: transFn\n            });\n        }\n    }\n\n    var tickSigns = axes.getTickSigns(ax);\n    var tickSubplots = [];\n\n    if(ax.ticks) {\n        var mainTickPath = axes.makeTickPath(ax, mainLinePosition, tickSigns[2]);\n        var mirrorTickPath;\n        var fullTickPath;\n        if(ax._anchorAxis && ax.mirror && ax.mirror !== true) {\n            mirrorTickPath = axes.makeTickPath(ax, mainMirrorPosition, tickSigns[3]);\n            fullTickPath = mainTickPath + mirrorTickPath;\n        } else {\n            mirrorTickPath = '';\n            fullTickPath = mainTickPath;\n        }\n\n        var tickPath;\n        if(ax.showdividers && ax.ticks === 'outside' && ax.tickson === 'boundaries') {\n            var dividerLookup = {};\n            for(i = 0; i < dividerVals.length; i++) {\n                dividerLookup[dividerVals[i].x] = 1;\n            }\n            tickPath = function(d) {\n                return dividerLookup[d.x] ? mirrorTickPath : fullTickPath;\n            };\n        } else {\n            tickPath = fullTickPath;\n        }\n\n        axes.drawTicks(gd, ax, {\n            vals: tickVals,\n            layer: mainAxLayer,\n            path: tickPath,\n            transFn: transFn\n        });\n\n        tickSubplots = Object.keys(ax._linepositions || {});\n    }\n\n    for(i = 0; i < tickSubplots.length; i++) {\n        sp = tickSubplots[i];\n        plotinfo = fullLayout._plots[sp];\n        // [bottom or left, top or right], free and main are handled above\n        var linepositions = ax._linepositions[sp] || [];\n        var spTickPath = axes.makeTickPath(ax, linepositions[0], tickSigns[0]) +\n            axes.makeTickPath(ax, linepositions[1], tickSigns[1]);\n\n        axes.drawTicks(gd, ax, {\n            vals: tickVals,\n            layer: plotinfo[axLetter + 'axislayer'],\n            path: spTickPath,\n            transFn: transFn\n        });\n    }\n\n    var seq = [];\n\n    // tick labels - for now just the main labels.\n    // TODO: mirror labels, esp for subplots\n\n    seq.push(function() {\n        var labelFns = axes.makeLabelFns(ax, mainLinePosition);\n        return axes.drawLabels(gd, ax, {\n            vals: vals,\n            layer: mainAxLayer,\n            transFn: transFn,\n            labelXFn: labelFns.labelXFn,\n            labelYFn: labelFns.labelYFn,\n            labelAnchorFn: labelFns.labelAnchorFn,\n        });\n    });\n\n    if(ax.type === 'multicategory') {\n        var labelLength = 0;\n        var pad = {x: 2, y: 10}[axLetter];\n        var sgn = tickSigns[2] * (ax.ticks === 'inside' ? -1 : 1);\n\n        seq.push(function() {\n            labelLength += getLabelLevelSpan(ax, axId + 'tick') + pad;\n            labelLength += ax._tickAngles[axId + 'tick'] ? ax.tickfont.size * LINE_SPACING : 0;\n            var secondaryPosition = mainLinePosition + labelLength * sgn;\n            var secondaryLabelFns = axes.makeLabelFns(ax, secondaryPosition);\n\n            return axes.drawLabels(gd, ax, {\n                vals: getSecondaryLabelVals(ax, vals),\n                layer: mainAxLayer,\n                cls: axId + 'tick2',\n                repositionOnUpdate: true,\n                secondary: true,\n                transFn: transFn,\n                labelXFn: secondaryLabelFns.labelXFn,\n                labelYFn: secondaryLabelFns.labelYFn,\n                labelAnchorFn: secondaryLabelFns.labelAnchorFn,\n            });\n        });\n\n        seq.push(function() {\n            labelLength += getLabelLevelSpan(ax, axId + 'tick2');\n            ax._labelLength = labelLength;\n\n            return drawDividers(gd, ax, {\n                vals: dividerVals,\n                layer: mainAxLayer,\n                path: axes.makeTickPath(ax, mainLinePosition, sgn, labelLength),\n                transFn: transFn\n            });\n        });\n    }\n\n    function extendRange(range, newRange) {\n        range[0] = Math.min(range[0], newRange[0]);\n        range[1] = Math.max(range[1], newRange[1]);\n    }\n\n    function calcBoundingBox() {\n        if(ax.showticklabels) {\n            var gdBB = gd.getBoundingClientRect();\n            var bBox = mainAxLayer.node().getBoundingClientRect();\n\n            /*\n             * the way we're going to use this, the positioning that matters\n             * is relative to the origin of gd. This is important particularly\n             * if gd is scrollable, and may have been scrolled between the time\n             * we calculate this and the time we use it\n             */\n\n            ax._boundingBox = {\n                width: bBox.width,\n                height: bBox.height,\n                left: bBox.left - gdBB.left,\n                right: bBox.right - gdBB.left,\n                top: bBox.top - gdBB.top,\n                bottom: bBox.bottom - gdBB.top\n            };\n        } else {\n            var gs = fullLayout._size;\n            var pos;\n\n            // set dummy bbox for ticklabel-less axes\n\n            if(axLetter === 'x') {\n                pos = ax.anchor === 'free' ?\n                    gs.t + gs.h * (1 - ax.position) :\n                    gs.t + gs.h * (1 - ax._anchorAxis.domain[{bottom: 0, top: 1}[ax.side]]);\n\n                ax._boundingBox = {\n                    top: pos,\n                    bottom: pos,\n                    left: ax._offset,\n                    right: ax._offset + ax._length,\n                    width: ax._length,\n                    height: 0\n                };\n            } else {\n                pos = ax.anchor === 'free' ?\n                    gs.l + gs.w * ax.position :\n                    gs.l + gs.w * ax._anchorAxis.domain[{left: 0, right: 1}[ax.side]];\n\n                ax._boundingBox = {\n                    left: pos,\n                    right: pos,\n                    bottom: ax._offset + ax._length,\n                    top: ax._offset,\n                    height: ax._length,\n                    width: 0\n                };\n            }\n        }\n\n        /*\n         * for spikelines: what's the full domain of positions in the\n         * opposite direction that are associated with this axis?\n         * This means any axes that we make a subplot with, plus the\n         * position of the axis itself if it's free.\n         */\n        if(subplotsWithAx) {\n            var fullRange = ax._counterSpan = [Infinity, -Infinity];\n\n            for(var i = 0; i < subplotsWithAx.length; i++) {\n                var plotinfo = fullLayout._plots[subplotsWithAx[i]];\n                var counterAxis = plotinfo[(axLetter === 'x') ? 'yaxis' : 'xaxis'];\n\n                extendRange(fullRange, [\n                    counterAxis._offset,\n                    counterAxis._offset + counterAxis._length\n                ]);\n            }\n\n            if(ax.anchor === 'free') {\n                extendRange(fullRange, (axLetter === 'x') ?\n                    [ax._boundingBox.bottom, ax._boundingBox.top] :\n                    [ax._boundingBox.right, ax._boundingBox.left]);\n            }\n        }\n    }\n\n    var hasRangeSlider = Registry.getComponentMethod('rangeslider', 'isVisible')(ax);\n\n    function doAutoMargins() {\n        var s = ax.side.charAt(0);\n        var push;\n        var rangeSliderPush;\n\n        if(hasRangeSlider) {\n            rangeSliderPush = Registry.getComponentMethod('rangeslider', 'autoMarginOpts')(gd, ax);\n        }\n        Plots.autoMargin(gd, rangeSliderAutoMarginID(ax), rangeSliderPush);\n\n        if(ax.automargin && (!hasRangeSlider || s !== 'b')) {\n            push = {x: 0, y: 0, r: 0, l: 0, t: 0, b: 0};\n\n            var bbox = ax._boundingBox;\n            var counterAx = mainPlotinfo[counterLetter + 'axis'];\n            var anchorAxDomainIndex;\n            var offset;\n\n            switch(axLetter + s) {\n                case 'xb':\n                    anchorAxDomainIndex = 0;\n                    offset = bbox.top - counterAx._length - counterAx._offset;\n                    push[s] = bbox.height;\n                    break;\n                case 'xt':\n                    anchorAxDomainIndex = 1;\n                    offset = counterAx._offset - bbox.bottom;\n                    push[s] = bbox.height;\n                    break;\n                case 'yl':\n                    anchorAxDomainIndex = 0;\n                    offset = counterAx._offset - bbox.right;\n                    push[s] = bbox.width;\n                    break;\n                case 'yr':\n                    anchorAxDomainIndex = 1;\n                    offset = bbox.left - counterAx._length - counterAx._offset;\n                    push[s] = bbox.width;\n                    break;\n            }\n\n            push[counterLetter] = ax.anchor === 'free' ?\n                ax.position :\n                ax._anchorAxis.domain[anchorAxDomainIndex];\n\n            if(push[s] > 0) {\n                push[s] += offset;\n            }\n            if(ax.title.text !== fullLayout._dfltTitle[axLetter]) {\n                push[s] += ax.title.font.size;\n            }\n        }\n\n        Plots.autoMargin(gd, axAutoMarginID(ax), push);\n    }\n\n    seq.push(calcBoundingBox, doAutoMargins);\n\n    if(!opts.skipTitle &&\n        !(hasRangeSlider && ax._boundingBox && ax.side === 'bottom')\n    ) {\n        seq.push(function() { return drawTitle(gd, ax); });\n    }\n\n    return Lib.syncOrAsync(seq);\n};\n\nfunction getBoundaryVals(ax, vals) {\n    var out = [];\n    var i;\n\n    // boundaryVals are never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            _push(vals[i], 0);\n        }\n        _push(vals[i - 1], 1);\n    }\n\n    return out;\n}\n\nfunction getSecondaryLabelVals(ax, vals) {\n    var out = [];\n    var lookup = {};\n\n    for(var i = 0; i < vals.length; i++) {\n        var d = vals[i];\n        if(lookup[d.text2]) {\n            lookup[d.text2].push(d.x);\n        } else {\n            lookup[d.text2] = [d.x];\n        }\n    }\n\n    for(var k in lookup) {\n        out.push(tickTextObj(ax, Lib.interp(lookup[k], 0.5), k));\n    }\n\n    return out;\n}\n\nfunction getDividerVals(ax, vals) {\n    var out = [];\n    var i, current;\n\n    // never used for labels;\n    // no need to worry about the other tickTextObj keys\n    var _push = function(d, bndIndex) {\n        var xb = d.xbnd[bndIndex];\n        if(xb !== null) {\n            out.push(Lib.extendFlat({}, d, {x: xb}));\n        }\n    };\n\n    if(ax.showdividers && vals.length) {\n        for(i = 0; i < vals.length; i++) {\n            var d = vals[i];\n            if(d.text2 !== current) {\n                _push(d, 0);\n            }\n            current = d.text2;\n        }\n        _push(vals[i - 1], 1);\n    }\n\n    return out;\n}\n\nfunction getLabelLevelSpan(ax, cls) {\n    var axLetter = ax._id.charAt(0);\n    var angle = ax._tickAngles[cls] || 0;\n    var rad = Lib.deg2rad(angle);\n    var sinA = Math.sin(rad);\n    var cosA = Math.cos(rad);\n    var maxX = 0;\n    var maxY = 0;\n\n    // N.B. Drawing.bBox does not take into account rotate transforms\n\n    ax._selections[cls].each(function() {\n        var thisLabel = selectTickLabel(this);\n        var bb = Drawing.bBox(thisLabel.node());\n        var w = bb.width;\n        var h = bb.height;\n        maxX = Math.max(maxX, cosA * w, sinA * h);\n        maxY = Math.max(maxY, sinA * w, cosA * h);\n    });\n\n    return {x: maxY, y: maxX}[axLetter];\n}\n\n/**\n * Which direction do the 'ax.side' values, and free ticks go?\n *\n * @param {object} ax (full) axis object\n *  - {string} _id (starting with 'x' or 'y')\n *  - {string} side\n *  - {string} ticks\n * @return {array} all entries are either -1 or 1\n *  - [0]: sign for top/right ticks (i.e. negative SVG direction)\n *  - [1]: sign for bottom/left ticks (i.e. positive SVG direction)\n *  - [2]: sign for ticks corresponding to 'ax.side'\n *  - [3]: sign for ticks mirroring 'ax.side'\n */\naxes.getTickSigns = function(ax) {\n    var axLetter = ax._id.charAt(0);\n    var sideOpposite = {x: 'top', y: 'right'}[axLetter];\n    var main = ax.side === sideOpposite ? 1 : -1;\n    var out = [-1, 1, main, -main];\n    // then we flip if outside XOR y axis\n    if((ax.ticks !== 'inside') === (axLetter === 'x')) {\n        out = out.map(function(v) { return -v; });\n    }\n    return out;\n};\n\n/**\n * Make axis translate transform function\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} _offset\n *  - {fn} l2p\n * @return {fn} function of calcTicks items\n */\naxes.makeTransFn = function(ax) {\n    var axLetter = ax._id.charAt(0);\n    var offset = ax._offset;\n    return axLetter === 'x' ?\n        function(d) { return 'translate(' + (offset + ax.l2p(d.x)) + ',0)'; } :\n        function(d) { return 'translate(0,' + (offset + ax.l2p(d.x)) + ')'; };\n};\n\n/**\n * Make axis tick path string\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {number} ticklen\n *  - {number} linewidth\n * @param {number} shift along direction of ticklen\n * @param {1 or -1} sng tick sign\n * @param {number (optional)} len tick length\n * @return {string}\n */\naxes.makeTickPath = function(ax, shift, sgn, len) {\n    len = len !== undefined ? len : ax.ticklen;\n\n    var axLetter = ax._id.charAt(0);\n    var pad = (ax.linewidth || 1) / 2;\n\n    return axLetter === 'x' ?\n        'M0,' + (shift + pad * sgn) + 'v' + (len * sgn) :\n        'M' + (shift + pad * sgn) + ',0h' + (len * sgn);\n};\n\n/**\n * Make axis tick label x, y and anchor functions\n *\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} ticklen\n *  - {string} side\n *  - {number} linewidth\n *  - {number} tickfont.size\n *  - {boolean} showline\n * @param {number} shift\n * @param {number} angle [in degrees] ...\n * @return {object}\n *  - {fn} labelXFn\n *  - {fn} labelYFn\n *  - {fn} labelAnchorFn\n *  - {number} labelStandoff\n *  - {number} labelShift\n */\naxes.makeLabelFns = function(ax, shift, angle) {\n    var axLetter = ax._id.charAt(0);\n    var pad = (ax.linewidth || 1) / 2;\n    var ticksOnOutsideLabels = ax.tickson !== 'boundaries' && ax.ticks === 'outside';\n\n    var labelStandoff = ticksOnOutsideLabels ? ax.ticklen : 0;\n    var labelShift = 0;\n\n    if(angle && ax.ticks === 'outside') {\n        var rad = Lib.deg2rad(angle);\n        labelStandoff = ax.ticklen * Math.cos(rad) + 1;\n        labelShift = ax.ticklen * Math.sin(rad);\n    }\n\n    if(ax.showticklabels && (ticksOnOutsideLabels || ax.showline)) {\n        labelStandoff += 0.2 * ax.tickfont.size;\n    }\n\n    // Used in polar angular label x/y functions\n    // TODO generalize makeLabelFns so that it just work for angular axes\n    var out = {\n        labelStandoff: labelStandoff,\n        labelShift: labelShift\n    };\n\n    var x0, y0, ff, flipIt;\n    if(axLetter === 'x') {\n        flipIt = ax.side === 'bottom' ? 1 : -1;\n        x0 = labelShift * flipIt;\n        y0 = shift + (labelStandoff + pad) * flipIt;\n        ff = ax.side === 'bottom' ? 1 : -0.2;\n\n        out.labelXFn = function(d) { return d.dx + x0; };\n        out.labelYFn = function(d) { return d.dy + y0 + d.fontSize * ff; };\n        out.labelAnchorFn = function(a) {\n            if(!isNumeric(a) || a === 0 || a === 180) {\n                return 'middle';\n            }\n            return (a * flipIt < 0) ? 'end' : 'start';\n        };\n    } else if(axLetter === 'y') {\n        flipIt = ax.side === 'right' ? 1 : -1;\n        x0 = labelStandoff + pad;\n        y0 = -labelShift * flipIt;\n        ff = Math.abs(ax.tickangle) === 90 ? 0.5 : 0;\n\n        out.labelXFn = function(d) { return d.dx + shift + (x0 + d.fontSize * ff) * flipIt; };\n        out.labelYFn = function(d) { return d.dy + y0 + d.fontSize * MID_SHIFT; };\n        out.labelAnchorFn = function(a) {\n            if(isNumeric(a) && Math.abs(a) === 90) {\n                return 'middle';\n            }\n            return ax.side === 'right' ? 'start' : 'end';\n        };\n    }\n\n    return out;\n};\n\nfunction tickDataFn(d) {\n    return [d.text, d.x, d.axInfo, d.font, d.fontSize, d.fontColor].join('_');\n}\n\n/**\n * Draw axis ticks\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} ticks\n *  - {number} linewidth\n *  - {string} tickcolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawTicks = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'tick';\n\n    var ticks = opts.layer.selectAll('path.' + cls)\n        .data(ax.ticks ? opts.vals : [], tickDataFn);\n\n    ticks.exit().remove();\n\n    ticks.enter().append('path')\n        .classed(cls, 1)\n        .classed('ticks', 1)\n        .classed('crisp', opts.crisp !== false)\n        .call(Color.stroke, ax.tickcolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.tickwidth, 1) + 'px')\n        .attr('d', opts.path);\n\n    ticks.attr('transform', opts.transFn);\n};\n\n/**\n * Draw axis grid\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showgrid\n *  - {string} gridcolor\n *  - {string} gridwidth\n *  - {boolean} zeroline\n *  - {string} type\n *  - {string} dtick\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n *     optional - only required if this axis supports zero lines\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawGrid = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var cls = ax._id + 'grid';\n    var vals = opts.vals;\n    var counterAx = opts.counterAxis;\n    if(ax.showgrid === false) {\n        vals = [];\n    }\n    else if(counterAx && axes.shouldShowZeroLine(gd, ax, counterAx)) {\n        var isArrayMode = ax.tickmode === 'array';\n        for(var i = 0; i < vals.length; i++) {\n            var xi = vals[i].x;\n            if(isArrayMode ? !xi : (Math.abs(xi) < ax.dtick / 100)) {\n                vals = vals.slice(0, i).concat(vals.slice(i + 1));\n                // In array mode you can in principle have multiple\n                // ticks at 0, so test them all. Otherwise once we found\n                // one we can stop.\n                if(isArrayMode) i--;\n                else break;\n            }\n        }\n    }\n\n    var grid = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    grid.exit().remove();\n\n    grid.enter().append('path')\n        .classed(cls, 1)\n        .classed('crisp', opts.crisp !== false);\n\n    ax._gw = Drawing.crispRound(gd, ax.gridwidth, 1);\n\n    grid.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.gridcolor || '#ddd')\n        .style('stroke-width', ax._gw + 'px');\n\n    if(typeof opts.path === 'function') grid.attr('d', opts.path);\n};\n\n/**\n * Draw axis zero-line\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} zeroline\n *  - {number} zerolinewidth\n *  - {string} zerolinecolor\n *  - {number (optional)} _gridWidthCrispRound\n * @param {object} opts\n * - {d3 selection} layer\n * - {object} counterAxis (full axis object corresponding to counter axis)\n * - {string or fn} path\n * - {fn} transFn\n * - {boolean} crisp (set to false to unset crisp-edge SVG rendering)\n */\naxes.drawZeroLine = function(gd, ax, opts) {\n    opts = opts || opts;\n\n    var cls = ax._id + 'zl';\n    var show = axes.shouldShowZeroLine(gd, ax, opts.counterAxis);\n\n    var zl = opts.layer.selectAll('path.' + cls)\n        .data(show ? [{x: 0, id: ax._id}] : []);\n\n    zl.exit().remove();\n\n    zl.enter().append('path')\n        .classed(cls, 1)\n        .classed('zl', 1)\n        .classed('crisp', opts.crisp !== false)\n        .each(function() {\n            // use the fact that only one element can enter to trigger a sort.\n            // If several zerolines enter at the same time we will sort once per,\n            // but generally this should be a minimal overhead.\n            opts.layer.selectAll('path').sort(function(da, db) {\n                return axisIds.idSort(da.id, db.id);\n            });\n        });\n\n    zl.attr('transform', opts.transFn)\n        .attr('d', opts.path)\n        .call(Color.stroke, ax.zerolinecolor || Color.defaultLine)\n        .style('stroke-width', Drawing.crispRound(gd, ax.zerolinewidth, ax._gw || 1) + 'px');\n};\n\n/**\n * Draw axis tick labels\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {boolean} showticklabels\n *  - {number} tickangle\n *  - {object (optional)} _selections\n *  - {object} (optional)} _tickAngles\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {string (optional)} cls (node className)\n * - {boolean} repositionOnUpdate (set to true to reposition update selection)\n * - {boolean} secondary\n * - {fn} transFn\n * - {fn} labelXFn\n * - {fn} labelYFn\n * - {fn} labelAnchorFn\n */\naxes.drawLabels = function(gd, ax, opts) {\n    opts = opts || {};\n\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var cls = opts.cls || axId + 'tick';\n    var vals = opts.vals;\n    var labelXFn = opts.labelXFn;\n    var labelYFn = opts.labelYFn;\n    var labelAnchorFn = opts.labelAnchorFn;\n    var tickAngle = opts.secondary ? 0 : ax.tickangle;\n    var lastAngle = (ax._tickAngles || {})[cls];\n\n    var tickLabels = opts.layer.selectAll('g.' + cls)\n        .data(ax.showticklabels ? vals : [], tickDataFn);\n\n    var labelsReady = [];\n\n    tickLabels.enter().append('g')\n        .classed(cls, 1)\n        .append('text')\n            // only so tex has predictable alignment that we can\n            // alter later\n            .attr('text-anchor', 'middle')\n            .each(function(d) {\n                var thisLabel = d3.select(this);\n                var newPromise = gd._promises.length;\n\n                thisLabel\n                    .call(svgTextUtils.positionText, labelXFn(d), labelYFn(d))\n                    .call(Drawing.font, d.font, d.fontSize, d.fontColor)\n                    .text(d.text)\n                    .call(svgTextUtils.convertToTspans, gd);\n\n                if(gd._promises[newPromise]) {\n                    // if we have an async label, we'll deal with that\n                    // all here so take it out of gd._promises and\n                    // instead position the label and promise this in\n                    // labelsReady\n                    labelsReady.push(gd._promises.pop().then(function() {\n                        positionLabels(thisLabel, tickAngle);\n                    }));\n                } else {\n                    // sync label: just position it now.\n                    positionLabels(thisLabel, tickAngle);\n                }\n            });\n\n    tickLabels.exit().remove();\n\n    if(opts.repositionOnUpdate) {\n        tickLabels.each(function(d) {\n            d3.select(this).select('text')\n                .call(svgTextUtils.positionText, labelXFn(d), labelYFn(d));\n        });\n    }\n\n    // How much to shift a multi-line label to center it vertically.\n    function getAnchorHeight(lineCount, lineHeight, angle) {\n        var h = (lineCount - 1) * lineHeight;\n        if(axLetter === 'x') {\n            if(angle < -60 || 60 < angle) {\n                return -0.5 * h;\n            } else if(ax.side === 'top') {\n                return -h;\n            }\n        } else {\n            angle *= ax.side === 'left' ? 1 : -1;\n            if(angle < -30) {\n                return -h;\n            } else if(angle < 30) {\n                return -0.5 * h;\n            }\n        }\n        return 0;\n    }\n\n    function positionLabels(s, angle) {\n        s.each(function(d) {\n            var thisLabel = d3.select(this);\n            var mathjaxGroup = thisLabel.select('.text-math-group');\n            var anchor = labelAnchorFn(angle, d);\n\n            var transform = opts.transFn.call(thisLabel.node(), d) +\n                ((isNumeric(angle) && +angle !== 0) ?\n                (' rotate(' + angle + ',' + labelXFn(d) + ',' +\n                    (labelYFn(d) - d.fontSize / 2) + ')') :\n                '');\n\n            var anchorHeight = getAnchorHeight(\n                svgTextUtils.lineCount(thisLabel),\n                LINE_SPACING * d.fontSize,\n                isNumeric(angle) ? +angle : 0\n            );\n\n            if(anchorHeight) {\n                transform += ' translate(0, ' + anchorHeight + ')';\n            }\n\n            if(mathjaxGroup.empty()) {\n                thisLabel.select('text').attr({\n                    transform: transform,\n                    'text-anchor': anchor\n                });\n            } else {\n                var mjWidth = Drawing.bBox(mathjaxGroup.node()).width;\n                var mjShift = mjWidth * {end: -0.5, start: 0.5}[anchor];\n                mathjaxGroup.attr('transform', transform + (mjShift ? 'translate(' + mjShift + ',0)' : ''));\n            }\n        });\n    }\n\n    // make sure all labels are correctly positioned at their base angle\n    // the positionLabels call above is only for newly drawn labels.\n    // do this without waiting, using the last calculated angle to\n    // minimize flicker, then do it again when we know all labels are\n    // there, putting back the prescribed angle to check for overlaps.\n    positionLabels(tickLabels, lastAngle || tickAngle);\n\n    function allLabelsReady() {\n        return labelsReady.length && Promise.all(labelsReady);\n    }\n\n    function fixLabelOverlaps() {\n        positionLabels(tickLabels, tickAngle);\n\n        var autoangle = null;\n\n        // check for auto-angling if x labels overlap\n        // don't auto-angle at all for log axes with\n        // base and digit format\n        if(vals.length && axLetter === 'x' && !isNumeric(tickAngle) &&\n            (ax.type !== 'log' || String(ax.dtick).charAt(0) !== 'D')\n        ) {\n            autoangle = 0;\n\n            var maxFontSize = 0;\n            var lbbArray = [];\n            var i;\n\n            tickLabels.each(function(d) {\n                maxFontSize = Math.max(maxFontSize, d.fontSize);\n\n                var x = ax.l2p(d.x);\n                var thisLabel = selectTickLabel(this);\n                var bb = Drawing.bBox(thisLabel.node());\n\n                lbbArray.push({\n                    // ignore about y, just deal with x overlaps\n                    top: 0,\n                    bottom: 10,\n                    height: 10,\n                    left: x - bb.width / 2,\n                    // impose a 2px gap\n                    right: x + bb.width / 2 + 2,\n                    width: bb.width + 2\n                });\n            });\n\n            if((ax.tickson === 'boundaries' || ax.showdividers) && !opts.secondary) {\n                var gap = 2;\n                if(ax.ticks) gap += ax.tickwidth / 2;\n\n                // TODO should secondary labels also fall into this fix-overlap regime?\n\n                for(i = 0; i < lbbArray.length; i++) {\n                    var xbnd = vals[i].xbnd;\n                    var lbb = lbbArray[i];\n                    if(\n                        (xbnd[0] !== null && (lbb.left - ax.l2p(xbnd[0])) < gap) ||\n                        (xbnd[1] !== null && (ax.l2p(xbnd[1]) - lbb.right) < gap)\n                    ) {\n                        autoangle = 90;\n                        break;\n                    }\n                }\n            } else {\n                var vLen = vals.length;\n                var tickSpacing = Math.abs((vals[vLen - 1].x - vals[0].x) * ax._m) / (vLen - 1);\n                var rotate90 = (tickSpacing < maxFontSize * 2.5) || ax.type === 'multicategory';\n\n                // any overlap at all - set 30 degrees or 90 degrees\n                for(i = 0; i < lbbArray.length - 1; i++) {\n                    if(Lib.bBoxIntersect(lbbArray[i], lbbArray[i + 1])) {\n                        autoangle = rotate90 ? 90 : 30;\n                        break;\n                    }\n                }\n            }\n\n            if(autoangle) {\n                positionLabels(tickLabels, autoangle);\n            }\n        }\n\n        if(ax._tickAngles) {\n            ax._tickAngles[cls] = autoangle === null ?\n                (isNumeric(tickAngle) ? tickAngle : 0) :\n                autoangle;\n        }\n    }\n\n    if(ax._selections) {\n        ax._selections[cls] = tickLabels;\n    }\n\n    var done = Lib.syncOrAsync([allLabelsReady, fixLabelOverlaps]);\n    if(done && done.then) gd._promises.push(done);\n    return done;\n};\n\n/**\n * Draw axis dividers\n *\n * @param {DOM element} gd\n * @param {object} ax (full) axis object\n *  - {string} _id\n *  - {string} showdividers\n *  - {number} dividerwidth\n *  - {string} dividercolor\n * @param {object} opts\n * - {array of object} vals (calcTicks output-like)\n * - {d3 selection} layer\n * - {fn} path\n * - {fn} transFn\n */\nfunction drawDividers(gd, ax, opts) {\n    var cls = ax._id + 'divider';\n    var vals = opts.vals;\n\n    var dividers = opts.layer.selectAll('path.' + cls)\n        .data(vals, tickDataFn);\n\n    dividers.exit().remove();\n\n    dividers.enter().insert('path', ':first-child')\n        .classed(cls, 1)\n        .classed('crisp', 1)\n        .call(Color.stroke, ax.dividercolor)\n        .style('stroke-width', Drawing.crispRound(gd, ax.dividerwidth, 1) + 'px');\n\n    dividers\n        .attr('transform', opts.transFn)\n        .attr('d', opts.path);\n}\n\nfunction drawTitle(gd, ax) {\n    var fullLayout = gd._fullLayout;\n    var axId = ax._id;\n    var axLetter = axId.charAt(0);\n    var gs = fullLayout._size;\n    var fontSize = ax.title.font.size;\n\n    var titleStandoff;\n    if(ax.type === 'multicategory') {\n        titleStandoff = ax._labelLength;\n    } else {\n        var offsetBase = 1.5;\n        titleStandoff = 10 + fontSize * offsetBase + (ax.linewidth ? ax.linewidth - 1 : 0);\n    }\n\n    var transform, counterAxis, x, y;\n\n    if(axLetter === 'x') {\n        counterAxis = (ax.anchor === 'free') ?\n            {_offset: gs.t + (1 - (ax.position || 0)) * gs.h, _length: 0} :\n            axisIds.getFromId(gd, ax.anchor);\n\n        x = ax._offset + ax._length / 2;\n\n        if(ax.side === 'top') {\n            y = -titleStandoff - fontSize * (ax.showticklabels ? 1 : 0);\n        } else {\n            y = counterAxis._length + titleStandoff +\n                fontSize * (ax.showticklabels ? 1.5 : 0.5);\n        }\n        y += counterAxis._offset;\n    } else {\n        counterAxis = (ax.anchor === 'free') ?\n            {_offset: gs.l + (ax.position || 0) * gs.w, _length: 0} :\n            axisIds.getFromId(gd, ax.anchor);\n\n        y = ax._offset + ax._length / 2;\n\n        if(ax.side === 'right') {\n            x = counterAxis._length + titleStandoff +\n                fontSize * (ax.showticklabels ? 1 : 0.5);\n        } else {\n            x = -titleStandoff - fontSize * (ax.showticklabels ? 0.5 : 0);\n        }\n        x += counterAxis._offset;\n\n        transform = {rotate: '-90', offset: 0};\n    }\n\n    var avoid;\n\n    if(ax.type !== 'multicategory') {\n        var tickLabels = ax._selections[ax._id + 'tick'];\n\n        avoid = {\n            selection: tickLabels,\n            side: ax.side\n        };\n\n        if(tickLabels && tickLabels.node() && tickLabels.node().parentNode) {\n            var translation = Drawing.getTranslate(tickLabels.node().parentNode);\n            avoid.offsetLeft = translation.x;\n            avoid.offsetTop = translation.y;\n        }\n    }\n\n    return Titles.draw(gd, axId + 'title', {\n        propContainer: ax,\n        propName: ax._name + '.title.text',\n        placeholder: fullLayout._dfltTitle[axLetter],\n        avoid: avoid,\n        transform: transform,\n        attributes: {x: x, y: y, 'text-anchor': 'middle'}\n    });\n}\n\naxes.shouldShowZeroLine = function(gd, ax, counterAxis) {\n    var rng = Lib.simpleMap(ax.range, ax.r2l);\n    return (\n        (rng[0] * rng[1] <= 0) &&\n        ax.zeroline &&\n        (ax.type === 'linear' || ax.type === '-') &&\n        ax._gridVals.length &&\n        (\n            clipEnds(ax, 0) ||\n            !anyCounterAxLineAtZero(gd, ax, counterAxis, rng) ||\n            hasBarsOrFill(gd, ax)\n        )\n    );\n};\n\naxes.clipEnds = function(ax, vals) {\n    return vals.filter(function(d) { return clipEnds(ax, d.x); });\n};\n\nfunction clipEnds(ax, l) {\n    var p = ax.l2p(l);\n    return (p > 1 && p < ax._length - 1);\n}\n\nfunction anyCounterAxLineAtZero(gd, ax, counterAxis, rng) {\n    var mainCounterAxis = counterAxis._mainAxis;\n    if(!mainCounterAxis) return;\n\n    var fullLayout = gd._fullLayout;\n    var axLetter = ax._id.charAt(0);\n    var counterLetter = axes.counterLetter(ax._id);\n\n    var zeroPosition = ax._offset + (\n        ((Math.abs(rng[0]) < Math.abs(rng[1])) === (axLetter === 'x')) ?\n        0 : ax._length\n    );\n\n    function lineNearZero(ax2) {\n        if(!ax2.showline || !ax2.linewidth) return false;\n        var tolerance = Math.max((ax2.linewidth + ax.zerolinewidth) / 2, 1);\n\n        function closeEnough(pos2) {\n            return typeof pos2 === 'number' && Math.abs(pos2 - zeroPosition) < tolerance;\n        }\n\n        if(closeEnough(ax2._mainLinePosition) || closeEnough(ax2._mainMirrorPosition)) {\n            return true;\n        }\n        var linePositions = ax2._linepositions || {};\n        for(var k in linePositions) {\n            if(closeEnough(linePositions[k][0]) || closeEnough(linePositions[k][1])) {\n                return true;\n            }\n        }\n    }\n\n    var plotinfo = fullLayout._plots[counterAxis._mainSubplot];\n    if(!(plotinfo.mainplotinfo || plotinfo).overlays.length) {\n        return lineNearZero(counterAxis, zeroPosition);\n    }\n\n    var counterLetterAxes = axes.list(gd, counterLetter);\n    for(var i = 0; i < counterLetterAxes.length; i++) {\n        var counterAxis2 = counterLetterAxes[i];\n        if(\n            counterAxis2._mainAxis === mainCounterAxis &&\n            lineNearZero(counterAxis2, zeroPosition)\n        ) {\n            return true;\n        }\n    }\n}\n\nfunction hasBarsOrFill(gd, ax) {\n    var fullData = gd._fullData;\n    var subplot = ax._mainSubplot;\n    var axLetter = ax._id.charAt(0);\n\n    for(var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if(trace.visible === true &&\n            (trace.xaxis + trace.yaxis) === subplot &&\n            (\n                Registry.traceIs(trace, 'bar') && trace.orientation === {x: 'h', y: 'v'}[axLetter] ||\n                trace.fill && trace.fill.charAt(trace.fill.length - 1) === axLetter\n            )\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction selectTickLabel(gTick) {\n    var s = d3.select(gTick);\n    var mj = s.select('.text-math-group');\n    return mj.empty() ? s.select('text') : mj;\n}\n\n/**\n * Find all margin pushers for 2D axes and reserve them for later use\n * Both label and rangeslider automargin calculations happen later so\n * we need to explicitly allow their ids in order to not delete them.\n *\n * TODO: can we pull the actual automargin calls forward to avoid this hack?\n * We're probably also doing multiple redraws in this case, would be faster\n * if we can just do the whole calculation ahead of time and draw once.\n */\naxes.allowAutoMargin = function(gd) {\n    var axList = axes.list(gd, '', true);\n    for(var i = 0; i < axList.length; i++) {\n        var ax = axList[i];\n        if(ax.automargin) {\n            Plots.allowAutoMargin(gd, axAutoMarginID(ax));\n        }\n        if(Registry.getComponentMethod('rangeslider', 'isVisible')(ax)) {\n            Plots.allowAutoMargin(gd, rangeSliderAutoMarginID(ax));\n        }\n    }\n};\n\nfunction axAutoMarginID(ax) { return ax._id + '.automargin'; }\nfunction rangeSliderAutoMarginID(ax) { return ax._id + '.rangeslider'; }\n\n// swap all the presentation attributes of the axes showing these traces\naxes.swap = function(gd, traces) {\n    var axGroups = makeAxisGroups(gd, traces);\n\n    for(var i = 0; i < axGroups.length; i++) {\n        swapAxisGroup(gd, axGroups[i].x, axGroups[i].y);\n    }\n};\n\nfunction makeAxisGroups(gd, traces) {\n    var groups = [];\n    var i, j;\n\n    for(i = 0; i < traces.length; i++) {\n        var groupsi = [];\n        var xi = gd._fullData[traces[i]].xaxis;\n        var yi = gd._fullData[traces[i]].yaxis;\n        if(!xi || !yi) continue; // not a 2D cartesian trace?\n\n        for(j = 0; j < groups.length; j++) {\n            if(groups[j].x.indexOf(xi) !== -1 || groups[j].y.indexOf(yi) !== -1) {\n                groupsi.push(j);\n            }\n        }\n\n        if(!groupsi.length) {\n            groups.push({x: [xi], y: [yi]});\n            continue;\n        }\n\n        var group0 = groups[groupsi[0]];\n        var groupj;\n\n        if(groupsi.length > 1) {\n            for(j = 1; j < groupsi.length; j++) {\n                groupj = groups[groupsi[j]];\n                mergeAxisGroups(group0.x, groupj.x);\n                mergeAxisGroups(group0.y, groupj.y);\n            }\n        }\n        mergeAxisGroups(group0.x, [xi]);\n        mergeAxisGroups(group0.y, [yi]);\n    }\n\n    return groups;\n}\n\nfunction mergeAxisGroups(intoSet, fromSet) {\n    for(var i = 0; i < fromSet.length; i++) {\n        if(intoSet.indexOf(fromSet[i]) === -1) intoSet.push(fromSet[i]);\n    }\n}\n\nfunction swapAxisGroup(gd, xIds, yIds) {\n    var xFullAxes = [];\n    var yFullAxes = [];\n    var layout = gd.layout;\n    var i, j;\n\n    for(i = 0; i < xIds.length; i++) xFullAxes.push(axes.getFromId(gd, xIds[i]));\n    for(i = 0; i < yIds.length; i++) yFullAxes.push(axes.getFromId(gd, yIds[i]));\n\n    var allAxKeys = Object.keys(axAttrs);\n\n    var noSwapAttrs = [\n        'anchor', 'domain', 'overlaying', 'position', 'side', 'tickangle', 'editType'\n    ];\n    var numericTypes = ['linear', 'log'];\n\n    for(i = 0; i < allAxKeys.length; i++) {\n        var keyi = allAxKeys[i];\n        var xVal = xFullAxes[0][keyi];\n        var yVal = yFullAxes[0][keyi];\n        var allEqual = true;\n        var coerceLinearX = false;\n        var coerceLinearY = false;\n        if(keyi.charAt(0) === '_' || typeof xVal === 'function' ||\n                noSwapAttrs.indexOf(keyi) !== -1) {\n            continue;\n        }\n        for(j = 1; j < xFullAxes.length && allEqual; j++) {\n            var xVali = xFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(xVal) !== -1 &&\n                    numericTypes.indexOf(xVali) !== -1 && xVal !== xVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearX = true;\n            }\n            else if(xVali !== xVal) allEqual = false;\n        }\n        for(j = 1; j < yFullAxes.length && allEqual; j++) {\n            var yVali = yFullAxes[j][keyi];\n            if(keyi === 'type' && numericTypes.indexOf(yVal) !== -1 &&\n                    numericTypes.indexOf(yVali) !== -1 && yVal !== yVali) {\n                // type is special - if we find a mixture of linear and log,\n                // coerce them all to linear on flipping\n                coerceLinearY = true;\n            }\n            else if(yFullAxes[j][keyi] !== yVal) allEqual = false;\n        }\n        if(allEqual) {\n            if(coerceLinearX) layout[xFullAxes[0]._name].type = 'linear';\n            if(coerceLinearY) layout[yFullAxes[0]._name].type = 'linear';\n            swapAxisAttrs(layout, keyi, xFullAxes, yFullAxes, gd._fullLayout._dfltTitle);\n        }\n    }\n\n    // now swap x&y for any annotations anchored to these x & y\n    for(i = 0; i < gd._fullLayout.annotations.length; i++) {\n        var ann = gd._fullLayout.annotations[i];\n        if(xIds.indexOf(ann.xref) !== -1 &&\n                yIds.indexOf(ann.yref) !== -1) {\n            Lib.swapAttrs(layout.annotations[i], ['?']);\n        }\n    }\n}\n\nfunction swapAxisAttrs(layout, key, xFullAxes, yFullAxes, dfltTitle) {\n    // in case the value is the default for either axis,\n    // look at the first axis in each list and see if\n    // this key's value is undefined\n    var np = Lib.nestedProperty;\n    var xVal = np(layout[xFullAxes[0]._name], key).get();\n    var yVal = np(layout[yFullAxes[0]._name], key).get();\n    var i;\n\n    if(key === 'title') {\n        // special handling of placeholder titles\n        if(xVal && xVal.text === dfltTitle.x) {\n            xVal.text = dfltTitle.y;\n        }\n        if(yVal && yVal.text === dfltTitle.y) {\n            yVal.text = dfltTitle.x;\n        }\n    }\n\n    for(i = 0; i < xFullAxes.length; i++) {\n        np(layout, xFullAxes[i]._name + '.' + key).set(yVal);\n    }\n    for(i = 0; i < yFullAxes.length; i++) {\n        np(layout, yFullAxes[i]._name + '.' + key).set(xVal);\n    }\n}\n\nfunction isAngular(ax) {\n    return ax._id === 'angularaxis';\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}