{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\nmodule.exports = function calc(gd, trace) {\n  // ignore as much processing as possible (and including in autorange) if not visible\n  if (trace.visible !== true) return;\n\n  // depending on orientation, set position and size axes and data ranges\n  // note: this logic for choosing orientation is duplicated in graph_obj->setstyles\n  var pos = [];\n  var size = [];\n  var pa = Axes.getFromId(gd, trace.orientation === 'h' ? trace.yaxis || 'y' : trace.xaxis || 'x');\n  var mainData = trace.orientation === 'h' ? 'y' : 'x';\n  var counterData = {\n    x: 'y',\n    y: 'x'\n  }[mainData];\n  var calendar = trace[mainData + 'calendar'];\n  var cumulativeSpec = trace.cumulative;\n  var i;\n  var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n  var binSpec = binsAndPos[0];\n  var pos0 = binsAndPos[1];\n  var nonuniformBins = typeof binSpec.size === 'string';\n  var binEdges = [];\n  var bins = nonuniformBins ? binEdges : binSpec;\n  // make the empty bin array\n  var inc = [];\n  var counts = [];\n  var inputPoints = [];\n  var total = 0;\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densityNorm = norm.indexOf('density') !== -1;\n  var i2, binEnd, n;\n  if (cumulativeSpec.enabled && densityNorm) {\n    // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n    // which in the end means it's the same as without \"density\"\n    norm = norm.replace(/ ?density$/, '');\n    densityNorm = false;\n  }\n  var extremeFunc = func === 'max' || func === 'min';\n  var sizeInit = extremeFunc ? null : 0;\n  var binFunc = binFunctions.count;\n  var normFunc = normFunctions[norm];\n  var isAvg = false;\n  var pr2c = function pr2c(v) {\n    return pa.r2c(v, 0, calendar);\n  };\n  var rawCounterData;\n  if (Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n    rawCounterData = trace[counterData];\n    isAvg = func === 'avg';\n    binFunc = binFunctions[func];\n  }\n\n  // create the bins (and any extra arrays needed)\n  // assume more than 1e6 bins is an error, so we don't crash the browser\n  i = pr2c(binSpec.start);\n\n  // decrease end a little in case of rounding errors\n  binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n  while (i < binEnd && pos.length < 1e6) {\n    i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n    pos.push((i + i2) / 2);\n    size.push(sizeInit);\n    inputPoints.push([]);\n    // nonuniform bins (like months) we need to search,\n    // rather than straight calculate the bin we're in\n    binEdges.push(i);\n    // nonuniform bins also need nonuniform normalization factors\n    if (densityNorm) inc.push(1 / (i2 - i));\n    if (isAvg) counts.push(0);\n    // break to avoid infinite loops\n    if (i2 <= i) break;\n    i = i2;\n  }\n  binEdges.push(i);\n\n  // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n  if (!nonuniformBins && pa.type === 'date') {\n    bins = {\n      start: pr2c(bins.start),\n      end: pr2c(bins.end),\n      size: bins.size\n    };\n  }\n\n  // bin the data\n  // and make histogram-specific pt-number-to-cd-index map object\n  var nMax = size.length;\n  var uniqueValsPerBin = true;\n  var leftGap = Infinity;\n  var rightGap = Infinity;\n  var ptNumber2cdIndex = {};\n  for (i = 0; i < pos0.length; i++) {\n    var posi = pos0[i];\n    n = Lib.findBin(posi, bins);\n    if (n >= 0 && n < nMax) {\n      total += binFunc(n, i, size, rawCounterData, counts);\n      if (uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n        uniqueValsPerBin = false;\n      }\n      inputPoints[n].push(i);\n      ptNumber2cdIndex[i] = n;\n      leftGap = Math.min(leftGap, posi - binEdges[n]);\n      rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n    }\n  }\n  var roundFn;\n  if (!uniqueValsPerBin) {\n    roundFn = getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar);\n  }\n\n  // average and/or normalize the data, if needed\n  if (isAvg) total = doAvg(size, counts);\n  if (normFunc) normFunc(size, total, inc);\n\n  // after all normalization etc, now we can accumulate if desired\n  if (cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n  var seriesLen = Math.min(pos.length, size.length);\n  var cd = [];\n  var firstNonzero = 0;\n  var lastNonzero = seriesLen - 1;\n\n  // look for empty bins at the ends to remove, so autoscale omits them\n  for (i = 0; i < seriesLen; i++) {\n    if (size[i]) {\n      firstNonzero = i;\n      break;\n    }\n  }\n  for (i = seriesLen - 1; i >= firstNonzero; i--) {\n    if (size[i]) {\n      lastNonzero = i;\n      break;\n    }\n  }\n\n  // create the \"calculated data\" to plot\n  for (i = firstNonzero; i <= lastNonzero; i++) {\n    if (isNumeric(pos[i]) && isNumeric(size[i])) {\n      var cdi = {\n        p: pos[i],\n        s: size[i],\n        b: 0\n      };\n\n      // setup hover and event data fields,\n      // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n      // for cumulative distributions\n      if (!cumulativeSpec.enabled) {\n        cdi.pts = inputPoints[i];\n        if (uniqueValsPerBin) {\n          cdi.ph0 = cdi.ph1 = inputPoints[i].length ? pos0[inputPoints[i][0]] : pos[i];\n        } else {\n          cdi.ph0 = roundFn(binEdges[i]);\n          cdi.ph1 = roundFn(binEdges[i + 1], true);\n        }\n      }\n      cd.push(cdi);\n    }\n  }\n  if (cd.length === 1) {\n    // when we collapse to a single bin, calcdata no longer describes bin size\n    // so we need to explicitly specify it\n    cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n  }\n  arraysToCalcdata(cd, trace);\n  if (Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n    Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n  }\n  return cd;\n};\n\n/*\n * calcAllAutoBins: we want all histograms on the same axes to share bin specs\n * if they're grouped or stacked. If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms grouped/stacked\n * together.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n  var binAttr = mainData + 'bins';\n  var fullLayout = gd._fullLayout;\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n  var cleanBound = pa.type === 'date' ? function (v) {\n    return v || v === 0 ? Lib.cleanDate(v, null, pa.calendar) : null;\n  } : function (v) {\n    return isNumeric(v) ? Number(v) : null;\n  };\n  function setBound(attr, bins, newBins) {\n    if (bins[attr + 'Found']) {\n      bins[attr] = cleanBound(bins[attr]);\n      if (bins[attr] === null) bins[attr] = newBins[attr];\n    } else {\n      autoVals[attr] = bins[attr] = newBins[attr];\n      Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n    }\n  }\n  var binOpts = fullLayout._histogramBinOpts[trace._groupName];\n\n  // all but the first trace in this group has already been marked finished\n  // clear this flag, so next time we run calc we will run autobin again\n  if (trace._autoBinFinished) {\n    delete trace._autoBinFinished;\n  } else {\n    traces = binOpts.traces;\n    var sizeFound = binOpts.sizeFound;\n    var allPos = [];\n    autoVals = traces[0]._autoBin = {};\n    // Note: we're including `legendonly` traces here for autobin purposes,\n    // so that showing & hiding from the legend won't affect bins.\n    // But this complicates things a bit since those traces don't `calc`,\n    // hence `isFirstVisible`.\n    var isFirstVisible = true;\n    for (i = 0; i < traces.length; i++) {\n      tracei = traces[i];\n      if (tracei.visible) {\n        pos0 = tracei._pos0 = pa.makeCalcdata(tracei, mainData);\n        allPos = Lib.concat(allPos, pos0);\n        delete tracei._autoBinFinished;\n        if (trace.visible === true) {\n          if (isFirstVisible) {\n            isFirstVisible = false;\n          } else {\n            delete tracei._autoBin;\n            tracei._autoBinFinished = 1;\n          }\n        }\n      }\n    }\n    calendar = traces[0][mainData + 'calendar'];\n    var newBinSpec = Axes.autoBin(allPos, pa, binOpts.nbins, false, calendar, sizeFound && binOpts.size);\n\n    // Edge case: single-valued histogram overlaying others\n    // Use them all together to calculate the bin size for the single-valued one\n    if (isOverlay && newBinSpec._dataSpan === 0 && pa.type !== 'category' && pa.type !== 'multicategory') {\n      // Several single-valued histograms! Stop infinite recursion,\n      // just return an extra flag that tells handleSingleValueOverlays\n      // to sort out this trace too\n      if (_overlayEdgeCase) return [newBinSpec, pos0, true];\n      newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n    }\n\n    // adjust for CDF edge cases\n    cumulativeSpec = tracei.cumulative;\n    if (cumulativeSpec.enabled && cumulativeSpec.currentbin !== 'include') {\n      if (cumulativeSpec.direction === 'decreasing') {\n        newBinSpec.start = pa.c2r(Axes.tickIncrement(pa.r2c(newBinSpec.start, 0, calendar), newBinSpec.size, true, calendar));\n      } else {\n        newBinSpec.end = pa.c2r(Axes.tickIncrement(pa.r2c(newBinSpec.end, 0, calendar), newBinSpec.size, false, calendar));\n      }\n    }\n    binOpts.size = newBinSpec.size;\n    if (!sizeFound) {\n      autoVals.size = newBinSpec.size;\n      Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n    }\n    setBound('start', binOpts, newBinSpec);\n    setBound('end', binOpts, newBinSpec);\n  }\n  pos0 = trace._pos0;\n  delete trace._pos0;\n\n  // Each trace can specify its own start/end, or if omitted\n  // we ensure they're beyond the bounds of this trace's data,\n  // and we need to make sure start is aligned with the main start\n  var traceInputBins = trace._input[binAttr] || {};\n  var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n  var mainStart = binOpts.start;\n  var startIn = pa.r2l(traceInputBins.start);\n  var hasStart = startIn !== undefined;\n  if ((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n    // We have an explicit start to reconcile across traces\n    // if this trace has an explicit start, shift it down to a bin edge\n    // if another trace had an explicit start, shift it down to a\n    // bin edge past our data\n    var traceStart = hasStart ? startIn : Lib.aggNums(Math.min, null, pos0);\n    var dummyAx = {\n      type: pa.type === 'category' || pa.type === 'multicategory' ? 'linear' : pa.type,\n      r2l: pa.r2l,\n      dtick: binOpts.size,\n      tick0: mainStart,\n      calendar: calendar,\n      range: [traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)].map(pa.l2r)\n    };\n    var newStart = Axes.tickFirst(dummyAx);\n    if (newStart > pa.r2l(traceStart)) {\n      newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n    }\n    traceBinOptsCalc.start = pa.l2r(newStart);\n    if (!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n  }\n  var mainEnd = binOpts.end;\n  var endIn = pa.r2l(traceInputBins.end);\n  var hasEnd = endIn !== undefined;\n  if ((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n    // Reconciling an explicit end is easier, as it doesn't need to\n    // match bin edges\n    var traceEnd = hasEnd ? endIn : Lib.aggNums(Math.max, null, pos0);\n    traceBinOptsCalc.end = pa.l2r(traceEnd);\n    if (!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n  }\n\n  // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n  var autoBinAttr = 'autobin' + mainData;\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n  return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n  var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n  var pastThisTrace = false;\n  var minSize = Infinity;\n  var singleValuedTraces = [trace];\n  var i, tracei;\n\n  // first collect all the:\n  // - min bin size from all multi-valued traces\n  // - single-valued traces\n  for (i = 0; i < overlaidTraceGroup.length; i++) {\n    tracei = overlaidTraceGroup[i];\n    if (tracei === trace) pastThisTrace = true;else if (!pastThisTrace) {\n      // This trace has already had its autobins calculated\n      // (so must not have been single-valued).\n      minSize = Math.min(minSize, tracei[binAttr].size);\n    } else {\n      var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n      var binSpeci = resulti[0];\n      var isSingleValued = resulti[2];\n\n      // so we can use this result when we get to tracei in the normal\n      // course of events, mark it as done and put _pos0 back\n      tracei._autoBinFinished = 1;\n      tracei._pos0 = resulti[1];\n      if (isSingleValued) {\n        singleValuedTraces.push(tracei);\n      } else {\n        minSize = Math.min(minSize, binSpeci.size);\n      }\n    }\n  }\n\n  // find the real data values for each single-valued trace\n  // hunt through pos0 for the first valid value\n  var dataVals = new Array(singleValuedTraces.length);\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    var pos0 = singleValuedTraces[i]._pos0;\n    for (var j = 0; j < pos0.length; j++) {\n      if (pos0[j] !== undefined) {\n        dataVals[i] = pos0[j];\n        break;\n      }\n    }\n  }\n\n  // are ALL traces are single-valued? use the min difference between\n  // all of their values (which defaults to 1 if there's still only one)\n  if (!isFinite(minSize)) {\n    minSize = Lib.distinctVals(dataVals).minDiff;\n  }\n\n  // now apply the min size we found to all single-valued traces\n  for (i = 0; i < singleValuedTraces.length; i++) {\n    tracei = singleValuedTraces[i];\n    var calendar = tracei[mainData + 'calendar'];\n    tracei._input[binAttr] = tracei[binAttr] = {\n      start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n      end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n      size: minSize\n    };\n  }\n  return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n  var xid = trace.xaxis;\n  var yid = trace.yaxis;\n  var orientation = trace.orientation;\n  var out = [];\n  var fullData = gd._fullData;\n  for (var i = 0; i < fullData.length; i++) {\n    var tracei = fullData[i];\n    if (tracei.type === 'histogram' && tracei.visible === true && tracei.orientation === orientation && tracei.xaxis === xid && tracei.yaxis === yid) {\n      out.push(tracei);\n    }\n  }\n  return out;\n}\nfunction cdf(size, direction, currentBin) {\n  var i, vi, prevSum;\n  function firstHalfPoint(i) {\n    prevSum = size[i];\n    size[i] /= 2;\n  }\n  function nextHalfPoint(i) {\n    vi = size[i];\n    size[i] = prevSum + vi / 2;\n    prevSum += vi;\n  }\n  if (currentBin === 'half') {\n    if (direction === 'increasing') {\n      firstHalfPoint(0);\n      for (i = 1; i < size.length; i++) {\n        nextHalfPoint(i);\n      }\n    } else {\n      firstHalfPoint(size.length - 1);\n      for (i = size.length - 2; i >= 0; i--) {\n        nextHalfPoint(i);\n      }\n    }\n  } else if (direction === 'increasing') {\n    for (i = 1; i < size.length; i++) {\n      size[i] += size[i - 1];\n    }\n\n    // 'exclude' is identical to 'include' just shifted one bin over\n    if (currentBin === 'exclude') {\n      size.unshift(0);\n      size.pop();\n    }\n  } else {\n    for (i = size.length - 2; i >= 0; i--) {\n      size[i] += size[i + 1];\n    }\n    if (currentBin === 'exclude') {\n      size.push(0);\n      size.shift();\n    }\n  }\n}","map":{"version":3,"names":["isNumeric","require","Lib","Axes","arraysToCalcdata","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","module","exports","calc","gd","trace","visible","pos","size","pa","getFromId","orientation","yaxis","xaxis","mainData","counterData","x","y","calendar","cumulativeSpec","cumulative","i","binsAndPos","calcAllAutoBins","binSpec","pos0","nonuniformBins","binEdges","bins","inc","counts","inputPoints","total","norm","histnorm","func","histfunc","densityNorm","indexOf","i2","binEnd","n","enabled","replace","extremeFunc","sizeInit","binFunc","count","normFunc","isAvg","pr2c","v","r2c","rawCounterData","isArrayOrTypedArray","start","end","tickIncrement","length","push","type","nMax","uniqueValsPerBin","leftGap","Infinity","rightGap","ptNumber2cdIndex","posi","findBin","Math","min","roundFn","cdf","direction","currentbin","seriesLen","cd","firstNonzero","lastNonzero","cdi","p","s","b","pts","ph0","ph1","width1","selectedpoints","tagSelected","_overlayEdgeCase","binAttr","fullLayout","_fullLayout","isOverlay","barmode","traces","tracei","autoVals","cleanBound","cleanDate","Number","setBound","attr","newBins","nestedProperty","set","binOpts","_histogramBinOpts","_groupName","_autoBinFinished","sizeFound","allPos","_autoBin","isFirstVisible","_pos0","makeCalcdata","concat","newBinSpec","autoBin","nbins","_dataSpan","handleSingleValueOverlays","c2r","traceInputBins","_input","traceBinOptsCalc","extendFlat","mainStart","startIn","r2l","hasStart","undefined","startFound","traceStart","aggNums","dummyAx","dtick","tick0","range","map","l2r","newStart","tickFirst","mainEnd","endIn","hasEnd","endFound","traceEnd","max","autoBinAttr","overlaidTraceGroup","getConnectedHistograms","pastThisTrace","minSize","singleValuedTraces","resulti","binSpeci","isSingleValued","dataVals","Array","j","isFinite","distinctVals","minDiff","xid","yid","out","fullData","_fullData","currentBin","vi","prevSum","firstHalfPoint","nextHalfPoint","unshift","pop","shift"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/histogram/calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar arraysToCalcdata = require('../bar/arrays_to_calcdata');\nvar binFunctions = require('./bin_functions');\nvar normFunctions = require('./norm_functions');\nvar doAvg = require('./average');\nvar getBinSpanLabelRound = require('./bin_label_vals');\n\nmodule.exports = function calc(gd, trace) {\n    // ignore as much processing as possible (and including in autorange) if not visible\n    if(trace.visible !== true) return;\n\n    // depending on orientation, set position and size axes and data ranges\n    // note: this logic for choosing orientation is duplicated in graph_obj->setstyles\n    var pos = [];\n    var size = [];\n    var pa = Axes.getFromId(gd, trace.orientation === 'h' ?\n        (trace.yaxis || 'y') : (trace.xaxis || 'x'));\n    var mainData = trace.orientation === 'h' ? 'y' : 'x';\n    var counterData = {x: 'y', y: 'x'}[mainData];\n    var calendar = trace[mainData + 'calendar'];\n    var cumulativeSpec = trace.cumulative;\n    var i;\n\n    var binsAndPos = calcAllAutoBins(gd, trace, pa, mainData);\n    var binSpec = binsAndPos[0];\n    var pos0 = binsAndPos[1];\n\n    var nonuniformBins = typeof binSpec.size === 'string';\n    var binEdges = [];\n    var bins = nonuniformBins ? binEdges : binSpec;\n    // make the empty bin array\n    var inc = [];\n    var counts = [];\n    var inputPoints = [];\n    var total = 0;\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densityNorm = norm.indexOf('density') !== -1;\n    var i2, binEnd, n;\n\n    if(cumulativeSpec.enabled && densityNorm) {\n        // we treat \"cumulative\" like it means \"integral\" if you use a density norm,\n        // which in the end means it's the same as without \"density\"\n        norm = norm.replace(/ ?density$/, '');\n        densityNorm = false;\n    }\n\n    var extremeFunc = func === 'max' || func === 'min';\n    var sizeInit = extremeFunc ? null : 0;\n    var binFunc = binFunctions.count;\n    var normFunc = normFunctions[norm];\n    var isAvg = false;\n    var pr2c = function(v) { return pa.r2c(v, 0, calendar); };\n    var rawCounterData;\n\n    if(Lib.isArrayOrTypedArray(trace[counterData]) && func !== 'count') {\n        rawCounterData = trace[counterData];\n        isAvg = func === 'avg';\n        binFunc = binFunctions[func];\n    }\n\n    // create the bins (and any extra arrays needed)\n    // assume more than 1e6 bins is an error, so we don't crash the browser\n    i = pr2c(binSpec.start);\n\n    // decrease end a little in case of rounding errors\n    binEnd = pr2c(binSpec.end) + (i - Axes.tickIncrement(i, binSpec.size, false, calendar)) / 1e6;\n\n    while(i < binEnd && pos.length < 1e6) {\n        i2 = Axes.tickIncrement(i, binSpec.size, false, calendar);\n        pos.push((i + i2) / 2);\n        size.push(sizeInit);\n        inputPoints.push([]);\n        // nonuniform bins (like months) we need to search,\n        // rather than straight calculate the bin we're in\n        binEdges.push(i);\n        // nonuniform bins also need nonuniform normalization factors\n        if(densityNorm) inc.push(1 / (i2 - i));\n        if(isAvg) counts.push(0);\n        // break to avoid infinite loops\n        if(i2 <= i) break;\n        i = i2;\n    }\n    binEdges.push(i);\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBins && pa.type === 'date') {\n        bins = {\n            start: pr2c(bins.start),\n            end: pr2c(bins.end),\n            size: bins.size\n        };\n    }\n\n    // bin the data\n    // and make histogram-specific pt-number-to-cd-index map object\n    var nMax = size.length;\n    var uniqueValsPerBin = true;\n    var leftGap = Infinity;\n    var rightGap = Infinity;\n    var ptNumber2cdIndex = {};\n    for(i = 0; i < pos0.length; i++) {\n        var posi = pos0[i];\n        n = Lib.findBin(posi, bins);\n        if(n >= 0 && n < nMax) {\n            total += binFunc(n, i, size, rawCounterData, counts);\n            if(uniqueValsPerBin && inputPoints[n].length && posi !== pos0[inputPoints[n][0]]) {\n                uniqueValsPerBin = false;\n            }\n            inputPoints[n].push(i);\n            ptNumber2cdIndex[i] = n;\n\n            leftGap = Math.min(leftGap, posi - binEdges[n]);\n            rightGap = Math.min(rightGap, binEdges[n + 1] - posi);\n        }\n    }\n\n    var roundFn;\n    if(!uniqueValsPerBin) {\n        roundFn = getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar);\n    }\n\n    // average and/or normalize the data, if needed\n    if(isAvg) total = doAvg(size, counts);\n    if(normFunc) normFunc(size, total, inc);\n\n    // after all normalization etc, now we can accumulate if desired\n    if(cumulativeSpec.enabled) cdf(size, cumulativeSpec.direction, cumulativeSpec.currentbin);\n\n\n    var seriesLen = Math.min(pos.length, size.length);\n    var cd = [];\n    var firstNonzero = 0;\n    var lastNonzero = seriesLen - 1;\n\n    // look for empty bins at the ends to remove, so autoscale omits them\n    for(i = 0; i < seriesLen; i++) {\n        if(size[i]) {\n            firstNonzero = i;\n            break;\n        }\n    }\n    for(i = seriesLen - 1; i >= firstNonzero; i--) {\n        if(size[i]) {\n            lastNonzero = i;\n            break;\n        }\n    }\n\n    // create the \"calculated data\" to plot\n    for(i = firstNonzero; i <= lastNonzero; i++) {\n        if((isNumeric(pos[i]) && isNumeric(size[i]))) {\n            var cdi = {\n                p: pos[i],\n                s: size[i],\n                b: 0\n            };\n\n            // setup hover and event data fields,\n            // N.B. pts and \"hover\" positions ph0/ph1 don't seem to make much sense\n            // for cumulative distributions\n            if(!cumulativeSpec.enabled) {\n                cdi.pts = inputPoints[i];\n                if(uniqueValsPerBin) {\n                    cdi.ph0 = cdi.ph1 = (inputPoints[i].length) ? pos0[inputPoints[i][0]] : pos[i];\n                }\n                else {\n                    cdi.ph0 = roundFn(binEdges[i]);\n                    cdi.ph1 = roundFn(binEdges[i + 1], true);\n                }\n            }\n            cd.push(cdi);\n        }\n    }\n\n    if(cd.length === 1) {\n        // when we collapse to a single bin, calcdata no longer describes bin size\n        // so we need to explicitly specify it\n        cd[0].width1 = Axes.tickIncrement(cd[0].p, binSpec.size, false, calendar) - cd[0].p;\n    }\n\n    arraysToCalcdata(cd, trace);\n\n    if(Lib.isArrayOrTypedArray(trace.selectedpoints)) {\n        Lib.tagSelected(cd, trace, ptNumber2cdIndex);\n    }\n\n    return cd;\n};\n\n/*\n * calcAllAutoBins: we want all histograms on the same axes to share bin specs\n * if they're grouped or stacked. If the user has explicitly specified differing\n * bin specs, there's nothing we can do, but if possible we will try to use the\n * smallest bins of any of the auto values for all histograms grouped/stacked\n * together.\n */\nfunction calcAllAutoBins(gd, trace, pa, mainData, _overlayEdgeCase) {\n    var binAttr = mainData + 'bins';\n    var fullLayout = gd._fullLayout;\n    var isOverlay = fullLayout.barmode === 'overlay';\n    var i, traces, tracei, calendar, pos0, autoVals, cumulativeSpec;\n\n    var cleanBound = (pa.type === 'date') ?\n        function(v) { return (v || v === 0) ? Lib.cleanDate(v, null, pa.calendar) : null; } :\n        function(v) { return isNumeric(v) ? Number(v) : null; };\n\n    function setBound(attr, bins, newBins) {\n        if(bins[attr + 'Found']) {\n            bins[attr] = cleanBound(bins[attr]);\n            if(bins[attr] === null) bins[attr] = newBins[attr];\n        }\n        else {\n            autoVals[attr] = bins[attr] = newBins[attr];\n            Lib.nestedProperty(traces[0], binAttr + '.' + attr).set(newBins[attr]);\n        }\n    }\n\n    var binOpts = fullLayout._histogramBinOpts[trace._groupName];\n\n    // all but the first trace in this group has already been marked finished\n    // clear this flag, so next time we run calc we will run autobin again\n    if(trace._autoBinFinished) {\n        delete trace._autoBinFinished;\n    }\n    else {\n        traces = binOpts.traces;\n        var sizeFound = binOpts.sizeFound;\n        var allPos = [];\n        autoVals = traces[0]._autoBin = {};\n        // Note: we're including `legendonly` traces here for autobin purposes,\n        // so that showing & hiding from the legend won't affect bins.\n        // But this complicates things a bit since those traces don't `calc`,\n        // hence `isFirstVisible`.\n        var isFirstVisible = true;\n        for(i = 0; i < traces.length; i++) {\n            tracei = traces[i];\n            if(tracei.visible) {\n                pos0 = tracei._pos0 = pa.makeCalcdata(tracei, mainData);\n                allPos = Lib.concat(allPos, pos0);\n                delete tracei._autoBinFinished;\n                if(trace.visible === true) {\n                    if(isFirstVisible) {\n                        isFirstVisible = false;\n                    }\n                    else {\n                        delete tracei._autoBin;\n                        tracei._autoBinFinished = 1;\n                    }\n                }\n            }\n        }\n        calendar = traces[0][mainData + 'calendar'];\n        var newBinSpec = Axes.autoBin(\n            allPos, pa, binOpts.nbins, false, calendar, sizeFound && binOpts.size);\n\n        // Edge case: single-valued histogram overlaying others\n        // Use them all together to calculate the bin size for the single-valued one\n        if(isOverlay && newBinSpec._dataSpan === 0 &&\n            pa.type !== 'category' && pa.type !== 'multicategory') {\n            // Several single-valued histograms! Stop infinite recursion,\n            // just return an extra flag that tells handleSingleValueOverlays\n            // to sort out this trace too\n            if(_overlayEdgeCase) return [newBinSpec, pos0, true];\n\n            newBinSpec = handleSingleValueOverlays(gd, trace, pa, mainData, binAttr);\n        }\n\n        // adjust for CDF edge cases\n        cumulativeSpec = tracei.cumulative;\n        if(cumulativeSpec.enabled && (cumulativeSpec.currentbin !== 'include')) {\n            if(cumulativeSpec.direction === 'decreasing') {\n                newBinSpec.start = pa.c2r(Axes.tickIncrement(\n                    pa.r2c(newBinSpec.start, 0, calendar),\n                    newBinSpec.size, true, calendar\n                ));\n            }\n            else {\n                newBinSpec.end = pa.c2r(Axes.tickIncrement(\n                    pa.r2c(newBinSpec.end, 0, calendar),\n                    newBinSpec.size, false, calendar\n                ));\n            }\n        }\n\n        binOpts.size = newBinSpec.size;\n        if(!sizeFound) {\n            autoVals.size = newBinSpec.size;\n            Lib.nestedProperty(traces[0], binAttr + '.size').set(newBinSpec.size);\n        }\n\n        setBound('start', binOpts, newBinSpec);\n        setBound('end', binOpts, newBinSpec);\n    }\n\n    pos0 = trace._pos0;\n    delete trace._pos0;\n\n    // Each trace can specify its own start/end, or if omitted\n    // we ensure they're beyond the bounds of this trace's data,\n    // and we need to make sure start is aligned with the main start\n    var traceInputBins = trace._input[binAttr] || {};\n    var traceBinOptsCalc = Lib.extendFlat({}, binOpts);\n    var mainStart = binOpts.start;\n    var startIn = pa.r2l(traceInputBins.start);\n    var hasStart = startIn !== undefined;\n    if((binOpts.startFound || hasStart) && startIn !== pa.r2l(mainStart)) {\n        // We have an explicit start to reconcile across traces\n        // if this trace has an explicit start, shift it down to a bin edge\n        // if another trace had an explicit start, shift it down to a\n        // bin edge past our data\n        var traceStart = hasStart ?\n            startIn :\n            Lib.aggNums(Math.min, null, pos0);\n\n        var dummyAx = {\n            type: (pa.type === 'category' || pa.type === 'multicategory') ? 'linear' : pa.type,\n            r2l: pa.r2l,\n            dtick: binOpts.size,\n            tick0: mainStart,\n            calendar: calendar,\n            range: ([traceStart, Axes.tickIncrement(traceStart, binOpts.size, false, calendar)]).map(pa.l2r)\n        };\n        var newStart = Axes.tickFirst(dummyAx);\n        if(newStart > pa.r2l(traceStart)) {\n            newStart = Axes.tickIncrement(newStart, binOpts.size, true, calendar);\n        }\n        traceBinOptsCalc.start = pa.l2r(newStart);\n        if(!hasStart) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.start);\n    }\n\n    var mainEnd = binOpts.end;\n    var endIn = pa.r2l(traceInputBins.end);\n    var hasEnd = endIn !== undefined;\n    if((binOpts.endFound || hasEnd) && endIn !== pa.r2l(mainEnd)) {\n        // Reconciling an explicit end is easier, as it doesn't need to\n        // match bin edges\n        var traceEnd = hasEnd ?\n            endIn :\n            Lib.aggNums(Math.max, null, pos0);\n\n        traceBinOptsCalc.end = pa.l2r(traceEnd);\n        if(!hasEnd) Lib.nestedProperty(trace, binAttr + '.start').set(traceBinOptsCalc.end);\n    }\n\n    // Backward compatibility for one-time autobinning.\n    // autobin: true is handled in cleanData, but autobin: false\n    // needs to be here where we have determined the values.\n    var autoBinAttr = 'autobin' + mainData;\n    if(trace._input[autoBinAttr] === false) {\n        trace._input[binAttr] = Lib.extendFlat({}, trace[binAttr] || {});\n        delete trace._input[autoBinAttr];\n        delete trace[autoBinAttr];\n    }\n\n    return [traceBinOptsCalc, pos0];\n}\n\n/*\n * Adjust single-value histograms in overlay mode to make as good a\n * guess as we can at autobin values the user would like.\n *\n * Returns the binSpec for the trace that sparked all this\n */\nfunction handleSingleValueOverlays(gd, trace, pa, mainData, binAttr) {\n    var overlaidTraceGroup = getConnectedHistograms(gd, trace);\n    var pastThisTrace = false;\n    var minSize = Infinity;\n    var singleValuedTraces = [trace];\n    var i, tracei;\n\n    // first collect all the:\n    // - min bin size from all multi-valued traces\n    // - single-valued traces\n    for(i = 0; i < overlaidTraceGroup.length; i++) {\n        tracei = overlaidTraceGroup[i];\n        if(tracei === trace) pastThisTrace = true;\n        else if(!pastThisTrace) {\n            // This trace has already had its autobins calculated\n            // (so must not have been single-valued).\n            minSize = Math.min(minSize, tracei[binAttr].size);\n        }\n        else {\n            var resulti = calcAllAutoBins(gd, tracei, pa, mainData, true);\n            var binSpeci = resulti[0];\n            var isSingleValued = resulti[2];\n\n            // so we can use this result when we get to tracei in the normal\n            // course of events, mark it as done and put _pos0 back\n            tracei._autoBinFinished = 1;\n            tracei._pos0 = resulti[1];\n\n            if(isSingleValued) {\n                singleValuedTraces.push(tracei);\n            }\n            else {\n                minSize = Math.min(minSize, binSpeci.size);\n            }\n        }\n    }\n\n    // find the real data values for each single-valued trace\n    // hunt through pos0 for the first valid value\n    var dataVals = new Array(singleValuedTraces.length);\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        var pos0 = singleValuedTraces[i]._pos0;\n        for(var j = 0; j < pos0.length; j++) {\n            if(pos0[j] !== undefined) {\n                dataVals[i] = pos0[j];\n                break;\n            }\n        }\n    }\n\n    // are ALL traces are single-valued? use the min difference between\n    // all of their values (which defaults to 1 if there's still only one)\n    if(!isFinite(minSize)) {\n        minSize = Lib.distinctVals(dataVals).minDiff;\n    }\n\n    // now apply the min size we found to all single-valued traces\n    for(i = 0; i < singleValuedTraces.length; i++) {\n        tracei = singleValuedTraces[i];\n        var calendar = tracei[mainData + 'calendar'];\n\n        tracei._input[binAttr] = tracei[binAttr] = {\n            start: pa.c2r(dataVals[i] - minSize / 2, 0, calendar),\n            end: pa.c2r(dataVals[i] + minSize / 2, 0, calendar),\n            size: minSize\n        };\n    }\n\n    return trace[binAttr];\n}\n\n/*\n * Return an array of histograms that share axes and orientation.\n *\n * Only considers histograms. In principle we could include bars in a\n * similar way to how we do manually binned histograms, though this\n * would have tons of edge cases and value judgments to make.\n */\nfunction getConnectedHistograms(gd, trace) {\n    var xid = trace.xaxis;\n    var yid = trace.yaxis;\n    var orientation = trace.orientation;\n\n    var out = [];\n    var fullData = gd._fullData;\n    for(var i = 0; i < fullData.length; i++) {\n        var tracei = fullData[i];\n        if(tracei.type === 'histogram' &&\n            tracei.visible === true &&\n            tracei.orientation === orientation &&\n            tracei.xaxis === xid && tracei.yaxis === yid\n        ) {\n            out.push(tracei);\n        }\n    }\n\n    return out;\n}\n\n\nfunction cdf(size, direction, currentBin) {\n    var i, vi, prevSum;\n\n    function firstHalfPoint(i) {\n        prevSum = size[i];\n        size[i] /= 2;\n    }\n\n    function nextHalfPoint(i) {\n        vi = size[i];\n        size[i] = prevSum + vi / 2;\n        prevSum += vi;\n    }\n\n    if(currentBin === 'half') {\n\n        if(direction === 'increasing') {\n            firstHalfPoint(0);\n            for(i = 1; i < size.length; i++) {\n                nextHalfPoint(i);\n            }\n        }\n        else {\n            firstHalfPoint(size.length - 1);\n            for(i = size.length - 2; i >= 0; i--) {\n                nextHalfPoint(i);\n            }\n        }\n    }\n    else if(direction === 'increasing') {\n        for(i = 1; i < size.length; i++) {\n            size[i] += size[i - 1];\n        }\n\n        // 'exclude' is identical to 'include' just shifted one bin over\n        if(currentBin === 'exclude') {\n            size.unshift(0);\n            size.pop();\n        }\n    }\n    else {\n        for(i = size.length - 2; i >= 0; i--) {\n            size[i] += size[i + 1];\n        }\n\n        if(currentBin === 'exclude') {\n            size.push(0);\n            size.shift();\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}