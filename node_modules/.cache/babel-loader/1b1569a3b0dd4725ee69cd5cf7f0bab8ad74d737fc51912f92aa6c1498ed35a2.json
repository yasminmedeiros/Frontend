{"ast":null,"code":"\"use strict\";\n\nmodule.exports = planarDual;\nvar compareAngle = require(\"compare-angle\");\nfunction planarDual(cells, positions) {\n  var numVertices = positions.length | 0;\n  var numEdges = cells.length;\n  var adj = [new Array(numVertices), new Array(numVertices)];\n  for (var i = 0; i < numVertices; ++i) {\n    adj[0][i] = [];\n    adj[1][i] = [];\n  }\n  for (var i = 0; i < numEdges; ++i) {\n    var c = cells[i];\n    adj[0][c[0]].push(c);\n    adj[1][c[1]].push(c);\n  }\n  var cycles = [];\n\n  //Add isolated vertices as trivial case\n  for (var i = 0; i < numVertices; ++i) {\n    if (adj[0][i].length + adj[1][i].length === 0) {\n      cycles.push([i]);\n    }\n  }\n\n  //Remove a half edge\n  function cut(c, i) {\n    var a = adj[i][c[i]];\n    a.splice(a.indexOf(c), 1);\n  }\n\n  //Find next vertex and cut edge\n  function next(a, b, noCut) {\n    var nextCell, nextVertex, nextDir;\n    for (var i = 0; i < 2; ++i) {\n      if (adj[i][b].length > 0) {\n        nextCell = adj[i][b][0];\n        nextDir = i;\n        break;\n      }\n    }\n    nextVertex = nextCell[nextDir ^ 1];\n    for (var dir = 0; dir < 2; ++dir) {\n      var nbhd = adj[dir][b];\n      for (var k = 0; k < nbhd.length; ++k) {\n        var e = nbhd[k];\n        var p = e[dir ^ 1];\n        var cmp = compareAngle(positions[a], positions[b], positions[nextVertex], positions[p]);\n        if (cmp > 0) {\n          nextCell = e;\n          nextVertex = p;\n          nextDir = dir;\n        }\n      }\n    }\n    if (noCut) {\n      return nextVertex;\n    }\n    if (nextCell) {\n      cut(nextCell, nextDir);\n    }\n    return nextVertex;\n  }\n  function extractCycle(v, dir) {\n    var e0 = adj[dir][v][0];\n    var cycle = [v];\n    cut(e0, dir);\n    var u = e0[dir ^ 1];\n    var d0 = dir;\n    while (true) {\n      while (u !== v) {\n        cycle.push(u);\n        u = next(cycle[cycle.length - 2], u, false);\n      }\n      if (adj[0][v].length + adj[1][v].length === 0) {\n        break;\n      }\n      var a = cycle[cycle.length - 1];\n      var b = v;\n      var c = cycle[1];\n      var d = next(a, b, true);\n      if (compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n        break;\n      }\n      cycle.push(v);\n      u = next(a, b);\n    }\n    return cycle;\n  }\n  function shouldGlue(pcycle, ncycle) {\n    return ncycle[1] === ncycle[ncycle.length - 1];\n  }\n  for (var i = 0; i < numVertices; ++i) {\n    for (var j = 0; j < 2; ++j) {\n      var pcycle = [];\n      while (adj[j][i].length > 0) {\n        var ni = adj[0][i].length;\n        var ncycle = extractCycle(i, j);\n        if (shouldGlue(pcycle, ncycle)) {\n          //Glue together trivial cycles\n          pcycle.push.apply(pcycle, ncycle);\n        } else {\n          if (pcycle.length > 0) {\n            cycles.push(pcycle);\n          }\n          pcycle = ncycle;\n        }\n      }\n      if (pcycle.length > 0) {\n        cycles.push(pcycle);\n      }\n    }\n  }\n\n  //Combine paths and loops together\n  return cycles;\n}","map":{"version":3,"names":["module","exports","planarDual","compareAngle","require","cells","positions","numVertices","length","numEdges","adj","Array","i","c","push","cycles","cut","a","splice","indexOf","next","b","noCut","nextCell","nextVertex","nextDir","dir","nbhd","k","e","p","cmp","extractCycle","v","e0","cycle","u","d0","d","shouldGlue","pcycle","ncycle","j","ni","apply"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/planar-dual/loops.js"],"sourcesContent":["\"use strict\"\n\nmodule.exports = planarDual\n\nvar compareAngle = require(\"compare-angle\")\n\nfunction planarDual(cells, positions) {\n\n  var numVertices = positions.length|0\n  var numEdges = cells.length\n  var adj = [new Array(numVertices), new Array(numVertices)]\n  for(var i=0; i<numVertices; ++i) {\n    adj[0][i] = []\n    adj[1][i] = []\n  }\n  for(var i=0; i<numEdges; ++i) {\n    var c = cells[i]\n    adj[0][c[0]].push(c)\n    adj[1][c[1]].push(c)\n  }\n\n  var cycles = []\n\n  //Add isolated vertices as trivial case\n  for(var i=0; i<numVertices; ++i) {\n    if(adj[0][i].length + adj[1][i].length === 0) {\n      cycles.push( [i] )\n    }\n  }\n\n  //Remove a half edge\n  function cut(c, i) {\n    var a = adj[i][c[i]]\n    a.splice(a.indexOf(c), 1)\n  }\n\n  //Find next vertex and cut edge\n  function next(a, b, noCut) {\n    var nextCell, nextVertex, nextDir\n    for(var i=0; i<2; ++i) {\n      if(adj[i][b].length > 0) {\n        nextCell = adj[i][b][0]\n        nextDir = i\n        break\n      }\n    }\n    nextVertex = nextCell[nextDir^1]\n\n    for(var dir=0; dir<2; ++dir) {\n      var nbhd = adj[dir][b]\n      for(var k=0; k<nbhd.length; ++k) {\n        var e = nbhd[k]\n        var p = e[dir^1]\n        var cmp = compareAngle(\n            positions[a], \n            positions[b], \n            positions[nextVertex],\n            positions[p])\n        if(cmp > 0) {\n          nextCell = e\n          nextVertex = p\n          nextDir = dir\n        }\n      }\n    }\n    if(noCut) {\n      return nextVertex\n    }\n    if(nextCell) {\n      cut(nextCell, nextDir)\n    }\n    return nextVertex\n  }\n\n  function extractCycle(v, dir) {\n    var e0 = adj[dir][v][0]\n    var cycle = [v]\n    cut(e0, dir)\n    var u = e0[dir^1]\n    var d0 = dir\n    while(true) {\n      while(u !== v) {\n        cycle.push(u)\n        u = next(cycle[cycle.length-2], u, false)\n      }\n      if(adj[0][v].length + adj[1][v].length === 0) {\n        break\n      }\n      var a = cycle[cycle.length-1]\n      var b = v\n      var c = cycle[1]\n      var d = next(a, b, true)\n      if(compareAngle(positions[a], positions[b], positions[c], positions[d]) < 0) {\n        break\n      }\n      cycle.push(v)\n      u = next(a, b)\n    }\n    return cycle\n  }\n\n  function shouldGlue(pcycle, ncycle) {\n    return (ncycle[1] === ncycle[ncycle.length-1])\n  }\n\n  for(var i=0; i<numVertices; ++i) {\n    for(var j=0; j<2; ++j) {\n      var pcycle = []\n      while(adj[j][i].length > 0) {\n        var ni = adj[0][i].length\n        var ncycle = extractCycle(i,j)\n        if(shouldGlue(pcycle, ncycle)) {\n          //Glue together trivial cycles\n          pcycle.push.apply(pcycle, ncycle)\n        } else {\n          if(pcycle.length > 0) {\n            cycles.push(pcycle)\n          }\n          pcycle = ncycle\n        }\n      }\n      if(pcycle.length > 0) {\n        cycles.push(pcycle)\n      }\n    }\n  }\n\n  //Combine paths and loops together\n  return cycles\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,OAAO,GAAGC,UAAU;AAE3B,IAAIC,YAAY,GAAGC,OAAO,CAAC,eAAe,CAAC;AAE3C,SAASF,UAAU,CAACG,KAAK,EAAEC,SAAS,EAAE;EAEpC,IAAIC,WAAW,GAAGD,SAAS,CAACE,MAAM,GAAC,CAAC;EACpC,IAAIC,QAAQ,GAAGJ,KAAK,CAACG,MAAM;EAC3B,IAAIE,GAAG,GAAG,CAAC,IAAIC,KAAK,CAACJ,WAAW,CAAC,EAAE,IAAII,KAAK,CAACJ,WAAW,CAAC,CAAC;EAC1D,KAAI,IAAIK,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACL,WAAW,EAAE,EAAEK,CAAC,EAAE;IAC/BF,GAAG,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,EAAE;IACdF,GAAG,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,GAAG,EAAE;EAChB;EACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACH,QAAQ,EAAE,EAAEG,CAAC,EAAE;IAC5B,IAAIC,CAAC,GAAGR,KAAK,CAACO,CAAC,CAAC;IAChBF,GAAG,CAAC,CAAC,CAAC,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACD,CAAC,CAAC;IACpBH,GAAG,CAAC,CAAC,CAAC,CAACG,CAAC,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAACD,CAAC,CAAC;EACtB;EAEA,IAAIE,MAAM,GAAG,EAAE;;EAEf;EACA,KAAI,IAAIH,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACL,WAAW,EAAE,EAAEK,CAAC,EAAE;IAC/B,IAAGF,GAAG,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,CAACJ,MAAM,GAAGE,GAAG,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,CAACJ,MAAM,KAAK,CAAC,EAAE;MAC5CO,MAAM,CAACD,IAAI,CAAE,CAACF,CAAC,CAAC,CAAE;IACpB;EACF;;EAEA;EACA,SAASI,GAAG,CAACH,CAAC,EAAED,CAAC,EAAE;IACjB,IAAIK,CAAC,GAAGP,GAAG,CAACE,CAAC,CAAC,CAACC,CAAC,CAACD,CAAC,CAAC,CAAC;IACpBK,CAAC,CAACC,MAAM,CAACD,CAAC,CAACE,OAAO,CAACN,CAAC,CAAC,EAAE,CAAC,CAAC;EAC3B;;EAEA;EACA,SAASO,IAAI,CAACH,CAAC,EAAEI,CAAC,EAAEC,KAAK,EAAE;IACzB,IAAIC,QAAQ,EAAEC,UAAU,EAAEC,OAAO;IACjC,KAAI,IAAIb,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC,CAAC,EAAE,EAAEA,CAAC,EAAE;MACrB,IAAGF,GAAG,CAACE,CAAC,CAAC,CAACS,CAAC,CAAC,CAACb,MAAM,GAAG,CAAC,EAAE;QACvBe,QAAQ,GAAGb,GAAG,CAACE,CAAC,CAAC,CAACS,CAAC,CAAC,CAAC,CAAC,CAAC;QACvBI,OAAO,GAAGb,CAAC;QACX;MACF;IACF;IACAY,UAAU,GAAGD,QAAQ,CAACE,OAAO,GAAC,CAAC,CAAC;IAEhC,KAAI,IAAIC,GAAG,GAAC,CAAC,EAAEA,GAAG,GAAC,CAAC,EAAE,EAAEA,GAAG,EAAE;MAC3B,IAAIC,IAAI,GAAGjB,GAAG,CAACgB,GAAG,CAAC,CAACL,CAAC,CAAC;MACtB,KAAI,IAAIO,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACD,IAAI,CAACnB,MAAM,EAAE,EAAEoB,CAAC,EAAE;QAC/B,IAAIC,CAAC,GAAGF,IAAI,CAACC,CAAC,CAAC;QACf,IAAIE,CAAC,GAAGD,CAAC,CAACH,GAAG,GAAC,CAAC,CAAC;QAChB,IAAIK,GAAG,GAAG5B,YAAY,CAClBG,SAAS,CAACW,CAAC,CAAC,EACZX,SAAS,CAACe,CAAC,CAAC,EACZf,SAAS,CAACkB,UAAU,CAAC,EACrBlB,SAAS,CAACwB,CAAC,CAAC,CAAC;QACjB,IAAGC,GAAG,GAAG,CAAC,EAAE;UACVR,QAAQ,GAAGM,CAAC;UACZL,UAAU,GAAGM,CAAC;UACdL,OAAO,GAAGC,GAAG;QACf;MACF;IACF;IACA,IAAGJ,KAAK,EAAE;MACR,OAAOE,UAAU;IACnB;IACA,IAAGD,QAAQ,EAAE;MACXP,GAAG,CAACO,QAAQ,EAAEE,OAAO,CAAC;IACxB;IACA,OAAOD,UAAU;EACnB;EAEA,SAASQ,YAAY,CAACC,CAAC,EAAEP,GAAG,EAAE;IAC5B,IAAIQ,EAAE,GAAGxB,GAAG,CAACgB,GAAG,CAAC,CAACO,CAAC,CAAC,CAAC,CAAC,CAAC;IACvB,IAAIE,KAAK,GAAG,CAACF,CAAC,CAAC;IACfjB,GAAG,CAACkB,EAAE,EAAER,GAAG,CAAC;IACZ,IAAIU,CAAC,GAAGF,EAAE,CAACR,GAAG,GAAC,CAAC,CAAC;IACjB,IAAIW,EAAE,GAAGX,GAAG;IACZ,OAAM,IAAI,EAAE;MACV,OAAMU,CAAC,KAAKH,CAAC,EAAE;QACbE,KAAK,CAACrB,IAAI,CAACsB,CAAC,CAAC;QACbA,CAAC,GAAGhB,IAAI,CAACe,KAAK,CAACA,KAAK,CAAC3B,MAAM,GAAC,CAAC,CAAC,EAAE4B,CAAC,EAAE,KAAK,CAAC;MAC3C;MACA,IAAG1B,GAAG,CAAC,CAAC,CAAC,CAACuB,CAAC,CAAC,CAACzB,MAAM,GAAGE,GAAG,CAAC,CAAC,CAAC,CAACuB,CAAC,CAAC,CAACzB,MAAM,KAAK,CAAC,EAAE;QAC5C;MACF;MACA,IAAIS,CAAC,GAAGkB,KAAK,CAACA,KAAK,CAAC3B,MAAM,GAAC,CAAC,CAAC;MAC7B,IAAIa,CAAC,GAAGY,CAAC;MACT,IAAIpB,CAAC,GAAGsB,KAAK,CAAC,CAAC,CAAC;MAChB,IAAIG,CAAC,GAAGlB,IAAI,CAACH,CAAC,EAAEI,CAAC,EAAE,IAAI,CAAC;MACxB,IAAGlB,YAAY,CAACG,SAAS,CAACW,CAAC,CAAC,EAAEX,SAAS,CAACe,CAAC,CAAC,EAAEf,SAAS,CAACO,CAAC,CAAC,EAAEP,SAAS,CAACgC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;QAC3E;MACF;MACAH,KAAK,CAACrB,IAAI,CAACmB,CAAC,CAAC;MACbG,CAAC,GAAGhB,IAAI,CAACH,CAAC,EAAEI,CAAC,CAAC;IAChB;IACA,OAAOc,KAAK;EACd;EAEA,SAASI,UAAU,CAACC,MAAM,EAAEC,MAAM,EAAE;IAClC,OAAQA,MAAM,CAAC,CAAC,CAAC,KAAKA,MAAM,CAACA,MAAM,CAACjC,MAAM,GAAC,CAAC,CAAC;EAC/C;EAEA,KAAI,IAAII,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACL,WAAW,EAAE,EAAEK,CAAC,EAAE;IAC/B,KAAI,IAAI8B,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC,CAAC,EAAE,EAAEA,CAAC,EAAE;MACrB,IAAIF,MAAM,GAAG,EAAE;MACf,OAAM9B,GAAG,CAACgC,CAAC,CAAC,CAAC9B,CAAC,CAAC,CAACJ,MAAM,GAAG,CAAC,EAAE;QAC1B,IAAImC,EAAE,GAAGjC,GAAG,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,CAACJ,MAAM;QACzB,IAAIiC,MAAM,GAAGT,YAAY,CAACpB,CAAC,EAAC8B,CAAC,CAAC;QAC9B,IAAGH,UAAU,CAACC,MAAM,EAAEC,MAAM,CAAC,EAAE;UAC7B;UACAD,MAAM,CAAC1B,IAAI,CAAC8B,KAAK,CAACJ,MAAM,EAAEC,MAAM,CAAC;QACnC,CAAC,MAAM;UACL,IAAGD,MAAM,CAAChC,MAAM,GAAG,CAAC,EAAE;YACpBO,MAAM,CAACD,IAAI,CAAC0B,MAAM,CAAC;UACrB;UACAA,MAAM,GAAGC,MAAM;QACjB;MACF;MACA,IAAGD,MAAM,CAAChC,MAAM,GAAG,CAAC,EAAE;QACpBO,MAAM,CAACD,IAAI,CAAC0B,MAAM,CAAC;MACrB;IACF;EACF;;EAEA;EACA,OAAOzB,MAAM;AACf"},"metadata":{},"sourceType":"script","externalDependencies":[]}