{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nvar TEXTOFFSETSIGN = {\n  start: 1,\n  left: 1,\n  end: -1,\n  right: -1,\n  middle: 0,\n  center: 0,\n  bottom: 1,\n  top: -1\n};\nfunction convertStyle(gd, trace) {\n  var i;\n  var opts = {\n    marker: undefined,\n    markerSel: undefined,\n    markerUnsel: undefined,\n    line: undefined,\n    fill: undefined,\n    errorX: undefined,\n    errorY: undefined,\n    text: undefined,\n    textSel: undefined,\n    textUnsel: undefined\n  };\n  if (trace.visible !== true) return opts;\n  if (subTypes.hasText(trace)) {\n    opts.text = convertTextStyle(trace);\n    opts.textSel = convertTextSelection(trace, trace.selected);\n    opts.textUnsel = convertTextSelection(trace, trace.unselected);\n  }\n  if (subTypes.hasMarkers(trace)) {\n    opts.marker = convertMarkerStyle(trace);\n    opts.markerSel = convertMarkerSelection(trace, trace.selected);\n    opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n    if (!trace.unselected && Array.isArray(trace.marker.opacity)) {\n      var mo = trace.marker.opacity;\n      opts.markerUnsel.opacity = new Array(mo.length);\n      for (i = 0; i < mo.length; i++) {\n        opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n      }\n    }\n  }\n  if (subTypes.hasLines(trace)) {\n    opts.line = {\n      overlay: true,\n      thickness: trace.line.width,\n      color: trace.line.color,\n      opacity: trace.opacity\n    };\n    var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n    for (i = 0; i < dashes.length; ++i) {\n      dashes[i] *= trace.line.width;\n    }\n    opts.line.dashes = dashes;\n  }\n  if (trace.error_x && trace.error_x.visible) {\n    opts.errorX = convertErrorBarStyle(trace, trace.error_x);\n  }\n  if (trace.error_y && trace.error_y.visible) {\n    opts.errorY = convertErrorBarStyle(trace, trace.error_y);\n  }\n  if (!!trace.fill && trace.fill !== 'none') {\n    opts.fill = {\n      closed: true,\n      fill: trace.fillcolor,\n      thickness: 0\n    };\n  }\n  return opts;\n}\nfunction convertTextStyle(trace) {\n  var count = trace._length;\n  var textfontIn = trace.textfont;\n  var textpositionIn = trace.textposition;\n  var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n  var tfc = textfontIn.color;\n  var tfs = textfontIn.size;\n  var tff = textfontIn.family;\n  var optsOut = {};\n  var i;\n  optsOut.text = trace.text;\n  optsOut.opacity = trace.opacity;\n  optsOut.font = {};\n  optsOut.align = [];\n  optsOut.baseline = [];\n  for (i = 0; i < textPos.length; i++) {\n    var tp = textPos[i].split(/\\s+/);\n    switch (tp[1]) {\n      case 'left':\n        optsOut.align.push('right');\n        break;\n      case 'right':\n        optsOut.align.push('left');\n        break;\n      default:\n        optsOut.align.push(tp[1]);\n    }\n    switch (tp[0]) {\n      case 'top':\n        optsOut.baseline.push('bottom');\n        break;\n      case 'bottom':\n        optsOut.baseline.push('top');\n        break;\n      default:\n        optsOut.baseline.push(tp[0]);\n    }\n  }\n  if (Array.isArray(tfc)) {\n    optsOut.color = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.color[i] = tfc[i];\n    }\n  } else {\n    optsOut.color = tfc;\n  }\n  if (Array.isArray(tfs) || Array.isArray(tff)) {\n    // if any textfont param is array - make render a batch\n    optsOut.font = new Array(count);\n    for (i = 0; i < count; i++) {\n      var fonti = optsOut.font[i] = {};\n      fonti.size = Array.isArray(tfs) ? isNumeric(tfs[i]) ? tfs[i] : 0 : tfs;\n      fonti.family = Array.isArray(tff) ? tff[i] : tff;\n    }\n  } else {\n    // if both are single values, make render fast single-value\n    optsOut.font = {\n      size: tfs,\n      family: tff\n    };\n  }\n  return optsOut;\n}\nfunction convertMarkerStyle(trace) {\n  var count = trace._length;\n  var optsIn = trace.marker;\n  var optsOut = {};\n  var i;\n  var multiSymbol = Array.isArray(optsIn.symbol);\n  var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n  var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n  var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n  var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n  var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n  var isOpen;\n  if (!multiSymbol) isOpen = constants.OPEN_RE.test(optsIn.symbol);\n\n  // prepare colors\n  if (multiSymbol || multiColor || multiLineColor || multiOpacity) {\n    optsOut.colors = new Array(count);\n    optsOut.borderColors = new Array(count);\n    var colors = formatColor(optsIn, optsIn.opacity, count);\n    var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n    if (!Array.isArray(borderColors[0])) {\n      var borderColor = borderColors;\n      borderColors = Array(count);\n      for (i = 0; i < count; i++) {\n        borderColors[i] = borderColor;\n      }\n    }\n    if (!Array.isArray(colors[0])) {\n      var color = colors;\n      colors = Array(count);\n      for (i = 0; i < count; i++) {\n        colors[i] = color;\n      }\n    }\n    optsOut.colors = colors;\n    optsOut.borderColors = borderColors;\n    for (i = 0; i < count; i++) {\n      if (multiSymbol) {\n        var symbol = optsIn.symbol[i];\n        isOpen = constants.OPEN_RE.test(symbol);\n      }\n      if (isOpen) {\n        borderColors[i] = colors[i].slice();\n        colors[i] = colors[i].slice();\n        colors[i][3] = 0;\n      }\n    }\n    optsOut.opacity = trace.opacity;\n  } else {\n    if (isOpen) {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.color[3] = 0;\n      optsOut.borderColor = rgba(optsIn.color, 'uint8');\n    } else {\n      optsOut.color = rgba(optsIn.color, 'uint8');\n      optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n    }\n    optsOut.opacity = trace.opacity * optsIn.opacity;\n  }\n\n  // prepare symbols\n  if (multiSymbol) {\n    optsOut.markers = new Array(count);\n    for (i = 0; i < count; i++) {\n      optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n    }\n  } else {\n    optsOut.marker = getSymbolSdf(optsIn.symbol);\n  }\n\n  // prepare sizes\n  var markerSizeFunc = makeBubbleSizeFn(trace);\n  var s;\n  if (multiSize || multiLineWidth) {\n    var sizes = optsOut.sizes = new Array(count);\n    var borderSizes = optsOut.borderSizes = new Array(count);\n    var sizeTotal = 0;\n    var sizeAvg;\n    if (multiSize) {\n      for (i = 0; i < count; i++) {\n        sizes[i] = markerSizeFunc(optsIn.size[i]);\n        sizeTotal += sizes[i];\n      }\n      sizeAvg = sizeTotal / count;\n    } else {\n      s = markerSizeFunc(optsIn.size);\n      for (i = 0; i < count; i++) {\n        sizes[i] = s;\n      }\n    }\n\n    // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n    if (multiLineWidth) {\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = optsIn.line.width[i] / 2;\n      }\n    } else {\n      s = optsIn.line.width / 2;\n      for (i = 0; i < count; i++) {\n        borderSizes[i] = s;\n      }\n    }\n    optsOut.sizeAvg = sizeAvg;\n  } else {\n    optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n    optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n  }\n  return optsOut;\n}\nfunction convertMarkerSelection(trace, target) {\n  var optsIn = trace.marker;\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.marker && target.marker.symbol) {\n    optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n  } else if (target.marker) {\n    if (target.marker.size) optsOut.size = target.marker.size / 2;\n    if (target.marker.color) optsOut.colors = target.marker.color;\n    if (target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n  }\n  return optsOut;\n}\nfunction convertTextSelection(trace, target) {\n  var optsOut = {};\n  if (!target) return optsOut;\n  if (target.textfont) {\n    var optsIn = {\n      opacity: 1,\n      text: trace.text,\n      textposition: trace.textposition,\n      textfont: Lib.extendFlat({}, trace.textfont)\n    };\n    if (target.textfont) {\n      Lib.extendFlat(optsIn.textfont, target.textfont);\n    }\n    optsOut = convertTextStyle(optsIn);\n  }\n  return optsOut;\n}\nfunction convertErrorBarStyle(trace, target) {\n  var optsOut = {\n    capSize: target.width * 2,\n    lineWidth: target.thickness,\n    color: target.color\n  };\n  if (target.copy_ystyle) {\n    optsOut = trace.error_y;\n  }\n  return optsOut;\n}\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\nfunction getSymbolSdf(symbol) {\n  if (symbol === 'circle') return null;\n  var symbolPath, symbolSdf;\n  var symbolNumber = Drawing.symbolNumber(symbol);\n  var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n  var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n  var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n  var isDot = constants.DOT_RE.test(symbol);\n\n  // get symbol sdf from cache or generate it\n  if (SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n  if (isDot && !symbolNoDot) {\n    symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n  } else {\n    symbolPath = symbolFunc(SYMBOL_SIZE);\n  }\n  symbolSdf = svgSdf(symbolPath, {\n    w: SYMBOL_SDF_SIZE,\n    h: SYMBOL_SDF_SIZE,\n    viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n    stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n  });\n  SYMBOL_SDF[symbol] = symbolSdf;\n  return symbolSdf || null;\n}\nfunction convertLinePositions(gd, trace, positions) {\n  var len = positions.length;\n  var count = len / 2;\n  var linePositions;\n  var i;\n  if (subTypes.hasLines(trace) && count) {\n    if (trace.line.shape === 'hv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'hvh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], midPtX, positions[i * 2 + 1], midPtX, positions[i * 2 + 3]);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vhv') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n          if (!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n          linePositions.push(NaN, NaN);\n        } else {\n          var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n          linePositions.push(positions[i * 2], positions[i * 2 + 1], positions[i * 2], midPtY, positions[i * 2 + 2], midPtY);\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else if (trace.line.shape === 'vh') {\n      linePositions = [];\n      for (i = 0; i < count - 1; i++) {\n        if (isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n          linePositions.push(NaN, NaN, NaN, NaN);\n        } else {\n          linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n          if (!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n            linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n          } else {\n            linePositions.push(NaN, NaN);\n          }\n        }\n      }\n      linePositions.push(positions[len - 2], positions[len - 1]);\n    } else {\n      linePositions = positions;\n    }\n  }\n\n  // If we have data with gaps, we ought to use rect joins\n  // FIXME: get rid of this\n  var hasNaN = false;\n  for (i = 0; i < linePositions.length; i++) {\n    if (isNaN(linePositions[i])) {\n      hasNaN = true;\n      break;\n    }\n  }\n  var join = hasNaN || linePositions.length > constants.TOO_MANY_POINTS ? 'rect' : subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n  // fill gaps\n  if (hasNaN && trace.connectgaps) {\n    var lastX = linePositions[0];\n    var lastY = linePositions[1];\n    for (i = 0; i < linePositions.length; i += 2) {\n      if (isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n        linePositions[i] = lastX;\n        linePositions[i + 1] = lastY;\n      } else {\n        lastX = linePositions[i];\n        lastY = linePositions[i + 1];\n      }\n    }\n  }\n  return {\n    join: join,\n    positions: linePositions\n  };\n}\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n  var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var count = positions.length / 2;\n  var out = {};\n  function convertOneAxis(coords, ax) {\n    var axLetter = ax._id.charAt(0);\n    var opts = trace['error_' + axLetter];\n    if (opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n      var computeError = makeComputeError(opts);\n      var pOffset = {\n        x: 0,\n        y: 1\n      }[axLetter];\n      var eOffset = {\n        x: [0, 1, 2, 3],\n        y: [2, 3, 0, 1]\n      }[axLetter];\n      var errors = new Float64Array(4 * count);\n      var minShoe = Infinity;\n      var maxHat = -Infinity;\n      for (var i = 0, j = 0; i < count; i++, j += 4) {\n        var dc = coords[i];\n        if (isNumeric(dc)) {\n          var dl = positions[i * 2 + pOffset];\n          var vals = computeError(dc, i);\n          var lv = vals[0];\n          var hv = vals[1];\n          if (isNumeric(lv) && isNumeric(hv)) {\n            var shoe = dc - lv;\n            var hat = dc + hv;\n            errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n            errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n            errors[j + eOffset[2]] = 0;\n            errors[j + eOffset[3]] = 0;\n            minShoe = Math.min(minShoe, dc - lv);\n            maxHat = Math.max(maxHat, dc + hv);\n          }\n        }\n      }\n      out[axLetter] = {\n        positions: positions,\n        errors: errors,\n        _bnds: [minShoe, maxHat]\n      };\n    }\n  }\n  convertOneAxis(x, xa);\n  convertOneAxis(y, ya);\n  return out;\n}\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n  var count = trace._length;\n  var out = {};\n  var i;\n\n  // corresponds to textPointPosition from component.drawing\n  if (subTypes.hasMarkers(trace)) {\n    var fontOpts = textOpts.font;\n    var align = textOpts.align;\n    var baseline = textOpts.baseline;\n    out.offset = new Array(count);\n    for (i = 0; i < count; i++) {\n      var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n      var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n      var a = Array.isArray(align) ? align.length > 1 ? align[i] : align[0] : align;\n      var b = Array.isArray(baseline) ? baseline.length > 1 ? baseline[i] : baseline[0] : baseline;\n      var hSign = TEXTOFFSETSIGN[a];\n      var vSign = TEXTOFFSETSIGN[b];\n      var xPad = ms ? ms / 0.8 + 1 : 0;\n      var yPad = -vSign * xPad - vSign * 0.5;\n      out.offset[i] = [hSign * xPad / fs, yPad / fs];\n    }\n  }\n  return out;\n}\nmodule.exports = {\n  style: convertStyle,\n  markerStyle: convertMarkerStyle,\n  markerSelection: convertMarkerSelection,\n  linePositions: convertLinePositions,\n  errorBarPositions: convertErrorBarPositions,\n  textPosition: convertTextPosition\n};","map":{"version":3,"names":["isNumeric","require","svgSdf","rgba","Registry","Lib","Drawing","AxisIDs","formatColor","subTypes","makeBubbleSizeFn","constants","DESELECTDIM","TEXTOFFSETSIGN","start","left","end","right","middle","center","bottom","top","convertStyle","gd","trace","i","opts","marker","undefined","markerSel","markerUnsel","line","fill","errorX","errorY","text","textSel","textUnsel","visible","hasText","convertTextStyle","convertTextSelection","selected","unselected","hasMarkers","convertMarkerStyle","convertMarkerSelection","Array","isArray","opacity","mo","length","hasLines","overlay","thickness","width","color","dashes","DASHES","dash","slice","error_x","convertErrorBarStyle","error_y","closed","fillcolor","count","_length","textfontIn","textfont","textpositionIn","textposition","textPos","tfc","tfs","size","tff","family","optsOut","font","align","baseline","tp","split","push","fonti","optsIn","multiSymbol","symbol","multiColor","isArrayOrTypedArray","multiLineColor","multiOpacity","multiSize","multiLineWidth","isOpen","OPEN_RE","test","colors","borderColors","borderColor","markers","getSymbolSdf","markerSizeFunc","s","sizes","borderSizes","sizeTotal","sizeAvg","target","extendFlat","capSize","lineWidth","copy_ystyle","SYMBOL_SDF_SIZE","SYMBOL_SIZE","SYMBOL_STROKE","SYMBOL_SDF","SYMBOL_SVG_CIRCLE","symbolFuncs","symbolPath","symbolSdf","symbolNumber","symbolFunc","symbolNoDot","symbolNoFill","isDot","DOT_RE","w","h","viewBox","stroke","convertLinePositions","positions","len","linePositions","shape","isNaN","NaN","midPtX","midPtY","hasNaN","join","TOO_MANY_POINTS","connectgaps","lastX","lastY","convertErrorBarPositions","x","y","makeComputeError","getComponentMethod","xa","getFromId","xaxis","ya","yaxis","out","convertOneAxis","coords","ax","axLetter","_id","charAt","type","computeError","pOffset","eOffset","errors","Float64Array","minShoe","Infinity","maxHat","j","dc","dl","vals","lv","hv","shoe","hat","c2l","Math","min","max","_bnds","convertTextPosition","textOpts","markerOpts","fontOpts","offset","ms","fs","a","b","hSign","vSign","xPad","yPad","module","exports","style","markerStyle","markerSelection","errorBarPositions","textPosition"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/scattergl/convert.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar svgSdf = require('svg-path-sdf');\nvar rgba = require('color-normalize');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar Drawing = require('../../components/drawing');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\n\nvar formatColor = require('../../lib/gl_format_color').formatColor;\nvar subTypes = require('../scatter/subtypes');\nvar makeBubbleSizeFn = require('../scatter/make_bubble_size_func');\n\nvar constants = require('./constants');\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nvar TEXTOFFSETSIGN = {\n    start: 1, left: 1, end: -1, right: -1, middle: 0, center: 0, bottom: 1, top: -1\n};\n\nfunction convertStyle(gd, trace) {\n    var i;\n\n    var opts = {\n        marker: undefined,\n        markerSel: undefined,\n        markerUnsel: undefined,\n        line: undefined,\n        fill: undefined,\n        errorX: undefined,\n        errorY: undefined,\n        text: undefined,\n        textSel: undefined,\n        textUnsel: undefined\n    };\n\n    if(trace.visible !== true) return opts;\n\n    if(subTypes.hasText(trace)) {\n        opts.text = convertTextStyle(trace);\n        opts.textSel = convertTextSelection(trace, trace.selected);\n        opts.textUnsel = convertTextSelection(trace, trace.unselected);\n    }\n\n    if(subTypes.hasMarkers(trace)) {\n        opts.marker = convertMarkerStyle(trace);\n        opts.markerSel = convertMarkerSelection(trace, trace.selected);\n        opts.markerUnsel = convertMarkerSelection(trace, trace.unselected);\n\n        if(!trace.unselected && Array.isArray(trace.marker.opacity)) {\n            var mo = trace.marker.opacity;\n            opts.markerUnsel.opacity = new Array(mo.length);\n            for(i = 0; i < mo.length; i++) {\n                opts.markerUnsel.opacity[i] = DESELECTDIM * mo[i];\n            }\n        }\n    }\n\n    if(subTypes.hasLines(trace)) {\n        opts.line = {\n            overlay: true,\n            thickness: trace.line.width,\n            color: trace.line.color,\n            opacity: trace.opacity\n        };\n\n        var dashes = (constants.DASHES[trace.line.dash] || [1]).slice();\n        for(i = 0; i < dashes.length; ++i) {\n            dashes[i] *= trace.line.width;\n        }\n        opts.line.dashes = dashes;\n    }\n\n    if(trace.error_x && trace.error_x.visible) {\n        opts.errorX = convertErrorBarStyle(trace, trace.error_x);\n    }\n\n    if(trace.error_y && trace.error_y.visible) {\n        opts.errorY = convertErrorBarStyle(trace, trace.error_y);\n    }\n\n    if(!!trace.fill && trace.fill !== 'none') {\n        opts.fill = {\n            closed: true,\n            fill: trace.fillcolor,\n            thickness: 0\n        };\n    }\n\n    return opts;\n}\n\nfunction convertTextStyle(trace) {\n    var count = trace._length;\n    var textfontIn = trace.textfont;\n    var textpositionIn = trace.textposition;\n    var textPos = Array.isArray(textpositionIn) ? textpositionIn : [textpositionIn];\n    var tfc = textfontIn.color;\n    var tfs = textfontIn.size;\n    var tff = textfontIn.family;\n    var optsOut = {};\n    var i;\n\n    optsOut.text = trace.text;\n    optsOut.opacity = trace.opacity;\n    optsOut.font = {};\n    optsOut.align = [];\n    optsOut.baseline = [];\n\n    for(i = 0; i < textPos.length; i++) {\n        var tp = textPos[i].split(/\\s+/);\n\n        switch(tp[1]) {\n            case 'left':\n                optsOut.align.push('right');\n                break;\n            case 'right':\n                optsOut.align.push('left');\n                break;\n            default:\n                optsOut.align.push(tp[1]);\n        }\n        switch(tp[0]) {\n            case 'top':\n                optsOut.baseline.push('bottom');\n                break;\n            case 'bottom':\n                optsOut.baseline.push('top');\n                break;\n            default:\n                optsOut.baseline.push(tp[0]);\n        }\n    }\n\n    if(Array.isArray(tfc)) {\n        optsOut.color = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.color[i] = tfc[i];\n        }\n    } else {\n        optsOut.color = tfc;\n    }\n\n    if(Array.isArray(tfs) || Array.isArray(tff)) {\n        // if any textfont param is array - make render a batch\n        optsOut.font = new Array(count);\n        for(i = 0; i < count; i++) {\n            var fonti = optsOut.font[i] = {};\n\n            fonti.size = Array.isArray(tfs) ?\n                (isNumeric(tfs[i]) ? tfs[i] : 0) :\n                tfs;\n\n            fonti.family = Array.isArray(tff) ? tff[i] : tff;\n        }\n    } else {\n        // if both are single values, make render fast single-value\n        optsOut.font = {size: tfs, family: tff};\n    }\n\n    return optsOut;\n}\n\n\nfunction convertMarkerStyle(trace) {\n    var count = trace._length;\n    var optsIn = trace.marker;\n    var optsOut = {};\n    var i;\n\n    var multiSymbol = Array.isArray(optsIn.symbol);\n    var multiColor = Lib.isArrayOrTypedArray(optsIn.color);\n    var multiLineColor = Lib.isArrayOrTypedArray(optsIn.line.color);\n    var multiOpacity = Lib.isArrayOrTypedArray(optsIn.opacity);\n    var multiSize = Lib.isArrayOrTypedArray(optsIn.size);\n    var multiLineWidth = Lib.isArrayOrTypedArray(optsIn.line.width);\n\n    var isOpen;\n    if(!multiSymbol) isOpen = constants.OPEN_RE.test(optsIn.symbol);\n\n    // prepare colors\n    if(multiSymbol || multiColor || multiLineColor || multiOpacity) {\n        optsOut.colors = new Array(count);\n        optsOut.borderColors = new Array(count);\n\n        var colors = formatColor(optsIn, optsIn.opacity, count);\n        var borderColors = formatColor(optsIn.line, optsIn.opacity, count);\n\n        if(!Array.isArray(borderColors[0])) {\n            var borderColor = borderColors;\n            borderColors = Array(count);\n            for(i = 0; i < count; i++) {\n                borderColors[i] = borderColor;\n            }\n        }\n        if(!Array.isArray(colors[0])) {\n            var color = colors;\n            colors = Array(count);\n            for(i = 0; i < count; i++) {\n                colors[i] = color;\n            }\n        }\n\n        optsOut.colors = colors;\n        optsOut.borderColors = borderColors;\n\n        for(i = 0; i < count; i++) {\n            if(multiSymbol) {\n                var symbol = optsIn.symbol[i];\n                isOpen = constants.OPEN_RE.test(symbol);\n            }\n            if(isOpen) {\n                borderColors[i] = colors[i].slice();\n                colors[i] = colors[i].slice();\n                colors[i][3] = 0;\n            }\n        }\n\n        optsOut.opacity = trace.opacity;\n    } else {\n        if(isOpen) {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.color[3] = 0;\n            optsOut.borderColor = rgba(optsIn.color, 'uint8');\n        } else {\n            optsOut.color = rgba(optsIn.color, 'uint8');\n            optsOut.borderColor = rgba(optsIn.line.color, 'uint8');\n        }\n\n        optsOut.opacity = trace.opacity * optsIn.opacity;\n    }\n\n    // prepare symbols\n    if(multiSymbol) {\n        optsOut.markers = new Array(count);\n        for(i = 0; i < count; i++) {\n            optsOut.markers[i] = getSymbolSdf(optsIn.symbol[i]);\n        }\n    } else {\n        optsOut.marker = getSymbolSdf(optsIn.symbol);\n    }\n\n    // prepare sizes\n    var markerSizeFunc = makeBubbleSizeFn(trace);\n    var s;\n\n    if(multiSize || multiLineWidth) {\n        var sizes = optsOut.sizes = new Array(count);\n        var borderSizes = optsOut.borderSizes = new Array(count);\n        var sizeTotal = 0;\n        var sizeAvg;\n\n        if(multiSize) {\n            for(i = 0; i < count; i++) {\n                sizes[i] = markerSizeFunc(optsIn.size[i]);\n                sizeTotal += sizes[i];\n            }\n            sizeAvg = sizeTotal / count;\n        } else {\n            s = markerSizeFunc(optsIn.size);\n            for(i = 0; i < count; i++) {\n                sizes[i] = s;\n            }\n        }\n\n        // See  https://github.com/plotly/plotly.js/pull/1781#discussion_r121820798\n        if(multiLineWidth) {\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = optsIn.line.width[i] / 2;\n            }\n        } else {\n            s = optsIn.line.width / 2;\n            for(i = 0; i < count; i++) {\n                borderSizes[i] = s;\n            }\n        }\n\n        optsOut.sizeAvg = sizeAvg;\n    } else {\n        optsOut.size = markerSizeFunc(optsIn && optsIn.size || 10);\n        optsOut.borderSizes = markerSizeFunc(optsIn.line.width);\n    }\n\n    return optsOut;\n}\n\nfunction convertMarkerSelection(trace, target) {\n    var optsIn = trace.marker;\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.marker && target.marker.symbol) {\n        optsOut = convertMarkerStyle(Lib.extendFlat({}, optsIn, target.marker));\n    } else if(target.marker) {\n        if(target.marker.size) optsOut.size = target.marker.size / 2;\n        if(target.marker.color) optsOut.colors = target.marker.color;\n        if(target.marker.opacity !== undefined) optsOut.opacity = target.marker.opacity;\n    }\n\n    return optsOut;\n}\n\nfunction convertTextSelection(trace, target) {\n    var optsOut = {};\n\n    if(!target) return optsOut;\n\n    if(target.textfont) {\n        var optsIn = {\n            opacity: 1,\n            text: trace.text,\n            textposition: trace.textposition,\n            textfont: Lib.extendFlat({}, trace.textfont)\n        };\n        if(target.textfont) {\n            Lib.extendFlat(optsIn.textfont, target.textfont);\n        }\n        optsOut = convertTextStyle(optsIn);\n    }\n\n    return optsOut;\n}\n\nfunction convertErrorBarStyle(trace, target) {\n    var optsOut = {\n        capSize: target.width * 2,\n        lineWidth: target.thickness,\n        color: target.color\n    };\n\n    if(target.copy_ystyle) {\n        optsOut = trace.error_y;\n    }\n\n    return optsOut;\n}\n\nvar SYMBOL_SDF_SIZE = constants.SYMBOL_SDF_SIZE;\nvar SYMBOL_SIZE = constants.SYMBOL_SIZE;\nvar SYMBOL_STROKE = constants.SYMBOL_STROKE;\nvar SYMBOL_SDF = {};\nvar SYMBOL_SVG_CIRCLE = Drawing.symbolFuncs[0](SYMBOL_SIZE * 0.05);\n\nfunction getSymbolSdf(symbol) {\n    if(symbol === 'circle') return null;\n\n    var symbolPath, symbolSdf;\n    var symbolNumber = Drawing.symbolNumber(symbol);\n    var symbolFunc = Drawing.symbolFuncs[symbolNumber % 100];\n    var symbolNoDot = !!Drawing.symbolNoDot[symbolNumber % 100];\n    var symbolNoFill = !!Drawing.symbolNoFill[symbolNumber % 100];\n\n    var isDot = constants.DOT_RE.test(symbol);\n\n    // get symbol sdf from cache or generate it\n    if(SYMBOL_SDF[symbol]) return SYMBOL_SDF[symbol];\n\n    if(isDot && !symbolNoDot) {\n        symbolPath = symbolFunc(SYMBOL_SIZE * 1.1) + SYMBOL_SVG_CIRCLE;\n    }\n    else {\n        symbolPath = symbolFunc(SYMBOL_SIZE);\n    }\n\n    symbolSdf = svgSdf(symbolPath, {\n        w: SYMBOL_SDF_SIZE,\n        h: SYMBOL_SDF_SIZE,\n        viewBox: [-SYMBOL_SIZE, -SYMBOL_SIZE, SYMBOL_SIZE, SYMBOL_SIZE],\n        stroke: symbolNoFill ? SYMBOL_STROKE : -SYMBOL_STROKE\n    });\n    SYMBOL_SDF[symbol] = symbolSdf;\n\n    return symbolSdf || null;\n}\n\nfunction convertLinePositions(gd, trace, positions) {\n    var len = positions.length;\n    var count = len / 2;\n    var linePositions;\n    var i;\n\n    if(subTypes.hasLines(trace) && count) {\n        if(trace.line.shape === 'hv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                } else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2 + 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'hvh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                }\n                else {\n                    var midPtX = (positions[i * 2] + positions[i * 2 + 2]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 1],\n                        midPtX,\n                        positions[i * 2 + 3]\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vhv') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1]) || isNaN(positions[i * 2 + 2]) || isNaN(positions[i * 2 + 3])) {\n                    if(!isNaN(positions[i * 2]) && !isNaN(positions[i * 2 + 1])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                    linePositions.push(NaN, NaN);\n                }\n                else {\n                    var midPtY = (positions[i * 2 + 1] + positions[i * 2 + 3]) / 2;\n                    linePositions.push(\n                        positions[i * 2],\n                        positions[i * 2 + 1],\n                        positions[i * 2],\n                        midPtY,\n                        positions[i * 2 + 2],\n                        midPtY\n                    );\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else if(trace.line.shape === 'vh') {\n            linePositions = [];\n            for(i = 0; i < count - 1; i++) {\n                if(isNaN(positions[i * 2]) || isNaN(positions[i * 2 + 1])) {\n                    linePositions.push(NaN, NaN, NaN, NaN);\n                }\n                else {\n                    linePositions.push(positions[i * 2], positions[i * 2 + 1]);\n                    if(!isNaN(positions[i * 2 + 2]) && !isNaN(positions[i * 2 + 3])) {\n                        linePositions.push(positions[i * 2], positions[i * 2 + 3]);\n                    } else {\n                        linePositions.push(NaN, NaN);\n                    }\n                }\n            }\n            linePositions.push(positions[len - 2], positions[len - 1]);\n        } else {\n            linePositions = positions;\n        }\n    }\n\n    // If we have data with gaps, we ought to use rect joins\n    // FIXME: get rid of this\n    var hasNaN = false;\n    for(i = 0; i < linePositions.length; i++) {\n        if(isNaN(linePositions[i])) {\n            hasNaN = true;\n            break;\n        }\n    }\n\n    var join = (hasNaN || linePositions.length > constants.TOO_MANY_POINTS) ? 'rect' :\n        subTypes.hasMarkers(trace) ? 'rect' : 'round';\n\n    // fill gaps\n    if(hasNaN && trace.connectgaps) {\n        var lastX = linePositions[0];\n        var lastY = linePositions[1];\n\n        for(i = 0; i < linePositions.length; i += 2) {\n            if(isNaN(linePositions[i]) || isNaN(linePositions[i + 1])) {\n                linePositions[i] = lastX;\n                linePositions[i + 1] = lastY;\n            }\n            else {\n                lastX = linePositions[i];\n                lastY = linePositions[i + 1];\n            }\n        }\n    }\n\n    return {\n        join: join,\n        positions: linePositions\n    };\n}\n\nfunction convertErrorBarPositions(gd, trace, positions, x, y) {\n    var makeComputeError = Registry.getComponentMethod('errorbars', 'makeComputeError');\n    var xa = AxisIDs.getFromId(gd, trace.xaxis);\n    var ya = AxisIDs.getFromId(gd, trace.yaxis);\n    var count = positions.length / 2;\n    var out = {};\n\n    function convertOneAxis(coords, ax) {\n        var axLetter = ax._id.charAt(0);\n        var opts = trace['error_' + axLetter];\n\n        if(opts && opts.visible && (ax.type === 'linear' || ax.type === 'log')) {\n            var computeError = makeComputeError(opts);\n            var pOffset = {x: 0, y: 1}[axLetter];\n            var eOffset = {x: [0, 1, 2, 3], y: [2, 3, 0, 1]}[axLetter];\n            var errors = new Float64Array(4 * count);\n            var minShoe = Infinity;\n            var maxHat = -Infinity;\n\n            for(var i = 0, j = 0; i < count; i++, j += 4) {\n                var dc = coords[i];\n\n                if(isNumeric(dc)) {\n                    var dl = positions[i * 2 + pOffset];\n                    var vals = computeError(dc, i);\n                    var lv = vals[0];\n                    var hv = vals[1];\n\n                    if(isNumeric(lv) && isNumeric(hv)) {\n                        var shoe = dc - lv;\n                        var hat = dc + hv;\n\n                        errors[j + eOffset[0]] = dl - ax.c2l(shoe);\n                        errors[j + eOffset[1]] = ax.c2l(hat) - dl;\n                        errors[j + eOffset[2]] = 0;\n                        errors[j + eOffset[3]] = 0;\n\n                        minShoe = Math.min(minShoe, dc - lv);\n                        maxHat = Math.max(maxHat, dc + hv);\n                    }\n                }\n            }\n\n            out[axLetter] = {\n                positions: positions,\n                errors: errors,\n                _bnds: [minShoe, maxHat]\n            };\n        }\n    }\n\n    convertOneAxis(x, xa);\n    convertOneAxis(y, ya);\n    return out;\n}\n\nfunction convertTextPosition(gd, trace, textOpts, markerOpts) {\n    var count = trace._length;\n    var out = {};\n    var i;\n\n    // corresponds to textPointPosition from component.drawing\n    if(subTypes.hasMarkers(trace)) {\n        var fontOpts = textOpts.font;\n        var align = textOpts.align;\n        var baseline = textOpts.baseline;\n        out.offset = new Array(count);\n\n        for(i = 0; i < count; i++) {\n            var ms = markerOpts.sizes ? markerOpts.sizes[i] : markerOpts.size;\n            var fs = Array.isArray(fontOpts) ? fontOpts[i].size : fontOpts.size;\n\n            var a = Array.isArray(align) ?\n                (align.length > 1 ? align[i] : align[0]) :\n                align;\n            var b = Array.isArray(baseline) ?\n                (baseline.length > 1 ? baseline[i] : baseline[0]) :\n                baseline;\n\n            var hSign = TEXTOFFSETSIGN[a];\n            var vSign = TEXTOFFSETSIGN[b];\n            var xPad = ms ? ms / 0.8 + 1 : 0;\n            var yPad = -vSign * xPad - vSign * 0.5;\n            out.offset[i] = [hSign * xPad / fs, yPad / fs];\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    style: convertStyle,\n\n    markerStyle: convertMarkerStyle,\n    markerSelection: convertMarkerSelection,\n\n    linePositions: convertLinePositions,\n    errorBarPositions: convertErrorBarPositions,\n    textPosition: convertTextPosition\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}