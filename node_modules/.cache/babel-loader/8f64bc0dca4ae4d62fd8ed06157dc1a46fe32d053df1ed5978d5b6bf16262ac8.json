{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var fullTraces = gd._fullData;\n  var calcTraces = gd.calcdata;\n  var calcTracesHorizontal = [];\n  var calcTracesVertical = [];\n  for (var i = 0; i < fullTraces.length; i++) {\n    var fullTrace = fullTraces[i];\n    if (fullTrace.visible === true && Registry.traceIs(fullTrace, 'bar') && fullTrace.xaxis === xa._id && fullTrace.yaxis === ya._id) {\n      if (fullTrace.orientation === 'h') {\n        calcTracesHorizontal.push(calcTraces[i]);\n      } else {\n        calcTracesVertical.push(calcTraces[i]);\n      }\n    }\n  }\n  setGroupPositions(gd, xa, ya, calcTracesVertical);\n  setGroupPositions(gd, ya, xa, calcTracesHorizontal);\n}\nfunction setGroupPositions(gd, pa, sa, calcTraces) {\n  if (!calcTraces.length) return;\n  var barmode = gd._fullLayout.barmode;\n  var overlay = barmode === 'overlay';\n  var group = barmode === 'group';\n  var excluded;\n  var included;\n  var i, calcTrace, fullTrace;\n  initBase(gd, pa, sa, calcTraces);\n  if (overlay) {\n    setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces);\n  } else if (group) {\n    // exclude from the group those traces for which the user set an offset\n    excluded = [];\n    included = [];\n    for (i = 0; i < calcTraces.length; i++) {\n      calcTrace = calcTraces[i];\n      fullTrace = calcTrace[0].trace;\n      if (fullTrace.offset === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n    }\n    if (included.length) {\n      setGroupPositionsInGroupMode(gd, pa, sa, included);\n    }\n    if (excluded.length) {\n      setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n    }\n  } else {\n    // exclude from the stack those traces for which the user set a base\n    excluded = [];\n    included = [];\n    for (i = 0; i < calcTraces.length; i++) {\n      calcTrace = calcTraces[i];\n      fullTrace = calcTrace[0].trace;\n      if (fullTrace.base === undefined) included.push(calcTrace);else excluded.push(calcTrace);\n    }\n    if (included.length) {\n      setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included);\n    }\n    if (excluded.length) {\n      setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n    }\n  }\n  collectExtents(calcTraces, pa);\n}\nfunction initBase(gd, pa, sa, calcTraces) {\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var cd = calcTraces[i];\n    var trace = cd[0].trace;\n    var base = trace.base;\n    var b;\n\n    // not sure if it really makes sense to have dates for bar size data...\n    // ideally if we want to make gantt charts or something we'd treat\n    // the actual size (trace.x or y) as time delta but base as absolute\n    // time. But included here for completeness.\n    var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n    // 'base' on categorical axes makes no sense\n    var d2c = sa.type === 'category' || sa.type === 'multicategory' ? function () {\n      return null;\n    } : sa.d2c;\n    if (isArrayOrTypedArray(base)) {\n      for (j = 0; j < Math.min(base.length, cd.length); j++) {\n        b = d2c(base[j], 0, scalendar);\n        if (isNumeric(b)) {\n          cd[j].b = +b;\n          cd[j].hasB = 1;\n        } else cd[j].b = 0;\n      }\n      for (; j < cd.length; j++) {\n        cd[j].b = 0;\n      }\n    } else {\n      b = d2c(base, 0, scalendar);\n      var hasBase = isNumeric(b);\n      b = hasBase ? b : 0;\n      for (j = 0; j < cd.length; j++) {\n        cd[j].b = b;\n        if (hasBase) cd[j].hasB = 1;\n      }\n    }\n  }\n}\nfunction setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces) {\n  var barnorm = gd._fullLayout.barnorm;\n  var separateNegativeValues = false;\n  var dontMergeOverlappingData = !barnorm;\n\n  // update position axis and set bar offsets and widths\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var sieve = new Sieve([calcTrace], separateNegativeValues, dontMergeOverlappingData);\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    //\n    // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n    // is defined, because this function is also invoked for traces that\n    // can't be grouped or stacked)\n    if (barnorm) {\n      sieveBars(gd, sa, sieve);\n      normalizeBars(gd, sa, sieve);\n    } else {\n      setBaseAndTop(gd, sa, sieve);\n    }\n  }\n}\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces) {\n  var fullLayout = gd._fullLayout;\n  var barnorm = fullLayout.barnorm;\n  var separateNegativeValues = false;\n  var dontMergeOverlappingData = !barnorm;\n  var sieve = new Sieve(calcTraces, separateNegativeValues, dontMergeOverlappingData);\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidthInGroupMode(gd, pa, sieve);\n\n  // set bar bases and sizes, and update size axis\n  if (barnorm) {\n    sieveBars(gd, sa, sieve);\n    normalizeBars(gd, sa, sieve);\n  } else {\n    setBaseAndTop(gd, sa, sieve);\n  }\n}\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces) {\n  var fullLayout = gd._fullLayout;\n  var barmode = fullLayout.barmode;\n  var stack = barmode === 'stack';\n  var relative = barmode === 'relative';\n  var barnorm = fullLayout.barnorm;\n  var separateNegativeValues = relative;\n  var dontMergeOverlappingData = !(barnorm || stack || relative);\n  var sieve = new Sieve(calcTraces, separateNegativeValues, dontMergeOverlappingData);\n\n  // set bar offsets and widths, and update position axis\n  setOffsetAndWidth(gd, pa, sieve);\n\n  // set bar bases and sizes, and update size axis\n  stackBars(gd, sa, sieve);\n\n  // flag the outmost bar (for text display purposes)\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var isOutmostBar = bar.b + bar.s === sieve.get(bar.p, bar.s);\n        if (isOutmostBar) bar._outmost = true;\n      }\n    }\n  }\n\n  // Note that marking the outmost bars has to be done\n  // before `normalizeBars` changes `bar.b` and `bar.s`.\n  if (barnorm) normalizeBars(gd, sa, sieve);\n}\nfunction setOffsetAndWidth(gd, pa, sieve) {\n  var fullLayout = gd._fullLayout;\n  var bargap = fullLayout.bargap;\n  var bargroupgap = fullLayout.bargroupgap || 0;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n\n  // set bar offsets and widths\n  var barGroupWidth = minDiff * (1 - bargap);\n  var barWidthPlusGap = barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n  // computer bar group center and bar offset\n  var offsetFromCenter = -barWidth / 2;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n\n    // store bar width and offset for this trace\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace offset and width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(gd, pa, sieve);\n\n  // update position axes\n  updatePositionAxis(gd, pa, sieve);\n}\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve) {\n  var fullLayout = gd._fullLayout;\n  var bargap = fullLayout.bargap;\n  var bargroupgap = fullLayout.bargroupgap || 0;\n  var positions = sieve.positions;\n  var distinctPositions = sieve.distinctPositions;\n  var minDiff = sieve.minDiff;\n  var calcTraces = sieve.traces;\n\n  // if there aren't any overlapping positions,\n  // let them have full width even if mode is group\n  var overlap = positions.length !== distinctPositions.length;\n  var nTraces = calcTraces.length;\n  var barGroupWidth = minDiff * (1 - bargap);\n  var barWidthPlusGap = overlap ? barGroupWidth / nTraces : barGroupWidth;\n  var barWidth = barWidthPlusGap * (1 - bargroupgap);\n  for (var i = 0; i < nTraces; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = overlap ? ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 : -barWidth / 2;\n\n    // store bar width and offset for this trace\n    t.barwidth = barWidth;\n    t.poffset = offsetFromCenter;\n    t.bargroupwidth = barGroupWidth;\n    t.bardelta = minDiff;\n  }\n\n  // stack bars that only differ by rounding\n  sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n  // if defined, apply trace width\n  applyAttributes(sieve);\n\n  // store the bar center in each calcdata item\n  setBarCenterAndWidth(gd, pa, sieve);\n\n  // update position axes\n  updatePositionAxis(gd, pa, sieve, overlap);\n}\nfunction applyAttributes(sieve) {\n  var calcTraces = sieve.traces;\n  var i, j;\n  for (i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var t = calcTrace0.t;\n    var offset = fullTrace._offset || fullTrace.offset;\n    var initialPoffset = t.poffset;\n    var newPoffset;\n    if (isArrayOrTypedArray(offset)) {\n      // if offset is an array, then clone it into t.poffset.\n      newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newPoffset.length; j++) {\n        if (!isNumeric(newPoffset[j])) {\n          newPoffset[j] = initialPoffset;\n        }\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.poffset\n      for (j = newPoffset.length; j < calcTrace.length; j++) {\n        newPoffset.push(initialPoffset);\n      }\n      t.poffset = newPoffset;\n    } else if (offset !== undefined) {\n      t.poffset = offset;\n    }\n    var width = fullTrace._width || fullTrace.width;\n    var initialBarwidth = t.barwidth;\n    if (isArrayOrTypedArray(width)) {\n      // if width is an array, then clone it into t.barwidth.\n      var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n      // guard against non-numeric items\n      for (j = 0; j < newBarwidth.length; j++) {\n        if (!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n      }\n\n      // if the length of the array is too short,\n      // then extend it with the initial value of t.barwidth\n      for (j = newBarwidth.length; j < calcTrace.length; j++) {\n        newBarwidth.push(initialBarwidth);\n      }\n      t.barwidth = newBarwidth;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        newPoffset = [];\n        for (j = 0; j < calcTrace.length; j++) {\n          newPoffset.push(initialPoffset + (initialBarwidth - newBarwidth[j]) / 2);\n        }\n        t.poffset = newPoffset;\n      }\n    } else if (width !== undefined) {\n      t.barwidth = width;\n\n      // if user didn't set offset,\n      // then correct t.poffset to ensure bars remain centered\n      if (offset === undefined) {\n        t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n      }\n    }\n  }\n}\nfunction setBarCenterAndWidth(gd, pa, sieve) {\n  var calcTraces = sieve.traces;\n  var pLetter = getAxisLetter(pa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var t = calcTrace[0].t;\n    var poffset = t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    var barwidth = t.barwidth;\n    var barwidthIsArray = Array.isArray(barwidth);\n    for (var j = 0; j < calcTrace.length; j++) {\n      var calcBar = calcTrace[j];\n\n      // store the actual bar width and position, for use by hover\n      var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n      calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n    }\n  }\n}\nfunction updatePositionAxis(gd, pa, sieve, allowMinDtick) {\n  var calcTraces = sieve.traces;\n  var minDiff = sieve.minDiff;\n  var vpad = minDiff / 2;\n  Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var calcTrace0 = calcTrace[0];\n    var fullTrace = calcTrace0.trace;\n    var pts = [];\n    var bar, l, r, j;\n    for (j = 0; j < calcTrace.length; j++) {\n      bar = calcTrace[j];\n      l = bar.p - vpad;\n      r = bar.p + vpad;\n      pts.push(l, r);\n    }\n    if (fullTrace.width || fullTrace.offset) {\n      var t = calcTrace0.t;\n      var poffset = t.poffset;\n      var barwidth = t.barwidth;\n      var poffsetIsArray = Array.isArray(poffset);\n      var barwidthIsArray = Array.isArray(barwidth);\n      for (j = 0; j < calcTrace.length; j++) {\n        bar = calcTrace[j];\n        var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n        var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n        l = bar.p + calcBarOffset;\n        r = l + calcBarWidth;\n        pts.push(l, r);\n      }\n    }\n    fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {\n      padded: false\n    });\n  }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(gd, sa, sieve) {\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var allBarBaseAboveZero = true;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      var barBase = bar.b;\n      var barTop = barBase + bar.s;\n      bar[sLetter] = barTop;\n      pts.push(barTop);\n      if (bar.hasB) pts.push(barBase);\n      if (!bar.hasB || !(bar.b > 0 && bar.s > 0)) {\n        allBarBaseAboveZero = false;\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: !allBarBaseAboveZero,\n      padded: true\n    });\n  }\n}\nfunction stackBars(gd, sa, sieve) {\n  var fullLayout = gd._fullLayout;\n  var barnorm = fullLayout.barnorm;\n  var sLetter = getAxisLetter(sa);\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        // stack current bar and get previous sum\n        var barBase = sieve.put(bar.p, bar.b + bar.s);\n        var barTop = barBase + bar.b + bar.s;\n\n        // store the bar base and top in each calcdata item\n        bar.b = barBase;\n        bar[sLetter] = barTop;\n        if (!barnorm) {\n          pts.push(barTop);\n          if (bar.hasB) pts.push(barBase);\n        }\n      }\n    }\n\n    // if barnorm is set, let normalizeBars update the axis range\n    if (!barnorm) {\n      fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n        // N.B. we don't stack base with 'base',\n        // so set tozero:true always!\n        tozero: true,\n        padded: true\n      });\n    }\n  }\n}\nfunction sieveBars(gd, sa, sieve) {\n  var calcTraces = sieve.traces;\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) sieve.put(bar.p, bar.b + bar.s);\n    }\n  }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(gd, sa, sieve) {\n  var fullLayout = gd._fullLayout;\n  var calcTraces = sieve.traces;\n  var sLetter = getAxisLetter(sa);\n  var sTop = fullLayout.barnorm === 'fraction' ? 1 : 100;\n  var sTiny = sTop / 1e9; // in case of rounding error in sum\n  var sMin = sa.l2c(sa.c2l(0));\n  var sMax = fullLayout.barmode === 'stack' ? sTop : sMin;\n  function needsPadding(v) {\n    return isNumeric(sa.c2l(v)) && (v < sMin - sTiny || v > sMax + sTiny || !isNumeric(sMin));\n  }\n  for (var i = 0; i < calcTraces.length; i++) {\n    var calcTrace = calcTraces[i];\n    var fullTrace = calcTrace[0].trace;\n    var pts = [];\n    var allBarBaseAboveZero = true;\n    var padded = false;\n    for (var j = 0; j < calcTrace.length; j++) {\n      var bar = calcTrace[j];\n      if (bar.s !== BADNUM) {\n        var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n        bar.b *= scale;\n        bar.s *= scale;\n        var barBase = bar.b;\n        var barTop = barBase + bar.s;\n        bar[sLetter] = barTop;\n        pts.push(barTop);\n        padded = padded || needsPadding(barTop);\n        if (bar.hasB) {\n          pts.push(barBase);\n          padded = padded || needsPadding(barBase);\n        }\n        if (!bar.hasB || !(bar.b > 0 && bar.s > 0)) {\n          allBarBaseAboveZero = false;\n        }\n      }\n    }\n    fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n      tozero: !allBarBaseAboveZero,\n      padded: padded\n    });\n  }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n  var pLetter = getAxisLetter(pa);\n  var extents = {};\n  var i, j, cd;\n  var pMin = Infinity;\n  var pMax = -Infinity;\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    for (j = 0; j < cd.length; j++) {\n      var p = cd[j].p;\n      if (isNumeric(p)) {\n        pMin = Math.min(pMin, p);\n        pMax = Math.max(pMax, p);\n      }\n    }\n  }\n\n  // this is just for positioning of hover labels, and nobody will care if\n  // the label is 1px too far out; so round positions to 1/10K in case\n  // position values don't exactly match from trace to trace\n  var roundFactor = 10000 / (pMax - pMin);\n  var round = extents.round = function (p) {\n    return String(Math.round(roundFactor * (p - pMin)));\n  };\n  for (i = 0; i < calcTraces.length; i++) {\n    cd = calcTraces[i];\n    cd[0].t.extents = extents;\n    var poffset = cd[0].t.poffset;\n    var poffsetIsArray = Array.isArray(poffset);\n    for (j = 0; j < cd.length; j++) {\n      var di = cd[j];\n      var p0 = di[pLetter] - di.w / 2;\n      if (isNumeric(p0)) {\n        var p1 = di[pLetter] + di.w / 2;\n        var pVal = round(di.p);\n        if (extents[pVal]) {\n          extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n        } else {\n          extents[pVal] = [p0, p1];\n        }\n      }\n      di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n      di.p1 = di.p0 + di.w;\n      di.s0 = di.b;\n      di.s1 = di.s0 + di.s;\n    }\n  }\n}\nfunction getAxisLetter(ax) {\n  return ax._id.charAt(0);\n}\nmodule.exports = {\n  crossTraceCalc: crossTraceCalc,\n  setGroupPositions: setGroupPositions\n};","map":{"version":3,"names":["isNumeric","require","isArrayOrTypedArray","BADNUM","Registry","Axes","Sieve","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","fullTraces","_fullData","calcTraces","calcdata","calcTracesHorizontal","calcTracesVertical","i","length","fullTrace","visible","traceIs","_id","orientation","push","setGroupPositions","pa","sa","barmode","_fullLayout","overlay","group","excluded","included","calcTrace","initBase","setGroupPositionsInOverlayMode","trace","offset","undefined","setGroupPositionsInGroupMode","base","setGroupPositionsInStackOrRelativeMode","collectExtents","j","cd","b","scalendar","xcalendar","ycalendar","d2c","type","Math","min","hasB","hasBase","barnorm","separateNegativeValues","dontMergeOverlappingData","sieve","setOffsetAndWidth","sieveBars","normalizeBars","setBaseAndTop","fullLayout","setOffsetAndWidthInGroupMode","stack","relative","stackBars","bar","s","isOutmostBar","get","p","_outmost","bargap","bargroupgap","minDiff","traces","barGroupWidth","barWidthPlusGap","barWidth","offsetFromCenter","t","barwidth","poffset","bargroupwidth","bardelta","binWidth","applyAttributes","setBarCenterAndWidth","updatePositionAxis","positions","distinctPositions","overlap","nTraces","calcTrace0","_offset","initialPoffset","newPoffset","Array","prototype","slice","call","width","_width","initialBarwidth","newBarwidth","pLetter","getAxisLetter","poffsetIsArray","isArray","barwidthIsArray","calcBar","w","allowMinDtick","vpad","minDtick","pts","l","r","calcBarOffset","calcBarWidth","_extremes","findExtremes","padded","sLetter","allBarBaseAboveZero","barBase","barTop","tozero","put","sTop","sTiny","sMin","l2c","c2l","sMax","needsPadding","v","scale","abs","extents","pMin","Infinity","pMax","max","roundFactor","round","String","di","p0","p1","pVal","s0","s1","ax","charAt","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/bar/cross_trace_calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isNumeric = require('fast-isnumeric');\nvar isArrayOrTypedArray = require('../../lib').isArrayOrTypedArray;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nvar Registry = require('../../registry');\nvar Axes = require('../../plots/cartesian/axes');\nvar Sieve = require('./sieve.js');\n\n/*\n * Bar chart stacking/grouping positioning and autoscaling calculations\n * for each direction separately calculate the ranges and positions\n * note that this handles histograms too\n * now doing this one subplot at a time\n */\n\nfunction crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var fullTraces = gd._fullData;\n    var calcTraces = gd.calcdata;\n    var calcTracesHorizontal = [];\n    var calcTracesVertical = [];\n\n    for(var i = 0; i < fullTraces.length; i++) {\n        var fullTrace = fullTraces[i];\n        if(\n            fullTrace.visible === true &&\n            Registry.traceIs(fullTrace, 'bar') &&\n            fullTrace.xaxis === xa._id &&\n            fullTrace.yaxis === ya._id\n        ) {\n            if(fullTrace.orientation === 'h') {\n                calcTracesHorizontal.push(calcTraces[i]);\n            } else {\n                calcTracesVertical.push(calcTraces[i]);\n            }\n        }\n    }\n\n    setGroupPositions(gd, xa, ya, calcTracesVertical);\n    setGroupPositions(gd, ya, xa, calcTracesHorizontal);\n}\n\nfunction setGroupPositions(gd, pa, sa, calcTraces) {\n    if(!calcTraces.length) return;\n\n    var barmode = gd._fullLayout.barmode;\n    var overlay = (barmode === 'overlay');\n    var group = (barmode === 'group');\n    var excluded;\n    var included;\n    var i, calcTrace, fullTrace;\n\n    initBase(gd, pa, sa, calcTraces);\n\n    if(overlay) {\n        setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces);\n    } else if(group) {\n        // exclude from the group those traces for which the user set an offset\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.offset === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInGroupMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    } else {\n        // exclude from the stack those traces for which the user set a base\n        excluded = [];\n        included = [];\n        for(i = 0; i < calcTraces.length; i++) {\n            calcTrace = calcTraces[i];\n            fullTrace = calcTrace[0].trace;\n\n            if(fullTrace.base === undefined) included.push(calcTrace);\n            else excluded.push(calcTrace);\n        }\n\n        if(included.length) {\n            setGroupPositionsInStackOrRelativeMode(gd, pa, sa, included);\n        }\n        if(excluded.length) {\n            setGroupPositionsInOverlayMode(gd, pa, sa, excluded);\n        }\n    }\n\n    collectExtents(calcTraces, pa);\n}\n\nfunction initBase(gd, pa, sa, calcTraces) {\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var cd = calcTraces[i];\n        var trace = cd[0].trace;\n        var base = trace.base;\n        var b;\n\n        // not sure if it really makes sense to have dates for bar size data...\n        // ideally if we want to make gantt charts or something we'd treat\n        // the actual size (trace.x or y) as time delta but base as absolute\n        // time. But included here for completeness.\n        var scalendar = trace.orientation === 'h' ? trace.xcalendar : trace.ycalendar;\n\n        // 'base' on categorical axes makes no sense\n        var d2c = sa.type === 'category' || sa.type === 'multicategory' ?\n            function() { return null; } :\n            sa.d2c;\n\n        if(isArrayOrTypedArray(base)) {\n            for(j = 0; j < Math.min(base.length, cd.length); j++) {\n                b = d2c(base[j], 0, scalendar);\n                if(isNumeric(b)) {\n                    cd[j].b = +b;\n                    cd[j].hasB = 1;\n                }\n                else cd[j].b = 0;\n            }\n            for(; j < cd.length; j++) {\n                cd[j].b = 0;\n            }\n        } else {\n            b = d2c(base, 0, scalendar);\n            var hasBase = isNumeric(b);\n            b = hasBase ? b : 0;\n            for(j = 0; j < cd.length; j++) {\n                cd[j].b = b;\n                if(hasBase) cd[j].hasB = 1;\n            }\n        }\n    }\n}\n\nfunction setGroupPositionsInOverlayMode(gd, pa, sa, calcTraces) {\n    var barnorm = gd._fullLayout.barnorm;\n    var separateNegativeValues = false;\n    var dontMergeOverlappingData = !barnorm;\n\n    // update position axis and set bar offsets and widths\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var sieve = new Sieve([calcTrace], separateNegativeValues, dontMergeOverlappingData);\n\n        // set bar offsets and widths, and update position axis\n        setOffsetAndWidth(gd, pa, sieve);\n\n        // set bar bases and sizes, and update size axis\n        //\n        // (note that `setGroupPositionsInOverlayMode` handles the case barnorm\n        // is defined, because this function is also invoked for traces that\n        // can't be grouped or stacked)\n        if(barnorm) {\n            sieveBars(gd, sa, sieve);\n            normalizeBars(gd, sa, sieve);\n        } else {\n            setBaseAndTop(gd, sa, sieve);\n        }\n    }\n}\n\nfunction setGroupPositionsInGroupMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout;\n    var barnorm = fullLayout.barnorm;\n    var separateNegativeValues = false;\n    var dontMergeOverlappingData = !barnorm;\n    var sieve = new Sieve(calcTraces, separateNegativeValues, dontMergeOverlappingData);\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidthInGroupMode(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    if(barnorm) {\n        sieveBars(gd, sa, sieve);\n        normalizeBars(gd, sa, sieve);\n    } else {\n        setBaseAndTop(gd, sa, sieve);\n    }\n}\n\nfunction setGroupPositionsInStackOrRelativeMode(gd, pa, sa, calcTraces) {\n    var fullLayout = gd._fullLayout;\n    var barmode = fullLayout.barmode;\n    var stack = barmode === 'stack';\n    var relative = barmode === 'relative';\n    var barnorm = fullLayout.barnorm;\n    var separateNegativeValues = relative;\n    var dontMergeOverlappingData = !(barnorm || stack || relative);\n    var sieve = new Sieve(calcTraces, separateNegativeValues, dontMergeOverlappingData);\n\n    // set bar offsets and widths, and update position axis\n    setOffsetAndWidth(gd, pa, sieve);\n\n    // set bar bases and sizes, and update size axis\n    stackBars(gd, sa, sieve);\n\n    // flag the outmost bar (for text display purposes)\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var isOutmostBar = ((bar.b + bar.s) === sieve.get(bar.p, bar.s));\n                if(isOutmostBar) bar._outmost = true;\n            }\n        }\n    }\n\n    // Note that marking the outmost bars has to be done\n    // before `normalizeBars` changes `bar.b` and `bar.s`.\n    if(barnorm) normalizeBars(gd, sa, sieve);\n}\n\nfunction setOffsetAndWidth(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout;\n    var bargap = fullLayout.bargap;\n    var bargroupgap = fullLayout.bargroupgap || 0;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // set bar offsets and widths\n    var barGroupWidth = minDiff * (1 - bargap);\n    var barWidthPlusGap = barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    // computer bar group center and bar offset\n    var offsetFromCenter = -barWidth / 2;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace offset and width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve);\n}\n\nfunction setOffsetAndWidthInGroupMode(gd, pa, sieve) {\n    var fullLayout = gd._fullLayout;\n    var bargap = fullLayout.bargap;\n    var bargroupgap = fullLayout.bargroupgap || 0;\n    var positions = sieve.positions;\n    var distinctPositions = sieve.distinctPositions;\n    var minDiff = sieve.minDiff;\n    var calcTraces = sieve.traces;\n\n    // if there aren't any overlapping positions,\n    // let them have full width even if mode is group\n    var overlap = (positions.length !== distinctPositions.length);\n\n    var nTraces = calcTraces.length;\n    var barGroupWidth = minDiff * (1 - bargap);\n    var barWidthPlusGap = (overlap) ? barGroupWidth / nTraces : barGroupWidth;\n    var barWidth = barWidthPlusGap * (1 - bargroupgap);\n\n    for(var i = 0; i < nTraces; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n\n        // computer bar group center and bar offset\n        var offsetFromCenter = overlap ?\n            ((2 * i + 1 - nTraces) * barWidthPlusGap - barWidth) / 2 :\n            -barWidth / 2;\n\n        // store bar width and offset for this trace\n        t.barwidth = barWidth;\n        t.poffset = offsetFromCenter;\n        t.bargroupwidth = barGroupWidth;\n        t.bardelta = minDiff;\n    }\n\n    // stack bars that only differ by rounding\n    sieve.binWidth = calcTraces[0][0].t.barwidth / 100;\n\n    // if defined, apply trace width\n    applyAttributes(sieve);\n\n    // store the bar center in each calcdata item\n    setBarCenterAndWidth(gd, pa, sieve);\n\n    // update position axes\n    updatePositionAxis(gd, pa, sieve, overlap);\n}\n\nfunction applyAttributes(sieve) {\n    var calcTraces = sieve.traces;\n    var i, j;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var t = calcTrace0.t;\n        var offset = fullTrace._offset || fullTrace.offset;\n        var initialPoffset = t.poffset;\n        var newPoffset;\n\n        if(isArrayOrTypedArray(offset)) {\n            // if offset is an array, then clone it into t.poffset.\n            newPoffset = Array.prototype.slice.call(offset, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newPoffset.length; j++) {\n                if(!isNumeric(newPoffset[j])) {\n                    newPoffset[j] = initialPoffset;\n                }\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.poffset\n            for(j = newPoffset.length; j < calcTrace.length; j++) {\n                newPoffset.push(initialPoffset);\n            }\n\n            t.poffset = newPoffset;\n        } else if(offset !== undefined) {\n            t.poffset = offset;\n        }\n\n        var width = fullTrace._width || fullTrace.width;\n        var initialBarwidth = t.barwidth;\n\n        if(isArrayOrTypedArray(width)) {\n            // if width is an array, then clone it into t.barwidth.\n            var newBarwidth = Array.prototype.slice.call(width, 0, calcTrace.length);\n\n            // guard against non-numeric items\n            for(j = 0; j < newBarwidth.length; j++) {\n                if(!isNumeric(newBarwidth[j])) newBarwidth[j] = initialBarwidth;\n            }\n\n            // if the length of the array is too short,\n            // then extend it with the initial value of t.barwidth\n            for(j = newBarwidth.length; j < calcTrace.length; j++) {\n                newBarwidth.push(initialBarwidth);\n            }\n\n            t.barwidth = newBarwidth;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                newPoffset = [];\n                for(j = 0; j < calcTrace.length; j++) {\n                    newPoffset.push(\n                        initialPoffset + (initialBarwidth - newBarwidth[j]) / 2\n                    );\n                }\n                t.poffset = newPoffset;\n            }\n        } else if(width !== undefined) {\n            t.barwidth = width;\n\n            // if user didn't set offset,\n            // then correct t.poffset to ensure bars remain centered\n            if(offset === undefined) {\n                t.poffset = initialPoffset + (initialBarwidth - width) / 2;\n            }\n        }\n    }\n}\n\nfunction setBarCenterAndWidth(gd, pa, sieve) {\n    var calcTraces = sieve.traces;\n    var pLetter = getAxisLetter(pa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var t = calcTrace[0].t;\n        var poffset = t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n        var barwidth = t.barwidth;\n        var barwidthIsArray = Array.isArray(barwidth);\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var calcBar = calcTrace[j];\n\n            // store the actual bar width and position, for use by hover\n            var width = calcBar.w = barwidthIsArray ? barwidth[j] : barwidth;\n            calcBar[pLetter] = calcBar.p + (poffsetIsArray ? poffset[j] : poffset) + width / 2;\n        }\n    }\n}\n\nfunction updatePositionAxis(gd, pa, sieve, allowMinDtick) {\n    var calcTraces = sieve.traces;\n    var minDiff = sieve.minDiff;\n    var vpad = minDiff / 2;\n\n    Axes.minDtick(pa, sieve.minDiff, sieve.distinctPositions[0], allowMinDtick);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var calcTrace0 = calcTrace[0];\n        var fullTrace = calcTrace0.trace;\n        var pts = [];\n        var bar, l, r, j;\n\n        for(j = 0; j < calcTrace.length; j++) {\n            bar = calcTrace[j];\n            l = bar.p - vpad;\n            r = bar.p + vpad;\n            pts.push(l, r);\n        }\n\n        if(fullTrace.width || fullTrace.offset) {\n            var t = calcTrace0.t;\n            var poffset = t.poffset;\n            var barwidth = t.barwidth;\n            var poffsetIsArray = Array.isArray(poffset);\n            var barwidthIsArray = Array.isArray(barwidth);\n\n            for(j = 0; j < calcTrace.length; j++) {\n                bar = calcTrace[j];\n                var calcBarOffset = poffsetIsArray ? poffset[j] : poffset;\n                var calcBarWidth = barwidthIsArray ? barwidth[j] : barwidth;\n                l = bar.p + calcBarOffset;\n                r = l + calcBarWidth;\n                pts.push(l, r);\n            }\n        }\n\n        fullTrace._extremes[pa._id] = Axes.findExtremes(pa, pts, {padded: false});\n    }\n}\n\n// store these bar bases and tops in calcdata\n// and make sure the size axis includes zero,\n// along with the bases and tops of each bar.\nfunction setBaseAndTop(gd, sa, sieve) {\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var allBarBaseAboveZero = true;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n            var barBase = bar.b;\n            var barTop = barBase + bar.s;\n\n            bar[sLetter] = barTop;\n            pts.push(barTop);\n            if(bar.hasB) pts.push(barBase);\n\n            if(!bar.hasB || !(bar.b > 0 && bar.s > 0)) {\n                allBarBaseAboveZero = false;\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: !allBarBaseAboveZero,\n            padded: true\n        });\n    }\n}\n\nfunction stackBars(gd, sa, sieve) {\n    var fullLayout = gd._fullLayout;\n    var barnorm = fullLayout.barnorm;\n    var sLetter = getAxisLetter(sa);\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                // stack current bar and get previous sum\n                var barBase = sieve.put(bar.p, bar.b + bar.s);\n                var barTop = barBase + bar.b + bar.s;\n\n                // store the bar base and top in each calcdata item\n                bar.b = barBase;\n                bar[sLetter] = barTop;\n\n                if(!barnorm) {\n                    pts.push(barTop);\n                    if(bar.hasB) pts.push(barBase);\n                }\n            }\n        }\n\n        // if barnorm is set, let normalizeBars update the axis range\n        if(!barnorm) {\n            fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n                // N.B. we don't stack base with 'base',\n                // so set tozero:true always!\n                tozero: true,\n                padded: true\n            });\n        }\n    }\n}\n\nfunction sieveBars(gd, sa, sieve) {\n    var calcTraces = sieve.traces;\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) sieve.put(bar.p, bar.b + bar.s);\n        }\n    }\n}\n\n// Note:\n//\n// normalizeBars requires that either sieveBars or stackBars has been\n// previously invoked.\nfunction normalizeBars(gd, sa, sieve) {\n    var fullLayout = gd._fullLayout;\n    var calcTraces = sieve.traces;\n    var sLetter = getAxisLetter(sa);\n    var sTop = fullLayout.barnorm === 'fraction' ? 1 : 100;\n    var sTiny = sTop / 1e9; // in case of rounding error in sum\n    var sMin = sa.l2c(sa.c2l(0));\n    var sMax = fullLayout.barmode === 'stack' ? sTop : sMin;\n\n    function needsPadding(v) {\n        return (\n            isNumeric(sa.c2l(v)) &&\n            ((v < sMin - sTiny) || (v > sMax + sTiny) || !isNumeric(sMin))\n        );\n    }\n\n    for(var i = 0; i < calcTraces.length; i++) {\n        var calcTrace = calcTraces[i];\n        var fullTrace = calcTrace[0].trace;\n        var pts = [];\n        var allBarBaseAboveZero = true;\n        var padded = false;\n\n        for(var j = 0; j < calcTrace.length; j++) {\n            var bar = calcTrace[j];\n\n            if(bar.s !== BADNUM) {\n                var scale = Math.abs(sTop / sieve.get(bar.p, bar.s));\n                bar.b *= scale;\n                bar.s *= scale;\n\n                var barBase = bar.b;\n                var barTop = barBase + bar.s;\n\n                bar[sLetter] = barTop;\n                pts.push(barTop);\n                padded = padded || needsPadding(barTop);\n\n                if(bar.hasB) {\n                    pts.push(barBase);\n                    padded = padded || needsPadding(barBase);\n                }\n\n                if(!bar.hasB || !(bar.b > 0 && bar.s > 0)) {\n                    allBarBaseAboveZero = false;\n                }\n            }\n        }\n\n        fullTrace._extremes[sa._id] = Axes.findExtremes(sa, pts, {\n            tozero: !allBarBaseAboveZero,\n            padded: padded\n        });\n    }\n}\n\n// find the full position span of bars at each position\n// for use by hover, to ensure labels move in if bars are\n// narrower than the space they're in.\n// run once per trace group (subplot & direction) and\n// the same mapping is attached to all calcdata traces\nfunction collectExtents(calcTraces, pa) {\n    var pLetter = getAxisLetter(pa);\n    var extents = {};\n    var i, j, cd;\n\n    var pMin = Infinity;\n    var pMax = -Infinity;\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        for(j = 0; j < cd.length; j++) {\n            var p = cd[j].p;\n            if(isNumeric(p)) {\n                pMin = Math.min(pMin, p);\n                pMax = Math.max(pMax, p);\n            }\n        }\n    }\n\n    // this is just for positioning of hover labels, and nobody will care if\n    // the label is 1px too far out; so round positions to 1/10K in case\n    // position values don't exactly match from trace to trace\n    var roundFactor = 10000 / (pMax - pMin);\n    var round = extents.round = function(p) {\n        return String(Math.round(roundFactor * (p - pMin)));\n    };\n\n    for(i = 0; i < calcTraces.length; i++) {\n        cd = calcTraces[i];\n        cd[0].t.extents = extents;\n\n        var poffset = cd[0].t.poffset;\n        var poffsetIsArray = Array.isArray(poffset);\n\n        for(j = 0; j < cd.length; j++) {\n            var di = cd[j];\n            var p0 = di[pLetter] - di.w / 2;\n\n            if(isNumeric(p0)) {\n                var p1 = di[pLetter] + di.w / 2;\n                var pVal = round(di.p);\n                if(extents[pVal]) {\n                    extents[pVal] = [Math.min(p0, extents[pVal][0]), Math.max(p1, extents[pVal][1])];\n                } else {\n                    extents[pVal] = [p0, p1];\n                }\n            }\n\n            di.p0 = di.p + (poffsetIsArray ? poffset[j] : poffset);\n            di.p1 = di.p0 + di.w;\n            di.s0 = di.b;\n            di.s1 = di.s0 + di.s;\n        }\n    }\n}\n\nfunction getAxisLetter(ax) {\n    return ax._id.charAt(0);\n}\n\nmodule.exports = {\n    crossTraceCalc: crossTraceCalc,\n    setGroupPositions: setGroupPositions\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}