{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n  draw: draw,\n  drawOne: drawOne,\n  drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n  var fullLayout = gd._fullLayout;\n  fullLayout._infolayer.selectAll('.annotation').remove();\n  for (var i = 0; i < fullLayout.annotations.length; i++) {\n    if (fullLayout.annotations[i].visible) {\n      drawOne(gd, i);\n    }\n  }\n  return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n  var fullLayout = gd._fullLayout;\n  var options = fullLayout.annotations[index] || {};\n  var xa = Axes.getFromId(gd, options.xref);\n  var ya = Axes.getFromId(gd, options.yref);\n  if (xa) xa.setScale();\n  if (ya) ya.setScale();\n  drawRaw(gd, options, index, false, xa, ya);\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n  var fullLayout = gd._fullLayout;\n  var gs = gd._fullLayout._size;\n  var edits = gd._context.edits;\n  var className, containerStr;\n  if (subplotId) {\n    className = 'annotation-' + subplotId;\n    containerStr = subplotId + '.annotations';\n  } else {\n    className = 'annotation';\n    containerStr = 'annotations';\n  }\n  var editHelpers = arrayEditor(gd.layout, containerStr, options);\n  var modifyBase = editHelpers.modifyBase;\n  var modifyItem = editHelpers.modifyItem;\n  var getUpdateObj = editHelpers.getUpdateObj;\n\n  // remove the existing annotation if there is one\n  fullLayout._infolayer.selectAll('.' + className + '[data-index=\"' + index + '\"]').remove();\n  var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n  // this annotation is gone - quit now after deleting it\n  // TODO: use d3 idioms instead of deleting and redrawing every time\n  if (!options._input || options.visible === false) {\n    d3.selectAll('#' + annClipID).remove();\n    return;\n  }\n\n  // calculated pixel positions\n  // x & y each will get text, head, and tail as appropriate\n  var annPosPx = {\n    x: {},\n    y: {}\n  };\n  var textangle = +options.textangle || 0;\n\n  // create the components\n  // made a single group to contain all, so opacity can work right\n  // with border/arrow together this could handle a whole bunch of\n  // cleanup at this point, but works for now\n  var annGroup = fullLayout._infolayer.append('g').classed(className, true).attr('data-index', String(index)).style('opacity', options.opacity);\n\n  // another group for text+background so that they can rotate together\n  var annTextGroup = annGroup.append('g').classed('annotation-text-g', true);\n  var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n  var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n  var annTextGroupInner = annTextGroup.append('g').style('pointer-events', textEvents ? 'all' : null).call(setCursor, 'pointer').on('click', function () {\n    gd._dragging = false;\n    var eventData = {\n      index: index,\n      annotation: options._input,\n      fullAnnotation: options,\n      event: d3.event\n    };\n    if (subplotId) {\n      eventData.subplotId = subplotId;\n    }\n    gd.emit('plotly_clickannotation', eventData);\n  });\n  if (options.hovertext) {\n    annTextGroupInner.on('mouseover', function () {\n      var hoverOptions = options.hoverlabel;\n      var hoverFont = hoverOptions.font;\n      var bBox = this.getBoundingClientRect();\n      var bBoxRef = gd.getBoundingClientRect();\n      Fx.loneHover({\n        x0: bBox.left - bBoxRef.left,\n        x1: bBox.right - bBoxRef.left,\n        y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n        text: options.hovertext,\n        color: hoverOptions.bgcolor,\n        borderColor: hoverOptions.bordercolor,\n        fontFamily: hoverFont.family,\n        fontSize: hoverFont.size,\n        fontColor: hoverFont.color\n      }, {\n        container: fullLayout._hoverlayer.node(),\n        outerContainer: fullLayout._paper.node(),\n        gd: gd\n      });\n    }).on('mouseout', function () {\n      Fx.loneUnhover(fullLayout._hoverlayer.node());\n    });\n  }\n  var borderwidth = options.borderwidth;\n  var borderpad = options.borderpad;\n  var borderfull = borderwidth + borderpad;\n  var annTextBG = annTextGroupInner.append('rect').attr('class', 'bg').style('stroke-width', borderwidth + 'px').call(Color.stroke, options.bordercolor).call(Color.fill, options.bgcolor);\n  var isSizeConstrained = options.width || options.height;\n  var annTextClip = fullLayout._topclips.selectAll('#' + annClipID).data(isSizeConstrained ? [0] : []);\n  annTextClip.enter().append('clipPath').classed('annclip', true).attr('id', annClipID).append('rect');\n  annTextClip.exit().remove();\n  var font = options.font;\n  var text = fullLayout.meta ? Lib.templateString(options.text, {\n    meta: fullLayout.meta\n  }) : options.text;\n  var annText = annTextGroupInner.append('text').classed('annotation-text', true).text(text);\n  function textLayout(s) {\n    s.call(Drawing.font, font).attr({\n      'text-anchor': {\n        left: 'start',\n        right: 'end'\n      }[options.align] || 'middle'\n    });\n    svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n    return s;\n  }\n  function drawGraphicalElements() {\n    // if the text has *only* a link, make the whole box into a link\n    var anchor3 = annText.selectAll('a');\n    if (anchor3.size() === 1 && anchor3.text() === annText.text()) {\n      var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n        'xlink:xlink:href': anchor3.attr('xlink:href'),\n        'xlink:xlink:show': anchor3.attr('xlink:show')\n      }).style({\n        cursor: 'pointer'\n      });\n      wholeLink.node().appendChild(annTextBG.node());\n    }\n    var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n    var hasMathjax = !mathjaxGroup.empty();\n    var anntextBB = Drawing.bBox((hasMathjax ? mathjaxGroup : annText).node());\n    var textWidth = anntextBB.width;\n    var textHeight = anntextBB.height;\n    var annWidth = options.width || textWidth;\n    var annHeight = options.height || textHeight;\n    var outerWidth = Math.round(annWidth + 2 * borderfull);\n    var outerHeight = Math.round(annHeight + 2 * borderfull);\n    function shiftFraction(v, anchor) {\n      if (anchor === 'auto') {\n        if (v < 1 / 3) anchor = 'left';else if (v > 2 / 3) anchor = 'right';else anchor = 'center';\n      }\n      return {\n        center: 0,\n        middle: 0,\n        left: 0.5,\n        bottom: -0.5,\n        right: -0.5,\n        top: 0.5\n      }[anchor];\n    }\n    var annotationIsOffscreen = false;\n    var letters = ['x', 'y'];\n    for (var i = 0; i < letters.length; i++) {\n      var axLetter = letters[i];\n      var axRef = options[axLetter + 'ref'] || axLetter;\n      var tailRef = options['a' + axLetter + 'ref'];\n      var ax = {\n        x: xa,\n        y: ya\n      }[axLetter];\n      var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n      // note that these two can be either positive or negative\n      var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n      var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n      // but this one is the positive total size\n      var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n      var anchor = options[axLetter + 'anchor'];\n      var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n      var posPx = annPosPx[axLetter];\n      var basePx;\n      var textPadShift;\n      var alignPosition;\n      var autoAlignFraction;\n      var textShift;\n\n      /*\n       * calculate the *primary* pixel position\n       * which is the arrowhead if there is one,\n       * otherwise the text anchor point\n       */\n      if (ax) {\n        // check if annotation is off screen, to bypass DOM manipulations\n        var posFraction = ax.r2fraction(options[axLetter]);\n        if (posFraction < 0 || posFraction > 1) {\n          if (tailRef === axRef) {\n            posFraction = ax.r2fraction(options['a' + axLetter]);\n            if (posFraction < 0 || posFraction > 1) {\n              annotationIsOffscreen = true;\n            }\n          } else {\n            annotationIsOffscreen = true;\n          }\n        }\n        basePx = ax._offset + ax.r2p(options[axLetter]);\n        autoAlignFraction = 0.5;\n      } else {\n        if (axLetter === 'x') {\n          alignPosition = options[axLetter];\n          basePx = gs.l + gs.w * alignPosition;\n        } else {\n          alignPosition = 1 - options[axLetter];\n          basePx = gs.t + gs.h * alignPosition;\n        }\n        autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n      }\n\n      // now translate this into pixel positions of head, tail, and text\n      // as well as paddings for autorange\n      if (options.showarrow) {\n        posPx.head = basePx;\n        var arrowLength = options['a' + axLetter];\n\n        // with an arrow, the text rotates around the anchor point\n        textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) - annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n        if (tailRef === axRef) {\n          posPx.tail = ax._offset + ax.r2p(arrowLength);\n          // tail is data-referenced: autorange pads the text in px from the tail\n          textPadShift = textShift;\n        } else {\n          posPx.tail = basePx + arrowLength;\n          // tail is specified in px from head, so autorange also pads vs head\n          textPadShift = textShift + arrowLength;\n        }\n        posPx.text = posPx.tail + textShift;\n\n        // constrain pixel/paper referenced so the draggers are at least\n        // partially visible\n        var maxPx = fullLayout[axLetter === 'x' ? 'width' : 'height'];\n        if (axRef === 'paper') {\n          posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n        }\n        if (tailRef === 'pixel') {\n          var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n          var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n          if (shiftPlus > 0) {\n            posPx.tail += shiftPlus;\n            posPx.text += shiftPlus;\n          } else if (shiftMinus > 0) {\n            posPx.tail -= shiftMinus;\n            posPx.text -= shiftMinus;\n          }\n        }\n        posPx.tail += overallShift;\n        posPx.head += overallShift;\n      } else {\n        // with no arrow, the text rotates and *then* we put the anchor\n        // relative to the new bounding box\n        textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n        textPadShift = textShift;\n        posPx.text = basePx + textShift;\n      }\n      posPx.text += overallShift;\n      textShift += overallShift;\n      textPadShift += overallShift;\n\n      // padplus/minus are used by autorange\n      options['_' + axLetter + 'padplus'] = annSize / 2 + textPadShift;\n      options['_' + axLetter + 'padminus'] = annSize / 2 - textPadShift;\n\n      // size/shift are used during dragging\n      options['_' + axLetter + 'size'] = annSize;\n      options['_' + axLetter + 'shift'] = textShift;\n    }\n\n    // We have everything we need for calcAutorange at this point,\n    // we can safely exit - unless we're currently dragging the plot\n    if (!gd._dragging && annotationIsOffscreen) {\n      annTextGroupInner.remove();\n      return;\n    }\n    var xShift = 0;\n    var yShift = 0;\n    if (options.align !== 'left') {\n      xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n    }\n    if (options.valign !== 'top') {\n      yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n    }\n    if (hasMathjax) {\n      mathjaxGroup.select('svg').attr({\n        x: borderfull + xShift - 1,\n        y: borderfull + yShift\n      }).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    } else {\n      var texty = borderfull + yShift - anntextBB.top;\n      var textx = borderfull + xShift - anntextBB.left;\n      annText.call(svgTextUtils.positionText, textx, texty).call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n    }\n    annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull, annWidth, annHeight);\n    annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2, outerWidth - borderwidth, outerHeight - borderwidth);\n    annTextGroupInner.call(Drawing.setTranslate, Math.round(annPosPx.x.text - outerWidth / 2), Math.round(annPosPx.y.text - outerHeight / 2));\n\n    /*\n     * rotate text and background\n     * we already calculated the text center position *as rotated*\n     * because we needed that for autoranging anyway, so now whether\n     * we have an arrow or not, we rotate about the text center.\n     */\n    annTextGroup.attr({\n      transform: 'rotate(' + textangle + ',' + annPosPx.x.text + ',' + annPosPx.y.text + ')'\n    });\n\n    /*\n     * add the arrow\n     * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n     * dx and dy are normally zero, but when you are dragging the textbox\n     * while the head stays put, dx and dy are the pixel offsets\n     */\n    var drawArrow = function drawArrow(dx, dy) {\n      annGroup.selectAll('.annotation-arrow-g').remove();\n      var headX = annPosPx.x.head;\n      var headY = annPosPx.y.head;\n      var tailX = annPosPx.x.tail + dx;\n      var tailY = annPosPx.y.tail + dy;\n      var textX = annPosPx.x.text + dx;\n      var textY = annPosPx.y.text + dy;\n\n      // find the edge of the text box, where we'll start the arrow:\n      // create transform matrix to rotate the text box corners\n      var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n      var applyTransform = Lib.apply2DTransform(transform);\n      var applyTransform2 = Lib.apply2DTransform2(transform);\n\n      // calculate and transform bounding box\n      var width = +annTextBG.attr('width');\n      var height = +annTextBG.attr('height');\n      var xLeft = textX - 0.5 * width;\n      var xRight = xLeft + width;\n      var yTop = textY - 0.5 * height;\n      var yBottom = yTop + height;\n      var edges = [[xLeft, yTop, xLeft, yBottom], [xLeft, yBottom, xRight, yBottom], [xRight, yBottom, xRight, yTop], [xRight, yTop, xLeft, yTop]].map(applyTransform2);\n\n      // Remove the line if it ends inside the box.  Use ray\n      // casting for rotated boxes: see which edges intersect a\n      // line from the arrowhead to far away and reduce with xor\n      // to get the parity of the number of intersections.\n      if (edges.reduce(function (a, x) {\n        return a ^ !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6, x[0], x[1], x[2], x[3]);\n      }, false)) {\n        // no line or arrow - so quit drawArrow now\n        return;\n      }\n      edges.forEach(function (x) {\n        var p = Lib.segmentsIntersect(tailX, tailY, headX, headY, x[0], x[1], x[2], x[3]);\n        if (p) {\n          tailX = p.x;\n          tailY = p.y;\n        }\n      });\n      var strokewidth = options.arrowwidth;\n      var arrowColor = options.arrowcolor;\n      var arrowSide = options.arrowside;\n      var arrowGroup = annGroup.append('g').style({\n        opacity: Color.opacity(arrowColor)\n      }).classed('annotation-arrow-g', true);\n      var arrow = arrowGroup.append('path').attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY).style('stroke-width', strokewidth + 'px').call(Color.stroke, Color.rgb(arrowColor));\n      drawArrowHead(arrow, arrowSide, options);\n\n      // the arrow dragger is a small square right at the head, then a line to the tail,\n      // all expanded by a stroke width of 6px plus the arrow line width\n      if (edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n        var arrowDragHeadX = headX;\n        var arrowDragHeadY = headY;\n        if (options.standoff) {\n          var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n          arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n          arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n        }\n        var arrowDrag = arrowGroup.append('path').classed('annotation-arrow', true).classed('anndrag', true).classed('cursor-move', true).attr({\n          d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n          transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n        }).style('stroke-width', strokewidth + 6 + 'px').call(Color.stroke, 'rgba(0,0,0,0)').call(Color.fill, 'rgba(0,0,0,0)');\n        var annx0, anny0;\n\n        // dragger for the arrow & head: translates the whole thing\n        // (head/tail/text) all together\n        dragElement.init({\n          element: arrowDrag.node(),\n          gd: gd,\n          prepFn: function prepFn() {\n            var pos = Drawing.getTranslate(annTextGroupInner);\n            annx0 = pos.x;\n            anny0 = pos.y;\n            if (xa && xa.autorange) {\n              modifyBase(xa._name + '.autorange', true);\n            }\n            if (ya && ya.autorange) {\n              modifyBase(ya._name + '.autorange', true);\n            }\n          },\n          moveFn: function moveFn(dx, dy) {\n            var annxy0 = applyTransform(annx0, anny0);\n            var xcenter = annxy0[0] + dx;\n            var ycenter = annxy0[1] + dy;\n            annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n            modifyItem('x', xa ? xa.p2r(xa.r2p(options.x) + dx) : options.x + dx / gs.w);\n            modifyItem('y', ya ? ya.p2r(ya.r2p(options.y) + dy) : options.y - dy / gs.h);\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            }\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            }\n            arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n            annTextGroup.attr({\n              transform: 'rotate(' + textangle + ',' + xcenter + ',' + ycenter + ')'\n            });\n          },\n          doneFn: function doneFn() {\n            Registry.call('_guiRelayout', gd, getUpdateObj());\n            var notesBox = document.querySelector('.js-notes-box-panel');\n            if (notesBox) notesBox.redraw(notesBox.selectedObj);\n          }\n        });\n      }\n    };\n    if (options.showarrow) drawArrow(0, 0);\n\n    // user dragging the annotation (text, not arrow)\n    if (editTextPosition) {\n      var baseTextTransform;\n\n      // dragger for the textbox: if there's an arrow, just drag the\n      // textbox and tail, leave the head untouched\n      dragElement.init({\n        element: annTextGroupInner.node(),\n        gd: gd,\n        prepFn: function prepFn() {\n          baseTextTransform = annTextGroup.attr('transform');\n        },\n        moveFn: function moveFn(dx, dy) {\n          var csr = 'pointer';\n          if (options.showarrow) {\n            if (options.axref === options.xref) {\n              modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n            } else {\n              modifyItem('ax', options.ax + dx);\n            }\n            if (options.ayref === options.yref) {\n              modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n            } else {\n              modifyItem('ay', options.ay + dy);\n            }\n            drawArrow(dx, dy);\n          } else if (!subplotId) {\n            var xUpdate, yUpdate;\n            if (xa) {\n              xUpdate = xa.p2r(xa.r2p(options.x) + dx);\n            } else {\n              var widthFraction = options._xsize / gs.w;\n              var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n              xUpdate = dragElement.align(xLeft + dx / gs.w, widthFraction, 0, 1, options.xanchor);\n            }\n            if (ya) {\n              yUpdate = ya.p2r(ya.r2p(options.y) + dy);\n            } else {\n              var heightFraction = options._ysize / gs.h;\n              var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n              yUpdate = dragElement.align(yBottom - dy / gs.h, heightFraction, 0, 1, options.yanchor);\n            }\n            modifyItem('x', xUpdate);\n            modifyItem('y', yUpdate);\n            if (!xa || !ya) {\n              csr = dragElement.getCursor(xa ? 0.5 : xUpdate, ya ? 0.5 : yUpdate, options.xanchor, options.yanchor);\n            }\n          } else return;\n          annTextGroup.attr({\n            transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n          });\n          setCursor(annTextGroupInner, csr);\n        },\n        doneFn: function doneFn() {\n          setCursor(annTextGroupInner);\n          Registry.call('_guiRelayout', gd, getUpdateObj());\n          var notesBox = document.querySelector('.js-notes-box-panel');\n          if (notesBox) notesBox.redraw(notesBox.selectedObj);\n        }\n      });\n    }\n  }\n  if (edits.annotationText) {\n    annText.call(svgTextUtils.makeEditable, {\n      delegate: annTextGroupInner,\n      gd: gd\n    }).call(textLayout).on('edit', function (_text) {\n      options.text = _text;\n      this.call(textLayout);\n      modifyItem('text', _text);\n      if (xa && xa.autorange) {\n        modifyBase(xa._name + '.autorange', true);\n      }\n      if (ya && ya.autorange) {\n        modifyBase(ya._name + '.autorange', true);\n      }\n      Registry.call('_guiRelayout', gd, getUpdateObj());\n    });\n  } else annText.call(textLayout);\n}","map":{"version":3,"names":["d3","require","Registry","Plots","Lib","Axes","Color","Drawing","Fx","svgTextUtils","setCursor","dragElement","arrayEditor","drawArrowHead","module","exports","draw","drawOne","drawRaw","gd","fullLayout","_fullLayout","_infolayer","selectAll","remove","i","annotations","length","visible","previousPromises","index","options","xa","getFromId","xref","ya","yref","setScale","subplotId","gs","_size","edits","_context","className","containerStr","editHelpers","layout","modifyBase","modifyItem","getUpdateObj","annClipID","_uid","_input","annPosPx","x","y","textangle","annGroup","append","classed","attr","String","style","opacity","annTextGroup","editTextPosition","showarrow","textEvents","captureevents","annotationText","annTextGroupInner","call","on","_dragging","eventData","annotation","fullAnnotation","event","emit","hovertext","hoverOptions","hoverlabel","hoverFont","font","bBox","getBoundingClientRect","bBoxRef","loneHover","x0","left","x1","right","top","bottom","text","color","bgcolor","borderColor","bordercolor","fontFamily","family","fontSize","size","fontColor","container","_hoverlayer","node","outerContainer","_paper","loneUnhover","borderwidth","borderpad","borderfull","annTextBG","stroke","fill","isSizeConstrained","width","height","annTextClip","_topclips","data","enter","exit","meta","templateString","annText","textLayout","s","align","convertToTspans","drawGraphicalElements","anchor3","wholeLink","insert","cursor","appendChild","mathjaxGroup","select","hasMathjax","empty","anntextBB","textWidth","textHeight","annWidth","annHeight","outerWidth","Math","round","outerHeight","shiftFraction","v","anchor","center","middle","annotationIsOffscreen","letters","axLetter","axRef","tailRef","ax","dimAngle","PI","annSizeFromWidth","cos","annSizeFromHeight","sin","annSize","abs","overallShift","posPx","basePx","textPadShift","alignPosition","autoAlignFraction","textShift","posFraction","r2fraction","_offset","r2p","l","w","t","h","head","arrowLength","xanchor","yanchor","tail","maxPx","constrain","shiftPlus","max","shiftMinus","min","xShift","yShift","valign","setClipUrl","texty","textx","positionText","setRect","setTranslate","transform","drawArrow","dx","dy","headX","headY","tailX","tailY","textX","textY","rotationXYMatrix","applyTransform","apply2DTransform","applyTransform2","apply2DTransform2","xLeft","xRight","yTop","yBottom","edges","map","reduce","a","segmentsIntersect","forEach","p","strokewidth","arrowwidth","arrowColor","arrowcolor","arrowSide","arrowside","arrowGroup","arrow","rgb","annotationPosition","parentNode","arrowDragHeadX","arrowDragHeadY","standoff","sqrt","pow","arrowDrag","d","annx0","anny0","init","element","prepFn","pos","getTranslate","autorange","_name","moveFn","annxy0","xcenter","ycenter","p2r","axref","ayref","ay","doneFn","notesBox","document","querySelector","redraw","selectedObj","baseTextTransform","csr","xUpdate","yUpdate","widthFraction","_xsize","_xshift","xshift","heightFraction","_ysize","_yshift","yshift","getCursor","makeEditable","delegate","_text"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/components/annotations/draw.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Plots = require('../../plots/plots');\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar Color = require('../color');\nvar Drawing = require('../drawing');\nvar Fx = require('../fx');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar setCursor = require('../../lib/setcursor');\nvar dragElement = require('../dragelement');\nvar arrayEditor = require('../../plot_api/plot_template').arrayEditor;\n\nvar drawArrowHead = require('./draw_arrow_head');\n\n// Annotations are stored in gd.layout.annotations, an array of objects\n// index can point to one item in this array,\n//  or non-numeric to simply add a new one\n//  or -1 to modify all existing\n// opt can be the full options object, or one key (to be set to value)\n//  or undefined to simply redraw\n// if opt is blank, val can be 'add' or a full options object to add a new\n//  annotation at that point in the array, or 'remove' to delete this one\n\nmodule.exports = {\n    draw: draw,\n    drawOne: drawOne,\n    drawRaw: drawRaw\n};\n\n/*\n * draw: draw all annotations without any new modifications\n */\nfunction draw(gd) {\n    var fullLayout = gd._fullLayout;\n\n    fullLayout._infolayer.selectAll('.annotation').remove();\n\n    for(var i = 0; i < fullLayout.annotations.length; i++) {\n        if(fullLayout.annotations[i].visible) {\n            drawOne(gd, i);\n        }\n    }\n\n    return Plots.previousPromises(gd);\n}\n\n/*\n * drawOne: draw a single cartesian or paper-ref annotation, potentially with modifications\n *\n * index (int): the annotation to draw\n */\nfunction drawOne(gd, index) {\n    var fullLayout = gd._fullLayout;\n    var options = fullLayout.annotations[index] || {};\n    var xa = Axes.getFromId(gd, options.xref);\n    var ya = Axes.getFromId(gd, options.yref);\n\n    if(xa) xa.setScale();\n    if(ya) ya.setScale();\n\n    drawRaw(gd, options, index, false, xa, ya);\n}\n\n/**\n * drawRaw: draw a single annotation, potentially with modifications\n *\n * @param {DOM element} gd\n * @param {object} options : this annotation's fullLayout options\n * @param {integer} index : index in 'annotations' container of the annotation to draw\n * @param {string} subplotId : id of the annotation's subplot\n *  - use false for 2d (i.e. cartesian or paper-ref) annotations\n * @param {object | undefined} xa : full x-axis object to compute subplot pos-to-px\n * @param {object | undefined} ya : ... y-axis\n */\nfunction drawRaw(gd, options, index, subplotId, xa, ya) {\n    var fullLayout = gd._fullLayout;\n    var gs = gd._fullLayout._size;\n    var edits = gd._context.edits;\n\n    var className, containerStr;\n\n    if(subplotId) {\n        className = 'annotation-' + subplotId;\n        containerStr = subplotId + '.annotations';\n    } else {\n        className = 'annotation';\n        containerStr = 'annotations';\n    }\n\n    var editHelpers = arrayEditor(gd.layout, containerStr, options);\n    var modifyBase = editHelpers.modifyBase;\n    var modifyItem = editHelpers.modifyItem;\n    var getUpdateObj = editHelpers.getUpdateObj;\n\n    // remove the existing annotation if there is one\n    fullLayout._infolayer\n        .selectAll('.' + className + '[data-index=\"' + index + '\"]')\n        .remove();\n\n    var annClipID = 'clip' + fullLayout._uid + '_ann' + index;\n\n    // this annotation is gone - quit now after deleting it\n    // TODO: use d3 idioms instead of deleting and redrawing every time\n    if(!options._input || options.visible === false) {\n        d3.selectAll('#' + annClipID).remove();\n        return;\n    }\n\n    // calculated pixel positions\n    // x & y each will get text, head, and tail as appropriate\n    var annPosPx = {x: {}, y: {}};\n    var textangle = +options.textangle || 0;\n\n    // create the components\n    // made a single group to contain all, so opacity can work right\n    // with border/arrow together this could handle a whole bunch of\n    // cleanup at this point, but works for now\n    var annGroup = fullLayout._infolayer.append('g')\n        .classed(className, true)\n        .attr('data-index', String(index))\n        .style('opacity', options.opacity);\n\n    // another group for text+background so that they can rotate together\n    var annTextGroup = annGroup.append('g')\n        .classed('annotation-text-g', true);\n\n    var editTextPosition = edits[options.showarrow ? 'annotationTail' : 'annotationPosition'];\n    var textEvents = options.captureevents || edits.annotationText || editTextPosition;\n\n    var annTextGroupInner = annTextGroup.append('g')\n        .style('pointer-events', textEvents ? 'all' : null)\n        .call(setCursor, 'pointer')\n        .on('click', function() {\n            gd._dragging = false;\n\n            var eventData = {\n                index: index,\n                annotation: options._input,\n                fullAnnotation: options,\n                event: d3.event\n            };\n\n            if(subplotId) {\n                eventData.subplotId = subplotId;\n            }\n\n            gd.emit('plotly_clickannotation', eventData);\n        });\n\n    if(options.hovertext) {\n        annTextGroupInner\n        .on('mouseover', function() {\n            var hoverOptions = options.hoverlabel;\n            var hoverFont = hoverOptions.font;\n            var bBox = this.getBoundingClientRect();\n            var bBoxRef = gd.getBoundingClientRect();\n\n            Fx.loneHover({\n                x0: bBox.left - bBoxRef.left,\n                x1: bBox.right - bBoxRef.left,\n                y: (bBox.top + bBox.bottom) / 2 - bBoxRef.top,\n                text: options.hovertext,\n                color: hoverOptions.bgcolor,\n                borderColor: hoverOptions.bordercolor,\n                fontFamily: hoverFont.family,\n                fontSize: hoverFont.size,\n                fontColor: hoverFont.color\n            }, {\n                container: fullLayout._hoverlayer.node(),\n                outerContainer: fullLayout._paper.node(),\n                gd: gd\n            });\n        })\n        .on('mouseout', function() {\n            Fx.loneUnhover(fullLayout._hoverlayer.node());\n        });\n    }\n\n    var borderwidth = options.borderwidth;\n    var borderpad = options.borderpad;\n    var borderfull = borderwidth + borderpad;\n\n    var annTextBG = annTextGroupInner.append('rect')\n        .attr('class', 'bg')\n        .style('stroke-width', borderwidth + 'px')\n        .call(Color.stroke, options.bordercolor)\n        .call(Color.fill, options.bgcolor);\n\n    var isSizeConstrained = options.width || options.height;\n\n    var annTextClip = fullLayout._topclips\n        .selectAll('#' + annClipID)\n        .data(isSizeConstrained ? [0] : []);\n\n    annTextClip.enter().append('clipPath')\n        .classed('annclip', true)\n        .attr('id', annClipID)\n      .append('rect');\n    annTextClip.exit().remove();\n\n    var font = options.font;\n\n    var text = fullLayout.meta ?\n        Lib.templateString(options.text, {meta: fullLayout.meta}) :\n        options.text;\n\n    var annText = annTextGroupInner.append('text')\n        .classed('annotation-text', true)\n        .text(text);\n\n    function textLayout(s) {\n        s.call(Drawing.font, font)\n        .attr({\n            'text-anchor': {\n                left: 'start',\n                right: 'end'\n            }[options.align] || 'middle'\n        });\n\n        svgTextUtils.convertToTspans(s, gd, drawGraphicalElements);\n        return s;\n    }\n\n    function drawGraphicalElements() {\n        // if the text has *only* a link, make the whole box into a link\n        var anchor3 = annText.selectAll('a');\n        if(anchor3.size() === 1 && anchor3.text() === annText.text()) {\n            var wholeLink = annTextGroupInner.insert('a', ':first-child').attr({\n                'xlink:xlink:href': anchor3.attr('xlink:href'),\n                'xlink:xlink:show': anchor3.attr('xlink:show')\n            })\n            .style({cursor: 'pointer'});\n\n            wholeLink.node().appendChild(annTextBG.node());\n        }\n\n        var mathjaxGroup = annTextGroupInner.select('.annotation-text-math-group');\n        var hasMathjax = !mathjaxGroup.empty();\n        var anntextBB = Drawing.bBox(\n                (hasMathjax ? mathjaxGroup : annText).node());\n        var textWidth = anntextBB.width;\n        var textHeight = anntextBB.height;\n        var annWidth = options.width || textWidth;\n        var annHeight = options.height || textHeight;\n        var outerWidth = Math.round(annWidth + 2 * borderfull);\n        var outerHeight = Math.round(annHeight + 2 * borderfull);\n\n        function shiftFraction(v, anchor) {\n            if(anchor === 'auto') {\n                if(v < 1 / 3) anchor = 'left';\n                else if(v > 2 / 3) anchor = 'right';\n                else anchor = 'center';\n            }\n            return {\n                center: 0,\n                middle: 0,\n                left: 0.5,\n                bottom: -0.5,\n                right: -0.5,\n                top: 0.5\n            }[anchor];\n        }\n\n        var annotationIsOffscreen = false;\n        var letters = ['x', 'y'];\n\n        for(var i = 0; i < letters.length; i++) {\n            var axLetter = letters[i];\n            var axRef = options[axLetter + 'ref'] || axLetter;\n            var tailRef = options['a' + axLetter + 'ref'];\n            var ax = {x: xa, y: ya}[axLetter];\n            var dimAngle = (textangle + (axLetter === 'x' ? 0 : -90)) * Math.PI / 180;\n            // note that these two can be either positive or negative\n            var annSizeFromWidth = outerWidth * Math.cos(dimAngle);\n            var annSizeFromHeight = outerHeight * Math.sin(dimAngle);\n            // but this one is the positive total size\n            var annSize = Math.abs(annSizeFromWidth) + Math.abs(annSizeFromHeight);\n            var anchor = options[axLetter + 'anchor'];\n            var overallShift = options[axLetter + 'shift'] * (axLetter === 'x' ? 1 : -1);\n            var posPx = annPosPx[axLetter];\n            var basePx;\n            var textPadShift;\n            var alignPosition;\n            var autoAlignFraction;\n            var textShift;\n\n            /*\n             * calculate the *primary* pixel position\n             * which is the arrowhead if there is one,\n             * otherwise the text anchor point\n             */\n            if(ax) {\n                // check if annotation is off screen, to bypass DOM manipulations\n                var posFraction = ax.r2fraction(options[axLetter]);\n                if(posFraction < 0 || posFraction > 1) {\n                    if(tailRef === axRef) {\n                        posFraction = ax.r2fraction(options['a' + axLetter]);\n                        if(posFraction < 0 || posFraction > 1) {\n                            annotationIsOffscreen = true;\n                        }\n                    } else {\n                        annotationIsOffscreen = true;\n                    }\n                }\n                basePx = ax._offset + ax.r2p(options[axLetter]);\n                autoAlignFraction = 0.5;\n            }\n            else {\n                if(axLetter === 'x') {\n                    alignPosition = options[axLetter];\n                    basePx = gs.l + gs.w * alignPosition;\n                }\n                else {\n                    alignPosition = 1 - options[axLetter];\n                    basePx = gs.t + gs.h * alignPosition;\n                }\n                autoAlignFraction = options.showarrow ? 0.5 : alignPosition;\n            }\n\n            // now translate this into pixel positions of head, tail, and text\n            // as well as paddings for autorange\n            if(options.showarrow) {\n                posPx.head = basePx;\n\n                var arrowLength = options['a' + axLetter];\n\n                // with an arrow, the text rotates around the anchor point\n                textShift = annSizeFromWidth * shiftFraction(0.5, options.xanchor) -\n                    annSizeFromHeight * shiftFraction(0.5, options.yanchor);\n\n                if(tailRef === axRef) {\n                    posPx.tail = ax._offset + ax.r2p(arrowLength);\n                    // tail is data-referenced: autorange pads the text in px from the tail\n                    textPadShift = textShift;\n                }\n                else {\n                    posPx.tail = basePx + arrowLength;\n                    // tail is specified in px from head, so autorange also pads vs head\n                    textPadShift = textShift + arrowLength;\n                }\n\n                posPx.text = posPx.tail + textShift;\n\n                // constrain pixel/paper referenced so the draggers are at least\n                // partially visible\n                var maxPx = fullLayout[(axLetter === 'x') ? 'width' : 'height'];\n                if(axRef === 'paper') {\n                    posPx.head = Lib.constrain(posPx.head, 1, maxPx - 1);\n                }\n                if(tailRef === 'pixel') {\n                    var shiftPlus = -Math.max(posPx.tail - 3, posPx.text);\n                    var shiftMinus = Math.min(posPx.tail + 3, posPx.text) - maxPx;\n                    if(shiftPlus > 0) {\n                        posPx.tail += shiftPlus;\n                        posPx.text += shiftPlus;\n                    }\n                    else if(shiftMinus > 0) {\n                        posPx.tail -= shiftMinus;\n                        posPx.text -= shiftMinus;\n                    }\n                }\n\n                posPx.tail += overallShift;\n                posPx.head += overallShift;\n            }\n            else {\n                // with no arrow, the text rotates and *then* we put the anchor\n                // relative to the new bounding box\n                textShift = annSize * shiftFraction(autoAlignFraction, anchor);\n                textPadShift = textShift;\n                posPx.text = basePx + textShift;\n            }\n\n            posPx.text += overallShift;\n            textShift += overallShift;\n            textPadShift += overallShift;\n\n            // padplus/minus are used by autorange\n            options['_' + axLetter + 'padplus'] = (annSize / 2) + textPadShift;\n            options['_' + axLetter + 'padminus'] = (annSize / 2) - textPadShift;\n\n            // size/shift are used during dragging\n            options['_' + axLetter + 'size'] = annSize;\n            options['_' + axLetter + 'shift'] = textShift;\n        }\n\n        // We have everything we need for calcAutorange at this point,\n        // we can safely exit - unless we're currently dragging the plot\n        if(!gd._dragging && annotationIsOffscreen) {\n            annTextGroupInner.remove();\n            return;\n        }\n\n        var xShift = 0;\n        var yShift = 0;\n\n        if(options.align !== 'left') {\n            xShift = (annWidth - textWidth) * (options.align === 'center' ? 0.5 : 1);\n        }\n        if(options.valign !== 'top') {\n            yShift = (annHeight - textHeight) * (options.valign === 'middle' ? 0.5 : 1);\n        }\n\n        if(hasMathjax) {\n            mathjaxGroup.select('svg').attr({\n                x: borderfull + xShift - 1,\n                y: borderfull + yShift\n            })\n            .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        }\n        else {\n            var texty = borderfull + yShift - anntextBB.top;\n            var textx = borderfull + xShift - anntextBB.left;\n\n            annText.call(svgTextUtils.positionText, textx, texty)\n                .call(Drawing.setClipUrl, isSizeConstrained ? annClipID : null, gd);\n        }\n\n        annTextClip.select('rect').call(Drawing.setRect, borderfull, borderfull,\n            annWidth, annHeight);\n\n        annTextBG.call(Drawing.setRect, borderwidth / 2, borderwidth / 2,\n            outerWidth - borderwidth, outerHeight - borderwidth);\n\n        annTextGroupInner.call(Drawing.setTranslate,\n            Math.round(annPosPx.x.text - outerWidth / 2),\n            Math.round(annPosPx.y.text - outerHeight / 2));\n\n        /*\n         * rotate text and background\n         * we already calculated the text center position *as rotated*\n         * because we needed that for autoranging anyway, so now whether\n         * we have an arrow or not, we rotate about the text center.\n         */\n        annTextGroup.attr({transform: 'rotate(' + textangle + ',' +\n                            annPosPx.x.text + ',' + annPosPx.y.text + ')'});\n\n        /*\n         * add the arrow\n         * uses options[arrowwidth,arrowcolor,arrowhead] for styling\n         * dx and dy are normally zero, but when you are dragging the textbox\n         * while the head stays put, dx and dy are the pixel offsets\n         */\n        var drawArrow = function(dx, dy) {\n            annGroup\n                .selectAll('.annotation-arrow-g')\n                .remove();\n\n            var headX = annPosPx.x.head;\n            var headY = annPosPx.y.head;\n            var tailX = annPosPx.x.tail + dx;\n            var tailY = annPosPx.y.tail + dy;\n            var textX = annPosPx.x.text + dx;\n            var textY = annPosPx.y.text + dy;\n\n            // find the edge of the text box, where we'll start the arrow:\n            // create transform matrix to rotate the text box corners\n            var transform = Lib.rotationXYMatrix(textangle, textX, textY);\n            var applyTransform = Lib.apply2DTransform(transform);\n            var applyTransform2 = Lib.apply2DTransform2(transform);\n\n            // calculate and transform bounding box\n            var width = +annTextBG.attr('width');\n            var height = +annTextBG.attr('height');\n            var xLeft = textX - 0.5 * width;\n            var xRight = xLeft + width;\n            var yTop = textY - 0.5 * height;\n            var yBottom = yTop + height;\n            var edges = [\n                [xLeft, yTop, xLeft, yBottom],\n                [xLeft, yBottom, xRight, yBottom],\n                [xRight, yBottom, xRight, yTop],\n                [xRight, yTop, xLeft, yTop]\n            ].map(applyTransform2);\n\n            // Remove the line if it ends inside the box.  Use ray\n            // casting for rotated boxes: see which edges intersect a\n            // line from the arrowhead to far away and reduce with xor\n            // to get the parity of the number of intersections.\n            if(edges.reduce(function(a, x) {\n                return a ^\n                    !!Lib.segmentsIntersect(headX, headY, headX + 1e6, headY + 1e6,\n                            x[0], x[1], x[2], x[3]);\n            }, false)) {\n                // no line or arrow - so quit drawArrow now\n                return;\n            }\n\n            edges.forEach(function(x) {\n                var p = Lib.segmentsIntersect(tailX, tailY, headX, headY,\n                            x[0], x[1], x[2], x[3]);\n                if(p) {\n                    tailX = p.x;\n                    tailY = p.y;\n                }\n            });\n\n            var strokewidth = options.arrowwidth;\n            var arrowColor = options.arrowcolor;\n            var arrowSide = options.arrowside;\n\n            var arrowGroup = annGroup.append('g')\n                .style({opacity: Color.opacity(arrowColor)})\n                .classed('annotation-arrow-g', true);\n\n            var arrow = arrowGroup.append('path')\n                .attr('d', 'M' + tailX + ',' + tailY + 'L' + headX + ',' + headY)\n                .style('stroke-width', strokewidth + 'px')\n                .call(Color.stroke, Color.rgb(arrowColor));\n\n            drawArrowHead(arrow, arrowSide, options);\n\n            // the arrow dragger is a small square right at the head, then a line to the tail,\n            // all expanded by a stroke width of 6px plus the arrow line width\n            if(edits.annotationPosition && arrow.node().parentNode && !subplotId) {\n                var arrowDragHeadX = headX;\n                var arrowDragHeadY = headY;\n                if(options.standoff) {\n                    var arrowLength = Math.sqrt(Math.pow(headX - tailX, 2) + Math.pow(headY - tailY, 2));\n                    arrowDragHeadX += options.standoff * (tailX - headX) / arrowLength;\n                    arrowDragHeadY += options.standoff * (tailY - headY) / arrowLength;\n                }\n                var arrowDrag = arrowGroup.append('path')\n                    .classed('annotation-arrow', true)\n                    .classed('anndrag', true)\n                    .classed('cursor-move', true)\n                    .attr({\n                        d: 'M3,3H-3V-3H3ZM0,0L' + (tailX - arrowDragHeadX) + ',' + (tailY - arrowDragHeadY),\n                        transform: 'translate(' + arrowDragHeadX + ',' + arrowDragHeadY + ')'\n                    })\n                    .style('stroke-width', (strokewidth + 6) + 'px')\n                    .call(Color.stroke, 'rgba(0,0,0,0)')\n                    .call(Color.fill, 'rgba(0,0,0,0)');\n\n                var annx0, anny0;\n\n                // dragger for the arrow & head: translates the whole thing\n                // (head/tail/text) all together\n                dragElement.init({\n                    element: arrowDrag.node(),\n                    gd: gd,\n                    prepFn: function() {\n                        var pos = Drawing.getTranslate(annTextGroupInner);\n\n                        annx0 = pos.x;\n                        anny0 = pos.y;\n                        if(xa && xa.autorange) {\n                            modifyBase(xa._name + '.autorange', true);\n                        }\n                        if(ya && ya.autorange) {\n                            modifyBase(ya._name + '.autorange', true);\n                        }\n                    },\n                    moveFn: function(dx, dy) {\n                        var annxy0 = applyTransform(annx0, anny0);\n                        var xcenter = annxy0[0] + dx;\n                        var ycenter = annxy0[1] + dy;\n                        annTextGroupInner.call(Drawing.setTranslate, xcenter, ycenter);\n\n                        modifyItem('x', xa ?\n                            xa.p2r(xa.r2p(options.x) + dx) :\n                            (options.x + (dx / gs.w)));\n                        modifyItem('y', ya ?\n                            ya.p2r(ya.r2p(options.y) + dy) :\n                            (options.y - (dy / gs.h)));\n\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n                        }\n\n                        arrowGroup.attr('transform', 'translate(' + dx + ',' + dy + ')');\n                        annTextGroup.attr({\n                            transform: 'rotate(' + textangle + ',' +\n                                   xcenter + ',' + ycenter + ')'\n                        });\n                    },\n                    doneFn: function() {\n                        Registry.call('_guiRelayout', gd, getUpdateObj());\n                        var notesBox = document.querySelector('.js-notes-box-panel');\n                        if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                    }\n                });\n            }\n        };\n\n        if(options.showarrow) drawArrow(0, 0);\n\n        // user dragging the annotation (text, not arrow)\n        if(editTextPosition) {\n            var baseTextTransform;\n\n            // dragger for the textbox: if there's an arrow, just drag the\n            // textbox and tail, leave the head untouched\n            dragElement.init({\n                element: annTextGroupInner.node(),\n                gd: gd,\n                prepFn: function() {\n                    baseTextTransform = annTextGroup.attr('transform');\n                },\n                moveFn: function(dx, dy) {\n                    var csr = 'pointer';\n                    if(options.showarrow) {\n                        if(options.axref === options.xref) {\n                            modifyItem('ax', xa.p2r(xa.r2p(options.ax) + dx));\n                        } else {\n                            modifyItem('ax', options.ax + dx);\n                        }\n\n                        if(options.ayref === options.yref) {\n                            modifyItem('ay', ya.p2r(ya.r2p(options.ay) + dy));\n                        } else {\n                            modifyItem('ay', options.ay + dy);\n                        }\n\n                        drawArrow(dx, dy);\n                    }\n                    else if(!subplotId) {\n                        var xUpdate, yUpdate;\n                        if(xa) {\n                            xUpdate = xa.p2r(xa.r2p(options.x) + dx);\n\n                        } else {\n                            var widthFraction = options._xsize / gs.w;\n                            var xLeft = options.x + (options._xshift - options.xshift) / gs.w - widthFraction / 2;\n\n                            xUpdate = dragElement.align(xLeft + dx / gs.w,\n                                widthFraction, 0, 1, options.xanchor);\n                        }\n\n                        if(ya) {\n                            yUpdate = ya.p2r(ya.r2p(options.y) + dy);\n                        } else {\n                            var heightFraction = options._ysize / gs.h;\n                            var yBottom = options.y - (options._yshift + options.yshift) / gs.h - heightFraction / 2;\n\n                            yUpdate = dragElement.align(yBottom - dy / gs.h,\n                                heightFraction, 0, 1, options.yanchor);\n                        }\n                        modifyItem('x', xUpdate);\n                        modifyItem('y', yUpdate);\n                        if(!xa || !ya) {\n                            csr = dragElement.getCursor(\n                                xa ? 0.5 : xUpdate,\n                                ya ? 0.5 : yUpdate,\n                                options.xanchor, options.yanchor\n                            );\n                        }\n                    }\n                    else return;\n\n                    annTextGroup.attr({\n                        transform: 'translate(' + dx + ',' + dy + ')' + baseTextTransform\n                    });\n\n                    setCursor(annTextGroupInner, csr);\n                },\n                doneFn: function() {\n                    setCursor(annTextGroupInner);\n                    Registry.call('_guiRelayout', gd, getUpdateObj());\n                    var notesBox = document.querySelector('.js-notes-box-panel');\n                    if(notesBox) notesBox.redraw(notesBox.selectedObj);\n                }\n            });\n        }\n    }\n\n    if(edits.annotationText) {\n        annText.call(svgTextUtils.makeEditable, {delegate: annTextGroupInner, gd: gd})\n            .call(textLayout)\n            .on('edit', function(_text) {\n                options.text = _text;\n\n                this.call(textLayout);\n\n                modifyItem('text', _text);\n\n                if(xa && xa.autorange) {\n                    modifyBase(xa._name + '.autorange', true);\n                }\n                if(ya && ya.autorange) {\n                    modifyBase(ya._name + '.autorange', true);\n                }\n\n                Registry.call('_guiRelayout', gd, getUpdateObj());\n            });\n    }\n    else annText.call(textLayout);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}