{"ast":null,"code":"/*! *****************************************************************************\nCopyright (c) Microsoft Corporation. All rights reserved.\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\nthis file except in compliance with the License. You may obtain a copy of the\nLicense at http://www.apache.org/licenses/LICENSE-2.0\n\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\nMERCHANTABLITY OR NON-INFRINGEMENT.\n\nSee the Apache Version 2.0 License for specific language governing permissions\nand limitations under the License.\n***************************************************************************** */\nvar _t = function t(r, e) {\n  return (_t = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (t, r) {\n    t.__proto__ = r;\n  } || function (t, r) {\n    for (var e in r) {\n      r.hasOwnProperty(e) && (t[e] = r[e]);\n    }\n  })(r, e);\n};\nfunction r(r, e) {\n  function i() {\n    this.constructor = r;\n  }\n  _t(r, e), r.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i());\n}\nfunction e(t) {\n  var r = \"\";\n  Array.isArray(t) || (t = [t]);\n  for (var e = 0; e < t.length; e++) {\n    var i = t[e];\n    if (i.type === f.CLOSE_PATH) r += \"z\";else if (i.type === f.HORIZ_LINE_TO) r += (i.relative ? \"h\" : \"H\") + i.x;else if (i.type === f.VERT_LINE_TO) r += (i.relative ? \"v\" : \"V\") + i.y;else if (i.type === f.MOVE_TO) r += (i.relative ? \"m\" : \"M\") + i.x + \" \" + i.y;else if (i.type === f.LINE_TO) r += (i.relative ? \"l\" : \"L\") + i.x + \" \" + i.y;else if (i.type === f.CURVE_TO) r += (i.relative ? \"c\" : \"C\") + i.x1 + \" \" + i.y1 + \" \" + i.x2 + \" \" + i.y2 + \" \" + i.x + \" \" + i.y;else if (i.type === f.SMOOTH_CURVE_TO) r += (i.relative ? \"s\" : \"S\") + i.x2 + \" \" + i.y2 + \" \" + i.x + \" \" + i.y;else if (i.type === f.QUAD_TO) r += (i.relative ? \"q\" : \"Q\") + i.x1 + \" \" + i.y1 + \" \" + i.x + \" \" + i.y;else if (i.type === f.SMOOTH_QUAD_TO) r += (i.relative ? \"t\" : \"T\") + i.x + \" \" + i.y;else {\n      if (i.type !== f.ARC) throw new Error('Unexpected command type \"' + i.type + '\" at index ' + e + \".\");\n      r += (i.relative ? \"a\" : \"A\") + i.rX + \" \" + i.rY + \" \" + i.xRot + \" \" + +i.lArcFlag + \" \" + +i.sweepFlag + \" \" + i.x + \" \" + i.y;\n    }\n  }\n  return r;\n}\nfunction i(t, r) {\n  var e = t[0],\n    i = t[1];\n  return [e * Math.cos(r) - i * Math.sin(r), e * Math.sin(r) + i * Math.cos(r)];\n}\nfunction a() {\n  for (var t = [], r = 0; r < arguments.length; r++) {\n    t[r] = arguments[r];\n  }\n  for (var e = 0; e < t.length; e++) {\n    if (\"number\" != typeof t[e]) throw new Error(\"assertNumbers arguments[\" + e + \"] is not a number. \" + typeof t[e] + \" == typeof \" + t[e]);\n  }\n  return !0;\n}\nvar n = Math.PI;\nfunction o(t, r, e) {\n  t.lArcFlag = 0 === t.lArcFlag ? 0 : 1, t.sweepFlag = 0 === t.sweepFlag ? 0 : 1;\n  var a = t.rX,\n    o = t.rY,\n    s = t.x,\n    u = t.y;\n  a = Math.abs(t.rX), o = Math.abs(t.rY);\n  var h = i([(r - s) / 2, (e - u) / 2], -t.xRot / 180 * n),\n    c = h[0],\n    y = h[1],\n    p = Math.pow(c, 2) / Math.pow(a, 2) + Math.pow(y, 2) / Math.pow(o, 2);\n  1 < p && (a *= Math.sqrt(p), o *= Math.sqrt(p)), t.rX = a, t.rY = o;\n  var m = Math.pow(a, 2) * Math.pow(y, 2) + Math.pow(o, 2) * Math.pow(c, 2),\n    O = (t.lArcFlag !== t.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a, 2) * Math.pow(o, 2) - m) / m)),\n    T = a * y / o * O,\n    v = -o * c / a * O,\n    l = i([T, v], t.xRot / 180 * n);\n  t.cX = l[0] + (r + s) / 2, t.cY = l[1] + (e + u) / 2, t.phi1 = Math.atan2((y - v) / o, (c - T) / a), t.phi2 = Math.atan2((-y - v) / o, (-c - T) / a), 0 === t.sweepFlag && t.phi2 > t.phi1 && (t.phi2 -= 2 * n), 1 === t.sweepFlag && t.phi2 < t.phi1 && (t.phi2 += 2 * n), t.phi1 *= 180 / n, t.phi2 *= 180 / n;\n}\nfunction s(t, r, e) {\n  a(t, r, e);\n  var i = t * t + r * r - e * e;\n  if (0 > i) return [];\n  if (0 === i) return [[t * e / (t * t + r * r), r * e / (t * t + r * r)]];\n  var n = Math.sqrt(i);\n  return [[(t * e + r * n) / (t * t + r * r), (r * e - t * n) / (t * t + r * r)], [(t * e - r * n) / (t * t + r * r), (r * e + t * n) / (t * t + r * r)]];\n}\nvar u,\n  h = Math.PI / 180;\nfunction c(t, r, e) {\n  return (1 - e) * t + e * r;\n}\nfunction y(t, r, e, i) {\n  return t + Math.cos(i / 180 * n) * r + Math.sin(i / 180 * n) * e;\n}\nfunction p(t, r, e, i) {\n  var a = r - t,\n    n = e - r,\n    o = 3 * a + 3 * (i - e) - 6 * n,\n    s = 6 * (n - a),\n    u = 3 * a;\n  return Math.abs(o) < 1e-6 ? [-u / s] : function (t, r, e) {\n    void 0 === e && (e = 1e-6);\n    var i = t * t / 4 - r;\n    if (i < -e) return [];\n    if (i <= e) return [-t / 2];\n    var a = Math.sqrt(i);\n    return [-t / 2 - a, -t / 2 + a];\n  }(s / o, u / o, 1e-6);\n}\nfunction m(t, r, e, i, a) {\n  var n = 1 - a;\n  return t * (n * n * n) + r * (3 * n * n * a) + e * (3 * n * a * a) + i * (a * a * a);\n}\n!function (t) {\n  function r() {\n    return u(function (t, r, e) {\n      return t.relative && (void 0 !== t.x1 && (t.x1 += r), void 0 !== t.y1 && (t.y1 += e), void 0 !== t.x2 && (t.x2 += r), void 0 !== t.y2 && (t.y2 += e), void 0 !== t.x && (t.x += r), void 0 !== t.y && (t.y += e), t.relative = !1), t;\n    });\n  }\n  function e() {\n    var t = NaN,\n      r = NaN,\n      e = NaN,\n      i = NaN;\n    return u(function (a, n, o) {\n      return a.type & f.SMOOTH_CURVE_TO && (a.type = f.CURVE_TO, t = isNaN(t) ? n : t, r = isNaN(r) ? o : r, a.x1 = a.relative ? n - t : 2 * n - t, a.y1 = a.relative ? o - r : 2 * o - r), a.type & f.CURVE_TO ? (t = a.relative ? n + a.x2 : a.x2, r = a.relative ? o + a.y2 : a.y2) : (t = NaN, r = NaN), a.type & f.SMOOTH_QUAD_TO && (a.type = f.QUAD_TO, e = isNaN(e) ? n : e, i = isNaN(i) ? o : i, a.x1 = a.relative ? n - e : 2 * n - e, a.y1 = a.relative ? o - i : 2 * o - i), a.type & f.QUAD_TO ? (e = a.relative ? n + a.x1 : a.x1, i = a.relative ? o + a.y1 : a.y1) : (e = NaN, i = NaN), a;\n    });\n  }\n  function n() {\n    var t = NaN,\n      r = NaN;\n    return u(function (e, i, a) {\n      if (e.type & f.SMOOTH_QUAD_TO && (e.type = f.QUAD_TO, t = isNaN(t) ? i : t, r = isNaN(r) ? a : r, e.x1 = e.relative ? i - t : 2 * i - t, e.y1 = e.relative ? a - r : 2 * a - r), e.type & f.QUAD_TO) {\n        t = e.relative ? i + e.x1 : e.x1, r = e.relative ? a + e.y1 : e.y1;\n        var n = e.x1,\n          o = e.y1;\n        e.type = f.CURVE_TO, e.x1 = ((e.relative ? 0 : i) + 2 * n) / 3, e.y1 = ((e.relative ? 0 : a) + 2 * o) / 3, e.x2 = (e.x + 2 * n) / 3, e.y2 = (e.y + 2 * o) / 3;\n      } else t = NaN, r = NaN;\n      return e;\n    });\n  }\n  function u(t) {\n    var r = 0,\n      e = 0,\n      i = NaN,\n      a = NaN;\n    return function (n) {\n      if (isNaN(i) && !(n.type & f.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      var o = t(n, r, e, i, a);\n      return n.type & f.CLOSE_PATH && (r = i, e = a), void 0 !== n.x && (r = n.relative ? r + n.x : n.x), void 0 !== n.y && (e = n.relative ? e + n.y : n.y), n.type & f.MOVE_TO && (i = r, a = e), o;\n    };\n  }\n  function O(t, r, e, i, n, o) {\n    return a(t, r, e, i, n, o), u(function (a, s, u, h) {\n      var c = a.x1,\n        y = a.x2,\n        p = a.relative && !isNaN(h),\n        m = void 0 !== a.x ? a.x : p ? 0 : s,\n        O = void 0 !== a.y ? a.y : p ? 0 : u;\n      function T(t) {\n        return t * t;\n      }\n      a.type & f.HORIZ_LINE_TO && 0 !== r && (a.type = f.LINE_TO, a.y = a.relative ? 0 : u), a.type & f.VERT_LINE_TO && 0 !== e && (a.type = f.LINE_TO, a.x = a.relative ? 0 : s), void 0 !== a.x && (a.x = a.x * t + O * e + (p ? 0 : n)), void 0 !== a.y && (a.y = m * r + a.y * i + (p ? 0 : o)), void 0 !== a.x1 && (a.x1 = a.x1 * t + a.y1 * e + (p ? 0 : n)), void 0 !== a.y1 && (a.y1 = c * r + a.y1 * i + (p ? 0 : o)), void 0 !== a.x2 && (a.x2 = a.x2 * t + a.y2 * e + (p ? 0 : n)), void 0 !== a.y2 && (a.y2 = y * r + a.y2 * i + (p ? 0 : o));\n      var v = t * i - r * e;\n      if (void 0 !== a.xRot && (1 !== t || 0 !== r || 0 !== e || 1 !== i)) if (0 === v) delete a.rX, delete a.rY, delete a.xRot, delete a.lArcFlag, delete a.sweepFlag, a.type = f.LINE_TO;else {\n        var l = a.xRot * Math.PI / 180,\n          _ = Math.sin(l),\n          N = Math.cos(l),\n          x = 1 / T(a.rX),\n          d = 1 / T(a.rY),\n          A = T(N) * x + T(_) * d,\n          E = 2 * _ * N * (x - d),\n          C = T(_) * x + T(N) * d,\n          M = A * i * i - E * r * i + C * r * r,\n          R = E * (t * i + r * e) - 2 * (A * e * i + C * t * r),\n          g = A * e * e - E * t * e + C * t * t,\n          I = (Math.atan2(R, M - g) + Math.PI) % Math.PI / 2,\n          S = Math.sin(I),\n          L = Math.cos(I);\n        a.rX = Math.abs(v) / Math.sqrt(M * T(L) + R * S * L + g * T(S)), a.rY = Math.abs(v) / Math.sqrt(M * T(S) - R * S * L + g * T(L)), a.xRot = 180 * I / Math.PI;\n      }\n      return void 0 !== a.sweepFlag && 0 > v && (a.sweepFlag = +!a.sweepFlag), a;\n    });\n  }\n  function T() {\n    return function (t) {\n      var r = {};\n      for (var e in t) {\n        r[e] = t[e];\n      }\n      return r;\n    };\n  }\n  t.ROUND = function (t) {\n    function r(r) {\n      return Math.round(r * t) / t;\n    }\n    return void 0 === t && (t = 1e13), a(t), function (t) {\n      return void 0 !== t.x1 && (t.x1 = r(t.x1)), void 0 !== t.y1 && (t.y1 = r(t.y1)), void 0 !== t.x2 && (t.x2 = r(t.x2)), void 0 !== t.y2 && (t.y2 = r(t.y2)), void 0 !== t.x && (t.x = r(t.x)), void 0 !== t.y && (t.y = r(t.y)), void 0 !== t.rX && (t.rX = r(t.rX)), void 0 !== t.rY && (t.rY = r(t.rY)), t;\n    };\n  }, t.TO_ABS = r, t.TO_REL = function () {\n    return u(function (t, r, e) {\n      return t.relative || (void 0 !== t.x1 && (t.x1 -= r), void 0 !== t.y1 && (t.y1 -= e), void 0 !== t.x2 && (t.x2 -= r), void 0 !== t.y2 && (t.y2 -= e), void 0 !== t.x && (t.x -= r), void 0 !== t.y && (t.y -= e), t.relative = !0), t;\n    });\n  }, t.NORMALIZE_HVZ = function (t, r, e) {\n    return void 0 === t && (t = !0), void 0 === r && (r = !0), void 0 === e && (e = !0), u(function (i, a, n, o, s) {\n      if (isNaN(o) && !(i.type & f.MOVE_TO)) throw new Error(\"path must start with moveto\");\n      return r && i.type & f.HORIZ_LINE_TO && (i.type = f.LINE_TO, i.y = i.relative ? 0 : n), e && i.type & f.VERT_LINE_TO && (i.type = f.LINE_TO, i.x = i.relative ? 0 : a), t && i.type & f.CLOSE_PATH && (i.type = f.LINE_TO, i.x = i.relative ? o - a : o, i.y = i.relative ? s - n : s), i.type & f.ARC && (0 === i.rX || 0 === i.rY) && (i.type = f.LINE_TO, delete i.rX, delete i.rY, delete i.xRot, delete i.lArcFlag, delete i.sweepFlag), i;\n    });\n  }, t.NORMALIZE_ST = e, t.QT_TO_C = n, t.INFO = u, t.SANITIZE = function (t) {\n    void 0 === t && (t = 0), a(t);\n    var r = NaN,\n      e = NaN,\n      i = NaN,\n      n = NaN;\n    return u(function (a, o, s, u, h) {\n      var c = Math.abs,\n        y = !1,\n        p = 0,\n        m = 0;\n      if (a.type & f.SMOOTH_CURVE_TO && (p = isNaN(r) ? 0 : o - r, m = isNaN(e) ? 0 : s - e), a.type & (f.CURVE_TO | f.SMOOTH_CURVE_TO) ? (r = a.relative ? o + a.x2 : a.x2, e = a.relative ? s + a.y2 : a.y2) : (r = NaN, e = NaN), a.type & f.SMOOTH_QUAD_TO ? (i = isNaN(i) ? o : 2 * o - i, n = isNaN(n) ? s : 2 * s - n) : a.type & f.QUAD_TO ? (i = a.relative ? o + a.x1 : a.x1, n = a.relative ? s + a.y1 : a.y2) : (i = NaN, n = NaN), a.type & f.LINE_COMMANDS || a.type & f.ARC && (0 === a.rX || 0 === a.rY || !a.lArcFlag) || a.type & f.CURVE_TO || a.type & f.SMOOTH_CURVE_TO || a.type & f.QUAD_TO || a.type & f.SMOOTH_QUAD_TO) {\n        var O = void 0 === a.x ? 0 : a.relative ? a.x : a.x - o,\n          T = void 0 === a.y ? 0 : a.relative ? a.y : a.y - s;\n        p = isNaN(i) ? void 0 === a.x1 ? p : a.relative ? a.x : a.x1 - o : i - o, m = isNaN(n) ? void 0 === a.y1 ? m : a.relative ? a.y : a.y1 - s : n - s;\n        var v = void 0 === a.x2 ? 0 : a.relative ? a.x : a.x2 - o,\n          l = void 0 === a.y2 ? 0 : a.relative ? a.y : a.y2 - s;\n        c(O) <= t && c(T) <= t && c(p) <= t && c(m) <= t && c(v) <= t && c(l) <= t && (y = !0);\n      }\n      return a.type & f.CLOSE_PATH && c(o - u) <= t && c(s - h) <= t && (y = !0), y ? [] : a;\n    });\n  }, t.MATRIX = O, t.ROTATE = function (t, r, e) {\n    void 0 === r && (r = 0), void 0 === e && (e = 0), a(t, r, e);\n    var i = Math.sin(t),\n      n = Math.cos(t);\n    return O(n, i, -i, n, r - r * n + e * i, e - r * i - e * n);\n  }, t.TRANSLATE = function (t, r) {\n    return void 0 === r && (r = 0), a(t, r), O(1, 0, 0, 1, t, r);\n  }, t.SCALE = function (t, r) {\n    return void 0 === r && (r = t), a(t, r), O(t, 0, 0, r, 0, 0);\n  }, t.SKEW_X = function (t) {\n    return a(t), O(1, 0, Math.atan(t), 1, 0, 0);\n  }, t.SKEW_Y = function (t) {\n    return a(t), O(1, Math.atan(t), 0, 1, 0, 0);\n  }, t.X_AXIS_SYMMETRY = function (t) {\n    return void 0 === t && (t = 0), a(t), O(-1, 0, 0, 1, t, 0);\n  }, t.Y_AXIS_SYMMETRY = function (t) {\n    return void 0 === t && (t = 0), a(t), O(1, 0, 0, -1, 0, t);\n  }, t.A_TO_C = function () {\n    return u(function (t, r, e) {\n      return f.ARC === t.type ? function (t, r, e) {\n        var a, n, s, u;\n        t.cX || o(t, r, e);\n        for (var y = Math.min(t.phi1, t.phi2), p = Math.max(t.phi1, t.phi2) - y, m = Math.ceil(p / 90), O = new Array(m), T = r, v = e, l = 0; l < m; l++) {\n          var _ = c(t.phi1, t.phi2, l / m),\n            N = c(t.phi1, t.phi2, (l + 1) / m),\n            x = N - _,\n            d = 4 / 3 * Math.tan(x * h / 4),\n            A = [Math.cos(_ * h) - d * Math.sin(_ * h), Math.sin(_ * h) + d * Math.cos(_ * h)],\n            E = A[0],\n            C = A[1],\n            M = [Math.cos(N * h), Math.sin(N * h)],\n            R = M[0],\n            g = M[1],\n            I = [R + d * Math.sin(N * h), g - d * Math.cos(N * h)],\n            S = I[0],\n            L = I[1];\n          O[l] = {\n            relative: t.relative,\n            type: f.CURVE_TO\n          };\n          var H = function H(r, e) {\n            var a = i([r * t.rX, e * t.rY], t.xRot),\n              n = a[0],\n              o = a[1];\n            return [t.cX + n, t.cY + o];\n          };\n          a = H(E, C), O[l].x1 = a[0], O[l].y1 = a[1], n = H(S, L), O[l].x2 = n[0], O[l].y2 = n[1], s = H(R, g), O[l].x = s[0], O[l].y = s[1], t.relative && (O[l].x1 -= T, O[l].y1 -= v, O[l].x2 -= T, O[l].y2 -= v, O[l].x -= T, O[l].y -= v), T = (u = [O[l].x, O[l].y])[0], v = u[1];\n        }\n        return O;\n      }(t, t.relative ? 0 : r, t.relative ? 0 : e) : t;\n    });\n  }, t.ANNOTATE_ARCS = function () {\n    return u(function (t, r, e) {\n      return t.relative && (r = 0, e = 0), f.ARC === t.type && o(t, r, e), t;\n    });\n  }, t.CLONE = T, t.CALCULATE_BOUNDS = function () {\n    var t = function t(_t2) {\n        var r = {};\n        for (var e in _t2) {\n          r[e] = _t2[e];\n        }\n        return r;\n      },\n      i = r(),\n      a = n(),\n      h = e(),\n      c = u(function (r, e, n) {\n        var u = h(a(i(t(r))));\n        function O(t) {\n          t > c.maxX && (c.maxX = t), t < c.minX && (c.minX = t);\n        }\n        function T(t) {\n          t > c.maxY && (c.maxY = t), t < c.minY && (c.minY = t);\n        }\n        if (u.type & f.DRAWING_COMMANDS && (O(e), T(n)), u.type & f.HORIZ_LINE_TO && O(u.x), u.type & f.VERT_LINE_TO && T(u.y), u.type & f.LINE_TO && (O(u.x), T(u.y)), u.type & f.CURVE_TO) {\n          O(u.x), T(u.y);\n          for (var v = 0, l = p(e, u.x1, u.x2, u.x); v < l.length; v++) {\n            0 < (w = l[v]) && 1 > w && O(m(e, u.x1, u.x2, u.x, w));\n          }\n          for (var _ = 0, N = p(n, u.y1, u.y2, u.y); _ < N.length; _++) {\n            0 < (w = N[_]) && 1 > w && T(m(n, u.y1, u.y2, u.y, w));\n          }\n        }\n        if (u.type & f.ARC) {\n          O(u.x), T(u.y), o(u, e, n);\n          for (var x = u.xRot / 180 * Math.PI, d = Math.cos(x) * u.rX, A = Math.sin(x) * u.rX, E = -Math.sin(x) * u.rY, C = Math.cos(x) * u.rY, M = u.phi1 < u.phi2 ? [u.phi1, u.phi2] : -180 > u.phi2 ? [u.phi2 + 360, u.phi1 + 360] : [u.phi2, u.phi1], R = M[0], g = M[1], I = function I(t) {\n              var r = t[0],\n                e = t[1],\n                i = 180 * Math.atan2(e, r) / Math.PI;\n              return i < R ? i + 360 : i;\n            }, S = 0, L = s(E, -d, 0).map(I); S < L.length; S++) {\n            (w = L[S]) > R && w < g && O(y(u.cX, d, E, w));\n          }\n          for (var H = 0, U = s(C, -A, 0).map(I); H < U.length; H++) {\n            var w;\n            (w = U[H]) > R && w < g && T(y(u.cY, A, C, w));\n          }\n        }\n        return r;\n      });\n    return c.minX = 1 / 0, c.maxX = -1 / 0, c.minY = 1 / 0, c.maxY = -1 / 0, c;\n  };\n}(u || (u = {}));\nvar O,\n  T = function () {\n    function t() {}\n    return t.prototype.round = function (t) {\n      return this.transform(u.ROUND(t));\n    }, t.prototype.toAbs = function () {\n      return this.transform(u.TO_ABS());\n    }, t.prototype.toRel = function () {\n      return this.transform(u.TO_REL());\n    }, t.prototype.normalizeHVZ = function (t, r, e) {\n      return this.transform(u.NORMALIZE_HVZ(t, r, e));\n    }, t.prototype.normalizeST = function () {\n      return this.transform(u.NORMALIZE_ST());\n    }, t.prototype.qtToC = function () {\n      return this.transform(u.QT_TO_C());\n    }, t.prototype.aToC = function () {\n      return this.transform(u.A_TO_C());\n    }, t.prototype.sanitize = function (t) {\n      return this.transform(u.SANITIZE(t));\n    }, t.prototype.translate = function (t, r) {\n      return this.transform(u.TRANSLATE(t, r));\n    }, t.prototype.scale = function (t, r) {\n      return this.transform(u.SCALE(t, r));\n    }, t.prototype.rotate = function (t, r, e) {\n      return this.transform(u.ROTATE(t, r, e));\n    }, t.prototype.matrix = function (t, r, e, i, a, n) {\n      return this.transform(u.MATRIX(t, r, e, i, a, n));\n    }, t.prototype.skewX = function (t) {\n      return this.transform(u.SKEW_X(t));\n    }, t.prototype.skewY = function (t) {\n      return this.transform(u.SKEW_Y(t));\n    }, t.prototype.xSymmetry = function (t) {\n      return this.transform(u.X_AXIS_SYMMETRY(t));\n    }, t.prototype.ySymmetry = function (t) {\n      return this.transform(u.Y_AXIS_SYMMETRY(t));\n    }, t.prototype.annotateArcs = function () {\n      return this.transform(u.ANNOTATE_ARCS());\n    }, t;\n  }(),\n  v = function v(t) {\n    return \" \" === t || \"\\t\" === t || \"\\r\" === t || \"\\n\" === t;\n  },\n  l = function l(t) {\n    return \"0\".charCodeAt(0) <= t.charCodeAt(0) && t.charCodeAt(0) <= \"9\".charCodeAt(0);\n  },\n  _ = function (t) {\n    function e() {\n      var r = t.call(this) || this;\n      return r.curNumber = \"\", r.curCommandType = -1, r.curCommandRelative = !1, r.canParseCommandOrComma = !0, r.curNumberHasExp = !1, r.curNumberHasExpDigits = !1, r.curNumberHasDecimal = !1, r.curArgs = [], r;\n    }\n    return r(e, t), e.prototype.finish = function (t) {\n      if (void 0 === t && (t = []), this.parse(\" \", t), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError(\"Unterminated command at the path end.\");\n      return t;\n    }, e.prototype.parse = function (t, r) {\n      var e = this;\n      void 0 === r && (r = []);\n      for (var i = function i(t) {\n          r.push(t), e.curArgs.length = 0, e.canParseCommandOrComma = !0;\n        }, a = 0; a < t.length; a++) {\n        var n = t[a],\n          o = !(this.curCommandType !== f.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || \"0\" !== this.curNumber && \"1\" !== this.curNumber),\n          s = l(n) && (\"0\" === this.curNumber && \"0\" === n || o);\n        if (!l(n) || s) {\n          if (\"e\" !== n && \"E\" !== n) {\n            if (\"-\" !== n && \"+\" !== n || !this.curNumberHasExp || this.curNumberHasExpDigits) {\n              if (\".\" !== n || this.curNumberHasExp || this.curNumberHasDecimal || o) {\n                if (this.curNumber && -1 !== this.curCommandType) {\n                  var u = Number(this.curNumber);\n                  if (isNaN(u)) throw new SyntaxError(\"Invalid number ending at \" + a);\n                  if (this.curCommandType === f.ARC) if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n                    if (0 > u) throw new SyntaxError('Expected positive number, got \"' + u + '\" at index \"' + a + '\"');\n                  } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && \"0\" !== this.curNumber && \"1\" !== this.curNumber) throw new SyntaxError('Expected a flag, got \"' + this.curNumber + '\" at index \"' + a + '\"');\n                  this.curArgs.push(u), this.curArgs.length === N[this.curCommandType] && (f.HORIZ_LINE_TO === this.curCommandType ? i({\n                    type: f.HORIZ_LINE_TO,\n                    relative: this.curCommandRelative,\n                    x: u\n                  }) : f.VERT_LINE_TO === this.curCommandType ? i({\n                    type: f.VERT_LINE_TO,\n                    relative: this.curCommandRelative,\n                    y: u\n                  }) : this.curCommandType === f.MOVE_TO || this.curCommandType === f.LINE_TO || this.curCommandType === f.SMOOTH_QUAD_TO ? (i({\n                    type: this.curCommandType,\n                    relative: this.curCommandRelative,\n                    x: this.curArgs[0],\n                    y: this.curArgs[1]\n                  }), f.MOVE_TO === this.curCommandType && (this.curCommandType = f.LINE_TO)) : this.curCommandType === f.CURVE_TO ? i({\n                    type: f.CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x2: this.curArgs[2],\n                    y2: this.curArgs[3],\n                    x: this.curArgs[4],\n                    y: this.curArgs[5]\n                  }) : this.curCommandType === f.SMOOTH_CURVE_TO ? i({\n                    type: f.SMOOTH_CURVE_TO,\n                    relative: this.curCommandRelative,\n                    x2: this.curArgs[0],\n                    y2: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === f.QUAD_TO ? i({\n                    type: f.QUAD_TO,\n                    relative: this.curCommandRelative,\n                    x1: this.curArgs[0],\n                    y1: this.curArgs[1],\n                    x: this.curArgs[2],\n                    y: this.curArgs[3]\n                  }) : this.curCommandType === f.ARC && i({\n                    type: f.ARC,\n                    relative: this.curCommandRelative,\n                    rX: this.curArgs[0],\n                    rY: this.curArgs[1],\n                    xRot: this.curArgs[2],\n                    lArcFlag: this.curArgs[3],\n                    sweepFlag: this.curArgs[4],\n                    x: this.curArgs[5],\n                    y: this.curArgs[6]\n                  })), this.curNumber = \"\", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;\n                }\n                if (!v(n)) if (\",\" === n && this.canParseCommandOrComma) this.canParseCommandOrComma = !1;else if (\"+\" !== n && \"-\" !== n && \".\" !== n) {\n                  if (s) this.curNumber = n, this.curNumberHasDecimal = !1;else {\n                    if (0 !== this.curArgs.length) throw new SyntaxError(\"Unterminated command at index \" + a + \".\");\n                    if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character \"' + n + '\" at index ' + a + \". Command cannot follow comma\");\n                    if (this.canParseCommandOrComma = !1, \"z\" !== n && \"Z\" !== n) {\n                      if (\"h\" === n || \"H\" === n) this.curCommandType = f.HORIZ_LINE_TO, this.curCommandRelative = \"h\" === n;else if (\"v\" === n || \"V\" === n) this.curCommandType = f.VERT_LINE_TO, this.curCommandRelative = \"v\" === n;else if (\"m\" === n || \"M\" === n) this.curCommandType = f.MOVE_TO, this.curCommandRelative = \"m\" === n;else if (\"l\" === n || \"L\" === n) this.curCommandType = f.LINE_TO, this.curCommandRelative = \"l\" === n;else if (\"c\" === n || \"C\" === n) this.curCommandType = f.CURVE_TO, this.curCommandRelative = \"c\" === n;else if (\"s\" === n || \"S\" === n) this.curCommandType = f.SMOOTH_CURVE_TO, this.curCommandRelative = \"s\" === n;else if (\"q\" === n || \"Q\" === n) this.curCommandType = f.QUAD_TO, this.curCommandRelative = \"q\" === n;else if (\"t\" === n || \"T\" === n) this.curCommandType = f.SMOOTH_QUAD_TO, this.curCommandRelative = \"t\" === n;else {\n                        if (\"a\" !== n && \"A\" !== n) throw new SyntaxError('Unexpected character \"' + n + '\" at index ' + a + \".\");\n                        this.curCommandType = f.ARC, this.curCommandRelative = \"a\" === n;\n                      }\n                    } else r.push({\n                      type: f.CLOSE_PATH\n                    }), this.canParseCommandOrComma = !0, this.curCommandType = -1;\n                  }\n                } else this.curNumber = n, this.curNumberHasDecimal = \".\" === n;\n              } else this.curNumber += n, this.curNumberHasDecimal = !0;\n            } else this.curNumber += n;\n          } else this.curNumber += n, this.curNumberHasExp = !0;\n        } else this.curNumber += n, this.curNumberHasExpDigits = this.curNumberHasExp;\n      }\n      return r;\n    }, e.prototype.transform = function (t) {\n      return Object.create(this, {\n        parse: {\n          value: function value(r, e) {\n            void 0 === e && (e = []);\n            for (var i = 0, a = Object.getPrototypeOf(this).parse.call(this, r); i < a.length; i++) {\n              var n = a[i],\n                o = t(n);\n              Array.isArray(o) ? e.push.apply(e, o) : e.push(o);\n            }\n            return e;\n          }\n        }\n      });\n    }, e;\n  }(T),\n  f = function (t) {\n    function i(r) {\n      var e = t.call(this) || this;\n      return e.commands = \"string\" == typeof r ? i.parse(r) : r, e;\n    }\n    return r(i, t), i.prototype.encode = function () {\n      return i.encode(this.commands);\n    }, i.prototype.getBounds = function () {\n      var t = u.CALCULATE_BOUNDS();\n      return this.transform(t), t;\n    }, i.prototype.transform = function (t) {\n      for (var r = [], e = 0, i = this.commands; e < i.length; e++) {\n        var a = t(i[e]);\n        Array.isArray(a) ? r.push.apply(r, a) : r.push(a);\n      }\n      return this.commands = r, this;\n    }, i.encode = function (t) {\n      return e(t);\n    }, i.parse = function (t) {\n      var r = new _(),\n        e = [];\n      return r.parse(t, e), r.finish(e), e;\n    }, i.CLOSE_PATH = 1, i.MOVE_TO = 2, i.HORIZ_LINE_TO = 4, i.VERT_LINE_TO = 8, i.LINE_TO = 16, i.CURVE_TO = 32, i.SMOOTH_CURVE_TO = 64, i.QUAD_TO = 128, i.SMOOTH_QUAD_TO = 256, i.ARC = 512, i.LINE_COMMANDS = i.LINE_TO | i.HORIZ_LINE_TO | i.VERT_LINE_TO, i.DRAWING_COMMANDS = i.HORIZ_LINE_TO | i.VERT_LINE_TO | i.LINE_TO | i.CURVE_TO | i.SMOOTH_CURVE_TO | i.QUAD_TO | i.SMOOTH_QUAD_TO | i.ARC, i;\n  }(T),\n  N = ((O = {})[f.MOVE_TO] = 2, O[f.LINE_TO] = 2, O[f.HORIZ_LINE_TO] = 1, O[f.VERT_LINE_TO] = 1, O[f.CLOSE_PATH] = 0, O[f.QUAD_TO] = 4, O[f.SMOOTH_QUAD_TO] = 2, O[f.CURVE_TO] = 6, O[f.SMOOTH_CURVE_TO] = 4, O[f.ARC] = 7, O);\nexport { N as COMMAND_ARG_COUNTS, f as SVGPathData, _ as SVGPathDataParser, u as SVGPathDataTransformer, e as encodeSVGPath };","map":{"version":3,"mappings":"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","names":["encodeSVGPath","commands","str","Array","isArray","i","length","command","type","SVGPathData","CLOSE_PATH","HORIZ_LINE_TO","relative","x","VERT_LINE_TO","y","MOVE_TO","LINE_TO","CURVE_TO","x1","y1","x2","y2","SMOOTH_CURVE_TO","QUAD_TO","SMOOTH_QUAD_TO","ARC","Error","rX","rY","xRot","lArcFlag","sweepFlag","rotate","_a","rad","Math","cos","sin","assertNumbers","numbers","PI","annotateArcCommand","c","abs","x1_","y1_","testValue","pow","sqrt","c_ScaleTemp","c_Scale","max","cx_","cy_","cRot","cX","cY","phi1","atan2","phi2","intersectionUnitCircleLine","a","b","termSqr","term","SVGPathDataTransformer","DEG","lerp","t","arcAt","phiDeg","bezierRoot","x0","x3","x01","x12","p","q","PRECISION","discriminantX4","root","pqFormula","bezierAt","s","TO_ABS","INFO","prevX","prevY","NORMALIZE_ST","prevCurveC2X","NaN","prevCurveC2Y","prevQuadCX","prevQuadCY","isNaN","QT_TO_C","prevQuadX1","prevQuadY1","f","prevXAbs","prevYAbs","pathStartXAbs","pathStartYAbs","result","MATRIX","d","e","pathStartX","origX1","origX2","comRel","sqr","det","sinRot","cosRot","xCurve","yCurve","A","B","C","A1","B1","C1","newXRot","newSinRot","newCosRot","CLONE","key","roundVal","rf","val","round","normalizeZ","normalizeH","normalizeV","pathStartY","EPS","skip","x1Rel","y1Rel","LINE_COMMANDS","xRel","yRel","x2Rel","y2Rel","dX","dY","atan","xOffset","yOffset","arc","y0","phiMin","min","deltaPhi","partCount","ceil","phiStart","phiEnd","deltaPhi_1","tan","_e","_f","_g","transform","xTemp","yTemp","_b","_c","_d","a2c","clone","toAbs","qtToC","normST","fixX","absX","maxX","minX","fixY","absY","maxY","minY","DRAWING_COMMANDS","xDerivRoots_1","_i","derivRoot","yDerivRoots_1","xRotRad","x90","y90","phiMin_1","phiMax","normalizeXiEta","xi","eta","phi","xDerivRoots_2","map","yDerivRoots_2","Infinity","T","TransformableSVG","this","ROUND","TO_REL","NORMALIZE_HVZ","A_TO_C","eps","SANITIZE","TRANSLATE","SCALE","ROTATE","SKEW_X","SKEW_Y","X_AXIS_SYMMETRY","Y_AXIS_SYMMETRY","ANNOTATE_ARCS","isWhiteSpace","isDigit","charCodeAt","_","_super","_this","__extends","SVGPathDataParser","parse","curArgs","canParseCommandOrComma","SyntaxError","finishCommand","push","isAArcFlag","curCommandType","curNumber","isEndingDigit","curNumberHasExp","curNumberHasExpDigits","curNumberHasDecimal","Number","COMMAND_ARG_COUNTS","curCommandRelative","Object","create","value","chunk","parsedCommands_1","getPrototypeOf","call","cT","content","encode","boundsTransform","CALCULATE_BOUNDS","transformFunction","newCommands","transformedCommand","path","parser","finish"],"sources":["/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/SVGPathDataEncoder.ts","/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/mathUtils.ts","/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/SVGPathDataTransformer.ts","/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/TransformableSVG.ts","/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/SVGPathDataParser.ts","/home/yasmin/rea de Trabalho/Frontend/node_modules/svg-pathdata/src/SVGPathData.ts"],"sourcesContent":["import { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand } from \"./types\";\n\n// Encode SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\n// Private consts : Char groups\nconst WSP = \" \";\n\nexport function encodeSVGPath(commands: SVGCommand | SVGCommand[]) {\n  let str = \"\";\n\n  if (!Array.isArray(commands)) {\n    commands = [commands];\n  }\n  for (let i = 0; i < commands.length; i++) {\n    const command = commands[i];\n    if (command.type === SVGPathData.CLOSE_PATH) {\n      str += \"z\";\n    } else if (command.type === SVGPathData.HORIZ_LINE_TO) {\n      str += (command.relative ? \"h\" : \"H\") +\n        command.x;\n    } else if (command.type === SVGPathData.VERT_LINE_TO) {\n      str += (command.relative ? \"v\" : \"V\") +\n        command.y;\n    } else if (command.type === SVGPathData.MOVE_TO) {\n      str += (command.relative ? \"m\" : \"M\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.LINE_TO) {\n      str += (command.relative ? \"l\" : \"L\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.CURVE_TO) {\n      str += (command.relative ? \"c\" : \"C\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_CURVE_TO) {\n      str += (command.relative ? \"s\" : \"S\") +\n        command.x2 + WSP + command.y2 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.QUAD_TO) {\n      str += (command.relative ? \"q\" : \"Q\") +\n        command.x1 + WSP + command.y1 +\n        WSP + command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.SMOOTH_QUAD_TO) {\n      str += (command.relative ? \"t\" : \"T\") +\n        command.x + WSP + command.y;\n    } else if (command.type === SVGPathData.ARC) {\n      str += (command.relative ? \"a\" : \"A\") +\n        command.rX + WSP + command.rY +\n        WSP + command.xRot +\n        WSP + (+command.lArcFlag) + WSP + (+command.sweepFlag) +\n        WSP + command.x + WSP + command.y;\n    } else {\n      // Unknown command\n      throw new Error(\n        `Unexpected command type \"${ (command as any).type}\" at index ${i}.`);\n    }\n  }\n\n  return str;\n}\n","import { SVGPathData } from \"./SVGPathData\";\nimport { CommandA, CommandC } from \"./types\";\n\nexport function rotate([x, y]: [number, number], rad: number) {\n  return [\n    x * Math.cos(rad) - y * Math.sin(rad),\n    x * Math.sin(rad) + y * Math.cos(rad),\n  ];\n}\n\nconst DEBUG_CHECK_NUMBERS = true;\nexport function assertNumbers(...numbers: number[]) {\n  if (DEBUG_CHECK_NUMBERS) {\n    for (let i = 0; i < numbers.length; i++) {\n      if (\"number\" !== typeof numbers[i]) {\n        throw new Error(\n          `assertNumbers arguments[${i}] is not a number. ${typeof numbers[i]} == typeof ${numbers[i]}`);\n      }\n    }\n  }\n  return true;\n}\n\nconst PI = Math.PI;\n\n/**\n * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n * Fixes rX and rY.\n * Ensures lArcFlag and sweepFlag are 0 or 1\n * Adds center coordinates: command.cX, command.cY (relative or absolute, depending on command.relative)\n * Adds start and end arc parameters (in degrees): command.phi1, command.phi2; phi1 < phi2 iff. c.sweepFlag == true\n */\nexport function annotateArcCommand(c: CommandA, x1: number, y1: number) {\n  c.lArcFlag = (0 === c.lArcFlag) ? 0 : 1;\n  c.sweepFlag = (0 === c.sweepFlag) ? 0 : 1;\n  // tslint:disable-next-line\n  let {rX, rY, x, y} = c;\n\n  rX = Math.abs(c.rX);\n  rY = Math.abs(c.rY);\n  const [x1_, y1_] = rotate([(x1 - x) / 2, (y1 - y) / 2], -c.xRot / 180 * PI);\n  const testValue = Math.pow(x1_, 2) / Math.pow(rX, 2) + Math.pow(y1_, 2) / Math.pow(rY, 2);\n\n  if (1 < testValue) {\n    rX *= Math.sqrt(testValue);\n    rY *= Math.sqrt(testValue);\n  }\n  c.rX = rX;\n  c.rY = rY;\n  const c_ScaleTemp = (Math.pow(rX, 2) * Math.pow(y1_, 2) + Math.pow(rY, 2) * Math.pow(x1_, 2));\n  const c_Scale = (c.lArcFlag !== c.sweepFlag ? 1 : -1) *\n    Math.sqrt(Math.max(0, (Math.pow(rX, 2) * Math.pow(rY, 2) - c_ScaleTemp) / c_ScaleTemp));\n  const cx_ = rX * y1_ / rY * c_Scale;\n  const cy_ = -rY * x1_ / rX * c_Scale;\n  const cRot = rotate([cx_, cy_], c.xRot / 180 * PI);\n\n  c.cX = cRot[0] + (x1 + x) / 2;\n  c.cY = cRot[1] + (y1 + y) / 2;\n  c.phi1 = Math.atan2((y1_ - cy_) / rY, (x1_ - cx_) / rX);\n  c.phi2 = Math.atan2((-y1_ - cy_) / rY, (-x1_ - cx_) / rX);\n  if (0 === c.sweepFlag && c.phi2 > c.phi1) {\n    c.phi2 -= 2 * PI;\n  }\n  if (1 === c.sweepFlag && c.phi2 < c.phi1) {\n    c.phi2 += 2 * PI;\n  }\n  c.phi1 *= 180 / PI;\n  c.phi2 *= 180 / PI;\n}\n\n/**\n * Solves a quadratic system of equations of the form\n *      a * x + b * y = c\n *      x + y = 1\n * This can be understood as the intersection of the unit circle with a line.\n *      => y = (c - a x) / b\n *      => x + (c - a x) / b = 1\n *      => x b + c - 2 c a x + a x = b\n *      => (a + b) x - 2 a c x + (c - b) = 0\n */\nexport function intersectionUnitCircleLine(a: number, b: number, c: number): [number, number][] {\n  assertNumbers(a, b, c);\n  // cf. pqFormula\n  const termSqr = a * a + b * b - c * c;\n\n  if (0 > termSqr) {\n    return [];\n  } else if (0 === termSqr) {\n    return [\n      [\n        (a * c) / (a * a + b * b),\n        (b * c) / (a * a + b * b)]];\n  }\n  const term = Math.sqrt(termSqr);\n\n  return [\n    [\n      (a * c + b * term) / (a * a + b * b),\n      (b * c - a * term) / (a * a + b * b)],\n    [\n      (a * c - b * term) / (a * a + b * b),\n      (b * c + a * term) / (a * a + b * b)]];\n\n}\n\nexport const DEG = Math.PI / 180;\n\nexport function lerp(a: number, b: number, t: number) {\n  return (1 - t) * a + t * b;\n}\n\nexport function arcAt(c: number, x1: number, x2: number, phiDeg: number) {\n  return c + Math.cos(phiDeg / 180 * PI) * x1 + Math.sin(phiDeg / 180 * PI) * x2;\n}\n\nexport function bezierRoot(x0: number, x1: number, x2: number, x3: number) {\n  const EPS = 1e-6;\n  const x01 = x1 - x0;\n  const x12 = x2 - x1;\n  const x23 = x3 - x2;\n  const a = 3 * x01 + 3 * x23 - 6 * x12;\n  const b = (x12 - x01) * 6;\n  const c = 3 * x01;\n  // solve a * t + b * t + c = 0\n\n  if (Math.abs(a) < EPS) {\n    // equivalent to b * t + c =>\n    return [-c / b];\n  }\n  return pqFormula(b / a, c / a, EPS);\n\n}\n\nexport function bezierAt(x0: number, x1: number, x2: number, x3: number, t: number) {\n  // console.log(x0, y0, x1, y1, x2, y2, x3, y3, t)\n  const s = 1 - t;\n  const c0 = s * s * s;\n  const c1 = 3 * s * s * t;\n  const c2 = 3 * s * t * t;\n  const c3 = t * t * t;\n\n  return x0 * c0 + x1 * c1 + x2 * c2 + x3 * c3;\n}\n\nfunction pqFormula(p: number, q: number, PRECISION = 1e-6) {\n  // 4 times the discriminant:in\n  const discriminantX4 = p * p / 4 - q;\n\n  if (discriminantX4 < -PRECISION) {\n    return [];\n  } else if (discriminantX4 <= PRECISION) {\n    return [-p / 2];\n  }\n  const root = Math.sqrt(discriminantX4);\n\n  return [-(p / 2) - root, -(p / 2) + root];\n\n}\n\nexport function a2c(arc: CommandA, x0: number, y0: number): CommandC[] {\n  if (!arc.cX) {\n    annotateArcCommand(arc, x0, y0);\n  }\n\n  const phiMin = Math.min(arc.phi1!, arc.phi2!), phiMax = Math.max(arc.phi1!, arc.phi2!), deltaPhi = phiMax - phiMin;\n  const partCount = Math.ceil(deltaPhi / 90 );\n\n  const result: CommandC[] = new Array(partCount);\n  let prevX = x0, prevY = y0;\n  for (let i = 0; i < partCount; i++) {\n    const phiStart = lerp(arc.phi1!, arc.phi2!, i / partCount);\n    const phiEnd = lerp(arc.phi1!, arc.phi2!, (i + 1) / partCount);\n    const deltaPhi = phiEnd - phiStart;\n    const f = 4 / 3 * Math.tan(deltaPhi * DEG / 4);\n    // x1/y1, x2/y2 and x/y coordinates on the unit circle for phiStart/phiEnd\n    const [x1, y1] = [\n      Math.cos(phiStart * DEG) - f * Math.sin(phiStart * DEG),\n      Math.sin(phiStart * DEG) + f * Math.cos(phiStart * DEG)];\n    const [x, y] = [Math.cos(phiEnd * DEG), Math.sin(phiEnd * DEG)];\n    const [x2, y2] = [x + f * Math.sin(phiEnd * DEG), y - f * Math.cos(phiEnd * DEG)];\n    result[i] = {relative: arc.relative, type: SVGPathData.CURVE_TO } as any;\n    const transform = (x: number, y: number) => {\n      const [xTemp, yTemp] = rotate([x * arc.rX, y * arc.rY], arc.xRot);\n      return [arc.cX! + xTemp, arc.cY! + yTemp];\n    };\n    [result[i].x1, result[i].y1] = transform(x1, y1);\n    [result[i].x2, result[i].y2] = transform(x2, y2);\n    [result[i].x, result[i].y] = transform(x, y);\n    if (arc.relative) {\n      result[i].x1 -= prevX;\n      result[i].y1 -= prevY;\n      result[i].x2 -= prevX;\n      result[i].y2 -= prevY;\n      result[i].x -= prevX;\n      result[i].y -= prevY;\n    }\n    [prevX, prevY] = [result[i].x, result[i].y];\n  }\n  return result;\n}\n","// Transform SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\n\nimport { a2c, annotateArcCommand, arcAt, assertNumbers, bezierAt, bezierRoot,\n  intersectionUnitCircleLine } from \"./mathUtils\";\nimport { SVGPathData } from \"./SVGPathData\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n\nexport namespace SVGPathDataTransformer {\n  // Predefined transforming functions\n  // Rounds commands values\n  export function ROUND(roundVal = 1e13) {\n    assertNumbers(roundVal);\n    function rf(val: number) { return Math.round(val * roundVal) / roundVal; }\n    return function round(command: any) {\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = rf(command.x1);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = rf(command.y1);\n      }\n\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = rf(command.x2);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = rf(command.y2);\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = rf(command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = rf(command.y);\n      }\n\n      if (\"undefined\" !== typeof command.rX) {\n        command.rX = rf(command.rX);\n      }\n      if (\"undefined\" !== typeof command.rY) {\n        command.rY = rf(command.rY);\n      }\n\n      return command;\n    };\n  }\n  // Relative to absolute commands\n  export function TO_ABS() {\n    return INFO((command, prevX, prevY) => {\n      if (command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 += prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 += prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 += prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x += prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y += prevY;\n        }\n        command.relative = false;\n      }\n      return command;\n    });\n  }\n  // Absolute to relative commands\n  export function TO_REL() {\n    return INFO((command, prevX, prevY) => {\n      if (!command.relative) {\n        // x1/y1 values\n        if (\"undefined\" !== typeof command.x1) {\n          command.x1 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y1) {\n          command.y1 -= prevY;\n        }\n        // x2/y2 values\n        if (\"undefined\" !== typeof command.x2) {\n          command.x2 -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y2) {\n          command.y2 -= prevY;\n        }\n        // Finally x/y values\n        if (\"undefined\" !== typeof command.x) {\n          command.x -= prevX;\n        }\n        if (\"undefined\" !== typeof command.y) {\n          command.y -= prevY;\n        }\n        command.relative = true;\n      }\n      return command;\n    });\n  }\n  // Convert H, V, Z and A with rX = 0 to L\n  export function NORMALIZE_HVZ(normalizeZ = true, normalizeH = true, normalizeV = true) {\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      if (isNaN(pathStartX) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n      if (normalizeH && command.type & SVGPathData.HORIZ_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (normalizeV && command.type & SVGPathData.VERT_LINE_TO) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n      if (normalizeZ && command.type & SVGPathData.CLOSE_PATH) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? pathStartX - prevX : pathStartX;\n        command.y = command.relative ? pathStartY - prevY : pathStartY;\n      }\n      if (command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY)) {\n        command.type = SVGPathData.LINE_TO;\n        delete command.rX;\n        delete command.rY;\n        delete command.xRot;\n        delete command.lArcFlag;\n        delete command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  /*\n   * Transforms smooth curves and quads to normal curves and quads (SsTt to CcQq)\n   */\n  export function NORMALIZE_ST() {\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        command.type = SVGPathData.CURVE_TO;\n        prevCurveC2X = isNaN(prevCurveC2X) ? prevX : prevCurveC2X;\n        prevCurveC2Y = isNaN(prevCurveC2Y) ? prevY : prevCurveC2Y;\n        command.x1 = command.relative ? prevX - prevCurveC2X : 2 * prevX - prevCurveC2X;\n        command.y1 = command.relative ? prevY - prevCurveC2Y : 2 * prevY - prevCurveC2Y;\n      }\n      if (command.type & SVGPathData.CURVE_TO) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : prevQuadCY;\n        command.x1 = command.relative ? prevX - prevQuadCX : 2 * prevX - prevQuadCX;\n        command.y1 = command.relative ? prevY - prevQuadCY : 2 * prevY - prevQuadCY;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y1;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      return command;\n    });\n  }\n  /*\n   * A quadratic bzier curve can be represented by a cubic bzier curve which has\n   * the same end points as the quadratic and both control points in place of the\n   * quadratic\"s one.\n   *\n   * This transformer replaces QqTt commands with Cc commands respectively.\n   * This is useful for reading path data into a system which only has a\n   * representation for cubic curves.\n   */\n  export function QT_TO_C() {\n    let prevQuadX1 = NaN;\n    let prevQuadY1 = NaN;\n\n    return INFO((command, prevX, prevY) => {\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        command.type = SVGPathData.QUAD_TO;\n        prevQuadX1 = isNaN(prevQuadX1) ? prevX : prevQuadX1;\n        prevQuadY1 = isNaN(prevQuadY1) ? prevY : prevQuadY1;\n        command.x1 = command.relative ? prevX - prevQuadX1 : 2 * prevX - prevQuadX1;\n        command.y1 = command.relative ? prevY - prevQuadY1 : 2 * prevY - prevQuadY1;\n      }\n      if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadX1 = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadY1 = command.relative ? prevY + command.y1 : command.y1;\n        const x1 = command.x1;\n        const y1 = command.y1;\n\n        command.type = SVGPathData.CURVE_TO;\n        command.x1 = ((command.relative ? 0 : prevX) + x1 * 2) / 3;\n        command.y1 = ((command.relative ? 0 : prevY) + y1 * 2) / 3;\n        command.x2 = (command.x + x1 * 2) / 3;\n        command.y2 = (command.y + y1 * 2) / 3;\n      } else {\n        prevQuadX1 = NaN;\n        prevQuadY1 = NaN;\n      }\n\n      return command;\n    });\n  }\n  export function INFO(\n    f: (command: any, prevXAbs: number, prevYAbs: number,\n        pathStartXAbs: number, pathStartYAbs: number) => any | any[]) {\n    let prevXAbs = 0;\n    let prevYAbs = 0;\n    let pathStartXAbs = NaN;\n    let pathStartYAbs = NaN;\n\n    return function transform(command: any) {\n      if (isNaN(pathStartXAbs) && !(command.type & SVGPathData.MOVE_TO)) {\n        throw new Error(\"path must start with moveto\");\n      }\n\n      const result = f(command, prevXAbs, prevYAbs, pathStartXAbs, pathStartYAbs);\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        prevXAbs = pathStartXAbs;\n        prevYAbs = pathStartYAbs;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        prevXAbs = (command.relative ? prevXAbs + command.x : command.x);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        prevYAbs = (command.relative ? prevYAbs + command.y : command.y);\n      }\n\n      if (command.type & SVGPathData.MOVE_TO) {\n        pathStartXAbs = prevXAbs;\n        pathStartYAbs = prevYAbs;\n      }\n\n      return result;\n    };\n  }\n  /*\n   * remove 0-length segments\n   */\n  export function SANITIZE(EPS = 0) {\n    assertNumbers(EPS);\n    let prevCurveC2X = NaN;\n    let prevCurveC2Y = NaN;\n    let prevQuadCX = NaN;\n    let prevQuadCY = NaN;\n\n    return INFO((command, prevX, prevY, pathStartX, pathStartY) => {\n      const abs = Math.abs;\n      let skip = false;\n      let x1Rel = 0;\n      let y1Rel = 0;\n\n      if (command.type & SVGPathData.SMOOTH_CURVE_TO) {\n        x1Rel = isNaN(prevCurveC2X) ? 0 : prevX - prevCurveC2X;\n        y1Rel = isNaN(prevCurveC2Y) ? 0 : prevY - prevCurveC2Y;\n      }\n      if (command.type & (SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO)) {\n        prevCurveC2X = command.relative ? prevX + command.x2 : command.x2;\n        prevCurveC2Y = command.relative ? prevY + command.y2 : command.y2;\n      } else {\n        prevCurveC2X = NaN;\n        prevCurveC2Y = NaN;\n      }\n      if (command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        prevQuadCX = isNaN(prevQuadCX) ? prevX : 2 * prevX - prevQuadCX;\n        prevQuadCY = isNaN(prevQuadCY) ? prevY : 2 * prevY - prevQuadCY;\n      } else if (command.type & SVGPathData.QUAD_TO) {\n        prevQuadCX = command.relative ? prevX + command.x1 : command.x1;\n        prevQuadCY = command.relative ? prevY + command.y1 : command.y2;\n      } else {\n        prevQuadCX = NaN;\n        prevQuadCY = NaN;\n      }\n\n      if (command.type & SVGPathData.LINE_COMMANDS ||\n        command.type & SVGPathData.ARC && (0 === command.rX || 0 === command.rY || !command.lArcFlag) ||\n        command.type & SVGPathData.CURVE_TO || command.type & SVGPathData.SMOOTH_CURVE_TO ||\n        command.type & SVGPathData.QUAD_TO || command.type & SVGPathData.SMOOTH_QUAD_TO) {\n        const xRel = \"undefined\" === typeof command.x ? 0 :\n          (command.relative ? command.x : command.x - prevX);\n        const yRel = \"undefined\" === typeof command.y ? 0 :\n          (command.relative ? command.y : command.y - prevY);\n\n        x1Rel = !isNaN(prevQuadCX) ? prevQuadCX - prevX :\n          \"undefined\" === typeof command.x1 ? x1Rel :\n            command.relative ? command.x :\n              command.x1 - prevX;\n        y1Rel = !isNaN(prevQuadCY) ? prevQuadCY - prevY :\n          \"undefined\" === typeof command.y1 ? y1Rel :\n            command.relative ? command.y :\n              command.y1 - prevY;\n\n        const x2Rel = \"undefined\" === typeof command.x2 ? 0 :\n          (command.relative ? command.x : command.x2 - prevX);\n        const y2Rel = \"undefined\" === typeof command.y2 ? 0 :\n          (command.relative ? command.y : command.y2 - prevY);\n\n        if (abs(xRel) <= EPS && abs(yRel) <= EPS &&\n          abs(x1Rel) <= EPS && abs(y1Rel) <= EPS &&\n          abs(x2Rel) <= EPS && abs(y2Rel) <= EPS) {\n          skip = true;\n        }\n      }\n\n      if (command.type & SVGPathData.CLOSE_PATH) {\n        if (abs(prevX - pathStartX) <= EPS && abs(prevY - pathStartY) <= EPS) {\n          skip = true;\n        }\n      }\n\n      return skip ? [] : command;\n    });\n  }\n  // SVG Transforms : http://www.w3.org/TR/SVGTiny12/coords.html#TransformList\n  // Matrix : http://apike.ca/prog_svg_transform.html\n  // a c e\n  // b d f\n  export function MATRIX(a: number, b: number, c: number, d: number, e: number, f: number) {\n    assertNumbers(a, b, c, d, e, f);\n\n    return INFO((command, prevX, prevY, pathStartX) => {\n      const origX1 = command.x1;\n      const origX2 = command.x2;\n      // if isNaN(pathStartX), then this is the first command, which is ALWAYS an\n      // absolute MOVE_TO, regardless what the relative flag says\n      const comRel = command.relative && !isNaN(pathStartX);\n      const x = \"undefined\" !== typeof command.x ? command.x : (comRel ? 0 : prevX);\n      const y = \"undefined\" !== typeof command.y ? command.y : (comRel ? 0 : prevY);\n\n      if (command.type & SVGPathData.HORIZ_LINE_TO && 0 !== b) {\n        command.type = SVGPathData.LINE_TO;\n        command.y = command.relative ? 0 : prevY;\n      }\n      if (command.type & SVGPathData.VERT_LINE_TO && 0 !== c) {\n        command.type = SVGPathData.LINE_TO;\n        command.x = command.relative ? 0 : prevX;\n      }\n\n      if (\"undefined\" !== typeof command.x) {\n        command.x = (command.x * a) + (y * c) + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y) {\n        command.y = (x * b) + command.y * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x1) {\n        command.x1 = command.x1 * a + command.y1 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y1) {\n        command.y1 = origX1 * b + command.y1 * d + (comRel ? 0 : f);\n      }\n      if (\"undefined\" !== typeof command.x2) {\n        command.x2 = command.x2 * a + command.y2 * c + (comRel ? 0 : e);\n      }\n      if (\"undefined\" !== typeof command.y2) {\n        command.y2 = origX2 * b + command.y2 * d + (comRel ? 0 : f);\n      }\n      function sqr(x: number) { return x * x; }\n      const det = a * d - b * c;\n\n      if (\"undefined\" !== typeof command.xRot) {\n        // Skip if this is a pure translation\n        if (1 !== a || 0 !== b || 0 !== c || 1 !== d) {\n          // Special case for singular matrix\n          if (0 === det) {\n            // In the singular case, the arc is compressed to a line. The actual geometric image of the original\n            // curve under this transform possibly extends beyond the starting and/or ending points of the segment, but\n            // for simplicity we ignore this detail and just replace this command with a single line segment.\n            delete command.rX;\n            delete command.rY;\n            delete command.xRot;\n            delete command.lArcFlag;\n            delete command.sweepFlag;\n            command.type = SVGPathData.LINE_TO;\n          } else {\n            // Convert to radians\n            const xRot = command.xRot * Math.PI / 180;\n\n            // Convert rotated ellipse to general conic form\n            // x0^2/rX^2 + y0^2/rY^2 - 1 = 0\n            // x0 = x*cos(xRot) + y*sin(xRot)\n            // y0 = -x*sin(xRot) + y*cos(xRot)\n            // --> A*x^2 + B*x*y + C*y^2 - 1 = 0, where\n            const sinRot = Math.sin(xRot);\n            const cosRot = Math.cos(xRot);\n            const xCurve = 1 / sqr(command.rX);\n            const yCurve = 1 / sqr(command.rY);\n            const A = sqr(cosRot) * xCurve + sqr(sinRot) * yCurve;\n            const B = 2 * sinRot * cosRot * (xCurve - yCurve);\n            const C = sqr(sinRot) * xCurve + sqr(cosRot) * yCurve;\n\n            // Apply matrix to A*x^2 + B*x*y + C*y^2 - 1 = 0\n            // x1 = a*x + c*y\n            // y1 = b*x + d*y\n            //      (we can ignore e and f, since pure translations don\"t affect the shape of the ellipse)\n            // --> A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 = 0, where\n            const A1 = A * d * d - B * b * d + C * b * b;\n            const B1 = B * (a * d + b * c) - 2 * (A * c * d + C * a * b);\n            const C1 = A * c * c - B * a * c + C * a * a;\n\n            // Unapply newXRot to get back to axis-aligned ellipse equation\n            // x1 = x2*cos(newXRot) - y2*sin(newXRot)\n            // y1 = x2*sin(newXRot) + y2*cos(newXRot)\n            // A1*x1^2 + B1*x1*y1 + C1*y1^2 - det^2 =\n            //   x2^2*(A1*cos(newXRot)^2 + B1*sin(newXRot)*cos(newXRot) + C1*sin(newXRot)^2)\n            //   + x2*y2*(2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2))\n            //   + y2^2*(A1*sin(newXRot)^2 - B1*sin(newXRot)*cos(newXRot) + C1*cos(newXRot)^2)\n            //   (which must have the same zeroes as)\n            // x2^2/newRX^2 + y2^2/newRY^2 - 1\n            //   (so we have)\n            // 2*(C1 - A1)*sin(newXRot)*cos(newXRot) + B1*(cos(newXRot)^2 - sin(newXRot)^2) = 0\n            // (A1 - C1)*sin(2*newXRot) = B1*cos(2*newXRot)\n            // 2*newXRot = atan2(B1, A1 - C1)\n            const newXRot = ((Math.atan2(B1, A1 - C1) + Math.PI) % Math.PI) / 2;\n            // For any integer n, (atan2(B1, A1 - C1) + n*pi)/2 is a solution to the above; incrementing n just swaps\n            // the x and y radii computed below (since that\"s what rotating an ellipse by pi/2 does).  Choosing the\n            // rotation between 0 and pi/2 eliminates the ambiguity and leads to more predictable output.\n\n            // Finally, we get newRX and newRY from the same-zeroes relationship that gave us newXRot\n            const newSinRot = Math.sin(newXRot);\n            const newCosRot = Math.cos(newXRot);\n\n            command.rX = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newCosRot) + B1 * newSinRot * newCosRot + C1 * sqr(newSinRot));\n            command.rY = Math.abs(det) /\n              Math.sqrt(A1 * sqr(newSinRot) - B1 * newSinRot * newCosRot + C1 * sqr(newCosRot));\n            command.xRot = newXRot * 180 / Math.PI;\n          }\n        }\n      }\n      // sweepFlag needs to be inverted when mirroring shapes\n      // see http://www.itk.ilstu.edu/faculty/javila/SVG/SVG_drawing1/elliptical_curve.htm\n      // m 65,10 a 50,25 0 1 0 50,25\n      // M 65,60 A 50,25 0 1 1 115,35\n      if (\"undefined\" !== typeof command.sweepFlag && 0 > det) {\n        command.sweepFlag = +!command.sweepFlag;\n      }\n      return command;\n    });\n  }\n  export function ROTATE(a: number, x = 0, y = 0) {\n    assertNumbers(a, x, y);\n    const sin = Math.sin(a);\n    const cos = Math.cos(a);\n\n    return MATRIX(cos, sin, -sin, cos, x - x * cos + y * sin, y - x * sin - y * cos);\n  }\n  export function TRANSLATE(dX: number, dY = 0) {\n    assertNumbers(dX, dY);\n    return MATRIX(1, 0, 0, 1, dX, dY);\n  }\n  export function SCALE(dX: number, dY = dX) {\n    assertNumbers(dX, dY);\n    return MATRIX(dX, 0, 0, dY, 0, 0);\n  }\n  export function SKEW_X(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, 0, Math.atan(a), 1, 0, 0);\n  }\n  export function SKEW_Y(a: number) {\n    assertNumbers(a);\n    return MATRIX(1, Math.atan(a), 0, 1, 0, 0);\n  }\n  export function X_AXIS_SYMMETRY(xOffset = 0) {\n    assertNumbers(xOffset);\n    return MATRIX(-1, 0, 0, 1, xOffset, 0);\n  }\n  export function Y_AXIS_SYMMETRY(yOffset = 0) {\n    assertNumbers(yOffset);\n    return MATRIX(1, 0, 0, -1, 0, yOffset);\n  }\n  // Convert arc commands to curve commands\n  export function A_TO_C() {\n    return INFO((command, prevX, prevY) => {\n      if (SVGPathData.ARC === command.type) {\n        return a2c(command, command.relative ? 0 : prevX, command.relative ? 0 : prevY);\n      }\n      return command;\n    });\n  }\n  // @see annotateArcCommand\n  export function ANNOTATE_ARCS() {\n    return INFO((c, x1, y1) => {\n      if (c.relative) {\n        x1 = 0;\n        y1 = 0;\n      }\n      if (SVGPathData.ARC === c.type) {\n        annotateArcCommand(c, x1, y1);\n      }\n      return c;\n    });\n  }\n  export function CLONE() {\n    return (c: SVGCommand) => {\n      const result = {} as SVGCommand;\n      // tslint:disable-next-line\n      for (const key in c) {\n        result[key as keyof SVGCommand] = c[key as keyof SVGCommand];\n      }\n      return result;\n    };\n  }\n  // @see annotateArcCommand\n  export function CALCULATE_BOUNDS() {\n    const clone = CLONE();\n    const toAbs = TO_ABS();\n    const qtToC = QT_TO_C();\n    const normST = NORMALIZE_ST();\n    const f: TransformFunction & {minX: number, maxX: number, minY: number, maxY: number} =\n        INFO((command, prevXAbs, prevYAbs) => {\n      const c = normST(qtToC(toAbs(clone(command))));\n      function fixX(absX: number) {\n        if (absX > f.maxX) { f.maxX = absX; }\n        if (absX < f.minX) { f.minX = absX; }\n      }\n      function fixY(absY: number) {\n        if (absY > f.maxY) { f.maxY = absY; }\n        if (absY < f.minY) { f.minY = absY; }\n      }\n      if (c.type & SVGPathData.DRAWING_COMMANDS) {\n        fixX(prevXAbs);\n        fixY(prevYAbs);\n      }\n      if (c.type & SVGPathData.HORIZ_LINE_TO) {\n        fixX(c.x);\n      }\n      if (c.type & SVGPathData.VERT_LINE_TO) {\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.LINE_TO) {\n        fixX(c.x);\n        fixY(c.y);\n      }\n      if (c.type & SVGPathData.CURVE_TO) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        const xDerivRoots = bezierRoot(prevXAbs, c.x1, c.x2, c.x);\n\n        for (const derivRoot of xDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixX(bezierAt(prevXAbs, c.x1, c.x2, c.x, derivRoot));\n          }\n        }\n        const yDerivRoots = bezierRoot(prevYAbs, c.y1, c.y2, c.y);\n\n        for (const derivRoot of yDerivRoots) {\n          if (0 < derivRoot && 1 > derivRoot) {\n            fixY(bezierAt(prevYAbs, c.y1, c.y2, c.y, derivRoot));\n          }\n        }\n      }\n      if (c.type & SVGPathData.ARC) {\n        // add start and end points\n        fixX(c.x);\n        fixY(c.y);\n        annotateArcCommand(c, prevXAbs, prevYAbs);\n        // p = cos(phi) * xv + sin(phi) * yv\n        // dp = -sin(phi) * xv + cos(phi) * yv = 0\n        const xRotRad = c.xRot / 180 * Math.PI;\n        // points on ellipse for phi = 0 and phi = 90\n        const x0 = Math.cos(xRotRad) * c.rX;\n        const y0 = Math.sin(xRotRad) * c.rX;\n        const x90 = -Math.sin(xRotRad) * c.rY;\n        const y90 = Math.cos(xRotRad) * c.rY;\n\n        // annotateArcCommand returns phi1 and phi2 such that -180 < phi1 < 180 and phi2 is smaller or greater\n        // depending on the sweep flag. Calculate phiMin, phiMax such that -180 < phiMin < 180 and phiMin < phiMax\n        const [phiMin, phiMax] = c.phi1 < c.phi2 ?\n          [c.phi1, c.phi2] :\n          (-180 > c.phi2 ? [c.phi2 + 360, c.phi1 + 360] : [c.phi2, c.phi1]);\n        const normalizeXiEta = ([xi, eta]: [number, number]) => {\n          const phiRad = Math.atan2(eta, xi);\n          const phi = phiRad * 180 / Math.PI;\n\n          return phi < phiMin ? phi + 360 : phi;\n        };\n        // xi = cos(phi), eta = sin(phi)\n\n        const xDerivRoots = intersectionUnitCircleLine(x90, -x0, 0).map(normalizeXiEta);\n        for (const derivRoot of xDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixX(arcAt(c.cX, x0, x90, derivRoot));\n          }\n        }\n\n        const yDerivRoots = intersectionUnitCircleLine(y90, -y0, 0).map(normalizeXiEta);\n        for (const derivRoot of yDerivRoots) {\n          if (derivRoot > phiMin && derivRoot < phiMax) {\n            fixY(arcAt(c.cY, y0, y90, derivRoot));\n          }\n        }\n      }\n      return command;\n    }) as any;\n\n    f.minX = Infinity;\n    f.maxX = -Infinity;\n    f.minY = Infinity;\n    f.maxY = -Infinity;\n    return f;\n  }\n}\n","import { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformFunction } from \"./types\";\n\nexport abstract class TransformableSVG {\n  round(x?: number) {\n    return this.transform(SVGPathDataTransformer.ROUND(x));\n  }\n\n  toAbs() {\n    return this.transform(SVGPathDataTransformer.TO_ABS());\n  }\n\n  toRel() {\n    return this.transform(SVGPathDataTransformer.TO_REL());\n  }\n\n  normalizeHVZ(a?: boolean, b?: boolean, c?: boolean) {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_HVZ(a, b, c));\n  }\n\n  normalizeST() {\n    return this.transform(SVGPathDataTransformer.NORMALIZE_ST());\n  }\n\n  qtToC() {\n    return this.transform(SVGPathDataTransformer.QT_TO_C());\n  }\n\n  aToC() {\n    return this.transform(SVGPathDataTransformer.A_TO_C());\n  }\n\n  sanitize(eps?: number) {\n    return this.transform(SVGPathDataTransformer.SANITIZE(eps));\n  }\n\n  translate(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.TRANSLATE(x, y));\n  }\n\n  scale(x: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.SCALE(x, y));\n  }\n\n  rotate(a: number, x?: number, y?: number) {\n    return this.transform(SVGPathDataTransformer.ROTATE(a, x, y));\n  }\n\n  matrix(a: number, b: number, c: number, d: number, e: number, f: number) {\n    return this.transform(SVGPathDataTransformer.MATRIX(a, b, c, d, e, f));\n  }\n\n  skewX(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_X(a));\n  }\n\n  skewY(a: number) {\n    return this.transform(SVGPathDataTransformer.SKEW_Y(a));\n  }\n\n  xSymmetry(xOffset?: number) {\n    return this.transform(SVGPathDataTransformer.X_AXIS_SYMMETRY(xOffset));\n  }\n\n  ySymmetry(yOffset?: number) {\n    return this.transform(SVGPathDataTransformer.Y_AXIS_SYMMETRY(yOffset));\n  }\n\n  annotateArcs() {\n    return this.transform(SVGPathDataTransformer.ANNOTATE_ARCS());\n  }\n\n  abstract transform(transformFunction: TransformFunction): this;\n}\n","// Parse SVG PathData\n// http://www.w3.org/TR/SVG/paths.html#PathDataBNF\nimport { COMMAND_ARG_COUNTS, SVGPathData } from \"./SVGPathData\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand, TransformFunction } from \"./types\";\n// Private consts : Char groups\nconst isWhiteSpace = (c: string) =>\n  \" \" === c || \"\\t\" === c || \"\\r\" === c || \"\\n\" === c;\nconst isDigit = (c: string) =>\n  \"0\".charCodeAt(0) <= c.charCodeAt(0) && c.charCodeAt(0) <= \"9\".charCodeAt(0);\nconst COMMANDS = \"mMzZlLhHvVcCsSqQtTaA\";\n\nexport class SVGPathDataParser extends TransformableSVG {\n  private curNumber: string = \"\";\n  private curCommandType: SVGCommand[\"type\"] | -1 = -1;\n  private curCommandRelative = false;\n  private canParseCommandOrComma = true;\n  private curNumberHasExp = false;\n  private curNumberHasExpDigits = false;\n  private curNumberHasDecimal = false;\n  private curArgs: number[] = [];\n\n  constructor() {\n    super();\n  }\n\n  finish(commands: SVGCommand[] = []) {\n    this.parse(\" \", commands);\n    // Adding residual command\n    if (0 !== this.curArgs.length || !this.canParseCommandOrComma) {\n      throw new SyntaxError(\"Unterminated command at the path end.\");\n    }\n    return commands;\n  }\n\n  parse(str: string, commands: SVGCommand[] = []) {\n    const finishCommand = (command: SVGCommand) => {\n      commands.push(command);\n      this.curArgs.length = 0;\n      this.canParseCommandOrComma = true;\n    };\n\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      // White spaces parsing\n      const isAArcFlag = this.curCommandType === SVGPathData.ARC &&\n        (this.curArgs.length === 3 || this.curArgs.length === 4) &&\n        this.curNumber.length === 1 &&\n        (this.curNumber === \"0\" || this.curNumber === \"1\");\n      const isEndingDigit = isDigit(c) && (\n        (this.curNumber === \"0\" && c === \"0\") ||\n        isAArcFlag\n      );\n\n      if (\n        isDigit(c) &&\n        !isEndingDigit\n      ) {\n        this.curNumber += c;\n        this.curNumberHasExpDigits = this.curNumberHasExp;\n        continue;\n      }\n      if (\"e\" === c || \"E\" === c) {\n        this.curNumber += c;\n        this.curNumberHasExp = true;\n        continue;\n      }\n      if (\n        (\"-\" === c || \"+\" === c) &&\n        this.curNumberHasExp &&\n        !this.curNumberHasExpDigits\n      ) {\n        this.curNumber += c;\n        continue;\n      }\n      // if we already have a \".\", it means we are starting a new number\n      if (\".\" === c && !this.curNumberHasExp && !this.curNumberHasDecimal && !isAArcFlag) {\n        this.curNumber += c;\n        this.curNumberHasDecimal = true;\n        continue;\n      }\n\n      // New number\n      if (this.curNumber && -1 !== this.curCommandType) {\n        const val = Number(this.curNumber);\n        if (isNaN(val)) {\n          throw new SyntaxError(`Invalid number ending at ${i}`);\n        }\n        if (this.curCommandType === SVGPathData.ARC) {\n          if (0 === this.curArgs.length || 1 === this.curArgs.length) {\n            if (0 > val) {\n              throw new SyntaxError(\n                `Expected positive number, got \"${val}\" at index \"${i}\"`,\n              );\n            }\n          } else if (3 === this.curArgs.length || 4 === this.curArgs.length) {\n            if (\"0\" !== this.curNumber && \"1\" !== this.curNumber) {\n              throw new SyntaxError(\n                `Expected a flag, got \"${this.curNumber}\" at index \"${i}\"`,\n              );\n            }\n          }\n        }\n        this.curArgs.push(val);\n        if (this.curArgs.length === COMMAND_ARG_COUNTS[this.curCommandType]) {\n          if (SVGPathData.HORIZ_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.HORIZ_LINE_TO,\n              relative: this.curCommandRelative,\n              x: val,\n            });\n          } else if (SVGPathData.VERT_LINE_TO === this.curCommandType) {\n            finishCommand({\n              type: SVGPathData.VERT_LINE_TO,\n              relative: this.curCommandRelative,\n              y: val,\n            });\n            // Move to / line to / smooth quadratic curve to commands (x, y)\n          } else if (\n            this.curCommandType === SVGPathData.MOVE_TO ||\n            this.curCommandType === SVGPathData.LINE_TO ||\n            this.curCommandType === SVGPathData.SMOOTH_QUAD_TO\n          ) {\n            finishCommand({\n              type: this.curCommandType,\n              relative: this.curCommandRelative,\n              x: this.curArgs[0],\n              y: this.curArgs[1],\n            } as SVGCommand);\n            // Switch to line to state\n            if (SVGPathData.MOVE_TO === this.curCommandType) {\n              this.curCommandType = SVGPathData.LINE_TO;\n            }\n          } else if (this.curCommandType === SVGPathData.CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.CURVE_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x2: this.curArgs[2],\n              y2: this.curArgs[3],\n              x: this.curArgs[4],\n              y: this.curArgs[5],\n            });\n          } else if (this.curCommandType === SVGPathData.SMOOTH_CURVE_TO) {\n            finishCommand({\n              type: SVGPathData.SMOOTH_CURVE_TO,\n              relative: this.curCommandRelative,\n              x2: this.curArgs[0],\n              y2: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.QUAD_TO) {\n            finishCommand({\n              type: SVGPathData.QUAD_TO,\n              relative: this.curCommandRelative,\n              x1: this.curArgs[0],\n              y1: this.curArgs[1],\n              x: this.curArgs[2],\n              y: this.curArgs[3],\n            });\n          } else if (this.curCommandType === SVGPathData.ARC) {\n            finishCommand({\n              type: SVGPathData.ARC,\n              relative: this.curCommandRelative,\n              rX: this.curArgs[0],\n              rY: this.curArgs[1],\n              xRot: this.curArgs[2],\n              lArcFlag: this.curArgs[3] as 0 | 1,\n              sweepFlag: this.curArgs[4] as 0 | 1,\n              x: this.curArgs[5],\n              y: this.curArgs[6],\n            });\n          }\n        }\n        this.curNumber = \"\";\n        this.curNumberHasExpDigits = false;\n        this.curNumberHasExp = false;\n        this.curNumberHasDecimal = false;\n        this.canParseCommandOrComma = true;\n      }\n      // Continue if a white space or a comma was detected\n      if (isWhiteSpace(c)) {\n        continue;\n      }\n      if (\",\" === c && this.canParseCommandOrComma) {\n        // L 0,0, H is not valid:\n        this.canParseCommandOrComma = false;\n        continue;\n      }\n      // if a sign is detected, then parse the new number\n      if (\"+\" === c || \"-\" === c || \".\" === c) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = \".\" === c;\n        continue;\n      }\n      // if a 0 is detected, then parse the new number\n      if (isEndingDigit) {\n        this.curNumber = c;\n        this.curNumberHasDecimal = false;\n        continue;\n      }\n\n      // Adding residual command\n      if (0 !== this.curArgs.length) {\n        throw new SyntaxError(`Unterminated command at index ${i}.`);\n      }\n      if (!this.canParseCommandOrComma) {\n        throw new SyntaxError(\n          `Unexpected character \"${c}\" at index ${i}. Command cannot follow comma`,\n        );\n      }\n      this.canParseCommandOrComma = false;\n      // Detecting the next command\n      if (\"z\" === c || \"Z\" === c) {\n        commands.push({\n          type: SVGPathData.CLOSE_PATH,\n        });\n        this.canParseCommandOrComma = true;\n        this.curCommandType = -1;\n        continue;\n        // Horizontal move to command\n      } else if (\"h\" === c || \"H\" === c) {\n        this.curCommandType = SVGPathData.HORIZ_LINE_TO;\n        this.curCommandRelative = \"h\" === c;\n        // Vertical move to command\n      } else if (\"v\" === c || \"V\" === c) {\n        this.curCommandType = SVGPathData.VERT_LINE_TO;\n        this.curCommandRelative = \"v\" === c;\n        // Move to command\n      } else if (\"m\" === c || \"M\" === c) {\n        this.curCommandType = SVGPathData.MOVE_TO;\n        this.curCommandRelative = \"m\" === c;\n        // Line to command\n      } else if (\"l\" === c || \"L\" === c) {\n        this.curCommandType = SVGPathData.LINE_TO;\n        this.curCommandRelative = \"l\" === c;\n        // Curve to command\n      } else if (\"c\" === c || \"C\" === c) {\n        this.curCommandType = SVGPathData.CURVE_TO;\n        this.curCommandRelative = \"c\" === c;\n        // Smooth curve to command\n      } else if (\"s\" === c || \"S\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_CURVE_TO;\n        this.curCommandRelative = \"s\" === c;\n        // Quadratic bezier curve to command\n      } else if (\"q\" === c || \"Q\" === c) {\n        this.curCommandType = SVGPathData.QUAD_TO;\n        this.curCommandRelative = \"q\" === c;\n        // Smooth quadratic bezier curve to command\n      } else if (\"t\" === c || \"T\" === c) {\n        this.curCommandType = SVGPathData.SMOOTH_QUAD_TO;\n        this.curCommandRelative = \"t\" === c;\n        // Elliptic arc command\n      } else if (\"a\" === c || \"A\" === c) {\n        this.curCommandType = SVGPathData.ARC;\n        this.curCommandRelative = \"a\" === c;\n      } else {\n        throw new SyntaxError(`Unexpected character \"${c}\" at index ${i}.`);\n      }\n    }\n    return commands;\n  }\n  /**\n   * Return a wrapper around this parser which applies the transformation on parsed commands.\n   */\n  transform(transform: TransformFunction) {\n    const result = Object.create(this, {\n      parse: {\n        value(chunk: string, commands: SVGCommand[] = []) {\n          const parsedCommands = Object.getPrototypeOf(this).parse.call(\n            this,\n            chunk,\n          );\n          for (const c of parsedCommands) {\n            const cT = transform(c);\n            if (Array.isArray(cT)) {\n              commands.push(...cT);\n            } else {\n              commands.push(cT);\n            }\n          }\n          return commands;\n        },\n      },\n    });\n    return result as this;\n  }\n}\n","import { encodeSVGPath } from \"./SVGPathDataEncoder\";\nimport { SVGPathDataParser } from \"./SVGPathDataParser\";\nimport { SVGPathDataTransformer } from \"./SVGPathDataTransformer\";\nimport { TransformableSVG } from \"./TransformableSVG\";\nimport { SVGCommand } from \"./types\";\n\nexport class SVGPathData extends TransformableSVG {\n  commands: SVGCommand[];\n  constructor(content: string | SVGCommand[]) {\n    super();\n    if (\"string\" === typeof content) {\n      this.commands = SVGPathData.parse(content);\n    } else {\n      this.commands = content;\n    }\n  }\n\n  encode() {\n    return SVGPathData.encode(this.commands);\n  }\n\n  getBounds() {\n    const boundsTransform = SVGPathDataTransformer.CALCULATE_BOUNDS();\n\n    this.transform(boundsTransform);\n    return boundsTransform;\n  }\n\n  transform(\n    transformFunction: (input: SVGCommand) => SVGCommand | SVGCommand[],\n  ) {\n    const newCommands = [];\n\n    for (const command of this.commands) {\n      const transformedCommand = transformFunction(command);\n\n      if (Array.isArray(transformedCommand)) {\n        newCommands.push(...transformedCommand);\n      } else {\n        newCommands.push(transformedCommand);\n      }\n    }\n    this.commands = newCommands;\n    return this;\n  }\n\n  static encode(commands: SVGCommand[]) {\n    return encodeSVGPath(commands);\n      }\n\n  static parse(path: string) {\n    const parser = new SVGPathDataParser();\n    const commands: SVGCommand[] = [];\n    parser.parse(path, commands);\n    parser.finish(commands);\n    return commands;\n  }\n\n  static readonly CLOSE_PATH: 1 = 1;\n  static readonly MOVE_TO: 2 = 2;\n  static readonly HORIZ_LINE_TO: 4 = 4;\n  static readonly VERT_LINE_TO: 8 = 8;\n  static readonly LINE_TO: 16 = 16;\n  static readonly CURVE_TO: 32 = 32;\n  static readonly SMOOTH_CURVE_TO: 64 = 64;\n  static readonly QUAD_TO: 128 = 128;\n  static readonly SMOOTH_QUAD_TO: 256 = 256;\n  static readonly ARC: 512 = 512;\n  static readonly LINE_COMMANDS = SVGPathData.LINE_TO | SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO;\n  static readonly DRAWING_COMMANDS = SVGPathData.HORIZ_LINE_TO | SVGPathData.VERT_LINE_TO | SVGPathData.LINE_TO |\n  SVGPathData.CURVE_TO | SVGPathData.SMOOTH_CURVE_TO | SVGPathData.QUAD_TO |\n  SVGPathData.SMOOTH_QUAD_TO | SVGPathData.ARC;\n}\n\nexport const COMMAND_ARG_COUNTS = {\n    [SVGPathData.MOVE_TO]: 2,\n    [SVGPathData.LINE_TO]: 2,\n    [SVGPathData.HORIZ_LINE_TO]: 1,\n    [SVGPathData.VERT_LINE_TO]: 1,\n    [SVGPathData.CLOSE_PATH]: 0,\n    [SVGPathData.QUAD_TO]: 4,\n    [SVGPathData.SMOOTH_QUAD_TO]: 2,\n    [SVGPathData.CURVE_TO]: 6,\n    [SVGPathData.SMOOTH_CURVE_TO]: 4,\n    [SVGPathData.ARC]: 7,\n};\n\nexport {encodeSVGPath} from \"./SVGPathDataEncoder\";\nexport {SVGPathDataParser} from \"./SVGPathDataParser\";\nexport {SVGPathDataTransformer} from \"./SVGPathDataTransformer\";\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}