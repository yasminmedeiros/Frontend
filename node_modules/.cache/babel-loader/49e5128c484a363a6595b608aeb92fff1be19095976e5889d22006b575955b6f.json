{"ast":null,"code":"'use strict';\n\nmodule.exports = extractContour;\nvar ndarray = require('ndarray');\nvar pool = require('typedarray-pool');\nvar ndsort = require('ndarray-sort');\nvar contourAlgorithm = require('./lib/codegen');\nfunction getDimension(cells) {\n  var numCells = cells.length;\n  var d = 0;\n  for (var i = 0; i < numCells; ++i) {\n    d = Math.max(d, cells[i].length) | 0;\n  }\n  return d - 1;\n}\nfunction getSigns(values, level) {\n  var numVerts = values.length;\n  var vertexSigns = pool.mallocUint8(numVerts);\n  for (var i = 0; i < numVerts; ++i) {\n    vertexSigns[i] = values[i] < level | 0;\n  }\n  return vertexSigns;\n}\nfunction getEdges(cells, d) {\n  var numCells = cells.length;\n  var maxEdges = d * (d + 1) / 2 * numCells | 0;\n  var edges = pool.mallocUint32(maxEdges * 2);\n  var ePtr = 0;\n  for (var i = 0; i < numCells; ++i) {\n    var c = cells[i];\n    var d = c.length;\n    for (var j = 0; j < d; ++j) {\n      for (var k = 0; k < j; ++k) {\n        var a = c[k];\n        var b = c[j];\n        edges[ePtr++] = Math.min(a, b) | 0;\n        edges[ePtr++] = Math.max(a, b) | 0;\n      }\n    }\n  }\n  var nedges = ePtr / 2 | 0;\n  ndsort(ndarray(edges, [nedges, 2]));\n  var ptr = 2;\n  for (var i = 2; i < ePtr; i += 2) {\n    if (edges[i - 2] === edges[i] && edges[i - 1] === edges[i + 1]) {\n      continue;\n    }\n    edges[ptr++] = edges[i];\n    edges[ptr++] = edges[i + 1];\n  }\n  return ndarray(edges, [ptr / 2 | 0, 2]);\n}\nfunction getCrossingWeights(edges, values, signs, level) {\n  var edata = edges.data;\n  var numEdges = edges.shape[0];\n  var weights = pool.mallocDouble(numEdges);\n  var ptr = 0;\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n    var b = edata[2 * i + 1];\n    if (signs[a] === signs[b]) {\n      continue;\n    }\n    var va = values[a];\n    var vb = values[b];\n    edata[2 * ptr] = a;\n    edata[2 * ptr + 1] = b;\n    weights[ptr++] = (vb - level) / (vb - va);\n  }\n  edges.shape[0] = ptr;\n  return ndarray(weights, [ptr]);\n}\nfunction getCascade(edges, numVerts) {\n  var result = pool.mallocInt32(numVerts * 2);\n  var numEdges = edges.shape[0];\n  var edata = edges.data;\n  result[0] = 0;\n  var lastV = 0;\n  for (var i = 0; i < numEdges; ++i) {\n    var a = edata[2 * i];\n    if (a !== lastV) {\n      result[2 * lastV + 1] = i;\n      while (++lastV < a) {\n        result[2 * lastV] = i;\n        result[2 * lastV + 1] = i;\n      }\n      result[2 * lastV] = i;\n    }\n  }\n  result[2 * lastV + 1] = numEdges;\n  while (++lastV < numVerts) {\n    result[2 * lastV] = result[2 * lastV + 1] = numEdges;\n  }\n  return result;\n}\nfunction unpackEdges(edges) {\n  var ne = edges.shape[0] | 0;\n  var edata = edges.data;\n  var result = new Array(ne);\n  for (var i = 0; i < ne; ++i) {\n    result[i] = [edata[2 * i], edata[2 * i + 1]];\n  }\n  return result;\n}\nfunction extractContour(cells, values, level, d) {\n  level = level || 0.0;\n\n  //If user didn't specify `d`, use brute force scan\n  if (typeof d === 'undefined') {\n    d = getDimension(cells);\n  }\n\n  //Count number of cells\n  var numCells = cells.length;\n  if (numCells === 0 || d < 1) {\n    return {\n      cells: [],\n      vertexIds: [],\n      vertexWeights: []\n    };\n  }\n\n  //Read in vertex signs\n  var vertexSigns = getSigns(values, +level);\n\n  //First get 1-skeleton, find all crossings\n  var edges = getEdges(cells, d);\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level);\n\n  //Build vertex cascade to speed up binary search\n  var vcascade = getCascade(edges, values.length | 0);\n\n  //Then construct cells\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns);\n\n  //Unpack data into pretty format\n  var uedges = unpackEdges(edges);\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0]);\n\n  //Release data\n  pool.free(vertexSigns);\n  pool.free(edges.data);\n  pool.free(weights.data);\n  pool.free(vcascade);\n  return {\n    cells: faces,\n    vertexIds: uedges,\n    vertexWeights: uweights\n  };\n}","map":{"version":3,"names":["module","exports","extractContour","ndarray","require","pool","ndsort","contourAlgorithm","getDimension","cells","numCells","length","d","i","Math","max","getSigns","values","level","numVerts","vertexSigns","mallocUint8","getEdges","maxEdges","edges","mallocUint32","ePtr","c","j","k","a","b","min","nedges","ptr","getCrossingWeights","signs","edata","data","numEdges","shape","weights","mallocDouble","va","vb","getCascade","result","mallocInt32","lastV","unpackEdges","ne","Array","vertexIds","vertexWeights","vcascade","faces","uedges","uweights","slice","call","free"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/simplicial-complex-contour/contour.js"],"sourcesContent":["'use strict'\n\nmodule.exports = extractContour\n\nvar ndarray = require('ndarray')\nvar pool    = require('typedarray-pool')\nvar ndsort  = require('ndarray-sort')\n\nvar contourAlgorithm = require('./lib/codegen')\n\nfunction getDimension(cells) {\n  var numCells = cells.length\n  var d = 0\n  for(var i=0; i<numCells; ++i) {\n    d = Math.max(d, cells[i].length)|0\n  }\n  return d-1\n}\n\nfunction getSigns(values, level) {\n  var numVerts    = values.length\n  var vertexSigns = pool.mallocUint8(numVerts)\n  for(var i=0; i<numVerts; ++i) {\n    vertexSigns[i] = (values[i] < level)|0\n  }\n  return vertexSigns\n}\n\nfunction getEdges(cells, d) {\n  var numCells = cells.length\n  var maxEdges = ((d * (d+1)/2) * numCells)|0\n  var edges    = pool.mallocUint32(maxEdges*2)\n  var ePtr     = 0\n  for(var i=0; i<numCells; ++i) {\n    var c = cells[i]\n    var d = c.length\n    for(var j=0; j<d; ++j) {\n      for(var k=0; k<j; ++k) {\n        var a = c[k]\n        var b = c[j]\n        edges[ePtr++] = Math.min(a,b)|0\n        edges[ePtr++] = Math.max(a,b)|0\n      }\n    }\n  }\n  var nedges = (ePtr/2)|0\n  ndsort(ndarray(edges, [nedges,2])) \n  var ptr = 2\n  for(var i=2; i<ePtr; i+=2) {\n    if(edges[i-2] === edges[i] &&\n       edges[i-1] === edges[i+1]) {\n      continue\n    }\n    edges[ptr++] = edges[i]\n    edges[ptr++] = edges[i+1]\n  }\n\n  return ndarray(edges, [(ptr/2)|0, 2])\n}\n\nfunction getCrossingWeights(edges, values, signs, level) {\n  var edata     = edges.data\n  var numEdges  = edges.shape[0]\n  var weights   = pool.mallocDouble(numEdges)\n  var ptr       = 0\n  for(var i=0; i<numEdges; ++i) {\n    var a  = edata[2*i]\n    var b  = edata[2*i+1]\n    if(signs[a] === signs[b]) {\n      continue\n    }\n    var va = values[a]\n    var vb = values[b]\n    edata[2*ptr]     = a\n    edata[2*ptr+1]   = b\n    weights[ptr++]   = (vb - level) / (vb - va)\n  }\n  edges.shape[0] = ptr\n  return ndarray(weights, [ptr])\n}\n\nfunction getCascade(edges, numVerts) {\n  var result   = pool.mallocInt32(numVerts*2)\n  var numEdges = edges.shape[0]\n  var edata    = edges.data\n  result[0]    = 0\n  var lastV    = 0\n  for(var i=0; i<numEdges; ++i) {\n    var a = edata[2*i]\n    if(a !== lastV) {\n      result[2*lastV+1] = i\n      while(++lastV < a) {\n        result[2*lastV] = i\n        result[2*lastV+1] = i\n      }\n      result[2*lastV] = i\n    }\n  }\n  result[2*lastV+1] = numEdges\n  while(++lastV < numVerts) {\n    result[2*lastV] = result[2*lastV+1] = numEdges\n  }\n  return result\n}\n\nfunction unpackEdges(edges) {\n  var ne = edges.shape[0]|0\n  var edata = edges.data\n  var result = new Array(ne)\n  for(var i=0; i<ne; ++i) {\n    result[i] = [edata[2*i], edata[2*i+1]]\n  }\n  return result\n}\n\nfunction extractContour(cells, values, level, d) {\n  level = level||0.0\n\n  //If user didn't specify `d`, use brute force scan\n  if(typeof d === 'undefined') {\n    d = getDimension(cells)\n  }\n\n  //Count number of cells\n  var numCells = cells.length\n  if(numCells === 0 || d < 1) {\n    return {\n      cells:         [],\n      vertexIds:     [],\n      vertexWeights: []\n    }\n  }\n\n  //Read in vertex signs\n  var vertexSigns = getSigns(values, +level)\n\n  //First get 1-skeleton, find all crossings\n  var edges   = getEdges(cells, d)\n  var weights = getCrossingWeights(edges, values, vertexSigns, +level)\n\n  //Build vertex cascade to speed up binary search\n  var vcascade = getCascade(edges, values.length|0)\n\n  //Then construct cells\n  var faces = contourAlgorithm(d)(cells, edges.data, vcascade, vertexSigns)\n\n  //Unpack data into pretty format\n  var uedges   = unpackEdges(edges)\n  var uweights = [].slice.call(weights.data, 0, weights.shape[0])\n\n  //Release data\n  pool.free(vertexSigns)\n  pool.free(edges.data)\n  pool.free(weights.data)\n  pool.free(vcascade)\n  \n  return {\n    cells:         faces,\n    vertexIds:     uedges,\n    vertexWeights: uweights\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}