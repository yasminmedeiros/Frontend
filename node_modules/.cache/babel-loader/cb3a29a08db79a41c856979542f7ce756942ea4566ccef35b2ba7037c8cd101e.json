{"ast":null,"code":"'use strict';\n\nvar monotoneTriangulate = require('./lib/monotone');\nvar makeIndex = require('./lib/triangulation');\nvar delaunayFlip = require('./lib/delaunay');\nvar filterTriangulation = require('./lib/filter');\nmodule.exports = cdt2d;\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])];\n}\nfunction compareEdge(a, b) {\n  return a[0] - b[0] || a[1] - b[1];\n}\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge);\n}\nfunction getDefault(options, property, dflt) {\n  if (property in options) {\n    return options[property];\n  }\n  return dflt;\n}\nfunction cdt2d(points, edges, options) {\n  if (!Array.isArray(edges)) {\n    options = edges || {};\n    edges = [];\n  } else {\n    options = options || {};\n    edges = edges || [];\n  }\n\n  //Parse out options\n  var delaunay = !!getDefault(options, 'delaunay', true);\n  var interior = !!getDefault(options, 'interior', true);\n  var exterior = !!getDefault(options, 'exterior', true);\n  var infinity = !!getDefault(options, 'infinity', false);\n\n  //Handle trivial case\n  if (!interior && !exterior || points.length === 0) {\n    return [];\n  }\n\n  //Construct initial triangulation\n  var cells = monotoneTriangulate(points, edges);\n\n  //If delaunay refinement needed, then improve quality by edge flipping\n  if (delaunay || interior !== exterior || infinity) {\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges));\n    for (var i = 0; i < cells.length; ++i) {\n      var f = cells[i];\n      triangulation.addTriangle(f[0], f[1], f[2]);\n    }\n\n    //Run edge flipping\n    if (delaunay) {\n      delaunayFlip(points, triangulation);\n    }\n\n    //Filter points\n    if (!exterior) {\n      return filterTriangulation(triangulation, -1);\n    } else if (!interior) {\n      return filterTriangulation(triangulation, 1, infinity);\n    } else if (infinity) {\n      return filterTriangulation(triangulation, 0, infinity);\n    } else {\n      return triangulation.cells();\n    }\n  } else {\n    return cells;\n  }\n}","map":{"version":3,"names":["monotoneTriangulate","require","makeIndex","delaunayFlip","filterTriangulation","module","exports","cdt2d","canonicalizeEdge","e","Math","min","max","compareEdge","a","b","canonicalizeEdges","edges","map","sort","getDefault","options","property","dflt","points","Array","isArray","delaunay","interior","exterior","infinity","length","cells","triangulation","i","f","addTriangle"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/cdt2d/cdt2d.js"],"sourcesContent":["'use strict'\n\nvar monotoneTriangulate = require('./lib/monotone')\nvar makeIndex = require('./lib/triangulation')\nvar delaunayFlip = require('./lib/delaunay')\nvar filterTriangulation = require('./lib/filter')\n\nmodule.exports = cdt2d\n\nfunction canonicalizeEdge(e) {\n  return [Math.min(e[0], e[1]), Math.max(e[0], e[1])]\n}\n\nfunction compareEdge(a, b) {\n  return a[0]-b[0] || a[1]-b[1]\n}\n\nfunction canonicalizeEdges(edges) {\n  return edges.map(canonicalizeEdge).sort(compareEdge)\n}\n\nfunction getDefault(options, property, dflt) {\n  if(property in options) {\n    return options[property]\n  }\n  return dflt\n}\n\nfunction cdt2d(points, edges, options) {\n\n  if(!Array.isArray(edges)) {\n    options = edges || {}\n    edges = []\n  } else {\n    options = options || {}\n    edges = edges || []\n  }\n\n  //Parse out options\n  var delaunay = !!getDefault(options, 'delaunay', true)\n  var interior = !!getDefault(options, 'interior', true)\n  var exterior = !!getDefault(options, 'exterior', true)\n  var infinity = !!getDefault(options, 'infinity', false)\n\n  //Handle trivial case\n  if((!interior && !exterior) || points.length === 0) {\n    return []\n  }\n\n  //Construct initial triangulation\n  var cells = monotoneTriangulate(points, edges)\n\n  //If delaunay refinement needed, then improve quality by edge flipping\n  if(delaunay || interior !== exterior || infinity) {\n\n    //Index all of the cells to support fast neighborhood queries\n    var triangulation = makeIndex(points.length, canonicalizeEdges(edges))\n    for(var i=0; i<cells.length; ++i) {\n      var f = cells[i]\n      triangulation.addTriangle(f[0], f[1], f[2])\n    }\n\n    //Run edge flipping\n    if(delaunay) {\n      delaunayFlip(points, triangulation)\n    }\n\n    //Filter points\n    if(!exterior) {\n      return filterTriangulation(triangulation, -1)\n    } else if(!interior) {\n      return filterTriangulation(triangulation,  1, infinity)\n    } else if(infinity) {\n      return filterTriangulation(triangulation, 0, infinity)\n    } else {\n      return triangulation.cells()\n    }\n    \n  } else {\n    return cells\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}