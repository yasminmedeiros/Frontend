{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar _ = Lib._;\nvar Axes = require('../../plots/cartesian/axes');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nfunction calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis);\n  var ya = Axes.getFromId(gd, trace.yaxis);\n  var tickLen = convertTickWidth(gd, xa, trace);\n  var minDiff = trace._minDiff;\n  trace._minDiff = null;\n  var x = trace._xcalc;\n  trace._xcalc = null;\n  var cd = calcCommon(gd, trace, x, ya, ptFunc);\n  trace._extremes[xa._id] = Axes.findExtremes(xa, x, {\n    vpad: minDiff / 2\n  });\n  if (cd.length) {\n    Lib.extendFlat(cd[0].t, {\n      wHover: minDiff / 2,\n      tickLen: tickLen\n    });\n    return cd;\n  } else {\n    return [{\n      t: {\n        empty: true\n      }\n    }];\n  }\n}\nfunction ptFunc(o, h, l, c) {\n  return {\n    o: o,\n    h: h,\n    l: l,\n    c: c\n  };\n}\n\n// shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\nfunction calcCommon(gd, trace, x, ya, ptFunc) {\n  var o = ya.makeCalcdata(trace, 'open');\n  var h = ya.makeCalcdata(trace, 'high');\n  var l = ya.makeCalcdata(trace, 'low');\n  var c = ya.makeCalcdata(trace, 'close');\n  var hasTextArray = Array.isArray(trace.text);\n\n  // we're optimists - before we have any changing data, assume increasing\n  var increasing = true;\n  var cPrev = null;\n  var cd = [];\n  for (var i = 0; i < x.length; i++) {\n    var xi = x[i];\n    var oi = o[i];\n    var hi = h[i];\n    var li = l[i];\n    var ci = c[i];\n    if (xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n      if (ci === oi) {\n        // if open == close, look for a change from the previous close\n        if (cPrev !== null && ci !== cPrev) increasing = ci > cPrev;\n        // else (c === cPrev or cPrev is null) no change\n      } else increasing = ci > oi;\n      cPrev = ci;\n      var pt = ptFunc(oi, hi, li, ci);\n      pt.pos = xi;\n      pt.yc = (oi + ci) / 2;\n      pt.i = i;\n      pt.dir = increasing ? 'increasing' : 'decreasing';\n      if (hasTextArray) pt.tx = trace.text[i];\n      cd.push(pt);\n    } else {\n      cd.push({\n        empty: true\n      });\n    }\n  }\n  trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {\n    padded: true\n  });\n  if (cd.length) {\n    cd[0].t = {\n      labels: {\n        open: _(gd, 'open:') + ' ',\n        high: _(gd, 'high:') + ' ',\n        low: _(gd, 'low:') + ' ',\n        close: _(gd, 'close:') + ' '\n      }\n    };\n  }\n  return cd;\n}\n\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc on the trace\n */\nfunction convertTickWidth(gd, xa, trace) {\n  var minDiff = trace._minDiff;\n  if (!minDiff) {\n    var fullData = gd._fullData;\n    var ohlcTracesOnThisXaxis = [];\n    minDiff = Infinity;\n    var i;\n    for (i = 0; i < fullData.length; i++) {\n      var tracei = fullData[i];\n      if (tracei.type === 'ohlc' && tracei.visible === true && tracei.xaxis === xa._id) {\n        ohlcTracesOnThisXaxis.push(tracei);\n        var xcalc = xa.makeCalcdata(tracei, 'x');\n        tracei._xcalc = xcalc;\n        var _minDiff = Lib.distinctVals(xcalc).minDiff;\n        if (_minDiff && isFinite(_minDiff)) {\n          minDiff = Math.min(minDiff, _minDiff);\n        }\n      }\n    }\n\n    // if minDiff is still Infinity here, set it to 1\n    if (minDiff === Infinity) minDiff = 1;\n    for (i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n      ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n    }\n  }\n  return minDiff * trace.tickwidth;\n}\nmodule.exports = {\n  calc: calc,\n  calcCommon: calcCommon\n};","map":{"version":3,"names":["Lib","require","_","Axes","BADNUM","calc","gd","trace","xa","getFromId","xaxis","ya","yaxis","tickLen","convertTickWidth","minDiff","_minDiff","x","_xcalc","cd","calcCommon","ptFunc","_extremes","_id","findExtremes","vpad","length","extendFlat","t","wHover","empty","o","h","l","c","makeCalcdata","hasTextArray","Array","isArray","text","increasing","cPrev","i","xi","oi","hi","li","ci","pt","pos","yc","dir","tx","push","concat","padded","labels","open","high","low","close","fullData","_fullData","ohlcTracesOnThisXaxis","Infinity","tracei","type","visible","xcalc","distinctVals","isFinite","Math","min","tickwidth","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/ohlc/calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar _ = Lib._;\nvar Axes = require('../../plots/cartesian/axes');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis);\n    var ya = Axes.getFromId(gd, trace.yaxis);\n\n    var tickLen = convertTickWidth(gd, xa, trace);\n    var minDiff = trace._minDiff;\n    trace._minDiff = null;\n    var x = trace._xcalc;\n    trace._xcalc = null;\n\n    var cd = calcCommon(gd, trace, x, ya, ptFunc);\n\n    trace._extremes[xa._id] = Axes.findExtremes(xa, x, {vpad: minDiff / 2});\n    if(cd.length) {\n        Lib.extendFlat(cd[0].t, {\n            wHover: minDiff / 2,\n            tickLen: tickLen\n        });\n        return cd;\n    } else {\n        return [{t: {empty: true}}];\n    }\n}\n\nfunction ptFunc(o, h, l, c) {\n    return {\n        o: o,\n        h: h,\n        l: l,\n        c: c\n    };\n}\n\n\n// shared between OHLC and candlestick\n// ptFunc makes a calcdata point specific to each trace type, from oi, hi, li, ci\nfunction calcCommon(gd, trace, x, ya, ptFunc) {\n    var o = ya.makeCalcdata(trace, 'open');\n    var h = ya.makeCalcdata(trace, 'high');\n    var l = ya.makeCalcdata(trace, 'low');\n    var c = ya.makeCalcdata(trace, 'close');\n\n    var hasTextArray = Array.isArray(trace.text);\n\n    // we're optimists - before we have any changing data, assume increasing\n    var increasing = true;\n    var cPrev = null;\n\n    var cd = [];\n    for(var i = 0; i < x.length; i++) {\n        var xi = x[i];\n        var oi = o[i];\n        var hi = h[i];\n        var li = l[i];\n        var ci = c[i];\n\n        if(xi !== BADNUM && oi !== BADNUM && hi !== BADNUM && li !== BADNUM && ci !== BADNUM) {\n            if(ci === oi) {\n                // if open == close, look for a change from the previous close\n                if(cPrev !== null && ci !== cPrev) increasing = ci > cPrev;\n                // else (c === cPrev or cPrev is null) no change\n            }\n            else increasing = ci > oi;\n\n            cPrev = ci;\n\n            var pt = ptFunc(oi, hi, li, ci);\n\n            pt.pos = xi;\n            pt.yc = (oi + ci) / 2;\n            pt.i = i;\n            pt.dir = increasing ? 'increasing' : 'decreasing';\n\n            if(hasTextArray) pt.tx = trace.text[i];\n\n            cd.push(pt);\n        } else {\n            cd.push({empty: true});\n        }\n    }\n\n    trace._extremes[ya._id] = Axes.findExtremes(ya, Lib.concat(l, h), {padded: true});\n\n    if(cd.length) {\n        cd[0].t = {\n            labels: {\n                open: _(gd, 'open:') + ' ',\n                high: _(gd, 'high:') + ' ',\n                low: _(gd, 'low:') + ' ',\n                close: _(gd, 'close:') + ' '\n            }\n        };\n    }\n\n    return cd;\n}\n\n/*\n * find min x-coordinates difference of all traces\n * attached to this x-axis and stash the result in _minDiff\n * in all traces; when a trace uses this in its\n * calc step it deletes _minDiff, so that next calc this is\n * done again in case the data changed.\n * also since we need it here, stash _xcalc on the trace\n */\nfunction convertTickWidth(gd, xa, trace) {\n    var minDiff = trace._minDiff;\n\n    if(!minDiff) {\n        var fullData = gd._fullData;\n        var ohlcTracesOnThisXaxis = [];\n\n        minDiff = Infinity;\n\n        var i;\n\n        for(i = 0; i < fullData.length; i++) {\n            var tracei = fullData[i];\n\n            if(tracei.type === 'ohlc' &&\n                tracei.visible === true &&\n                tracei.xaxis === xa._id\n            ) {\n                ohlcTracesOnThisXaxis.push(tracei);\n\n                var xcalc = xa.makeCalcdata(tracei, 'x');\n                tracei._xcalc = xcalc;\n\n                var _minDiff = Lib.distinctVals(xcalc).minDiff;\n                if(_minDiff && isFinite(_minDiff)) {\n                    minDiff = Math.min(minDiff, _minDiff);\n                }\n            }\n        }\n\n        // if minDiff is still Infinity here, set it to 1\n        if(minDiff === Infinity) minDiff = 1;\n\n        for(i = 0; i < ohlcTracesOnThisXaxis.length; i++) {\n            ohlcTracesOnThisXaxis[i]._minDiff = minDiff;\n        }\n    }\n\n    return minDiff * trace.tickwidth;\n}\n\nmodule.exports = {\n    calc: calc,\n    calcCommon: calcCommon\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}