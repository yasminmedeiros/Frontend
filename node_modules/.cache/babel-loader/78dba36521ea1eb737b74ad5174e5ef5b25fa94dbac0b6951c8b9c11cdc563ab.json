{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\nvar orient = require('robust-orientation')[3];\nvar EVENT_POINT = 0;\nvar EVENT_END = 1;\nvar EVENT_START = 2;\nmodule.exports = monotoneTriangulate;\n\n//A partial convex hull fragment, made of two unimonotone polygons\nfunction PartialHull(a, b, idx, lowerIds, upperIds) {\n  this.a = a;\n  this.b = b;\n  this.idx = idx;\n  this.lowerIds = lowerIds;\n  this.upperIds = upperIds;\n}\n\n//An event in the sweep line procedure\nfunction Event(a, b, type, idx) {\n  this.a = a;\n  this.b = b;\n  this.type = type;\n  this.idx = idx;\n}\n\n//This is used to compare events for the sweep line procedure\n// Points are:\n//  1. sorted lexicographically\n//  2. sorted by type  (point < end < start)\n//  3. segments sorted by winding order\n//  4. sorted by index\nfunction compareEvent(a, b) {\n  var d = a.a[0] - b.a[0] || a.a[1] - b.a[1] || a.type - b.type;\n  if (d) {\n    return d;\n  }\n  if (a.type !== EVENT_POINT) {\n    d = orient(a.a, a.b, b.b);\n    if (d) {\n      return d;\n    }\n  }\n  return a.idx - b.idx;\n}\nfunction testPoint(hull, p) {\n  return orient(hull.a, hull.b, p);\n}\nfunction addPoint(cells, hulls, points, p, idx) {\n  var lo = bsearch.lt(hulls, p, testPoint);\n  var hi = bsearch.gt(hulls, p, testPoint);\n  for (var i = lo; i < hi; ++i) {\n    var hull = hulls[i];\n\n    //Insert p into lower hull\n    var lowerIds = hull.lowerIds;\n    var m = lowerIds.length;\n    while (m > 1 && orient(points[lowerIds[m - 2]], points[lowerIds[m - 1]], p) > 0) {\n      cells.push([lowerIds[m - 1], lowerIds[m - 2], idx]);\n      m -= 1;\n    }\n    lowerIds.length = m;\n    lowerIds.push(idx);\n\n    //Insert p into upper hull\n    var upperIds = hull.upperIds;\n    var m = upperIds.length;\n    while (m > 1 && orient(points[upperIds[m - 2]], points[upperIds[m - 1]], p) < 0) {\n      cells.push([upperIds[m - 2], upperIds[m - 1], idx]);\n      m -= 1;\n    }\n    upperIds.length = m;\n    upperIds.push(idx);\n  }\n}\nfunction findSplit(hull, edge) {\n  var d;\n  if (hull.a[0] < edge.a[0]) {\n    d = orient(hull.a, hull.b, edge.a);\n  } else {\n    d = orient(edge.b, edge.a, hull.a);\n  }\n  if (d) {\n    return d;\n  }\n  if (edge.b[0] < hull.b[0]) {\n    d = orient(hull.a, hull.b, edge.b);\n  } else {\n    d = orient(edge.b, edge.a, hull.b);\n  }\n  return d || hull.idx - edge.idx;\n}\nfunction splitHulls(hulls, points, event) {\n  var splitIdx = bsearch.le(hulls, event, findSplit);\n  var hull = hulls[splitIdx];\n  var upperIds = hull.upperIds;\n  var x = upperIds[upperIds.length - 1];\n  hull.upperIds = [x];\n  hulls.splice(splitIdx + 1, 0, new PartialHull(event.a, event.b, event.idx, [x], upperIds));\n}\nfunction mergeHulls(hulls, points, event) {\n  //Swap pointers for merge search\n  var tmp = event.a;\n  event.a = event.b;\n  event.b = tmp;\n  var mergeIdx = bsearch.eq(hulls, event, findSplit);\n  var upper = hulls[mergeIdx];\n  var lower = hulls[mergeIdx - 1];\n  lower.upperIds = upper.upperIds;\n  hulls.splice(mergeIdx, 1);\n}\nfunction monotoneTriangulate(points, edges) {\n  var numPoints = points.length;\n  var numEdges = edges.length;\n  var events = [];\n\n  //Create point events\n  for (var i = 0; i < numPoints; ++i) {\n    events.push(new Event(points[i], null, EVENT_POINT, i));\n  }\n\n  //Create edge events\n  for (var i = 0; i < numEdges; ++i) {\n    var e = edges[i];\n    var a = points[e[0]];\n    var b = points[e[1]];\n    if (a[0] < b[0]) {\n      events.push(new Event(a, b, EVENT_START, i), new Event(b, a, EVENT_END, i));\n    } else if (a[0] > b[0]) {\n      events.push(new Event(b, a, EVENT_START, i), new Event(a, b, EVENT_END, i));\n    }\n  }\n\n  //Sort events\n  events.sort(compareEvent);\n\n  //Initialize hull\n  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52);\n  var hull = [new PartialHull([minX, 1], [minX, 0], -1, [], [], [], [])];\n\n  //Process events in order\n  var cells = [];\n  for (var i = 0, numEvents = events.length; i < numEvents; ++i) {\n    var event = events[i];\n    var type = event.type;\n    if (type === EVENT_POINT) {\n      addPoint(cells, hull, points, event.a, event.idx);\n    } else if (type === EVENT_START) {\n      splitHulls(hull, points, event);\n    } else {\n      mergeHulls(hull, points, event);\n    }\n  }\n\n  //Return triangulation\n  return cells;\n}","map":{"version":3,"names":["bsearch","require","orient","EVENT_POINT","EVENT_END","EVENT_START","module","exports","monotoneTriangulate","PartialHull","a","b","idx","lowerIds","upperIds","Event","type","compareEvent","d","testPoint","hull","p","addPoint","cells","hulls","points","lo","lt","hi","gt","i","m","length","push","findSplit","edge","splitHulls","event","splitIdx","le","x","splice","mergeHulls","tmp","mergeIdx","eq","upper","lower","edges","numPoints","numEdges","events","e","sort","minX","Math","abs","pow","numEvents"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/cdt2d/lib/monotone.js"],"sourcesContent":["'use strict'\n\nvar bsearch = require('binary-search-bounds')\nvar orient = require('robust-orientation')[3]\n\nvar EVENT_POINT = 0\nvar EVENT_END   = 1\nvar EVENT_START = 2\n\nmodule.exports = monotoneTriangulate\n\n//A partial convex hull fragment, made of two unimonotone polygons\nfunction PartialHull(a, b, idx, lowerIds, upperIds) {\n  this.a = a\n  this.b = b\n  this.idx = idx\n  this.lowerIds = lowerIds\n  this.upperIds = upperIds\n}\n\n//An event in the sweep line procedure\nfunction Event(a, b, type, idx) {\n  this.a    = a\n  this.b    = b\n  this.type = type\n  this.idx  = idx\n}\n\n//This is used to compare events for the sweep line procedure\n// Points are:\n//  1. sorted lexicographically\n//  2. sorted by type  (point < end < start)\n//  3. segments sorted by winding order\n//  4. sorted by index\nfunction compareEvent(a, b) {\n  var d =\n    (a.a[0] - b.a[0]) ||\n    (a.a[1] - b.a[1]) ||\n    (a.type - b.type)\n  if(d) { return d }\n  if(a.type !== EVENT_POINT) {\n    d = orient(a.a, a.b, b.b)\n    if(d) { return d }\n  }\n  return a.idx - b.idx\n}\n\nfunction testPoint(hull, p) {\n  return orient(hull.a, hull.b, p)\n}\n\nfunction addPoint(cells, hulls, points, p, idx) {\n  var lo = bsearch.lt(hulls, p, testPoint)\n  var hi = bsearch.gt(hulls, p, testPoint)\n  for(var i=lo; i<hi; ++i) {\n    var hull = hulls[i]\n\n    //Insert p into lower hull\n    var lowerIds = hull.lowerIds\n    var m = lowerIds.length\n    while(m > 1 && orient(\n        points[lowerIds[m-2]],\n        points[lowerIds[m-1]],\n        p) > 0) {\n      cells.push(\n        [lowerIds[m-1],\n         lowerIds[m-2],\n         idx])\n      m -= 1\n    }\n    lowerIds.length = m\n    lowerIds.push(idx)\n\n    //Insert p into upper hull\n    var upperIds = hull.upperIds\n    var m = upperIds.length\n    while(m > 1 && orient(\n        points[upperIds[m-2]],\n        points[upperIds[m-1]],\n        p) < 0) {\n      cells.push(\n        [upperIds[m-2],\n         upperIds[m-1],\n         idx])\n      m -= 1\n    }\n    upperIds.length = m\n    upperIds.push(idx)\n  }\n}\n\nfunction findSplit(hull, edge) {\n  var d\n  if(hull.a[0] < edge.a[0]) {\n    d = orient(hull.a, hull.b, edge.a)\n  } else {\n    d = orient(edge.b, edge.a, hull.a)\n  }\n  if(d) { return d }\n  if(edge.b[0] < hull.b[0]) {\n    d = orient(hull.a, hull.b, edge.b)\n  } else {\n    d = orient(edge.b, edge.a, hull.b)\n  }\n  return d || hull.idx - edge.idx\n}\n\nfunction splitHulls(hulls, points, event) {\n  var splitIdx = bsearch.le(hulls, event, findSplit)\n  var hull = hulls[splitIdx]\n  var upperIds = hull.upperIds\n  var x = upperIds[upperIds.length-1]\n  hull.upperIds = [x]\n  hulls.splice(splitIdx+1, 0,\n    new PartialHull(event.a, event.b, event.idx, [x], upperIds))\n}\n\n\nfunction mergeHulls(hulls, points, event) {\n  //Swap pointers for merge search\n  var tmp = event.a\n  event.a = event.b\n  event.b = tmp\n  var mergeIdx = bsearch.eq(hulls, event, findSplit)\n  var upper = hulls[mergeIdx]\n  var lower = hulls[mergeIdx-1]\n  lower.upperIds = upper.upperIds\n  hulls.splice(mergeIdx, 1)\n}\n\n\nfunction monotoneTriangulate(points, edges) {\n\n  var numPoints = points.length\n  var numEdges = edges.length\n\n  var events = []\n\n  //Create point events\n  for(var i=0; i<numPoints; ++i) {\n    events.push(new Event(\n      points[i],\n      null,\n      EVENT_POINT,\n      i))\n  }\n\n  //Create edge events\n  for(var i=0; i<numEdges; ++i) {\n    var e = edges[i]\n    var a = points[e[0]]\n    var b = points[e[1]]\n    if(a[0] < b[0]) {\n      events.push(\n        new Event(a, b, EVENT_START, i),\n        new Event(b, a, EVENT_END, i))\n    } else if(a[0] > b[0]) {\n      events.push(\n        new Event(b, a, EVENT_START, i),\n        new Event(a, b, EVENT_END, i))\n    }\n  }\n\n  //Sort events\n  events.sort(compareEvent)\n\n  //Initialize hull\n  var minX = events[0].a[0] - (1 + Math.abs(events[0].a[0])) * Math.pow(2, -52)\n  var hull = [ new PartialHull([minX, 1], [minX, 0], -1, [], [], [], []) ]\n\n  //Process events in order\n  var cells = []\n  for(var i=0, numEvents=events.length; i<numEvents; ++i) {\n    var event = events[i]\n    var type = event.type\n    if(type === EVENT_POINT) {\n      addPoint(cells, hull, points, event.a, event.idx)\n    } else if(type === EVENT_START) {\n      splitHulls(hull, points, event)\n    } else {\n      mergeHulls(hull, points, event)\n    }\n  }\n\n  //Return triangulation\n  return cells\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}