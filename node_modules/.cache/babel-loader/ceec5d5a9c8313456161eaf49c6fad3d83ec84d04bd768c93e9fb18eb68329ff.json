{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar tube2mesh = require('gl-streamtube3d');\nvar createTubeMesh = tube2mesh.createTubeMesh;\nvar Lib = require('../../lib');\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\nvar zip3 = require('../../plots/gl3d/zip3');\nvar axisName2scaleIndex = {\n  xaxis: 0,\n  yaxis: 1,\n  zaxis: 2\n};\nfunction Streamtube(scene, uid) {\n  this.scene = scene;\n  this.uid = uid;\n  this.mesh = null;\n  this.data = null;\n}\nvar proto = Streamtube.prototype;\nproto.handlePick = function (selection) {\n  var sceneLayout = this.scene.fullSceneLayout;\n  var dataScale = this.scene.dataScale;\n  function fromDataScale(v, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return ax.l2c(v) / scale;\n  }\n  if (selection.object === this.mesh) {\n    var pos = selection.data.position;\n    var uvx = selection.data.velocity;\n    selection.traceCoordinate = [fromDataScale(pos[0], 'xaxis'), fromDataScale(pos[1], 'yaxis'), fromDataScale(pos[2], 'zaxis'), fromDataScale(uvx[0], 'xaxis'), fromDataScale(uvx[1], 'yaxis'), fromDataScale(uvx[2], 'zaxis'),\n    // u/v/w norm\n    selection.data.intensity * this.data._normMax,\n    // divergence\n    selection.data.divergence];\n    selection.textLabel = this.data.text;\n    return true;\n  }\n};\nfunction distinctVals(col) {\n  return Lib.distinctVals(col).vals;\n}\nfunction getDfltStartingPositions(vec) {\n  var len = vec.length;\n  var s;\n  if (len > 2) {\n    s = vec.slice(1, len - 1);\n  } else if (len === 2) {\n    s = [(vec[0] + vec[1]) / 2];\n  } else {\n    s = vec;\n  }\n  return s;\n}\nfunction getBoundPads(vec) {\n  var len = vec.length;\n  if (len === 1) {\n    return [0.5, 0.5];\n  } else {\n    return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];\n  }\n}\nfunction convert(scene, trace) {\n  var sceneLayout = scene.fullSceneLayout;\n  var dataScale = scene.dataScale;\n  var len = trace._len;\n  var tubeOpts = {};\n  function toDataCoords(arr, axisName) {\n    var ax = sceneLayout[axisName];\n    var scale = dataScale[axisName2scaleIndex[axisName]];\n    return Lib.simpleMap(arr, function (v) {\n      return ax.d2l(v) * scale;\n    });\n  }\n  tubeOpts.vectors = zip3(toDataCoords(trace.u, 'xaxis'), toDataCoords(trace.v, 'yaxis'), toDataCoords(trace.w, 'zaxis'), len);\n  var valsx = distinctVals(trace.x.slice(0, len));\n  var valsy = distinctVals(trace.y.slice(0, len));\n  var valsz = distinctVals(trace.z.slice(0, len));\n\n  // Over-specified mesh case, this would error in tube2mesh\n  if (valsx.length * valsy.length * valsz.length > len) {\n    return {\n      positions: [],\n      cells: []\n    };\n  }\n  var meshx = toDataCoords(valsx, 'xaxis');\n  var meshy = toDataCoords(valsy, 'yaxis');\n  var meshz = toDataCoords(valsz, 'zaxis');\n  tubeOpts.meshgrid = [meshx, meshy, meshz];\n  if (trace.starts) {\n    var slen = trace._slen;\n    tubeOpts.startingPositions = zip3(toDataCoords(trace.starts.x.slice(0, slen), 'xaxis'), toDataCoords(trace.starts.y.slice(0, slen), 'yaxis'), toDataCoords(trace.starts.z.slice(0, slen), 'zaxis'));\n  } else {\n    // Default starting positions:\n    //\n    // if len>2, cut xz plane at min-y,\n    // takes all x/y/z pts on that plane except those on the edges\n    // to generate \"well-defined\" tubes,\n    //\n    // if len=2, take position halfway between two the pts,\n    //\n    // if len=1, take that pt\n    var sy0 = meshy[0];\n    var sx = getDfltStartingPositions(meshx);\n    var sz = getDfltStartingPositions(meshz);\n    var startingPositions = new Array(sx.length * sz.length);\n    var m = 0;\n    for (var i = 0; i < sx.length; i++) {\n      for (var k = 0; k < sz.length; k++) {\n        startingPositions[m++] = [sx[i], sy0, sz[k]];\n      }\n    }\n    tubeOpts.startingPositions = startingPositions;\n  }\n  tubeOpts.colormap = parseColorScale(trace);\n  tubeOpts.tubeSize = trace.sizeref;\n  tubeOpts.maxLength = trace.maxdisplayed;\n\n  // add some padding around the bounds\n  // to e.g. allow tubes starting from a slice of the x/y/z mesh\n  // to go beyond bounds a little bit w/o getting clipped\n  var xbnds = toDataCoords(trace._xbnds, 'xaxis');\n  var ybnds = toDataCoords(trace._ybnds, 'yaxis');\n  var zbnds = toDataCoords(trace._zbnds, 'zaxis');\n  var xpads = getBoundPads(meshx);\n  var ypads = getBoundPads(meshy);\n  var zpads = getBoundPads(meshz);\n  var bounds = [[xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]], [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]];\n  var meshData = tube2mesh(tubeOpts, bounds);\n\n  // N.B. cmin/cmax correspond to the min/max vector norm\n  // in the u/v/w arrays, which in general is NOT equal to max\n  // intensity that colors the tubes.\n  meshData.vertexIntensityBounds = [trace.cmin / trace._normMax, trace.cmax / trace._normMax];\n\n  // pass gl-mesh3d lighting attributes\n  var lp = trace.lightposition;\n  meshData.lightPosition = [lp.x, lp.y, lp.z];\n  meshData.ambient = trace.lighting.ambient;\n  meshData.diffuse = trace.lighting.diffuse;\n  meshData.specular = trace.lighting.specular;\n  meshData.roughness = trace.lighting.roughness;\n  meshData.fresnel = trace.lighting.fresnel;\n  meshData.opacity = trace.opacity;\n\n  // stash autorange pad value\n  trace._pad = meshData.tubeScale * trace.sizeref * 2;\n  return meshData;\n}\nproto.update = function (data) {\n  this.data = data;\n  var meshData = convert(this.scene, data);\n  this.mesh.update(meshData);\n};\nproto.dispose = function () {\n  this.scene.glplot.remove(this.mesh);\n  this.mesh.dispose();\n};\nfunction createStreamtubeTrace(scene, data) {\n  var gl = scene.glplot.gl;\n  var meshData = convert(scene, data);\n  var mesh = createTubeMesh(gl, meshData);\n  var streamtube = new Streamtube(scene, data.uid);\n  streamtube.mesh = mesh;\n  streamtube.data = data;\n  mesh._trace = streamtube;\n  scene.glplot.add(mesh);\n  return streamtube;\n}\nmodule.exports = createStreamtubeTrace;","map":{"version":3,"names":["tube2mesh","require","createTubeMesh","Lib","parseColorScale","zip3","axisName2scaleIndex","xaxis","yaxis","zaxis","Streamtube","scene","uid","mesh","data","proto","prototype","handlePick","selection","sceneLayout","fullSceneLayout","dataScale","fromDataScale","v","axisName","ax","scale","l2c","object","pos","position","uvx","velocity","traceCoordinate","intensity","_normMax","divergence","textLabel","text","distinctVals","col","vals","getDfltStartingPositions","vec","len","length","s","slice","getBoundPads","convert","trace","_len","tubeOpts","toDataCoords","arr","simpleMap","d2l","vectors","u","w","valsx","x","valsy","y","valsz","z","positions","cells","meshx","meshy","meshz","meshgrid","starts","slen","_slen","startingPositions","sy0","sx","sz","Array","m","i","k","colormap","tubeSize","sizeref","maxLength","maxdisplayed","xbnds","_xbnds","ybnds","_ybnds","zbnds","_zbnds","xpads","ypads","zpads","bounds","meshData","vertexIntensityBounds","cmin","cmax","lp","lightposition","lightPosition","ambient","lighting","diffuse","specular","roughness","fresnel","opacity","_pad","tubeScale","update","dispose","glplot","remove","createStreamtubeTrace","gl","streamtube","_trace","add","module","exports"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/streamtube/convert.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar tube2mesh = require('gl-streamtube3d');\nvar createTubeMesh = tube2mesh.createTubeMesh;\n\nvar Lib = require('../../lib');\nvar parseColorScale = require('../../lib/gl_format_color').parseColorScale;\nvar zip3 = require('../../plots/gl3d/zip3');\n\nvar axisName2scaleIndex = {xaxis: 0, yaxis: 1, zaxis: 2};\n\nfunction Streamtube(scene, uid) {\n    this.scene = scene;\n    this.uid = uid;\n    this.mesh = null;\n    this.data = null;\n}\n\nvar proto = Streamtube.prototype;\n\nproto.handlePick = function(selection) {\n    var sceneLayout = this.scene.fullSceneLayout;\n    var dataScale = this.scene.dataScale;\n\n    function fromDataScale(v, axisName) {\n        var ax = sceneLayout[axisName];\n        var scale = dataScale[axisName2scaleIndex[axisName]];\n        return ax.l2c(v) / scale;\n    }\n\n    if(selection.object === this.mesh) {\n        var pos = selection.data.position;\n        var uvx = selection.data.velocity;\n\n        selection.traceCoordinate = [\n            fromDataScale(pos[0], 'xaxis'),\n            fromDataScale(pos[1], 'yaxis'),\n            fromDataScale(pos[2], 'zaxis'),\n\n            fromDataScale(uvx[0], 'xaxis'),\n            fromDataScale(uvx[1], 'yaxis'),\n            fromDataScale(uvx[2], 'zaxis'),\n\n            // u/v/w norm\n            selection.data.intensity * this.data._normMax,\n            // divergence\n            selection.data.divergence\n        ];\n\n        selection.textLabel = this.data.text;\n\n        return true;\n    }\n};\n\nfunction distinctVals(col) {\n    return Lib.distinctVals(col).vals;\n}\n\nfunction getDfltStartingPositions(vec) {\n    var len = vec.length;\n    var s;\n\n    if(len > 2) {\n        s = vec.slice(1, len - 1);\n    } else if(len === 2) {\n        s = [(vec[0] + vec[1]) / 2];\n    } else {\n        s = vec;\n    }\n    return s;\n}\n\nfunction getBoundPads(vec) {\n    var len = vec.length;\n    if(len === 1) {\n        return [0.5, 0.5];\n    } else {\n        return [vec[1] - vec[0], vec[len - 1] - vec[len - 2]];\n    }\n}\n\nfunction convert(scene, trace) {\n    var sceneLayout = scene.fullSceneLayout;\n    var dataScale = scene.dataScale;\n    var len = trace._len;\n    var tubeOpts = {};\n\n    function toDataCoords(arr, axisName) {\n        var ax = sceneLayout[axisName];\n        var scale = dataScale[axisName2scaleIndex[axisName]];\n        return Lib.simpleMap(arr, function(v) { return ax.d2l(v) * scale; });\n    }\n\n    tubeOpts.vectors = zip3(\n        toDataCoords(trace.u, 'xaxis'),\n        toDataCoords(trace.v, 'yaxis'),\n        toDataCoords(trace.w, 'zaxis'),\n        len\n    );\n\n    var valsx = distinctVals(trace.x.slice(0, len));\n    var valsy = distinctVals(trace.y.slice(0, len));\n    var valsz = distinctVals(trace.z.slice(0, len));\n\n    // Over-specified mesh case, this would error in tube2mesh\n    if(valsx.length * valsy.length * valsz.length > len) {\n        return {positions: [], cells: []};\n    }\n\n    var meshx = toDataCoords(valsx, 'xaxis');\n    var meshy = toDataCoords(valsy, 'yaxis');\n    var meshz = toDataCoords(valsz, 'zaxis');\n\n    tubeOpts.meshgrid = [meshx, meshy, meshz];\n\n    if(trace.starts) {\n        var slen = trace._slen;\n        tubeOpts.startingPositions = zip3(\n            toDataCoords(trace.starts.x.slice(0, slen), 'xaxis'),\n            toDataCoords(trace.starts.y.slice(0, slen), 'yaxis'),\n            toDataCoords(trace.starts.z.slice(0, slen), 'zaxis')\n        );\n    } else {\n        // Default starting positions:\n        //\n        // if len>2, cut xz plane at min-y,\n        // takes all x/y/z pts on that plane except those on the edges\n        // to generate \"well-defined\" tubes,\n        //\n        // if len=2, take position halfway between two the pts,\n        //\n        // if len=1, take that pt\n        var sy0 = meshy[0];\n        var sx = getDfltStartingPositions(meshx);\n        var sz = getDfltStartingPositions(meshz);\n        var startingPositions = new Array(sx.length * sz.length);\n        var m = 0;\n\n        for(var i = 0; i < sx.length; i++) {\n            for(var k = 0; k < sz.length; k++) {\n                startingPositions[m++] = [sx[i], sy0, sz[k]];\n            }\n        }\n        tubeOpts.startingPositions = startingPositions;\n    }\n\n    tubeOpts.colormap = parseColorScale(trace);\n    tubeOpts.tubeSize = trace.sizeref;\n    tubeOpts.maxLength = trace.maxdisplayed;\n\n    // add some padding around the bounds\n    // to e.g. allow tubes starting from a slice of the x/y/z mesh\n    // to go beyond bounds a little bit w/o getting clipped\n    var xbnds = toDataCoords(trace._xbnds, 'xaxis');\n    var ybnds = toDataCoords(trace._ybnds, 'yaxis');\n    var zbnds = toDataCoords(trace._zbnds, 'zaxis');\n    var xpads = getBoundPads(meshx);\n    var ypads = getBoundPads(meshy);\n    var zpads = getBoundPads(meshz);\n\n    var bounds = [\n        [xbnds[0] - xpads[0], ybnds[0] - ypads[0], zbnds[0] - zpads[0]],\n        [xbnds[1] + xpads[1], ybnds[1] + ypads[1], zbnds[1] + zpads[1]]\n    ];\n\n    var meshData = tube2mesh(tubeOpts, bounds);\n\n    // N.B. cmin/cmax correspond to the min/max vector norm\n    // in the u/v/w arrays, which in general is NOT equal to max\n    // intensity that colors the tubes.\n    meshData.vertexIntensityBounds = [trace.cmin / trace._normMax, trace.cmax / trace._normMax];\n\n    // pass gl-mesh3d lighting attributes\n    var lp = trace.lightposition;\n    meshData.lightPosition = [lp.x, lp.y, lp.z];\n    meshData.ambient = trace.lighting.ambient;\n    meshData.diffuse = trace.lighting.diffuse;\n    meshData.specular = trace.lighting.specular;\n    meshData.roughness = trace.lighting.roughness;\n    meshData.fresnel = trace.lighting.fresnel;\n    meshData.opacity = trace.opacity;\n\n    // stash autorange pad value\n    trace._pad = meshData.tubeScale * trace.sizeref * 2;\n\n    return meshData;\n}\n\nproto.update = function(data) {\n    this.data = data;\n\n    var meshData = convert(this.scene, data);\n    this.mesh.update(meshData);\n};\n\nproto.dispose = function() {\n    this.scene.glplot.remove(this.mesh);\n    this.mesh.dispose();\n};\n\nfunction createStreamtubeTrace(scene, data) {\n    var gl = scene.glplot.gl;\n\n    var meshData = convert(scene, data);\n    var mesh = createTubeMesh(gl, meshData);\n\n    var streamtube = new Streamtube(scene, data.uid);\n    streamtube.mesh = mesh;\n    streamtube.data = data;\n    mesh._trace = streamtube;\n\n    scene.glplot.add(mesh);\n\n    return streamtube;\n}\n\nmodule.exports = createStreamtubeTrace;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}