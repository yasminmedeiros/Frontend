{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar cluster = require('point-cluster');\nvar arrayRange = require('array-range');\nvar Text = require('gl-text');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar prepareRegl = require('../../lib/prepare_regl');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\nvar Color = require('../../components/color');\nvar subTypes = require('../scatter/subtypes');\nvar scatterCalc = require('../scatter/calc');\nvar calcMarkerSize = scatterCalc.calcMarkerSize;\nvar calcAxisExpansion = scatterCalc.calcAxisExpansion;\nvar setFirstScatter = scatterCalc.setFirstScatter;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar linkTraces = require('../scatter/link_traces');\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillHoverText = require('../scatter/fill_hover_text');\nvar convert = require('./convert');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('./constants').TOO_MANY_POINTS;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\nfunction calc(gd, trace) {\n  var fullLayout = gd._fullLayout;\n  var xa = AxisIDs.getFromId(gd, trace.xaxis);\n  var ya = AxisIDs.getFromId(gd, trace.yaxis);\n  var subplot = fullLayout._plots[trace.xaxis + trace.yaxis];\n  var len = trace._length;\n  var len2 = len * 2;\n  var stash = {};\n  var i, xx, yy;\n  var x = xa.makeCalcdata(trace, 'x');\n  var y = ya.makeCalcdata(trace, 'y');\n\n  // we need hi-precision for scatter2d,\n  // regl-scatter2d uses NaNs for bad/missing values\n  var positions = new Array(len2);\n  for (i = 0; i < len; i++) {\n    xx = x[i];\n    yy = y[i];\n    positions[i * 2] = xx === BADNUM ? NaN : xx;\n    positions[i * 2 + 1] = yy === BADNUM ? NaN : yy;\n  }\n  if (xa.type === 'log') {\n    for (i = 0; i < len2; i += 2) {\n      positions[i] = xa.c2l(positions[i]);\n    }\n  }\n  if (ya.type === 'log') {\n    for (i = 1; i < len2; i += 2) {\n      positions[i] = ya.c2l(positions[i]);\n    }\n  }\n\n  // we don't build a tree for log axes since it takes long to convert log2px\n  // and it is also\n  if (xa.type !== 'log' && ya.type !== 'log') {\n    // FIXME: delegate this to webworker\n    stash.tree = cluster(positions);\n  } else {\n    var ids = stash.ids = new Array(len);\n    for (i = 0; i < len; i++) {\n      ids[i] = i;\n    }\n  }\n\n  // create scene options and scene\n  calcColorscale(gd, trace);\n  var opts = sceneOptions(gd, subplot, trace, positions, x, y);\n  var scene = sceneUpdate(gd, subplot);\n\n  // Reuse SVG scatter axis expansion routine.\n  // For graphs with very large number of points and array marker.size,\n  // use average marker size instead to speed things up.\n  setFirstScatter(fullLayout, trace);\n  var ppad;\n  if (len < TOO_MANY_POINTS) {\n    ppad = calcMarkerSize(trace, len);\n  } else if (opts.marker) {\n    ppad = 2 * (opts.marker.sizeAvg || Math.max(opts.marker.size, 3));\n  }\n  calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n  if (opts.errorX) expandForErrorBars(trace, xa, opts.errorX);\n  if (opts.errorY) expandForErrorBars(trace, ya, opts.errorY);\n\n  // set flags to create scene renderers\n  if (opts.fill && !scene.fill2d) scene.fill2d = true;\n  if (opts.marker && !scene.scatter2d) scene.scatter2d = true;\n  if (opts.line && !scene.line2d) scene.line2d = true;\n  if ((opts.errorX || opts.errorY) && !scene.error2d) scene.error2d = true;\n  if (opts.text && !scene.glText) scene.glText = true;\n\n  // FIXME: organize it in a more appropriate manner, probably in sceneOptions\n  // put point-cluster instance for optimized regl calc\n  if (opts.marker && len >= TOO_MANY_POINTS) {\n    opts.marker.cluster = stash.tree;\n  }\n\n  // save scene opts batch\n  scene.lineOptions.push(opts.line);\n  scene.errorXOptions.push(opts.errorX);\n  scene.errorYOptions.push(opts.errorY);\n  scene.fillOptions.push(opts.fill);\n  scene.markerOptions.push(opts.marker);\n  scene.markerSelectedOptions.push(opts.markerSel);\n  scene.markerUnselectedOptions.push(opts.markerUnsel);\n  scene.textOptions.push(opts.text);\n  scene.textSelectedOptions.push(opts.textSel);\n  scene.textUnselectedOptions.push(opts.textUnsel);\n\n  // stash scene ref\n  stash._scene = scene;\n  stash.index = scene.count;\n  stash.x = x;\n  stash.y = y;\n  stash.positions = positions;\n  scene.count++;\n  return [{\n    x: false,\n    y: false,\n    t: stash,\n    trace: trace\n  }];\n}\nfunction expandForErrorBars(trace, ax, opts) {\n  var extremes = trace._extremes[ax._id];\n  var errExt = findExtremes(ax, opts._bnds, {\n    padded: true\n  });\n  extremes.min = extremes.min.concat(errExt.min);\n  extremes.max = extremes.max.concat(errExt.max);\n}\n\n// create scene options\nfunction sceneOptions(gd, subplot, trace, positions, x, y) {\n  var opts = convert.style(gd, trace);\n  if (opts.marker) {\n    opts.marker.positions = positions;\n  }\n  if (opts.line && positions.length > 1) {\n    Lib.extendFlat(opts.line, convert.linePositions(gd, trace, positions));\n  }\n  if (opts.errorX || opts.errorY) {\n    var errors = convert.errorBarPositions(gd, trace, positions, x, y);\n    if (opts.errorX) {\n      Lib.extendFlat(opts.errorX, errors.x);\n    }\n    if (opts.errorY) {\n      Lib.extendFlat(opts.errorY, errors.y);\n    }\n  }\n  if (opts.text) {\n    Lib.extendFlat(opts.text, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.marker));\n    Lib.extendFlat(opts.textSel, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.markerSel));\n    Lib.extendFlat(opts.textUnsel, {\n      positions: positions\n    }, convert.textPosition(gd, trace, opts.text, opts.markerUnsel));\n  }\n  return opts;\n}\n\n// make sure scene exists on subplot, return it\nfunction sceneUpdate(gd, subplot) {\n  var scene = subplot._scene;\n  var resetOpts = {\n    // number of traces in subplot, since scene:subplot → 1:1\n    count: 0,\n    // whether scene requires init hook in plot call (dirty plot call)\n    dirty: true,\n    // last used options\n    lineOptions: [],\n    fillOptions: [],\n    markerOptions: [],\n    markerSelectedOptions: [],\n    markerUnselectedOptions: [],\n    errorXOptions: [],\n    errorYOptions: [],\n    textOptions: [],\n    textSelectedOptions: [],\n    textUnselectedOptions: []\n  };\n  var initOpts = {\n    selectBatch: null,\n    unselectBatch: null,\n    // regl- component stubs, initialized in dirty plot call\n    fill2d: false,\n    scatter2d: false,\n    error2d: false,\n    line2d: false,\n    glText: false,\n    select2d: null\n  };\n  if (!subplot._scene) {\n    scene = subplot._scene = {};\n    scene.init = function init() {\n      Lib.extendFlat(scene, initOpts, resetOpts);\n    };\n    scene.init();\n\n    // apply new option to all regl components (used on drag)\n    scene.update = function update(opt) {\n      var opts = Lib.repeat(opt, scene.count);\n      if (scene.fill2d) scene.fill2d.update(opts);\n      if (scene.scatter2d) scene.scatter2d.update(opts);\n      if (scene.line2d) scene.line2d.update(opts);\n      if (scene.error2d) scene.error2d.update(opts.concat(opts));\n      if (scene.select2d) scene.select2d.update(opts);\n      if (scene.glText) {\n        for (var i = 0; i < scene.count; i++) {\n          scene.glText[i].update(opt);\n        }\n      }\n    };\n\n    // draw traces in proper order\n    scene.draw = function draw() {\n      var count = scene.count;\n      var fill2d = scene.fill2d;\n      var error2d = scene.error2d;\n      var line2d = scene.line2d;\n      var scatter2d = scene.scatter2d;\n      var glText = scene.glText;\n      var select2d = scene.select2d;\n      var selectBatch = scene.selectBatch;\n      var unselectBatch = scene.unselectBatch;\n      for (var i = 0; i < count; i++) {\n        if (fill2d && scene.fillOrder[i]) {\n          fill2d.draw(scene.fillOrder[i]);\n        }\n        if (line2d && scene.lineOptions[i]) {\n          line2d.draw(i);\n        }\n        if (error2d) {\n          if (scene.errorXOptions[i]) error2d.draw(i);\n          if (scene.errorYOptions[i]) error2d.draw(i + count);\n        }\n        if (scatter2d && scene.markerOptions[i] && (!selectBatch || !selectBatch[i])) {\n          scatter2d.draw(i);\n        }\n        if (glText[i] && scene.textOptions[i]) {\n          glText[i].render();\n        }\n      }\n      if (scatter2d && select2d && selectBatch) {\n        select2d.draw(selectBatch);\n        scatter2d.draw(unselectBatch);\n      }\n      scene.dirty = false;\n    };\n\n    // remove scene resources\n    scene.destroy = function destroy() {\n      if (scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();\n      if (scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();\n      if (scene.error2d && scene.error2d.destroy) scene.error2d.destroy();\n      if (scene.line2d && scene.line2d.destroy) scene.line2d.destroy();\n      if (scene.select2d && scene.select2d.destroy) scene.select2d.destroy();\n      if (scene.glText) {\n        scene.glText.forEach(function (text) {\n          if (text.destroy) text.destroy();\n        });\n      }\n      scene.lineOptions = null;\n      scene.fillOptions = null;\n      scene.markerOptions = null;\n      scene.markerSelectedOptions = null;\n      scene.markerUnselectedOptions = null;\n      scene.errorXOptions = null;\n      scene.errorYOptions = null;\n      scene.textOptions = null;\n      scene.textSelectedOptions = null;\n      scene.textUnselectedOptions = null;\n      scene.selectBatch = null;\n      scene.unselectBatch = null;\n\n      // we can't just delete _scene, because `destroy` is called in the\n      // middle of supplyDefaults, before relinkPrivateKeys which will put it back.\n      subplot._scene = null;\n    };\n  }\n\n  // In case if we have scene from the last calc - reset data\n  if (!scene.dirty) {\n    Lib.extendFlat(scene, resetOpts);\n  }\n  return scene;\n}\nfunction getViewport(fullLayout, xaxis, yaxis) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  return [gs.l + xaxis.domain[0] * gs.w, gs.b + yaxis.domain[0] * gs.h, width - gs.r - (1 - xaxis.domain[1]) * gs.w, height - gs.t - (1 - yaxis.domain[1]) * gs.h];\n}\nfunction plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j;\n\n  // we may have more subplots than initialized data due to Axes.getSubplots method\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n  if (!success) {\n    scene.init();\n    return;\n  }\n  var regl = fullLayout._glcanvas.data()[0].regl;\n\n  // that is needed for fills\n  linkTraces(gd, subplot, cdata);\n  if (scene.dirty) {\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl);\n    }\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n    if (scene.glText === true) {\n      scene.glText = new Array(scene.count);\n      for (i = 0; i < scene.count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    }\n\n    // update main marker options\n    if (scene.glText) {\n      if (scene.count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = scene.count - scene.glText.length;\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (scene.count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - scene.count;\n        var removedTexts = scene.glText.splice(scene.count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n      for (i = 0; i < scene.count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n          var lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n\n    // fill requires linked traces, so we generate it's positions here\n    scene.fillOrder = Lib.repeat(null, scene.count);\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n          lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n          lastptdef = srcPos.length - 2;\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              last = j + 2;\n            }\n          }\n          pos = pos.concat(srcPos.slice(last));\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        }\n\n        // detect prev trace positions to exclude from current fill\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions;\n\n          // FIXME: likely this logic should be tested better\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  }\n\n  // form batch arrays, and check for selected points\n  scene.selectBatch = null;\n  scene.unselectBatch = null;\n  var dragmode = fullLayout.dragmode;\n  var selectMode = dragmode === 'lasso' || dragmode === 'select';\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n  for (i = 0; i < cdata.length; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n    if (trace.selectedpoints || selectMode || clickSelectEnabled) {\n      if (!selectMode) selectMode = true;\n      if (!scene.selectBatch) {\n        scene.selectBatch = [];\n        scene.unselectBatch = [];\n      }\n\n      // regenerate scene batch, if traces number changed during selection\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n        var unselPts = [];\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n        scene.unselectBatch[index] = unselPts;\n      }\n\n      // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n  if (selectMode) {\n    // create select2d\n    if (!scene.select2d) {\n      // create scatter instance by cloning scatter2d\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    }\n    if (scene.scatter2d && scene.selectBatch && scene.selectBatch.length) {\n      // update only traces with selection\n      scene.scatter2d.update(scene.markerUnselectedOptions.map(function (opts, i) {\n        return scene.selectBatch[i] ? opts : null;\n      }));\n    }\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        if (cdscatter && cdscatter[0] && cdscatter[0].trace) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    if (scene.scatter2d) {\n      // reset scatter2d opts to base opts,\n      // thus unsetting markerUnselectedOptions from selection\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  }\n\n  // provide viewport and range\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count);\n\n  // upload viewport/range data to GPU\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n}\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var stash = cd[0].t;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var x = stash.x;\n  var y = stash.y;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var maxDistance = pointData.distance;\n  var ids;\n\n  // FIXME: make sure this is a proper way to calc search radius\n  if (stash.tree) {\n    var xl = xa.p2c(xpx - maxDistance);\n    var xr = xa.p2c(xpx + maxDistance);\n    var yl = ya.p2c(ypx - maxDistance);\n    var yr = ya.p2c(ypx + maxDistance);\n    if (hovermode === 'x') {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(ya._rl[0], ya._rl[1]), Math.max(xl, xr), Math.max(ya._rl[0], ya._rl[1]));\n    } else {\n      ids = stash.tree.range(Math.min(xl, xr), Math.min(yl, yr), Math.max(xl, xr), Math.max(yl, yr));\n    }\n  } else if (stash.ids) {\n    ids = stash.ids;\n  } else return [pointData];\n\n  // pick the id closest to the point\n  // note that point possibly may not be found\n  var id, ptx, pty, i, dx, dy, dist, dxy;\n  var minDist = maxDistance;\n  if (hovermode === 'x') {\n    for (i = 0; i < ids.length; i++) {\n      ptx = x[ids[i]];\n      dx = Math.abs(xa.c2p(ptx) - xpx);\n      if (dx < minDist) {\n        minDist = dx;\n        dy = ya.c2p(y[ids[i]]) - ypx;\n        dxy = Math.sqrt(dx * dx + dy * dy);\n        id = ids[i];\n      }\n    }\n  } else {\n    for (i = 0; i < ids.length; i++) {\n      ptx = x[ids[i]];\n      pty = y[ids[i]];\n      dx = xa.c2p(ptx) - xpx;\n      dy = ya.c2p(pty) - ypx;\n      dist = Math.sqrt(dx * dx + dy * dy);\n      if (dist < minDist) {\n        minDist = dxy = dist;\n        id = ids[i];\n      }\n    }\n  }\n  pointData.index = id;\n  pointData.distance = minDist;\n  pointData.dxy = dxy;\n  if (id === undefined) return [pointData];\n  calcHover(pointData, x, y, trace);\n  return [pointData];\n}\nfunction calcHover(pointData, x, y, trace) {\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var minDist = pointData.distance;\n  var dxy = pointData.dxy;\n  var id = pointData.index;\n\n  // the closest data point\n  var di = {\n    pointNumber: id,\n    x: x[id],\n    y: y[id]\n  };\n\n  // that is single-item arrays_to_calcdata excerpt, since we are doing it for a single point and we don't have to do it beforehead for 1e6 points\n  di.tx = Array.isArray(trace.text) ? trace.text[id] : trace.text;\n  di.htx = Array.isArray(trace.hovertext) ? trace.hovertext[id] : trace.hovertext;\n  di.data = Array.isArray(trace.customdata) ? trace.customdata[id] : trace.customdata;\n  di.tp = Array.isArray(trace.textposition) ? trace.textposition[id] : trace.textposition;\n  var font = trace.textfont;\n  if (font) {\n    di.ts = Array.isArray(font.size) ? font.size[id] : font.size;\n    di.tc = Array.isArray(font.color) ? font.color[id] : font.color;\n    di.tf = Array.isArray(font.family) ? font.family[id] : font.family;\n  }\n  var marker = trace.marker;\n  if (marker) {\n    di.ms = Lib.isArrayOrTypedArray(marker.size) ? marker.size[id] : marker.size;\n    di.mo = Lib.isArrayOrTypedArray(marker.opacity) ? marker.opacity[id] : marker.opacity;\n    di.mx = Array.isArray(marker.symbol) ? marker.symbol[id] : marker.symbol;\n    di.mc = Lib.isArrayOrTypedArray(marker.color) ? marker.color[id] : marker.color;\n  }\n  var line = marker && marker.line;\n  if (line) {\n    di.mlc = Array.isArray(line.color) ? line.color[id] : line.color;\n    di.mlw = Lib.isArrayOrTypedArray(line.width) ? line.width[id] : line.width;\n  }\n  var grad = marker && marker.gradient;\n  if (grad && grad.type !== 'none') {\n    di.mgt = Array.isArray(grad.type) ? grad.type[id] : grad.type;\n    di.mgc = Array.isArray(grad.color) ? grad.color[id] : grad.color;\n  }\n  var xp = xa.c2p(di.x, true);\n  var yp = ya.c2p(di.y, true);\n  var rad = di.mrc || 1;\n  var hoverlabel = trace.hoverlabel;\n  if (hoverlabel) {\n    di.hbg = Array.isArray(hoverlabel.bgcolor) ? hoverlabel.bgcolor[id] : hoverlabel.bgcolor;\n    di.hbc = Array.isArray(hoverlabel.bordercolor) ? hoverlabel.bordercolor[id] : hoverlabel.bordercolor;\n    di.hts = Array.isArray(hoverlabel.font.size) ? hoverlabel.font.size[id] : hoverlabel.font.size;\n    di.htc = Array.isArray(hoverlabel.font.color) ? hoverlabel.font.color[id] : hoverlabel.font.color;\n    di.htf = Array.isArray(hoverlabel.font.family) ? hoverlabel.font.family[id] : hoverlabel.font.family;\n    di.hnl = Array.isArray(hoverlabel.namelength) ? hoverlabel.namelength[id] : hoverlabel.namelength;\n  }\n  var hoverinfo = trace.hoverinfo;\n  if (hoverinfo) {\n    di.hi = Array.isArray(hoverinfo) ? hoverinfo[id] : hoverinfo;\n  }\n  var hovertemplate = trace.hovertemplate;\n  if (hovertemplate) {\n    di.ht = Array.isArray(hovertemplate) ? hovertemplate[id] : hovertemplate;\n  }\n  var fakeCd = {};\n  fakeCd[pointData.index] = di;\n  Lib.extendFlat(pointData, {\n    color: getTraceColor(trace, di),\n    x0: xp - rad,\n    x1: xp + rad,\n    xLabelVal: di.x,\n    y0: yp - rad,\n    y1: yp + rad,\n    yLabelVal: di.y,\n    cd: fakeCd,\n    distance: minDist,\n    spikeDistance: dxy,\n    hovertemplate: di.ht\n  });\n  if (di.htx) pointData.text = di.htx;else if (di.tx) pointData.text = di.tx;else if (trace.text) pointData.text = trace.text;\n  fillHoverText(di, trace, pointData);\n  Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n  return pointData;\n}\nfunction selectPoints(searchInfo, selectionTester) {\n  var cd = searchInfo.cd;\n  var selection = [];\n  var trace = cd[0].trace;\n  var stash = cd[0].t;\n  var len = trace._length;\n  var x = stash.x;\n  var y = stash.y;\n  var scene = stash._scene;\n  if (!scene) return selection;\n  var hasText = subTypes.hasText(trace);\n  var hasMarkers = subTypes.hasMarkers(trace);\n  var hasOnlyLines = !hasMarkers && !hasText;\n  if (trace.visible !== true || hasOnlyLines) return selection;\n\n  // degenerate polygon does not enable selection\n  // filter out points by visible scatter ones\n  var els = null;\n  var unels = null;\n  // FIXME: clearing selection does not work here\n  var i;\n  if (selectionTester !== false && !selectionTester.degenerate) {\n    els = [], unels = [];\n    for (i = 0; i < len; i++) {\n      if (selectionTester.contains([stash.xpx[i], stash.ypx[i]], false, i, searchInfo)) {\n        els.push(i);\n        selection.push({\n          pointNumber: i,\n          x: x[i],\n          y: y[i]\n        });\n      } else {\n        unels.push(i);\n      }\n    }\n  } else {\n    unels = arrayRange(len);\n  }\n\n  // make sure selectBatch is created\n  if (!scene.selectBatch) {\n    scene.selectBatch = [];\n    scene.unselectBatch = [];\n  }\n  if (!scene.selectBatch[stash.index]) {\n    // enter every trace select mode\n    for (i = 0; i < scene.count; i++) {\n      scene.selectBatch[i] = [];\n      scene.unselectBatch[i] = [];\n    }\n    // we should turn scatter2d into unselected once we have any points selected\n    if (hasMarkers) {\n      scene.scatter2d.update(scene.markerUnselectedOptions);\n    }\n  }\n  scene.selectBatch[stash.index] = els;\n  scene.unselectBatch[stash.index] = unels;\n\n  // update text options\n  if (hasText) {\n    styleTextSelection(cd);\n  }\n  return selection;\n}\nfunction styleTextSelection(cd) {\n  var cd0 = cd[0];\n  var trace = cd0.trace;\n  var stash = cd0.t;\n  var scene = stash._scene;\n  var index = stash.index;\n  var els = scene.selectBatch[index];\n  var unels = scene.unselectBatch[index];\n  var baseOpts = scene.textOptions[index];\n  var selOpts = scene.textSelectedOptions[index] || {};\n  var unselOpts = scene.textUnselectedOptions[index] || {};\n  var opts = Lib.extendFlat({}, baseOpts);\n  var i, j;\n  if (els && unels) {\n    var stc = selOpts.color;\n    var utc = unselOpts.color;\n    var base = baseOpts.color;\n    var hasArrayBase = Array.isArray(base);\n    opts.color = new Array(trace._length);\n    for (i = 0; i < els.length; i++) {\n      j = els[i];\n      opts.color[j] = stc || (hasArrayBase ? base[j] : base);\n    }\n    for (i = 0; i < unels.length; i++) {\n      j = unels[i];\n      var basej = hasArrayBase ? base[j] : base;\n      opts.color[j] = utc ? utc : stc ? basej : Color.addOpacity(basej, DESELECTDIM);\n    }\n  }\n  scene.glText[index].update(opts);\n}\nmodule.exports = {\n  moduleType: 'trace',\n  name: 'scattergl',\n  basePlotModule: require('../../plots/cartesian'),\n  categories: ['gl', 'regl', 'cartesian', 'symbols', 'errorBarsOK', 'showLegend', 'scatter-like'],\n  attributes: require('./attributes'),\n  supplyDefaults: require('./defaults'),\n  crossTraceDefaults: require('../scatter/cross_trace_defaults'),\n  colorbar: require('../scatter/marker_colorbar'),\n  calc: calc,\n  plot: plot,\n  hoverPoints: hoverPoints,\n  selectPoints: selectPoints,\n  sceneUpdate: sceneUpdate,\n  calcHover: calcHover,\n  meta: {\n    hrName: 'scatter_gl',\n    description: ['The data visualized as scatter point or lines is set in `x` and `y`', 'using the WebGL plotting engine.', 'Bubble charts are achieved by setting `marker.size` and/or `marker.color`', 'to a numerical arrays.'].join(' ')\n  }\n};","map":{"version":3,"names":["createScatter","require","createLine","createError","cluster","arrayRange","Text","Registry","Lib","prepareRegl","AxisIDs","findExtremes","Color","subTypes","scatterCalc","calcMarkerSize","calcAxisExpansion","setFirstScatter","calcColorscale","linkTraces","getTraceColor","fillHoverText","convert","BADNUM","TOO_MANY_POINTS","DESELECTDIM","calc","gd","trace","fullLayout","_fullLayout","xa","getFromId","xaxis","ya","yaxis","subplot","_plots","len","_length","len2","stash","i","xx","yy","x","makeCalcdata","y","positions","Array","NaN","type","c2l","tree","ids","opts","sceneOptions","scene","sceneUpdate","ppad","marker","sizeAvg","Math","max","size","errorX","expandForErrorBars","errorY","fill","fill2d","scatter2d","line","line2d","error2d","text","glText","lineOptions","push","errorXOptions","errorYOptions","fillOptions","markerOptions","markerSelectedOptions","markerSel","markerUnselectedOptions","markerUnsel","textOptions","textSelectedOptions","textSel","textUnselectedOptions","textUnsel","_scene","index","count","t","ax","extremes","_extremes","_id","errExt","_bnds","padded","min","concat","style","length","extendFlat","linePositions","errors","errorBarPositions","textPosition","resetOpts","dirty","initOpts","selectBatch","unselectBatch","select2d","init","update","opt","repeat","draw","fillOrder","render","destroy","forEach","getViewport","gs","_size","width","height","l","domain","w","b","h","r","plot","cdata","j","success","regl","_glcanvas","data","textsToAdd","textsToRemove","removedTexts","splice","map","srcPos","firstptdef","isNaN","lastptdef","slice","errorBatch","cdscatter","cd","last","fillData","_ownfill","_nexttrace","pos","nextTrace","nextOptions","nextPos","floor","fillcolor","_prevtrace","prevLinePos","offset","hole","fillmode","opacity","dragmode","selectMode","clickSelectEnabled","clickmode","indexOf","cd0","selectedpoints","selPts","selIndices2selPoints","selDict","unselPts","xpx","ypx","c2p","styleTextSelection","vpRange0","viewport","range","_rl","vpRange","hoverPoints","pointData","xval","yval","hovermode","maxDistance","distance","xl","p2c","xr","yl","yr","id","ptx","pty","dx","dy","dist","dxy","minDist","abs","sqrt","undefined","calcHover","di","pointNumber","tx","isArray","htx","hovertext","customdata","tp","textposition","font","textfont","ts","tc","color","tf","family","ms","isArrayOrTypedArray","mo","mx","symbol","mc","mlc","mlw","grad","gradient","mgt","mgc","xp","yp","rad","mrc","hoverlabel","hbg","bgcolor","hbc","bordercolor","hts","htc","htf","hnl","namelength","hoverinfo","hi","hovertemplate","ht","fakeCd","x0","x1","xLabelVal","y0","y1","yLabelVal","spikeDistance","getComponentMethod","selectPoints","searchInfo","selectionTester","selection","hasText","hasMarkers","hasOnlyLines","visible","els","unels","degenerate","contains","baseOpts","selOpts","unselOpts","stc","utc","base","hasArrayBase","basej","addOpacity","module","exports","moduleType","name","basePlotModule","categories","attributes","supplyDefaults","crossTraceDefaults","colorbar","meta","hrName","description","join"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/scattergl/index.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar createScatter = require('regl-scatter2d');\nvar createLine = require('regl-line2d');\nvar createError = require('regl-error2d');\nvar cluster = require('point-cluster');\nvar arrayRange = require('array-range');\nvar Text = require('gl-text');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar prepareRegl = require('../../lib/prepare_regl');\nvar AxisIDs = require('../../plots/cartesian/axis_ids');\nvar findExtremes = require('../../plots/cartesian/autorange').findExtremes;\nvar Color = require('../../components/color');\n\nvar subTypes = require('../scatter/subtypes');\nvar scatterCalc = require('../scatter/calc');\nvar calcMarkerSize = scatterCalc.calcMarkerSize;\nvar calcAxisExpansion = scatterCalc.calcAxisExpansion;\nvar setFirstScatter = scatterCalc.setFirstScatter;\nvar calcColorscale = require('../scatter/colorscale_calc');\nvar linkTraces = require('../scatter/link_traces');\nvar getTraceColor = require('../scatter/get_trace_color');\nvar fillHoverText = require('../scatter/fill_hover_text');\nvar convert = require('./convert');\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\nvar TOO_MANY_POINTS = require('./constants').TOO_MANY_POINTS;\nvar DESELECTDIM = require('../../constants/interactions').DESELECTDIM;\n\nfunction calc(gd, trace) {\n    var fullLayout = gd._fullLayout;\n    var xa = AxisIDs.getFromId(gd, trace.xaxis);\n    var ya = AxisIDs.getFromId(gd, trace.yaxis);\n    var subplot = fullLayout._plots[trace.xaxis + trace.yaxis];\n    var len = trace._length;\n    var len2 = len * 2;\n    var stash = {};\n    var i, xx, yy;\n\n    var x = xa.makeCalcdata(trace, 'x');\n    var y = ya.makeCalcdata(trace, 'y');\n\n    // we need hi-precision for scatter2d,\n    // regl-scatter2d uses NaNs for bad/missing values\n    var positions = new Array(len2);\n    for(i = 0; i < len; i++) {\n        xx = x[i];\n        yy = y[i];\n        positions[i * 2] = xx === BADNUM ? NaN : xx;\n        positions[i * 2 + 1] = yy === BADNUM ? NaN : yy;\n    }\n\n    if(xa.type === 'log') {\n        for(i = 0; i < len2; i += 2) {\n            positions[i] = xa.c2l(positions[i]);\n        }\n    }\n    if(ya.type === 'log') {\n        for(i = 1; i < len2; i += 2) {\n            positions[i] = ya.c2l(positions[i]);\n        }\n    }\n\n    // we don't build a tree for log axes since it takes long to convert log2px\n    // and it is also\n    if(xa.type !== 'log' && ya.type !== 'log') {\n        // FIXME: delegate this to webworker\n        stash.tree = cluster(positions);\n    } else {\n        var ids = stash.ids = new Array(len);\n        for(i = 0; i < len; i++) {\n            ids[i] = i;\n        }\n    }\n\n    // create scene options and scene\n    calcColorscale(gd, trace);\n    var opts = sceneOptions(gd, subplot, trace, positions, x, y);\n    var scene = sceneUpdate(gd, subplot);\n\n    // Reuse SVG scatter axis expansion routine.\n    // For graphs with very large number of points and array marker.size,\n    // use average marker size instead to speed things up.\n    setFirstScatter(fullLayout, trace);\n    var ppad;\n    if(len < TOO_MANY_POINTS) {\n        ppad = calcMarkerSize(trace, len);\n    } else if(opts.marker) {\n        ppad = 2 * (opts.marker.sizeAvg || Math.max(opts.marker.size, 3));\n    }\n    calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n    if(opts.errorX) expandForErrorBars(trace, xa, opts.errorX);\n    if(opts.errorY) expandForErrorBars(trace, ya, opts.errorY);\n\n    // set flags to create scene renderers\n    if(opts.fill && !scene.fill2d) scene.fill2d = true;\n    if(opts.marker && !scene.scatter2d) scene.scatter2d = true;\n    if(opts.line && !scene.line2d) scene.line2d = true;\n    if((opts.errorX || opts.errorY) && !scene.error2d) scene.error2d = true;\n    if(opts.text && !scene.glText) scene.glText = true;\n\n    // FIXME: organize it in a more appropriate manner, probably in sceneOptions\n    // put point-cluster instance for optimized regl calc\n    if(opts.marker && len >= TOO_MANY_POINTS) {\n        opts.marker.cluster = stash.tree;\n    }\n\n    // save scene opts batch\n    scene.lineOptions.push(opts.line);\n    scene.errorXOptions.push(opts.errorX);\n    scene.errorYOptions.push(opts.errorY);\n    scene.fillOptions.push(opts.fill);\n    scene.markerOptions.push(opts.marker);\n    scene.markerSelectedOptions.push(opts.markerSel);\n    scene.markerUnselectedOptions.push(opts.markerUnsel);\n    scene.textOptions.push(opts.text);\n    scene.textSelectedOptions.push(opts.textSel);\n    scene.textUnselectedOptions.push(opts.textUnsel);\n\n    // stash scene ref\n    stash._scene = scene;\n    stash.index = scene.count;\n    stash.x = x;\n    stash.y = y;\n    stash.positions = positions;\n    scene.count++;\n\n    return [{x: false, y: false, t: stash, trace: trace}];\n}\n\nfunction expandForErrorBars(trace, ax, opts) {\n    var extremes = trace._extremes[ax._id];\n    var errExt = findExtremes(ax, opts._bnds, {padded: true});\n    extremes.min = extremes.min.concat(errExt.min);\n    extremes.max = extremes.max.concat(errExt.max);\n}\n\n// create scene options\nfunction sceneOptions(gd, subplot, trace, positions, x, y) {\n    var opts = convert.style(gd, trace);\n\n    if(opts.marker) {\n        opts.marker.positions = positions;\n    }\n\n    if(opts.line && positions.length > 1) {\n        Lib.extendFlat(\n            opts.line,\n            convert.linePositions(gd, trace, positions)\n        );\n    }\n\n    if(opts.errorX || opts.errorY) {\n        var errors = convert.errorBarPositions(gd, trace, positions, x, y);\n\n        if(opts.errorX) {\n            Lib.extendFlat(opts.errorX, errors.x);\n        }\n        if(opts.errorY) {\n            Lib.extendFlat(opts.errorY, errors.y);\n        }\n    }\n\n    if(opts.text) {\n        Lib.extendFlat(\n            opts.text,\n            {positions: positions},\n            convert.textPosition(gd, trace, opts.text, opts.marker)\n        );\n        Lib.extendFlat(\n            opts.textSel,\n            {positions: positions},\n            convert.textPosition(gd, trace, opts.text, opts.markerSel)\n        );\n        Lib.extendFlat(\n            opts.textUnsel,\n            {positions: positions},\n            convert.textPosition(gd, trace, opts.text, opts.markerUnsel)\n        );\n    }\n\n    return opts;\n}\n\n\n// make sure scene exists on subplot, return it\nfunction sceneUpdate(gd, subplot) {\n    var scene = subplot._scene;\n\n    var resetOpts = {\n        // number of traces in subplot, since scene:subplot → 1:1\n        count: 0,\n        // whether scene requires init hook in plot call (dirty plot call)\n        dirty: true,\n        // last used options\n        lineOptions: [],\n        fillOptions: [],\n        markerOptions: [],\n        markerSelectedOptions: [],\n        markerUnselectedOptions: [],\n        errorXOptions: [],\n        errorYOptions: [],\n        textOptions: [],\n        textSelectedOptions: [],\n        textUnselectedOptions: []\n    };\n\n    var initOpts = {\n        selectBatch: null,\n        unselectBatch: null,\n        // regl- component stubs, initialized in dirty plot call\n        fill2d: false,\n        scatter2d: false,\n        error2d: false,\n        line2d: false,\n        glText: false,\n        select2d: null\n    };\n\n    if(!subplot._scene) {\n        scene = subplot._scene = {};\n\n        scene.init = function init() {\n            Lib.extendFlat(scene, initOpts, resetOpts);\n        };\n\n        scene.init();\n\n        // apply new option to all regl components (used on drag)\n        scene.update = function update(opt) {\n            var opts = Lib.repeat(opt, scene.count);\n\n            if(scene.fill2d) scene.fill2d.update(opts);\n            if(scene.scatter2d) scene.scatter2d.update(opts);\n            if(scene.line2d) scene.line2d.update(opts);\n            if(scene.error2d) scene.error2d.update(opts.concat(opts));\n            if(scene.select2d) scene.select2d.update(opts);\n            if(scene.glText) {\n                for(var i = 0; i < scene.count; i++) {\n                    scene.glText[i].update(opt);\n                }\n            }\n        };\n\n        // draw traces in proper order\n        scene.draw = function draw() {\n            var count = scene.count;\n            var fill2d = scene.fill2d;\n            var error2d = scene.error2d;\n            var line2d = scene.line2d;\n            var scatter2d = scene.scatter2d;\n            var glText = scene.glText;\n            var select2d = scene.select2d;\n            var selectBatch = scene.selectBatch;\n            var unselectBatch = scene.unselectBatch;\n\n            for(var i = 0; i < count; i++) {\n                if(fill2d && scene.fillOrder[i]) {\n                    fill2d.draw(scene.fillOrder[i]);\n                }\n                if(line2d && scene.lineOptions[i]) {\n                    line2d.draw(i);\n                }\n                if(error2d) {\n                    if(scene.errorXOptions[i]) error2d.draw(i);\n                    if(scene.errorYOptions[i]) error2d.draw(i + count);\n                }\n                if(scatter2d && scene.markerOptions[i] && (!selectBatch || !selectBatch[i])) {\n                    scatter2d.draw(i);\n                }\n                if(glText[i] && scene.textOptions[i]) {\n                    glText[i].render();\n                }\n            }\n\n            if(scatter2d && select2d && selectBatch) {\n                select2d.draw(selectBatch);\n                scatter2d.draw(unselectBatch);\n            }\n\n            scene.dirty = false;\n        };\n\n        // remove scene resources\n        scene.destroy = function destroy() {\n            if(scene.fill2d && scene.fill2d.destroy) scene.fill2d.destroy();\n            if(scene.scatter2d && scene.scatter2d.destroy) scene.scatter2d.destroy();\n            if(scene.error2d && scene.error2d.destroy) scene.error2d.destroy();\n            if(scene.line2d && scene.line2d.destroy) scene.line2d.destroy();\n            if(scene.select2d && scene.select2d.destroy) scene.select2d.destroy();\n            if(scene.glText) {\n                scene.glText.forEach(function(text) {\n                    if(text.destroy) text.destroy();\n                });\n            }\n\n            scene.lineOptions = null;\n            scene.fillOptions = null;\n            scene.markerOptions = null;\n            scene.markerSelectedOptions = null;\n            scene.markerUnselectedOptions = null;\n            scene.errorXOptions = null;\n            scene.errorYOptions = null;\n            scene.textOptions = null;\n            scene.textSelectedOptions = null;\n            scene.textUnselectedOptions = null;\n\n            scene.selectBatch = null;\n            scene.unselectBatch = null;\n\n            // we can't just delete _scene, because `destroy` is called in the\n            // middle of supplyDefaults, before relinkPrivateKeys which will put it back.\n            subplot._scene = null;\n        };\n    }\n\n    // In case if we have scene from the last calc - reset data\n    if(!scene.dirty) {\n        Lib.extendFlat(scene, resetOpts);\n    }\n\n    return scene;\n}\n\nfunction getViewport(fullLayout, xaxis, yaxis) {\n    var gs = fullLayout._size;\n    var width = fullLayout.width;\n    var height = fullLayout.height;\n    return [\n        gs.l + xaxis.domain[0] * gs.w,\n        gs.b + yaxis.domain[0] * gs.h,\n        (width - gs.r) - (1 - xaxis.domain[1]) * gs.w,\n        (height - gs.t) - (1 - yaxis.domain[1]) * gs.h\n    ];\n}\n\nfunction plot(gd, subplot, cdata) {\n    if(!cdata.length) return;\n\n    var fullLayout = gd._fullLayout;\n    var scene = subplot._scene;\n    var xaxis = subplot.xaxis;\n    var yaxis = subplot.yaxis;\n    var i, j;\n\n    // we may have more subplots than initialized data due to Axes.getSubplots method\n    if(!scene) return;\n\n    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n    if(!success) {\n        scene.init();\n        return;\n    }\n\n    var regl = fullLayout._glcanvas.data()[0].regl;\n\n    // that is needed for fills\n    linkTraces(gd, subplot, cdata);\n\n    if(scene.dirty) {\n        // make sure scenes are created\n        if(scene.error2d === true) {\n            scene.error2d = createError(regl);\n        }\n        if(scene.line2d === true) {\n            scene.line2d = createLine(regl);\n        }\n        if(scene.scatter2d === true) {\n            scene.scatter2d = createScatter(regl);\n        }\n        if(scene.fill2d === true) {\n            scene.fill2d = createLine(regl);\n        }\n        if(scene.glText === true) {\n            scene.glText = new Array(scene.count);\n            for(i = 0; i < scene.count; i++) {\n                scene.glText[i] = new Text(regl);\n            }\n        }\n\n        // update main marker options\n        if(scene.glText) {\n            if(scene.count > scene.glText.length) {\n                // add gl text marker\n                var textsToAdd = scene.count - scene.glText.length;\n                for(i = 0; i < textsToAdd; i++) {\n                    scene.glText.push(new Text(regl));\n                }\n            } else if(scene.count < scene.glText.length) {\n                // remove gl text marker\n                var textsToRemove = scene.glText.length - scene.count;\n                var removedTexts = scene.glText.splice(scene.count, textsToRemove);\n                removedTexts.forEach(function(text) { text.destroy(); });\n            }\n\n            for(i = 0; i < scene.count; i++) {\n                scene.glText[i].update(scene.textOptions[i]);\n            }\n        }\n        if(scene.line2d) {\n            scene.line2d.update(scene.lineOptions);\n            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {\n                if(lineOptions && lineOptions.positions) {\n                    var srcPos = lineOptions.positions;\n\n                    var firstptdef = 0;\n                    while(firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n                        firstptdef += 2;\n                    }\n                    var lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n                        lastptdef -= 2;\n                    }\n                    lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n                }\n                return lineOptions;\n            });\n            scene.line2d.update(scene.lineOptions);\n        }\n        if(scene.error2d) {\n            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n            scene.error2d.update(errorBatch);\n        }\n        if(scene.scatter2d) {\n            scene.scatter2d.update(scene.markerOptions);\n        }\n\n        // fill requires linked traces, so we generate it's positions here\n        scene.fillOrder = Lib.repeat(null, scene.count);\n        if(scene.fill2d) {\n            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i) {\n                var cdscatter = cdata[i];\n                if(!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n                var cd = cdscatter[0];\n                var trace = cd.trace;\n                var stash = cd.t;\n                var lineOptions = scene.lineOptions[i];\n                var last, j;\n\n                var fillData = [];\n                if(trace._ownfill) fillData.push(i);\n                if(trace._nexttrace) fillData.push(i + 1);\n                if(fillData.length) scene.fillOrder[i] = fillData;\n\n                var pos = [];\n                var srcPos = (lineOptions && lineOptions.positions) || stash.positions;\n                var firstptdef, lastptdef;\n\n                if(trace.fill === 'tozeroy') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef + 1] !== 0) {\n                        pos = [srcPos[firstptdef], 0];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef + 1] !== 0) {\n                        pos = pos.concat([srcPos[lastptdef], 0]);\n                    }\n                }\n                else if(trace.fill === 'tozerox') {\n                    firstptdef = 0;\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n                        firstptdef += 2;\n                    }\n                    lastptdef = srcPos.length - 2;\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n                        lastptdef -= 2;\n                    }\n                    if(srcPos[firstptdef] !== 0) {\n                        pos = [0, srcPos[firstptdef + 1]];\n                    }\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n                    if(srcPos[lastptdef] !== 0) {\n                        pos = pos.concat([ 0, srcPos[lastptdef + 1]]);\n                    }\n                }\n                else if(trace.fill === 'toself' || trace.fill === 'tonext') {\n                    pos = [];\n                    last = 0;\n                    for(j = 0; j < srcPos.length; j += 2) {\n                        if(isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n                            pos = pos.concat(srcPos.slice(last, j));\n                            pos.push(srcPos[last], srcPos[last + 1]);\n                            last = j + 2;\n                        }\n                    }\n                    pos = pos.concat(srcPos.slice(last));\n                    if(last) {\n                        pos.push(srcPos[last], srcPos[last + 1]);\n                    }\n                }\n                else {\n                    var nextTrace = trace._nexttrace;\n\n                    if(nextTrace) {\n                        var nextOptions = scene.lineOptions[i + 1];\n\n                        if(nextOptions) {\n                            var nextPos = nextOptions.positions;\n                            if(trace.fill === 'tonexty') {\n                                pos = srcPos.slice();\n\n                                for(i = Math.floor(nextPos.length / 2); i--;) {\n                                    var xx = nextPos[i * 2];\n                                    var yy = nextPos[i * 2 + 1];\n                                    if(isNaN(xx) || isNaN(yy)) continue;\n                                    pos.push(xx, yy);\n                                }\n                                fillOptions.fill = nextTrace.fillcolor;\n                            }\n                        }\n                    }\n                }\n\n                // detect prev trace positions to exclude from current fill\n                if(trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n                    var prevLinePos = scene.lineOptions[i - 1].positions;\n\n                    // FIXME: likely this logic should be tested better\n                    var offset = pos.length / 2;\n                    last = offset;\n                    var hole = [last];\n                    for(j = 0; j < prevLinePos.length; j += 2) {\n                        if(isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n                            hole.push(j / 2 + offset + 1);\n                            last = j + 2;\n                        }\n                    }\n\n                    pos = pos.concat(prevLinePos);\n                    fillOptions.hole = hole;\n                }\n                fillOptions.fillmode = trace.fill;\n                fillOptions.opacity = trace.opacity;\n                fillOptions.positions = pos;\n\n                return fillOptions;\n            });\n\n            scene.fill2d.update(scene.fillOptions);\n        }\n    }\n\n    // form batch arrays, and check for selected points\n    scene.selectBatch = null;\n    scene.unselectBatch = null;\n    var dragmode = fullLayout.dragmode;\n    var selectMode = dragmode === 'lasso' || dragmode === 'select';\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n    for(i = 0; i < cdata.length; i++) {\n        var cd0 = cdata[i][0];\n        var trace = cd0.trace;\n        var stash = cd0.t;\n        var index = stash.index;\n        var len = trace._length;\n        var x = stash.x;\n        var y = stash.y;\n\n        if(trace.selectedpoints || selectMode || clickSelectEnabled) {\n            if(!selectMode) selectMode = true;\n\n            if(!scene.selectBatch) {\n                scene.selectBatch = [];\n                scene.unselectBatch = [];\n            }\n\n            // regenerate scene batch, if traces number changed during selection\n            if(trace.selectedpoints) {\n                var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n\n                var selDict = {};\n                for(j = 0; j < selPts.length; j++) {\n                    selDict[selPts[j]] = 1;\n                }\n                var unselPts = [];\n                for(j = 0; j < len; j++) {\n                    if(!selDict[j]) unselPts.push(j);\n                }\n                scene.unselectBatch[index] = unselPts;\n            }\n\n            // precalculate px coords since we are not going to pan during select\n            // TODO, could do better here e.g.\n            // - spin that in a webworker\n            // - compute selection from polygons in data coordinates\n            //   (maybe just for linear axes)\n            var xpx = stash.xpx = new Array(len);\n            var ypx = stash.ypx = new Array(len);\n            for(j = 0; j < len; j++) {\n                xpx[j] = xaxis.c2p(x[j]);\n                ypx[j] = yaxis.c2p(y[j]);\n            }\n        } else {\n            stash.xpx = stash.ypx = null;\n        }\n    }\n\n\n    if(selectMode) {\n        // create select2d\n        if(!scene.select2d) {\n            // create scatter instance by cloning scatter2d\n            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n        }\n\n        if(scene.scatter2d && scene.selectBatch && scene.selectBatch.length) {\n            // update only traces with selection\n            scene.scatter2d.update(scene.markerUnselectedOptions.map(function(opts, i) {\n                return scene.selectBatch[i] ? opts : null;\n            }));\n        }\n\n        if(scene.select2d) {\n            scene.select2d.update(scene.markerOptions);\n            scene.select2d.update(scene.markerSelectedOptions);\n        }\n\n        if(scene.glText) {\n            cdata.forEach(function(cdscatter) {\n                if(cdscatter && cdscatter[0] && cdscatter[0].trace) {\n                    styleTextSelection(cdscatter);\n                }\n            });\n        }\n    } else {\n        if(scene.scatter2d) {\n            // reset scatter2d opts to base opts,\n            // thus unsetting markerUnselectedOptions from selection\n            scene.scatter2d.update(scene.markerOptions);\n        }\n    }\n\n    // provide viewport and range\n    var vpRange0 = {\n        viewport: getViewport(fullLayout, xaxis, yaxis),\n        // TODO do we need those fallbacks?\n        range: [\n            (xaxis._rl || xaxis.range)[0],\n            (yaxis._rl || yaxis.range)[0],\n            (xaxis._rl || xaxis.range)[1],\n            (yaxis._rl || yaxis.range)[1]\n        ]\n    };\n    var vpRange = Lib.repeat(vpRange0, scene.count);\n\n    // upload viewport/range data to GPU\n    if(scene.fill2d) {\n        scene.fill2d.update(vpRange);\n    }\n    if(scene.line2d) {\n        scene.line2d.update(vpRange);\n    }\n    if(scene.error2d) {\n        scene.error2d.update(vpRange.concat(vpRange));\n    }\n    if(scene.scatter2d) {\n        scene.scatter2d.update(vpRange);\n    }\n    if(scene.select2d) {\n        scene.select2d.update(vpRange);\n    }\n    if(scene.glText) {\n        scene.glText.forEach(function(text) { text.update(vpRange0); });\n    }\n}\n\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var stash = cd[0].t;\n    var trace = cd[0].trace;\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var x = stash.x;\n    var y = stash.y;\n    var xpx = xa.c2p(xval);\n    var ypx = ya.c2p(yval);\n    var maxDistance = pointData.distance;\n    var ids;\n\n    // FIXME: make sure this is a proper way to calc search radius\n    if(stash.tree) {\n        var xl = xa.p2c(xpx - maxDistance);\n        var xr = xa.p2c(xpx + maxDistance);\n        var yl = ya.p2c(ypx - maxDistance);\n        var yr = ya.p2c(ypx + maxDistance);\n\n        if(hovermode === 'x') {\n            ids = stash.tree.range(\n                Math.min(xl, xr), Math.min(ya._rl[0], ya._rl[1]),\n                Math.max(xl, xr), Math.max(ya._rl[0], ya._rl[1])\n            );\n        }\n        else {\n            ids = stash.tree.range(\n                Math.min(xl, xr), Math.min(yl, yr),\n                Math.max(xl, xr), Math.max(yl, yr)\n            );\n        }\n    }\n    else if(stash.ids) {\n        ids = stash.ids;\n    }\n    else return [pointData];\n\n    // pick the id closest to the point\n    // note that point possibly may not be found\n    var id, ptx, pty, i, dx, dy, dist, dxy;\n\n    var minDist = maxDistance;\n    if(hovermode === 'x') {\n        for(i = 0; i < ids.length; i++) {\n            ptx = x[ids[i]];\n            dx = Math.abs(xa.c2p(ptx) - xpx);\n            if(dx < minDist) {\n                minDist = dx;\n                dy = ya.c2p(y[ids[i]]) - ypx;\n                dxy = Math.sqrt(dx * dx + dy * dy);\n                id = ids[i];\n            }\n        }\n    }\n    else {\n        for(i = 0; i < ids.length; i++) {\n            ptx = x[ids[i]];\n            pty = y[ids[i]];\n            dx = xa.c2p(ptx) - xpx;\n            dy = ya.c2p(pty) - ypx;\n\n            dist = Math.sqrt(dx * dx + dy * dy);\n            if(dist < minDist) {\n                minDist = dxy = dist;\n                id = ids[i];\n            }\n        }\n    }\n\n    pointData.index = id;\n    pointData.distance = minDist;\n    pointData.dxy = dxy;\n\n    if(id === undefined) return [pointData];\n\n    calcHover(pointData, x, y, trace);\n\n    return [pointData];\n}\n\n\nfunction calcHover(pointData, x, y, trace) {\n    var xa = pointData.xa;\n    var ya = pointData.ya;\n    var minDist = pointData.distance;\n    var dxy = pointData.dxy;\n    var id = pointData.index;\n\n    // the closest data point\n    var di = {\n        pointNumber: id,\n        x: x[id],\n        y: y[id]\n    };\n\n    // that is single-item arrays_to_calcdata excerpt, since we are doing it for a single point and we don't have to do it beforehead for 1e6 points\n    di.tx = Array.isArray(trace.text) ? trace.text[id] : trace.text;\n    di.htx = Array.isArray(trace.hovertext) ? trace.hovertext[id] : trace.hovertext;\n    di.data = Array.isArray(trace.customdata) ? trace.customdata[id] : trace.customdata;\n    di.tp = Array.isArray(trace.textposition) ? trace.textposition[id] : trace.textposition;\n\n    var font = trace.textfont;\n    if(font) {\n        di.ts = Array.isArray(font.size) ? font.size[id] : font.size;\n        di.tc = Array.isArray(font.color) ? font.color[id] : font.color;\n        di.tf = Array.isArray(font.family) ? font.family[id] : font.family;\n    }\n\n    var marker = trace.marker;\n    if(marker) {\n        di.ms = Lib.isArrayOrTypedArray(marker.size) ? marker.size[id] : marker.size;\n        di.mo = Lib.isArrayOrTypedArray(marker.opacity) ? marker.opacity[id] : marker.opacity;\n        di.mx = Array.isArray(marker.symbol) ? marker.symbol[id] : marker.symbol;\n        di.mc = Lib.isArrayOrTypedArray(marker.color) ? marker.color[id] : marker.color;\n    }\n\n    var line = marker && marker.line;\n    if(line) {\n        di.mlc = Array.isArray(line.color) ? line.color[id] : line.color;\n        di.mlw = Lib.isArrayOrTypedArray(line.width) ? line.width[id] : line.width;\n    }\n\n    var grad = marker && marker.gradient;\n    if(grad && grad.type !== 'none') {\n        di.mgt = Array.isArray(grad.type) ? grad.type[id] : grad.type;\n        di.mgc = Array.isArray(grad.color) ? grad.color[id] : grad.color;\n    }\n\n    var xp = xa.c2p(di.x, true);\n    var yp = ya.c2p(di.y, true);\n    var rad = di.mrc || 1;\n\n    var hoverlabel = trace.hoverlabel;\n\n    if(hoverlabel) {\n        di.hbg = Array.isArray(hoverlabel.bgcolor) ? hoverlabel.bgcolor[id] : hoverlabel.bgcolor;\n        di.hbc = Array.isArray(hoverlabel.bordercolor) ? hoverlabel.bordercolor[id] : hoverlabel.bordercolor;\n        di.hts = Array.isArray(hoverlabel.font.size) ? hoverlabel.font.size[id] : hoverlabel.font.size;\n        di.htc = Array.isArray(hoverlabel.font.color) ? hoverlabel.font.color[id] : hoverlabel.font.color;\n        di.htf = Array.isArray(hoverlabel.font.family) ? hoverlabel.font.family[id] : hoverlabel.font.family;\n        di.hnl = Array.isArray(hoverlabel.namelength) ? hoverlabel.namelength[id] : hoverlabel.namelength;\n    }\n    var hoverinfo = trace.hoverinfo;\n    if(hoverinfo) {\n        di.hi = Array.isArray(hoverinfo) ? hoverinfo[id] : hoverinfo;\n    }\n\n    var hovertemplate = trace.hovertemplate;\n    if(hovertemplate) {\n        di.ht = Array.isArray(hovertemplate) ? hovertemplate[id] : hovertemplate;\n    }\n\n    var fakeCd = {};\n    fakeCd[pointData.index] = di;\n\n    Lib.extendFlat(pointData, {\n        color: getTraceColor(trace, di),\n\n        x0: xp - rad,\n        x1: xp + rad,\n        xLabelVal: di.x,\n\n        y0: yp - rad,\n        y1: yp + rad,\n        yLabelVal: di.y,\n\n        cd: fakeCd,\n        distance: minDist,\n        spikeDistance: dxy,\n\n        hovertemplate: di.ht\n    });\n\n    if(di.htx) pointData.text = di.htx;\n    else if(di.tx) pointData.text = di.tx;\n    else if(trace.text) pointData.text = trace.text;\n\n    fillHoverText(di, trace, pointData);\n    Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n\n    return pointData;\n}\n\n\nfunction selectPoints(searchInfo, selectionTester) {\n    var cd = searchInfo.cd;\n    var selection = [];\n    var trace = cd[0].trace;\n    var stash = cd[0].t;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n    var scene = stash._scene;\n\n    if(!scene) return selection;\n\n    var hasText = subTypes.hasText(trace);\n    var hasMarkers = subTypes.hasMarkers(trace);\n    var hasOnlyLines = !hasMarkers && !hasText;\n    if(trace.visible !== true || hasOnlyLines) return selection;\n\n    // degenerate polygon does not enable selection\n    // filter out points by visible scatter ones\n    var els = null;\n    var unels = null;\n    // FIXME: clearing selection does not work here\n    var i;\n    if(selectionTester !== false && !selectionTester.degenerate) {\n        els = [], unels = [];\n        for(i = 0; i < len; i++) {\n            if(selectionTester.contains([stash.xpx[i], stash.ypx[i]], false, i, searchInfo)) {\n                els.push(i);\n                selection.push({\n                    pointNumber: i,\n                    x: x[i],\n                    y: y[i]\n                });\n            }\n            else {\n                unels.push(i);\n            }\n        }\n    } else {\n        unels = arrayRange(len);\n    }\n\n    // make sure selectBatch is created\n    if(!scene.selectBatch) {\n        scene.selectBatch = [];\n        scene.unselectBatch = [];\n    }\n\n    if(!scene.selectBatch[stash.index]) {\n        // enter every trace select mode\n        for(i = 0; i < scene.count; i++) {\n            scene.selectBatch[i] = [];\n            scene.unselectBatch[i] = [];\n        }\n        // we should turn scatter2d into unselected once we have any points selected\n        if(hasMarkers) {\n            scene.scatter2d.update(scene.markerUnselectedOptions);\n        }\n    }\n\n    scene.selectBatch[stash.index] = els;\n    scene.unselectBatch[stash.index] = unels;\n\n    // update text options\n    if(hasText) {\n        styleTextSelection(cd);\n    }\n\n    return selection;\n}\n\nfunction styleTextSelection(cd) {\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var scene = stash._scene;\n    var index = stash.index;\n    var els = scene.selectBatch[index];\n    var unels = scene.unselectBatch[index];\n    var baseOpts = scene.textOptions[index];\n    var selOpts = scene.textSelectedOptions[index] || {};\n    var unselOpts = scene.textUnselectedOptions[index] || {};\n    var opts = Lib.extendFlat({}, baseOpts);\n    var i, j;\n\n    if(els && unels) {\n        var stc = selOpts.color;\n        var utc = unselOpts.color;\n        var base = baseOpts.color;\n        var hasArrayBase = Array.isArray(base);\n        opts.color = new Array(trace._length);\n\n        for(i = 0; i < els.length; i++) {\n            j = els[i];\n            opts.color[j] = stc || (hasArrayBase ? base[j] : base);\n        }\n        for(i = 0; i < unels.length; i++) {\n            j = unels[i];\n            var basej = hasArrayBase ? base[j] : base;\n            opts.color[j] = utc ? utc :\n                stc ? basej : Color.addOpacity(basej, DESELECTDIM);\n        }\n    }\n\n    scene.glText[index].update(opts);\n}\n\nmodule.exports = {\n    moduleType: 'trace',\n    name: 'scattergl',\n    basePlotModule: require('../../plots/cartesian'),\n    categories: ['gl', 'regl', 'cartesian', 'symbols', 'errorBarsOK', 'showLegend', 'scatter-like'],\n\n    attributes: require('./attributes'),\n    supplyDefaults: require('./defaults'),\n    crossTraceDefaults: require('../scatter/cross_trace_defaults'),\n    colorbar: require('../scatter/marker_colorbar'),\n    calc: calc,\n    plot: plot,\n    hoverPoints: hoverPoints,\n    selectPoints: selectPoints,\n\n    sceneUpdate: sceneUpdate,\n    calcHover: calcHover,\n\n    meta: {\n        hrName: 'scatter_gl',\n        description: [\n            'The data visualized as scatter point or lines is set in `x` and `y`',\n            'using the WebGL plotting engine.',\n            'Bubble charts are achieved by setting `marker.size` and/or `marker.color`',\n            'to a numerical arrays.'\n        ].join(' ')\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}