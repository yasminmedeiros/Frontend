{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\n\n// Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\nmodule.exports = function makeCrossings(pathinfo) {\n  var z = pathinfo[0].z;\n  var m = z.length;\n  var n = z[0].length; // we already made sure z isn't ragged in interp2d\n  var twoWide = m === 2 || n === 2;\n  var xi;\n  var yi;\n  var startIndices;\n  var ystartIndices;\n  var label;\n  var corners;\n  var mi;\n  var pi;\n  var i;\n  for (yi = 0; yi < m - 1; yi++) {\n    ystartIndices = [];\n    if (yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n    if (yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n    for (xi = 0; xi < n - 1; xi++) {\n      startIndices = ystartIndices.slice();\n      if (xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n      if (xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n      label = xi + ',' + yi;\n      corners = [[z[yi][xi], z[yi][xi + 1]], [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n      for (i = 0; i < pathinfo.length; i++) {\n        pi = pathinfo[i];\n        mi = getMarchingIndex(pi.level, corners);\n        if (!mi) continue;\n        pi.crossings[label] = mi;\n        if (startIndices.indexOf(mi) !== -1) {\n          pi.starts.push([xi, yi]);\n          if (twoWide && startIndices.indexOf(mi, startIndices.indexOf(mi) + 1) !== -1) {\n            // the same square has starts from opposite sides\n            // it's not possible to have starts on opposite edges\n            // of a corner, only a start and an end...\n            // but if the array is only two points wide (either way)\n            // you can have starts on opposite sides.\n            pi.starts.push([xi, yi]);\n          }\n        }\n      }\n    }\n  }\n};\n\n// modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\nfunction getMarchingIndex(val, corners) {\n  var mi = (corners[0][0] > val ? 0 : 1) + (corners[0][1] > val ? 0 : 2) + (corners[1][1] > val ? 0 : 4) + (corners[1][0] > val ? 0 : 8);\n  if (mi === 5 || mi === 10) {\n    var avg = (corners[0][0] + corners[0][1] + corners[1][0] + corners[1][1]) / 4;\n    // two peaks with a big valley\n    if (val > avg) return mi === 5 ? 713 : 1114;\n    // two valleys with a big ridge\n    return mi === 5 ? 104 : 208;\n  }\n  return mi === 15 ? 0 : mi;\n}","map":{"version":3,"names":["constants","require","module","exports","makeCrossings","pathinfo","z","m","length","n","twoWide","xi","yi","startIndices","ystartIndices","label","corners","mi","pi","i","concat","BOTTOMSTART","TOPSTART","slice","LEFTSTART","RIGHTSTART","getMarchingIndex","level","crossings","indexOf","starts","push","val","avg"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/contour/make_crossings.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\n\n// Calculate all the marching indices, for ALL levels at once.\n// since we want to be exhaustive we'll check for contour crossings\n// at every intersection, rather than just following a path\n// TODO: shorten the inner loop to only the relevant levels\nmodule.exports = function makeCrossings(pathinfo) {\n    var z = pathinfo[0].z;\n    var m = z.length;\n    var n = z[0].length; // we already made sure z isn't ragged in interp2d\n    var twoWide = m === 2 || n === 2;\n    var xi;\n    var yi;\n    var startIndices;\n    var ystartIndices;\n    var label;\n    var corners;\n    var mi;\n    var pi;\n    var i;\n\n    for(yi = 0; yi < m - 1; yi++) {\n        ystartIndices = [];\n        if(yi === 0) ystartIndices = ystartIndices.concat(constants.BOTTOMSTART);\n        if(yi === m - 2) ystartIndices = ystartIndices.concat(constants.TOPSTART);\n\n        for(xi = 0; xi < n - 1; xi++) {\n            startIndices = ystartIndices.slice();\n            if(xi === 0) startIndices = startIndices.concat(constants.LEFTSTART);\n            if(xi === n - 2) startIndices = startIndices.concat(constants.RIGHTSTART);\n\n            label = xi + ',' + yi;\n            corners = [[z[yi][xi], z[yi][xi + 1]],\n                       [z[yi + 1][xi], z[yi + 1][xi + 1]]];\n            for(i = 0; i < pathinfo.length; i++) {\n                pi = pathinfo[i];\n                mi = getMarchingIndex(pi.level, corners);\n                if(!mi) continue;\n\n                pi.crossings[label] = mi;\n                if(startIndices.indexOf(mi) !== -1) {\n                    pi.starts.push([xi, yi]);\n                    if(twoWide && startIndices.indexOf(mi,\n                            startIndices.indexOf(mi) + 1) !== -1) {\n                        // the same square has starts from opposite sides\n                        // it's not possible to have starts on opposite edges\n                        // of a corner, only a start and an end...\n                        // but if the array is only two points wide (either way)\n                        // you can have starts on opposite sides.\n                        pi.starts.push([xi, yi]);\n                    }\n                }\n            }\n        }\n    }\n};\n\n// modified marching squares algorithm,\n// so we disambiguate the saddle points from the start\n// and we ignore the cases with no crossings\n// the index I'm using is based on:\n// http://en.wikipedia.org/wiki/Marching_squares\n// except that the saddles bifurcate and I represent them\n// as the decimal combination of the two appropriate\n// non-saddle indices\nfunction getMarchingIndex(val, corners) {\n    var mi = (corners[0][0] > val ? 0 : 1) +\n             (corners[0][1] > val ? 0 : 2) +\n             (corners[1][1] > val ? 0 : 4) +\n             (corners[1][0] > val ? 0 : 8);\n    if(mi === 5 || mi === 10) {\n        var avg = (corners[0][0] + corners[0][1] +\n                   corners[1][0] + corners[1][1]) / 4;\n        // two peaks with a big valley\n        if(val > avg) return (mi === 5) ? 713 : 1114;\n        // two valleys with a big ridge\n        return (mi === 5) ? 104 : 208;\n    }\n    return (mi === 15) ? 0 : mi;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}