{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar binFunctions = require('../histogram/bin_functions');\nvar normFunctions = require('../histogram/norm_functions');\nvar doAvg = require('../histogram/average');\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\nmodule.exports = function calc(gd, trace) {\n  var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n  var x = trace.x ? xa.makeCalcdata(trace, 'x') : [];\n  var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n  var y = trace.y ? ya.makeCalcdata(trace, 'y') : [];\n  var xcalendar = trace.xcalendar;\n  var ycalendar = trace.ycalendar;\n  var xr2c = function xr2c(v) {\n    return xa.r2c(v, 0, xcalendar);\n  };\n  var yr2c = function yr2c(v) {\n    return ya.r2c(v, 0, ycalendar);\n  };\n  var xc2r = function xc2r(v) {\n    return xa.c2r(v, 0, xcalendar);\n  };\n  var yc2r = function yc2r(v) {\n    return ya.c2r(v, 0, ycalendar);\n  };\n  var i, j, n, m;\n  var serieslen = trace._length;\n  if (x.length > serieslen) x.splice(serieslen, x.length - serieslen);\n  if (y.length > serieslen) y.splice(serieslen, y.length - serieslen);\n\n  // calculate the bins\n  doAutoBin(trace, 'x', x, xa, xr2c, xc2r, xcalendar);\n  doAutoBin(trace, 'y', y, ya, yr2c, yc2r, ycalendar);\n\n  // make the empty bin array & scale the map\n  var z = [];\n  var onecol = [];\n  var zerocol = [];\n  var nonuniformBinsX = typeof trace.xbins.size === 'string';\n  var nonuniformBinsY = typeof trace.ybins.size === 'string';\n  var xEdges = [];\n  var yEdges = [];\n  var xbins = nonuniformBinsX ? xEdges : trace.xbins;\n  var ybins = nonuniformBinsY ? yEdges : trace.ybins;\n  var total = 0;\n  var counts = [];\n  var inputPoints = [];\n  var norm = trace.histnorm;\n  var func = trace.histfunc;\n  var densitynorm = norm.indexOf('density') !== -1;\n  var extremefunc = func === 'max' || func === 'min';\n  var sizeinit = extremefunc ? null : 0;\n  var binfunc = binFunctions.count;\n  var normfunc = normFunctions[norm];\n  var doavg = false;\n  var xinc = [];\n  var yinc = [];\n\n  // set a binning function other than count?\n  // for binning functions: check first for 'z',\n  // then 'mc' in case we had a colored scatter plot\n  // and want to transfer these colors to the 2D histo\n  // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n  var rawCounterData = 'z' in trace ? trace.z : 'marker' in trace && Array.isArray(trace.marker.color) ? trace.marker.color : '';\n  if (rawCounterData && func !== 'count') {\n    doavg = func === 'avg';\n    binfunc = binFunctions[func];\n  }\n\n  // decrease end a little in case of rounding errors\n  var binSpec = trace.xbins;\n  var binStart = xr2c(binSpec.start);\n  var binEnd = xr2c(binSpec.end) + (binStart - Axes.tickIncrement(binStart, binSpec.size, false, xcalendar)) / 1e6;\n  for (i = binStart; i < binEnd; i = Axes.tickIncrement(i, binSpec.size, false, xcalendar)) {\n    onecol.push(sizeinit);\n    xEdges.push(i);\n    if (doavg) zerocol.push(0);\n  }\n  xEdges.push(i);\n  var nx = onecol.length;\n  var x0c = xr2c(trace.xbins.start);\n  var dx = (i - x0c) / nx;\n  var x0 = xc2r(x0c + dx / 2);\n  binSpec = trace.ybins;\n  binStart = yr2c(binSpec.start);\n  binEnd = yr2c(binSpec.end) + (binStart - Axes.tickIncrement(binStart, binSpec.size, false, ycalendar)) / 1e6;\n  for (i = binStart; i < binEnd; i = Axes.tickIncrement(i, binSpec.size, false, ycalendar)) {\n    z.push(onecol.slice());\n    yEdges.push(i);\n    var ipCol = new Array(nx);\n    for (j = 0; j < nx; j++) {\n      ipCol[j] = [];\n    }\n    inputPoints.push(ipCol);\n    if (doavg) counts.push(zerocol.slice());\n  }\n  yEdges.push(i);\n  var ny = z.length;\n  var y0c = yr2c(trace.ybins.start);\n  var dy = (i - y0c) / ny;\n  var y0 = yc2r(y0c + dy / 2);\n  if (densitynorm) {\n    xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n    yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n  }\n\n  // for date axes we need bin bounds to be calcdata. For nonuniform bins\n  // we already have this, but uniform with start/end/size they're still strings.\n  if (!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n  if (!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins);\n\n  // put data into bins\n  var uniqueValsPerX = true;\n  var uniqueValsPerY = true;\n  var xVals = new Array(nx);\n  var yVals = new Array(ny);\n  var xGapLow = Infinity;\n  var xGapHigh = Infinity;\n  var yGapLow = Infinity;\n  var yGapHigh = Infinity;\n  for (i = 0; i < serieslen; i++) {\n    var xi = x[i];\n    var yi = y[i];\n    n = Lib.findBin(xi, xbins);\n    m = Lib.findBin(yi, ybins);\n    if (n >= 0 && n < nx && m >= 0 && m < ny) {\n      total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n      inputPoints[m][n].push(i);\n      if (uniqueValsPerX) {\n        if (xVals[n] === undefined) xVals[n] = xi;else if (xVals[n] !== xi) uniqueValsPerX = false;\n      }\n      if (uniqueValsPerY) {\n        if (yVals[n] === undefined) yVals[n] = yi;else if (yVals[n] !== yi) uniqueValsPerY = false;\n      }\n      xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n      xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n      yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n      yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n    }\n  }\n  // normalize, if needed\n  if (doavg) {\n    for (m = 0; m < ny; m++) {\n      total += doAvg(z[m], counts[m]);\n    }\n  }\n  if (normfunc) {\n    for (m = 0; m < ny; m++) {\n      normfunc(z[m], total, xinc, yinc[m]);\n    }\n  }\n  return {\n    x: x,\n    xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n    x0: x0,\n    dx: dx,\n    y: y,\n    yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n    y0: y0,\n    dy: dy,\n    z: z,\n    pts: inputPoints\n  };\n};\nfunction doAutoBin(trace, axLetter, data, ax, r2c, c2r, calendar) {\n  var binAttr = axLetter + 'bins';\n  var binSpec = trace[binAttr];\n  if (!binSpec) binSpec = trace[binAttr] = {};\n  var inputBinSpec = trace._input[binAttr] || {};\n  var autoBin = trace._autoBin = {};\n\n  // clear out any previously added autobin info\n  if (!inputBinSpec.size) delete binSpec.size;\n  if (inputBinSpec.start === undefined) delete binSpec.start;\n  if (inputBinSpec.end === undefined) delete binSpec.end;\n  var autoSize = !binSpec.size;\n  var autoStart = binSpec.start === undefined;\n  var autoEnd = binSpec.end === undefined;\n  if (autoSize || autoStart || autoEnd) {\n    var newBinSpec = Axes.autoBin(data, ax, trace['nbins' + axLetter], '2d', calendar, binSpec.size);\n    if (trace.type === 'histogram2dcontour') {\n      // the \"true\" 2nd argument reverses the tick direction (which we can't\n      // just do with a minus sign because of month bins)\n      if (autoStart) {\n        newBinSpec.start = c2r(Axes.tickIncrement(r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n      }\n      if (autoEnd) {\n        newBinSpec.end = c2r(Axes.tickIncrement(r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n      }\n    }\n    if (autoSize) binSpec.size = autoBin.size = newBinSpec.size;\n    if (autoStart) binSpec.start = autoBin.start = newBinSpec.start;\n    if (autoEnd) binSpec.end = autoBin.end = newBinSpec.end;\n  }\n\n  // Backward compatibility for one-time autobinning.\n  // autobin: true is handled in cleanData, but autobin: false\n  // needs to be here where we have determined the values.\n  var autoBinAttr = 'autobin' + axLetter;\n  if (trace._input[autoBinAttr] === false) {\n    trace._input[binAttr] = Lib.extendFlat({}, binSpec);\n    delete trace._input[autoBinAttr];\n    delete trace[autoBinAttr];\n  }\n}\nfunction makeIncrements(len, bins, dv, nonuniform) {\n  var out = new Array(len);\n  var i;\n  if (nonuniform) {\n    for (i = 0; i < len; i++) {\n      out[i] = 1 / (bins[i + 1] - bins[i]);\n    }\n  } else {\n    var inc = 1 / dv;\n    for (i = 0; i < len; i++) {\n      out[i] = inc;\n    }\n  }\n  return out;\n}\nfunction binsToCalc(r2c, bins) {\n  return {\n    start: r2c(bins.start),\n    end: r2c(bins.end),\n    size: bins.size\n  };\n}\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n  var i;\n  var len = edges.length - 1;\n  var out = new Array(len);\n  if (uniqueVals) {\n    for (i = 0; i < len; i++) {\n      out[i] = [uniqueVals[i], uniqueVals[i]];\n    }\n  } else {\n    var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n    for (i = 0; i < len; i++) {\n      out[i] = [roundFn(edges[i]), roundFn(edges[i + 1], true)];\n    }\n  }\n  return out;\n}","map":{"version":3,"names":["Lib","require","Axes","binFunctions","normFunctions","doAvg","getBinSpanLabelRound","module","exports","calc","gd","trace","xa","getFromId","xaxis","x","makeCalcdata","ya","yaxis","y","xcalendar","ycalendar","xr2c","v","r2c","yr2c","xc2r","c2r","yc2r","i","j","n","m","serieslen","_length","length","splice","doAutoBin","z","onecol","zerocol","nonuniformBinsX","xbins","size","nonuniformBinsY","ybins","xEdges","yEdges","total","counts","inputPoints","norm","histnorm","func","histfunc","densitynorm","indexOf","extremefunc","sizeinit","binfunc","count","normfunc","doavg","xinc","yinc","rawCounterData","Array","isArray","marker","color","binSpec","binStart","start","binEnd","end","tickIncrement","push","nx","x0c","dx","x0","slice","ipCol","ny","y0c","dy","y0","makeIncrements","type","binsToCalc","uniqueValsPerX","uniqueValsPerY","xVals","yVals","xGapLow","Infinity","xGapHigh","yGapLow","yGapHigh","xi","yi","findBin","undefined","Math","min","xRanges","getRanges","yRanges","pts","axLetter","data","ax","calendar","binAttr","inputBinSpec","_input","autoBin","_autoBin","autoSize","autoStart","autoEnd","newBinSpec","autoBinAttr","extendFlat","len","bins","dv","nonuniform","out","inc","edges","uniqueVals","gapLow","gapHigh","roundFn"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/histogram2d/calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\n\nvar binFunctions = require('../histogram/bin_functions');\nvar normFunctions = require('../histogram/norm_functions');\nvar doAvg = require('../histogram/average');\nvar getBinSpanLabelRound = require('../histogram/bin_label_vals');\n\n\nmodule.exports = function calc(gd, trace) {\n    var xa = Axes.getFromId(gd, trace.xaxis || 'x');\n    var x = trace.x ? xa.makeCalcdata(trace, 'x') : [];\n    var ya = Axes.getFromId(gd, trace.yaxis || 'y');\n    var y = trace.y ? ya.makeCalcdata(trace, 'y') : [];\n    var xcalendar = trace.xcalendar;\n    var ycalendar = trace.ycalendar;\n    var xr2c = function(v) { return xa.r2c(v, 0, xcalendar); };\n    var yr2c = function(v) { return ya.r2c(v, 0, ycalendar); };\n    var xc2r = function(v) { return xa.c2r(v, 0, xcalendar); };\n    var yc2r = function(v) { return ya.c2r(v, 0, ycalendar); };\n\n    var i, j, n, m;\n\n    var serieslen = trace._length;\n    if(x.length > serieslen) x.splice(serieslen, x.length - serieslen);\n    if(y.length > serieslen) y.splice(serieslen, y.length - serieslen);\n\n    // calculate the bins\n    doAutoBin(trace, 'x', x, xa, xr2c, xc2r, xcalendar);\n    doAutoBin(trace, 'y', y, ya, yr2c, yc2r, ycalendar);\n\n    // make the empty bin array & scale the map\n    var z = [];\n    var onecol = [];\n    var zerocol = [];\n    var nonuniformBinsX = (typeof(trace.xbins.size) === 'string');\n    var nonuniformBinsY = (typeof(trace.ybins.size) === 'string');\n    var xEdges = [];\n    var yEdges = [];\n    var xbins = nonuniformBinsX ? xEdges : trace.xbins;\n    var ybins = nonuniformBinsY ? yEdges : trace.ybins;\n    var total = 0;\n    var counts = [];\n    var inputPoints = [];\n    var norm = trace.histnorm;\n    var func = trace.histfunc;\n    var densitynorm = (norm.indexOf('density') !== -1);\n    var extremefunc = (func === 'max' || func === 'min');\n    var sizeinit = (extremefunc ? null : 0);\n    var binfunc = binFunctions.count;\n    var normfunc = normFunctions[norm];\n    var doavg = false;\n    var xinc = [];\n    var yinc = [];\n\n    // set a binning function other than count?\n    // for binning functions: check first for 'z',\n    // then 'mc' in case we had a colored scatter plot\n    // and want to transfer these colors to the 2D histo\n    // TODO: axe this, make it the responsibility of the app changing type? or an impliedEdit?\n    var rawCounterData = ('z' in trace) ?\n        trace.z :\n        (('marker' in trace && Array.isArray(trace.marker.color)) ?\n            trace.marker.color : '');\n    if(rawCounterData && func !== 'count') {\n        doavg = func === 'avg';\n        binfunc = binFunctions[func];\n    }\n\n    // decrease end a little in case of rounding errors\n    var binSpec = trace.xbins;\n    var binStart = xr2c(binSpec.start);\n    var binEnd = xr2c(binSpec.end) +\n        (binStart - Axes.tickIncrement(binStart, binSpec.size, false, xcalendar)) / 1e6;\n\n    for(i = binStart; i < binEnd; i = Axes.tickIncrement(i, binSpec.size, false, xcalendar)) {\n        onecol.push(sizeinit);\n        xEdges.push(i);\n        if(doavg) zerocol.push(0);\n    }\n    xEdges.push(i);\n\n    var nx = onecol.length;\n    var x0c = xr2c(trace.xbins.start);\n    var dx = (i - x0c) / nx;\n    var x0 = xc2r(x0c + dx / 2);\n\n    binSpec = trace.ybins;\n    binStart = yr2c(binSpec.start);\n    binEnd = yr2c(binSpec.end) +\n        (binStart - Axes.tickIncrement(binStart, binSpec.size, false, ycalendar)) / 1e6;\n\n    for(i = binStart; i < binEnd; i = Axes.tickIncrement(i, binSpec.size, false, ycalendar)) {\n        z.push(onecol.slice());\n        yEdges.push(i);\n        var ipCol = new Array(nx);\n        for(j = 0; j < nx; j++) ipCol[j] = [];\n        inputPoints.push(ipCol);\n        if(doavg) counts.push(zerocol.slice());\n    }\n    yEdges.push(i);\n\n    var ny = z.length;\n    var y0c = yr2c(trace.ybins.start);\n    var dy = (i - y0c) / ny;\n    var y0 = yc2r(y0c + dy / 2);\n\n    if(densitynorm) {\n        xinc = makeIncrements(onecol.length, xbins, dx, nonuniformBinsX);\n        yinc = makeIncrements(z.length, ybins, dy, nonuniformBinsY);\n    }\n\n    // for date axes we need bin bounds to be calcdata. For nonuniform bins\n    // we already have this, but uniform with start/end/size they're still strings.\n    if(!nonuniformBinsX && xa.type === 'date') xbins = binsToCalc(xr2c, xbins);\n    if(!nonuniformBinsY && ya.type === 'date') ybins = binsToCalc(yr2c, ybins);\n\n    // put data into bins\n    var uniqueValsPerX = true;\n    var uniqueValsPerY = true;\n    var xVals = new Array(nx);\n    var yVals = new Array(ny);\n    var xGapLow = Infinity;\n    var xGapHigh = Infinity;\n    var yGapLow = Infinity;\n    var yGapHigh = Infinity;\n    for(i = 0; i < serieslen; i++) {\n        var xi = x[i];\n        var yi = y[i];\n        n = Lib.findBin(xi, xbins);\n        m = Lib.findBin(yi, ybins);\n        if(n >= 0 && n < nx && m >= 0 && m < ny) {\n            total += binfunc(n, i, z[m], rawCounterData, counts[m]);\n            inputPoints[m][n].push(i);\n\n            if(uniqueValsPerX) {\n                if(xVals[n] === undefined) xVals[n] = xi;\n                else if(xVals[n] !== xi) uniqueValsPerX = false;\n            }\n            if(uniqueValsPerY) {\n                if(yVals[n] === undefined) yVals[n] = yi;\n                else if(yVals[n] !== yi) uniqueValsPerY = false;\n            }\n\n            xGapLow = Math.min(xGapLow, xi - xEdges[n]);\n            xGapHigh = Math.min(xGapHigh, xEdges[n + 1] - xi);\n            yGapLow = Math.min(yGapLow, yi - yEdges[m]);\n            yGapHigh = Math.min(yGapHigh, yEdges[m + 1] - yi);\n        }\n    }\n    // normalize, if needed\n    if(doavg) {\n        for(m = 0; m < ny; m++) total += doAvg(z[m], counts[m]);\n    }\n    if(normfunc) {\n        for(m = 0; m < ny; m++) normfunc(z[m], total, xinc, yinc[m]);\n    }\n\n    return {\n        x: x,\n        xRanges: getRanges(xEdges, uniqueValsPerX && xVals, xGapLow, xGapHigh, xa, xcalendar),\n        x0: x0,\n        dx: dx,\n        y: y,\n        yRanges: getRanges(yEdges, uniqueValsPerY && yVals, yGapLow, yGapHigh, ya, ycalendar),\n        y0: y0,\n        dy: dy,\n        z: z,\n        pts: inputPoints\n    };\n};\n\nfunction doAutoBin(trace, axLetter, data, ax, r2c, c2r, calendar) {\n    var binAttr = axLetter + 'bins';\n    var binSpec = trace[binAttr];\n    if(!binSpec) binSpec = trace[binAttr] = {};\n    var inputBinSpec = trace._input[binAttr] || {};\n    var autoBin = trace._autoBin = {};\n\n    // clear out any previously added autobin info\n    if(!inputBinSpec.size) delete binSpec.size;\n    if(inputBinSpec.start === undefined) delete binSpec.start;\n    if(inputBinSpec.end === undefined) delete binSpec.end;\n\n    var autoSize = !binSpec.size;\n    var autoStart = binSpec.start === undefined;\n    var autoEnd = binSpec.end === undefined;\n\n    if(autoSize || autoStart || autoEnd) {\n        var newBinSpec = Axes.autoBin(data, ax, trace['nbins' + axLetter], '2d', calendar, binSpec.size);\n        if(trace.type === 'histogram2dcontour') {\n            // the \"true\" 2nd argument reverses the tick direction (which we can't\n            // just do with a minus sign because of month bins)\n            if(autoStart) {\n                newBinSpec.start = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.start), newBinSpec.size, true, calendar));\n            }\n            if(autoEnd) {\n                newBinSpec.end = c2r(Axes.tickIncrement(\n                    r2c(newBinSpec.end), newBinSpec.size, false, calendar));\n            }\n        }\n        if(autoSize) binSpec.size = autoBin.size = newBinSpec.size;\n        if(autoStart) binSpec.start = autoBin.start = newBinSpec.start;\n        if(autoEnd) binSpec.end = autoBin.end = newBinSpec.end;\n    }\n\n    // Backward compatibility for one-time autobinning.\n    // autobin: true is handled in cleanData, but autobin: false\n    // needs to be here where we have determined the values.\n    var autoBinAttr = 'autobin' + axLetter;\n    if(trace._input[autoBinAttr] === false) {\n        trace._input[binAttr] = Lib.extendFlat({}, binSpec);\n        delete trace._input[autoBinAttr];\n        delete trace[autoBinAttr];\n    }\n}\n\nfunction makeIncrements(len, bins, dv, nonuniform) {\n    var out = new Array(len);\n    var i;\n    if(nonuniform) {\n        for(i = 0; i < len; i++) out[i] = 1 / (bins[i + 1] - bins[i]);\n    }\n    else {\n        var inc = 1 / dv;\n        for(i = 0; i < len; i++) out[i] = inc;\n    }\n    return out;\n}\n\nfunction binsToCalc(r2c, bins) {\n    return {\n        start: r2c(bins.start),\n        end: r2c(bins.end),\n        size: bins.size\n    };\n}\n\nfunction getRanges(edges, uniqueVals, gapLow, gapHigh, ax, calendar) {\n    var i;\n    var len = edges.length - 1;\n    var out = new Array(len);\n    if(uniqueVals) {\n        for(i = 0; i < len; i++) out[i] = [uniqueVals[i], uniqueVals[i]];\n    }\n    else {\n        var roundFn = getBinSpanLabelRound(gapLow, gapHigh, edges, ax, calendar);\n        for(i = 0; i < len; i++) out[i] = [roundFn(edges[i]), roundFn(edges[i + 1], true)];\n    }\n    return out;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}