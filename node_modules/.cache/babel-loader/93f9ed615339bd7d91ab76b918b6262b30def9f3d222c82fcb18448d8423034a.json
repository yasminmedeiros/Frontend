{"ast":null,"code":"\"use strict\";\n\nvar pool = require(\"typedarray-pool\");\nmodule.exports = createSurfaceExtractor;\n\n//Helper macros\nfunction array(i) {\n  return \"a\" + i;\n}\nfunction data(i) {\n  return \"d\" + i;\n}\nfunction cube(i, bitmask) {\n  return \"c\" + i + \"_\" + bitmask;\n}\nfunction shape(i) {\n  return \"s\" + i;\n}\nfunction stride(i, j) {\n  return \"t\" + i + \"_\" + j;\n}\nfunction offset(i) {\n  return \"o\" + i;\n}\nfunction scalar(i) {\n  return \"x\" + i;\n}\nfunction pointer(i) {\n  return \"p\" + i;\n}\nfunction delta(i, bitmask) {\n  return \"d\" + i + \"_\" + bitmask;\n}\nfunction index(i) {\n  return \"i\" + i;\n}\nfunction step(i, j) {\n  return \"u\" + i + \"_\" + j;\n}\nfunction pcube(bitmask) {\n  return \"b\" + bitmask;\n}\nfunction qcube(bitmask) {\n  return \"y\" + bitmask;\n}\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask;\n}\nfunction vert(i) {\n  return \"v\" + i;\n}\nvar VERTEX_IDS = \"V\";\nvar PHASES = \"P\";\nvar VERTEX_COUNT = \"N\";\nvar POOL_SIZE = \"Q\";\nvar POINTER = \"X\";\nvar TEMPORARY = \"T\";\nfunction permBitmask(dimension, mask, order) {\n  var r = 0;\n  for (var i = 0; i < dimension; ++i) {\n    if (mask & 1 << i) {\n      r |= 1 << order[i];\n    }\n  }\n  return r;\n}\n\n//Generates the surface procedure\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length;\n  var dimension = order.length;\n  if (dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\");\n  }\n  var funcName = \"extractContour\" + order.join(\"_\");\n  var code = [];\n  var vars = [];\n  var args = [];\n\n  //Assemble arguments\n  for (var i = 0; i < arrayArgs; ++i) {\n    args.push(array(i));\n  }\n  for (var i = 0; i < scalarArgs; ++i) {\n    args.push(scalar(i));\n  }\n\n  //Shape\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\");\n  }\n  //Data, stride, offset pointers\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\", offset(i) + \"=\" + array(i) + \".offset|0\");\n    for (var j = 0; j < dimension; ++j) {\n      vars.push(stride(i, j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\");\n    }\n  }\n  //Pointer, delta and cube variables\n  for (var i = 0; i < arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i));\n    vars.push(cube(i, 0));\n    for (var j = 1; j < 1 << dimension; ++j) {\n      var ptrStr = [];\n      for (var k = 0; k < dimension; ++k) {\n        if (j & 1 << k) {\n          ptrStr.push(\"-\" + stride(i, k));\n        }\n      }\n      vars.push(delta(i, j) + \"=(\" + ptrStr.join(\"\") + \")|0\");\n      vars.push(cube(i, j) + \"=0\");\n    }\n  }\n  //Create step variables\n  for (var i = 0; i < arrayArgs; ++i) {\n    for (var j = 0; j < dimension; ++j) {\n      var stepVal = [stride(i, order[j])];\n      if (j > 0) {\n        stepVal.push(stride(i, order[j - 1]) + \"*\" + shape(order[j - 1]));\n      }\n      vars.push(step(i, order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\");\n    }\n  }\n  //Create index variables\n  for (var i = 0; i < dimension; ++i) {\n    vars.push(index(i) + \"=0\");\n  }\n  //Vertex count\n  vars.push(VERTEX_COUNT + \"=0\");\n  //Compute pool size, initialize pool step\n  var sizeVariable = [\"2\"];\n  for (var i = dimension - 2; i >= 0; --i) {\n    sizeVariable.push(shape(order[i]));\n  }\n  //Previous phases and vertex_ids\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\", PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\", VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\", POINTER + \"=0\");\n  //Create cube variables for phases\n  vars.push(pcube(0) + \"=0\");\n  for (var j = 1; j < 1 << dimension; ++j) {\n    var cubeDelta = [];\n    var cubeStep = [];\n    for (var k = 0; k < dimension; ++k) {\n      if (j & 1 << k) {\n        if (cubeStep.length === 0) {\n          cubeDelta.push(\"1\");\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"));\n        }\n      }\n      cubeStep.push(shape(order[k]));\n    }\n    var signFlag = \"\";\n    if (cubeDelta[0].indexOf(shape(order[dimension - 2])) < 0) {\n      signFlag = \"-\";\n    }\n    var jperm = permBitmask(dimension, j, order);\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\", qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\", pcube(jperm) + \"=0\");\n  }\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\");\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\", index(order[i]), \"<\", shape(order[i]), \";\", \"++\", index(order[i]), \"){\");\n  }\n  function forLoopEnd(i) {\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n    code.push(\"}\");\n  }\n  function fillEmptySlice(k) {\n    for (var i = k - 1; i >= 0; --i) {\n      forLoopBegin(i, 0);\n    }\n    var phaseFuncArgs = [];\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\");\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\");\n      }\n    }\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\");\n    for (var i = 0; i < k; ++i) {\n      forLoopEnd(i);\n    }\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[k]), \";\");\n    }\n  }\n  function processGridCell(mask) {\n    //Read in local data\n    for (var i = 0; i < arrayArgs; ++i) {\n      if (typesig[i]) {\n        code.push(cube(i, 0), \"=\", data(i), \".get(\", pointer(i), \");\");\n      } else {\n        code.push(cube(i, 0), \"=\", data(i), \"[\", pointer(i), \"];\");\n      }\n    }\n\n    //Read in phase\n    var phaseFuncArgs = [];\n    for (var i = 0; i < arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i, 0));\n    }\n    for (var i = 0; i < scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i));\n    }\n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\");\n\n    //Read in other cube data\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\");\n    }\n\n    //Check for boundary crossing\n    var vertexPredicate = [];\n    for (var j = 1; j < 1 << dimension; ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\");\n    }\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\");\n\n    //Read in boundary data\n    var vertexArgs = [];\n    for (var i = 0; i < dimension; ++i) {\n      vertexArgs.push(index(i));\n    }\n    for (var i = 0; i < arrayArgs; ++i) {\n      vertexArgs.push(cube(i, 0));\n      for (var j = 1; j < 1 << dimension; ++j) {\n        if (typesig[i]) {\n          code.push(cube(i, j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i, j), \");\");\n        } else {\n          code.push(cube(i, j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i, j), \"];\");\n        }\n        vertexArgs.push(cube(i, j));\n      }\n    }\n    for (var i = 0; i < 1 << dimension; ++i) {\n      vertexArgs.push(pcube(i));\n    }\n    for (var i = 0; i < scalarArgs; ++i) {\n      vertexArgs.push(scalar(i));\n    }\n\n    //Generate vertex\n    code.push(\"vertex(\", vertexArgs.join(), \");\", vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\");\n\n    //Check for face crossings\n    var base = (1 << dimension) - 1;\n    var corner = pcube(base);\n    for (var j = 0; j < dimension; ++j) {\n      if ((mask & ~(1 << j)) === 0) {\n        //Check face\n        var subset = base ^ 1 << j;\n        var edge = pcube(subset);\n        var faceArgs = [];\n        for (var k = subset; k > 0; k = k - 1 & subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\");\n        }\n        faceArgs.push(vert(0));\n        for (var k = 0; k < arrayArgs; ++k) {\n          if (j & 1) {\n            faceArgs.push(cube(k, base), cube(k, subset));\n          } else {\n            faceArgs.push(cube(k, subset), cube(k, base));\n          }\n        }\n        if (j & 1) {\n          faceArgs.push(corner, edge);\n        } else {\n          faceArgs.push(edge, corner);\n        }\n        for (var k = 0; k < scalarArgs; ++k) {\n          faceArgs.push(scalar(k));\n        }\n        code.push(\"if(\", corner, \"!==\", edge, \"){\", \"face(\", faceArgs.join(), \")}\");\n      }\n    }\n\n    //Increment pointer, close off if statement\n    code.push(\"}\", POINTER, \"+=1;\");\n  }\n  function flip() {\n    for (var j = 1; j < 1 << dimension; ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\", pdelta(j), \"=\", qcube(j), \";\", qcube(j), \"=\", TEMPORARY, \";\");\n    }\n  }\n  function createLoop(i, mask) {\n    if (i < 0) {\n      processGridCell(mask);\n      return;\n    }\n    fillEmptySlice(i);\n    code.push(\"if(\", shape(order[i]), \">0){\", index(order[i]), \"=1;\");\n    createLoop(i - 1, mask | 1 << order[i]);\n    for (var j = 0; j < arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j, order[i]), \";\");\n    }\n    if (i === dimension - 1) {\n      code.push(POINTER, \"=0;\");\n      flip();\n    }\n    forLoopBegin(i, 2);\n    createLoop(i - 1, mask);\n    if (i === dimension - 1) {\n      code.push(\"if(\", index(order[dimension - 1]), \"&1){\", POINTER, \"=0;}\");\n      flip();\n    }\n    forLoopEnd(i);\n    code.push(\"}\");\n  }\n  createLoop(dimension - 1, 0);\n\n  //Release scratch memory\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\");\n\n  //Compile and link procedure\n  var procedureCode = [\"'use strict';\", \"function \", funcName, \"(\", args.join(), \"){\", \"var \", vars.join(), \";\", code.join(\"\"), \"}\", \"return \", funcName].join(\"\");\n  var proc = new Function(\"vertex\", \"face\", \"phase\", \"mallocUint32\", \"freeUint32\", procedureCode);\n  return proc(vertexFunc, faceFunc, phaseFunc, pool.mallocUint32, pool.freeUint32);\n}\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg);\n  }\n  if (typeof args !== \"object\") {\n    error(\"Must specify arguments\");\n  }\n  var order = args.order;\n  if (!Array.isArray(order)) {\n    error(\"Must specify order\");\n  }\n  var arrays = args.arrayArguments || 1;\n  if (arrays < 1) {\n    error(\"Must have at least one array argument\");\n  }\n  var scalars = args.scalarArguments || 0;\n  if (scalars < 0) {\n    error(\"Scalar arg count must be > 0\");\n  }\n  if (typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\");\n  }\n  if (typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\");\n  }\n  if (typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\");\n  }\n  var getters = args.getters || [];\n  var typesig = new Array(arrays);\n  for (var i = 0; i < arrays; ++i) {\n    if (getters.indexOf(i) >= 0) {\n      typesig[i] = true;\n    } else {\n      typesig[i] = false;\n    }\n  }\n  return compileSurfaceProcedure(args.vertex, args.cell, args.phase, scalars, order, typesig);\n}","map":{"version":3,"names":["pool","require","module","exports","createSurfaceExtractor","array","i","data","cube","bitmask","shape","stride","j","offset","scalar","pointer","delta","index","step","pcube","qcube","pdelta","vert","VERTEX_IDS","PHASES","VERTEX_COUNT","POOL_SIZE","POINTER","TEMPORARY","permBitmask","dimension","mask","order","r","compileSurfaceProcedure","vertexFunc","faceFunc","phaseFunc","scalarArgs","typesig","arrayArgs","length","Error","funcName","join","code","vars","args","push","ptrStr","k","stepVal","sizeVariable","cubeDelta","cubeStep","unshift","signFlag","indexOf","jperm","forLoopBegin","start","forLoopEnd","fillEmptySlice","phaseFuncArgs","processGridCell","vertexPredicate","vertexArgs","base","corner","subset","edge","faceArgs","flip","createLoop","procedureCode","proc","Function","mallocUint32","freeUint32","error","msg","Array","isArray","arrays","arrayArguments","scalars","scalarArguments","vertex","cell","phase","getters"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/ndarray-extract-contour/contour.js"],"sourcesContent":["\"use strict\"\n\nvar pool = require(\"typedarray-pool\")\n\nmodule.exports = createSurfaceExtractor\n\n//Helper macros\nfunction array(i) {\n  return \"a\" + i\n}\nfunction data(i) {\n  return \"d\" + i\n}\nfunction cube(i,bitmask) {\n  return \"c\" + i + \"_\" + bitmask\n}\nfunction shape(i) {\n  return \"s\" + i\n}\nfunction stride(i,j) {\n  return \"t\" + i + \"_\" + j\n}\nfunction offset(i) {\n  return \"o\" + i\n}\nfunction scalar(i) {\n  return \"x\" + i\n}\nfunction pointer(i) {\n  return \"p\" + i\n}\nfunction delta(i,bitmask) {\n  return \"d\" + i + \"_\" + bitmask\n}\nfunction index(i) {\n  return \"i\" + i\n}\nfunction step(i,j) {\n  return \"u\" + i + \"_\" + j\n}\nfunction pcube(bitmask) {\n  return \"b\" + bitmask\n}\nfunction qcube(bitmask) {\n  return \"y\" + bitmask\n}\nfunction pdelta(bitmask) {\n  return \"e\" + bitmask\n}\nfunction vert(i) {\n  return \"v\" + i\n}\nvar VERTEX_IDS = \"V\"\nvar PHASES = \"P\"\nvar VERTEX_COUNT = \"N\"\nvar POOL_SIZE = \"Q\"\nvar POINTER = \"X\"\nvar TEMPORARY = \"T\"\n\nfunction permBitmask(dimension, mask, order) {\n  var r = 0\n  for(var i=0; i<dimension; ++i) {\n    if(mask & (1<<i)) {\n      r |= (1<<order[i])\n    }\n  }\n  return r\n}\n\n//Generates the surface procedure\nfunction compileSurfaceProcedure(vertexFunc, faceFunc, phaseFunc, scalarArgs, order, typesig) {\n  var arrayArgs = typesig.length\n  var dimension = order.length\n\n  if(dimension < 2) {\n    throw new Error(\"ndarray-extract-contour: Dimension must be at least 2\")\n  }\n\n  var funcName = \"extractContour\" + order.join(\"_\")\n  var code = []\n  var vars = []\n  var args = []\n\n  //Assemble arguments\n  for(var i=0; i<arrayArgs; ++i) {\n    args.push(array(i))  \n  }\n  for(var i=0; i<scalarArgs; ++i) {\n    args.push(scalar(i))\n  }\n\n  //Shape\n  for(var i=0; i<dimension; ++i) {\n    vars.push(shape(i) + \"=\" + array(0) + \".shape[\" + i + \"]|0\")\n  }\n  //Data, stride, offset pointers\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(data(i) + \"=\" + array(i) + \".data\",\n              offset(i) + \"=\" + array(i) + \".offset|0\")\n    for(var j=0; j<dimension; ++j) {\n      vars.push(stride(i,j) + \"=\" + array(i) + \".stride[\" + j + \"]|0\")\n    }\n  }\n  //Pointer, delta and cube variables\n  for(var i=0; i<arrayArgs; ++i) {\n    vars.push(pointer(i) + \"=\" + offset(i))\n    vars.push(cube(i,0))\n    for(var j=1; j<(1<<dimension); ++j) {\n      var ptrStr = []\n      for(var k=0; k<dimension; ++k) {\n        if(j & (1<<k)) {\n          ptrStr.push(\"-\" + stride(i,k))\n        }\n      }\n      vars.push(delta(i,j) + \"=(\" + ptrStr.join(\"\") + \")|0\")\n      vars.push(cube(i,j) + \"=0\")\n    }\n  }\n  //Create step variables\n  for(var i=0; i<arrayArgs; ++i) {\n    for(var j=0; j<dimension; ++j) {\n      var stepVal = [ stride(i,order[j]) ]\n      if(j > 0) {\n        stepVal.push(stride(i, order[j-1]) + \"*\" + shape(order[j-1]) )\n      }\n      vars.push(step(i,order[j]) + \"=(\" + stepVal.join(\"-\") + \")|0\")\n    }\n  }\n  //Create index variables\n  for(var i=0; i<dimension; ++i) {\n    vars.push(index(i) + \"=0\")\n  }\n  //Vertex count\n  vars.push(VERTEX_COUNT + \"=0\")\n  //Compute pool size, initialize pool step\n  var sizeVariable = [\"2\"]\n  for(var i=dimension-2; i>=0; --i) {\n    sizeVariable.push(shape(order[i]))\n  }\n  //Previous phases and vertex_ids\n  vars.push(POOL_SIZE + \"=(\" + sizeVariable.join(\"*\") + \")|0\",\n            PHASES + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            VERTEX_IDS + \"=mallocUint32(\" + POOL_SIZE + \")\",\n            POINTER + \"=0\")\n  //Create cube variables for phases\n  vars.push(pcube(0) + \"=0\")\n  for(var j=1; j<(1<<dimension); ++j) {\n    var cubeDelta = []\n    var cubeStep = [ ]\n    for(var k=0; k<dimension; ++k) {\n      if(j & (1<<k)) {\n        if(cubeStep.length === 0) {\n          cubeDelta.push(\"1\")\n        } else {\n          cubeDelta.unshift(cubeStep.join(\"*\"))\n        }\n      }\n      cubeStep.push(shape(order[k]))\n    }\n    var signFlag = \"\"\n    if(cubeDelta[0].indexOf(shape(order[dimension-2])) < 0) {\n      signFlag = \"-\"\n    }\n    var jperm = permBitmask(dimension, j, order)\n    vars.push(pdelta(jperm) + \"=(-\" + cubeDelta.join(\"-\") + \")|0\",\n              qcube(jperm) + \"=(\" + signFlag + cubeDelta.join(\"-\") + \")|0\",\n              pcube(jperm) + \"=0\")\n  }\n  vars.push(vert(0) + \"=0\", TEMPORARY + \"=0\")\n\n  function forLoopBegin(i, start) {\n    code.push(\"for(\", index(order[i]), \"=\", start, \";\",\n      index(order[i]), \"<\", shape(order[i]), \";\",\n      \"++\", index(order[i]), \"){\")\n  }\n\n  function forLoopEnd(i) {\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    code.push(\"}\")\n  }\n\n  function fillEmptySlice(k) {\n    for(var i=k-1; i>=0; --i) {\n      forLoopBegin(i, 0) \n    }\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        phaseFuncArgs.push(data(i) + \".get(\" + pointer(i) + \")\")\n      } else {\n        phaseFuncArgs.push(data(i) + \"[\" + pointer(i) + \"]\")\n      }\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    code.push(PHASES, \"[\", POINTER, \"++]=phase(\", phaseFuncArgs.join(), \");\")\n    for(var i=0; i<k; ++i) {\n      forLoopEnd(i)\n    }\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[k]), \";\")\n    }\n  }\n\n  function processGridCell(mask) {\n    //Read in local data\n    for(var i=0; i<arrayArgs; ++i) {\n      if(typesig[i]) {\n        code.push(cube(i,0), \"=\", data(i), \".get(\", pointer(i), \");\")\n      } else {\n        code.push(cube(i,0), \"=\", data(i), \"[\", pointer(i), \"];\")\n      }\n    }\n\n    //Read in phase\n    var phaseFuncArgs = []\n    for(var i=0; i<arrayArgs; ++i) {\n      phaseFuncArgs.push(cube(i,0))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      phaseFuncArgs.push(scalar(i))\n    }\n    \n    code.push(pcube(0), \"=\", PHASES, \"[\", POINTER, \"]=phase(\", phaseFuncArgs.join(), \");\")\n    \n    //Read in other cube data\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(pcube(j), \"=\", PHASES, \"[\", POINTER, \"+\", pdelta(j), \"];\")\n    }\n\n    //Check for boundary crossing\n    var vertexPredicate = []\n    for(var j=1; j<(1<<dimension); ++j) {\n      vertexPredicate.push(\"(\" + pcube(0) + \"!==\" + pcube(j) + \")\")\n    }\n    code.push(\"if(\", vertexPredicate.join(\"||\"), \"){\")\n\n    //Read in boundary data\n    var vertexArgs = []\n    for(var i=0; i<dimension; ++i) {\n      vertexArgs.push(index(i))\n    }\n    for(var i=0; i<arrayArgs; ++i) {\n      vertexArgs.push(cube(i,0))\n      for(var j=1; j<(1<<dimension); ++j) {\n        if(typesig[i]) {\n          code.push(cube(i,j), \"=\", data(i), \".get(\", pointer(i), \"+\", delta(i,j), \");\")\n        } else {\n          code.push(cube(i,j), \"=\", data(i), \"[\", pointer(i), \"+\", delta(i,j), \"];\")\n        }\n        vertexArgs.push(cube(i,j))\n      }\n    }\n    for(var i=0; i<(1<<dimension); ++i) {\n      vertexArgs.push(pcube(i))\n    }\n    for(var i=0; i<scalarArgs; ++i) {\n      vertexArgs.push(scalar(i))\n    }\n\n    //Generate vertex\n    code.push(\"vertex(\", vertexArgs.join(), \");\",\n      vert(0), \"=\", VERTEX_IDS, \"[\", POINTER, \"]=\", VERTEX_COUNT, \"++;\")\n\n    //Check for face crossings\n    var base = (1<<dimension)-1\n    var corner = pcube(base)\n    for(var j=0; j<dimension; ++j) {\n      if((mask & ~(1<<j))===0) {\n        //Check face\n        var subset = base^(1<<j)\n        var edge = pcube(subset)\n        var faceArgs = [ ]\n        for(var k=subset; k>0; k=(k-1)&subset) {\n          faceArgs.push(VERTEX_IDS + \"[\" + POINTER + \"+\" + pdelta(k) + \"]\")\n        }\n        faceArgs.push(vert(0))\n        for(var k=0; k<arrayArgs; ++k) {\n          if(j&1) {\n            faceArgs.push(cube(k,base), cube(k,subset))\n          } else {\n            faceArgs.push(cube(k,subset), cube(k,base))\n          }\n        }\n        if(j&1) {\n          faceArgs.push(corner, edge)\n        } else {\n          faceArgs.push(edge, corner)\n        }\n        for(var k=0; k<scalarArgs; ++k) {\n          faceArgs.push(scalar(k))\n        }\n        code.push(\"if(\", corner, \"!==\", edge, \"){\",\n          \"face(\", faceArgs.join(), \")}\")\n      }\n    }\n    \n    //Increment pointer, close off if statement\n    code.push(\"}\",\n      POINTER, \"+=1;\")\n  }\n\n  function flip() {\n    for(var j=1; j<(1<<dimension); ++j) {\n      code.push(TEMPORARY, \"=\", pdelta(j), \";\",\n                pdelta(j), \"=\", qcube(j), \";\",\n                qcube(j), \"=\", TEMPORARY, \";\")\n    }\n  }\n\n  function createLoop(i, mask) {\n    if(i < 0) {\n      processGridCell(mask)\n      return\n    }\n    fillEmptySlice(i)\n    code.push(\"if(\", shape(order[i]), \">0){\",\n      index(order[i]), \"=1;\")\n    createLoop(i-1, mask|(1<<order[i]))\n\n    for(var j=0; j<arrayArgs; ++j) {\n      code.push(pointer(j), \"+=\", step(j,order[i]), \";\")\n    }\n    if(i === dimension-1) {\n      code.push(POINTER, \"=0;\")\n      flip()\n    }\n    forLoopBegin(i, 2)\n    createLoop(i-1, mask)\n    if(i === dimension-1) {\n      code.push(\"if(\", index(order[dimension-1]), \"&1){\",\n        POINTER, \"=0;}\")\n      flip()\n    }\n    forLoopEnd(i)\n    code.push(\"}\")\n  }\n\n  createLoop(dimension-1, 0)\n\n  //Release scratch memory\n  code.push(\"freeUint32(\", VERTEX_IDS, \");freeUint32(\", PHASES, \");\")\n\n  //Compile and link procedure\n  var procedureCode = [\n    \"'use strict';\",\n    \"function \", funcName, \"(\", args.join(), \"){\",\n      \"var \", vars.join(), \";\",\n      code.join(\"\"),\n    \"}\",\n    \"return \", funcName ].join(\"\")\n\n  var proc = new Function(\n    \"vertex\", \n    \"face\", \n    \"phase\", \n    \"mallocUint32\", \n    \"freeUint32\",\n    procedureCode)\n  return proc(\n    vertexFunc, \n    faceFunc, \n    phaseFunc, \n    pool.mallocUint32, \n    pool.freeUint32)\n}\n\nfunction createSurfaceExtractor(args) {\n  function error(msg) {\n    throw new Error(\"ndarray-extract-contour: \" + msg)\n  }\n  if(typeof args !== \"object\") {\n    error(\"Must specify arguments\")\n  }\n  var order = args.order\n  if(!Array.isArray(order)) {\n    error(\"Must specify order\")\n  }\n  var arrays = args.arrayArguments||1\n  if(arrays < 1) {\n    error(\"Must have at least one array argument\")\n  }\n  var scalars = args.scalarArguments||0\n  if(scalars < 0) {\n    error(\"Scalar arg count must be > 0\")\n  }\n  if(typeof args.vertex !== \"function\") {\n    error(\"Must specify vertex creation function\")\n  }\n  if(typeof args.cell !== \"function\") {\n    error(\"Must specify cell creation function\")\n  }\n  if(typeof args.phase !== \"function\") {\n    error(\"Must specify phase function\")\n  }\n  var getters = args.getters || []\n  var typesig = new Array(arrays)\n  for(var i=0; i<arrays; ++i) {\n    if(getters.indexOf(i) >= 0) {\n      typesig[i] = true\n    } else {\n      typesig[i] = false\n    }\n  }\n  return compileSurfaceProcedure(\n    args.vertex,\n    args.cell,\n    args.phase,\n    scalars,\n    order,\n    typesig)\n}"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,IAAI,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAErCC,MAAM,CAACC,OAAO,GAAGC,sBAAsB;;AAEvC;AACA,SAASC,KAAK,CAACC,CAAC,EAAE;EAChB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASC,IAAI,CAACD,CAAC,EAAE;EACf,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASE,IAAI,CAACF,CAAC,EAACG,OAAO,EAAE;EACvB,OAAO,GAAG,GAAGH,CAAC,GAAG,GAAG,GAAGG,OAAO;AAChC;AACA,SAASC,KAAK,CAACJ,CAAC,EAAE;EAChB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASK,MAAM,CAACL,CAAC,EAACM,CAAC,EAAE;EACnB,OAAO,GAAG,GAAGN,CAAC,GAAG,GAAG,GAAGM,CAAC;AAC1B;AACA,SAASC,MAAM,CAACP,CAAC,EAAE;EACjB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASQ,MAAM,CAACR,CAAC,EAAE;EACjB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASS,OAAO,CAACT,CAAC,EAAE;EAClB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASU,KAAK,CAACV,CAAC,EAACG,OAAO,EAAE;EACxB,OAAO,GAAG,GAAGH,CAAC,GAAG,GAAG,GAAGG,OAAO;AAChC;AACA,SAASQ,KAAK,CAACX,CAAC,EAAE;EAChB,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,SAASY,IAAI,CAACZ,CAAC,EAACM,CAAC,EAAE;EACjB,OAAO,GAAG,GAAGN,CAAC,GAAG,GAAG,GAAGM,CAAC;AAC1B;AACA,SAASO,KAAK,CAACV,OAAO,EAAE;EACtB,OAAO,GAAG,GAAGA,OAAO;AACtB;AACA,SAASW,KAAK,CAACX,OAAO,EAAE;EACtB,OAAO,GAAG,GAAGA,OAAO;AACtB;AACA,SAASY,MAAM,CAACZ,OAAO,EAAE;EACvB,OAAO,GAAG,GAAGA,OAAO;AACtB;AACA,SAASa,IAAI,CAAChB,CAAC,EAAE;EACf,OAAO,GAAG,GAAGA,CAAC;AAChB;AACA,IAAIiB,UAAU,GAAG,GAAG;AACpB,IAAIC,MAAM,GAAG,GAAG;AAChB,IAAIC,YAAY,GAAG,GAAG;AACtB,IAAIC,SAAS,GAAG,GAAG;AACnB,IAAIC,OAAO,GAAG,GAAG;AACjB,IAAIC,SAAS,GAAG,GAAG;AAEnB,SAASC,WAAW,CAACC,SAAS,EAAEC,IAAI,EAAEC,KAAK,EAAE;EAC3C,IAAIC,CAAC,GAAG,CAAC;EACT,KAAI,IAAI3B,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACwB,SAAS,EAAE,EAAExB,CAAC,EAAE;IAC7B,IAAGyB,IAAI,GAAI,CAAC,IAAEzB,CAAE,EAAE;MAChB2B,CAAC,IAAK,CAAC,IAAED,KAAK,CAAC1B,CAAC,CAAE;IACpB;EACF;EACA,OAAO2B,CAAC;AACV;;AAEA;AACA,SAASC,uBAAuB,CAACC,UAAU,EAAEC,QAAQ,EAAEC,SAAS,EAAEC,UAAU,EAAEN,KAAK,EAAEO,OAAO,EAAE;EAC5F,IAAIC,SAAS,GAAGD,OAAO,CAACE,MAAM;EAC9B,IAAIX,SAAS,GAAGE,KAAK,CAACS,MAAM;EAE5B,IAAGX,SAAS,GAAG,CAAC,EAAE;IAChB,MAAM,IAAIY,KAAK,CAAC,uDAAuD,CAAC;EAC1E;EAEA,IAAIC,QAAQ,GAAG,gBAAgB,GAAGX,KAAK,CAACY,IAAI,CAAC,GAAG,CAAC;EACjD,IAAIC,IAAI,GAAG,EAAE;EACb,IAAIC,IAAI,GAAG,EAAE;EACb,IAAIC,IAAI,GAAG,EAAE;;EAEb;EACA,KAAI,IAAIzC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;IAC7ByC,IAAI,CAACC,IAAI,CAAC3C,KAAK,CAACC,CAAC,CAAC,CAAC;EACrB;EACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACgC,UAAU,EAAE,EAAEhC,CAAC,EAAE;IAC9ByC,IAAI,CAACC,IAAI,CAAClC,MAAM,CAACR,CAAC,CAAC,CAAC;EACtB;;EAEA;EACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACwB,SAAS,EAAE,EAAExB,CAAC,EAAE;IAC7BwC,IAAI,CAACE,IAAI,CAACtC,KAAK,CAACJ,CAAC,CAAC,GAAG,GAAG,GAAGD,KAAK,CAAC,CAAC,CAAC,GAAG,SAAS,GAAGC,CAAC,GAAG,KAAK,CAAC;EAC9D;EACA;EACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;IAC7BwC,IAAI,CAACE,IAAI,CAACzC,IAAI,CAACD,CAAC,CAAC,GAAG,GAAG,GAAGD,KAAK,CAACC,CAAC,CAAC,GAAG,OAAO,EAClCO,MAAM,CAACP,CAAC,CAAC,GAAG,GAAG,GAAGD,KAAK,CAACC,CAAC,CAAC,GAAG,WAAW,CAAC;IACnD,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkB,SAAS,EAAE,EAAElB,CAAC,EAAE;MAC7BkC,IAAI,CAACE,IAAI,CAACrC,MAAM,CAACL,CAAC,EAACM,CAAC,CAAC,GAAG,GAAG,GAAGP,KAAK,CAACC,CAAC,CAAC,GAAG,UAAU,GAAGM,CAAC,GAAG,KAAK,CAAC;IAClE;EACF;EACA;EACA,KAAI,IAAIN,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;IAC7BwC,IAAI,CAACE,IAAI,CAACjC,OAAO,CAACT,CAAC,CAAC,GAAG,GAAG,GAAGO,MAAM,CAACP,CAAC,CAAC,CAAC;IACvCwC,IAAI,CAACE,IAAI,CAACxC,IAAI,CAACF,CAAC,EAAC,CAAC,CAAC,CAAC;IACpB,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;MAClC,IAAIqC,MAAM,GAAG,EAAE;MACf,KAAI,IAAIC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACpB,SAAS,EAAE,EAAEoB,CAAC,EAAE;QAC7B,IAAGtC,CAAC,GAAI,CAAC,IAAEsC,CAAE,EAAE;UACbD,MAAM,CAACD,IAAI,CAAC,GAAG,GAAGrC,MAAM,CAACL,CAAC,EAAC4C,CAAC,CAAC,CAAC;QAChC;MACF;MACAJ,IAAI,CAACE,IAAI,CAAChC,KAAK,CAACV,CAAC,EAACM,CAAC,CAAC,GAAG,IAAI,GAAGqC,MAAM,CAACL,IAAI,CAAC,EAAE,CAAC,GAAG,KAAK,CAAC;MACtDE,IAAI,CAACE,IAAI,CAACxC,IAAI,CAACF,CAAC,EAACM,CAAC,CAAC,GAAG,IAAI,CAAC;IAC7B;EACF;EACA;EACA,KAAI,IAAIN,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;IAC7B,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkB,SAAS,EAAE,EAAElB,CAAC,EAAE;MAC7B,IAAIuC,OAAO,GAAG,CAAExC,MAAM,CAACL,CAAC,EAAC0B,KAAK,CAACpB,CAAC,CAAC,CAAC,CAAE;MACpC,IAAGA,CAAC,GAAG,CAAC,EAAE;QACRuC,OAAO,CAACH,IAAI,CAACrC,MAAM,CAACL,CAAC,EAAE0B,KAAK,CAACpB,CAAC,GAAC,CAAC,CAAC,CAAC,GAAG,GAAG,GAAGF,KAAK,CAACsB,KAAK,CAACpB,CAAC,GAAC,CAAC,CAAC,CAAC,CAAE;MAChE;MACAkC,IAAI,CAACE,IAAI,CAAC9B,IAAI,CAACZ,CAAC,EAAC0B,KAAK,CAACpB,CAAC,CAAC,CAAC,GAAG,IAAI,GAAGuC,OAAO,CAACP,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;IAChE;EACF;EACA;EACA,KAAI,IAAItC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACwB,SAAS,EAAE,EAAExB,CAAC,EAAE;IAC7BwC,IAAI,CAACE,IAAI,CAAC/B,KAAK,CAACX,CAAC,CAAC,GAAG,IAAI,CAAC;EAC5B;EACA;EACAwC,IAAI,CAACE,IAAI,CAACvB,YAAY,GAAG,IAAI,CAAC;EAC9B;EACA,IAAI2B,YAAY,GAAG,CAAC,GAAG,CAAC;EACxB,KAAI,IAAI9C,CAAC,GAACwB,SAAS,GAAC,CAAC,EAAExB,CAAC,IAAE,CAAC,EAAE,EAAEA,CAAC,EAAE;IAChC8C,YAAY,CAACJ,IAAI,CAACtC,KAAK,CAACsB,KAAK,CAAC1B,CAAC,CAAC,CAAC,CAAC;EACpC;EACA;EACAwC,IAAI,CAACE,IAAI,CAACtB,SAAS,GAAG,IAAI,GAAG0B,YAAY,CAACR,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,EACjDpB,MAAM,GAAG,gBAAgB,GAAGE,SAAS,GAAG,GAAG,EAC3CH,UAAU,GAAG,gBAAgB,GAAGG,SAAS,GAAG,GAAG,EAC/CC,OAAO,GAAG,IAAI,CAAC;EACzB;EACAmB,IAAI,CAACE,IAAI,CAAC7B,KAAK,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;EAC1B,KAAI,IAAIP,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;IAClC,IAAIyC,SAAS,GAAG,EAAE;IAClB,IAAIC,QAAQ,GAAG,EAAG;IAClB,KAAI,IAAIJ,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACpB,SAAS,EAAE,EAAEoB,CAAC,EAAE;MAC7B,IAAGtC,CAAC,GAAI,CAAC,IAAEsC,CAAE,EAAE;QACb,IAAGI,QAAQ,CAACb,MAAM,KAAK,CAAC,EAAE;UACxBY,SAAS,CAACL,IAAI,CAAC,GAAG,CAAC;QACrB,CAAC,MAAM;UACLK,SAAS,CAACE,OAAO,CAACD,QAAQ,CAACV,IAAI,CAAC,GAAG,CAAC,CAAC;QACvC;MACF;MACAU,QAAQ,CAACN,IAAI,CAACtC,KAAK,CAACsB,KAAK,CAACkB,CAAC,CAAC,CAAC,CAAC;IAChC;IACA,IAAIM,QAAQ,GAAG,EAAE;IACjB,IAAGH,SAAS,CAAC,CAAC,CAAC,CAACI,OAAO,CAAC/C,KAAK,CAACsB,KAAK,CAACF,SAAS,GAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE;MACtD0B,QAAQ,GAAG,GAAG;IAChB;IACA,IAAIE,KAAK,GAAG7B,WAAW,CAACC,SAAS,EAAElB,CAAC,EAAEoB,KAAK,CAAC;IAC5Cc,IAAI,CAACE,IAAI,CAAC3B,MAAM,CAACqC,KAAK,CAAC,GAAG,KAAK,GAAGL,SAAS,CAACT,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,EACnDxB,KAAK,CAACsC,KAAK,CAAC,GAAG,IAAI,GAAGF,QAAQ,GAAGH,SAAS,CAACT,IAAI,CAAC,GAAG,CAAC,GAAG,KAAK,EAC5DzB,KAAK,CAACuC,KAAK,CAAC,GAAG,IAAI,CAAC;EAChC;EACAZ,IAAI,CAACE,IAAI,CAAC1B,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,EAAEM,SAAS,GAAG,IAAI,CAAC;EAE3C,SAAS+B,YAAY,CAACrD,CAAC,EAAEsD,KAAK,EAAE;IAC9Bf,IAAI,CAACG,IAAI,CAAC,MAAM,EAAE/B,KAAK,CAACe,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,GAAG,EAAEsD,KAAK,EAAE,GAAG,EAChD3C,KAAK,CAACe,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,GAAG,EAAEI,KAAK,CAACsB,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,GAAG,EAC1C,IAAI,EAAEW,KAAK,CAACe,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;EAChC;EAEA,SAASuD,UAAU,CAACvD,CAAC,EAAE;IACrB,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC4B,SAAS,EAAE,EAAE5B,CAAC,EAAE;MAC7BiC,IAAI,CAACG,IAAI,CAACjC,OAAO,CAACH,CAAC,CAAC,EAAE,IAAI,EAAEM,IAAI,CAACN,CAAC,EAACoB,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;IACpD;IACAuC,IAAI,CAACG,IAAI,CAAC,GAAG,CAAC;EAChB;EAEA,SAASc,cAAc,CAACZ,CAAC,EAAE;IACzB,KAAI,IAAI5C,CAAC,GAAC4C,CAAC,GAAC,CAAC,EAAE5C,CAAC,IAAE,CAAC,EAAE,EAAEA,CAAC,EAAE;MACxBqD,YAAY,CAACrD,CAAC,EAAE,CAAC,CAAC;IACpB;IACA,IAAIyD,aAAa,GAAG,EAAE;IACtB,KAAI,IAAIzD,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;MAC7B,IAAGiC,OAAO,CAACjC,CAAC,CAAC,EAAE;QACbyD,aAAa,CAACf,IAAI,CAACzC,IAAI,CAACD,CAAC,CAAC,GAAG,OAAO,GAAGS,OAAO,CAACT,CAAC,CAAC,GAAG,GAAG,CAAC;MAC1D,CAAC,MAAM;QACLyD,aAAa,CAACf,IAAI,CAACzC,IAAI,CAACD,CAAC,CAAC,GAAG,GAAG,GAAGS,OAAO,CAACT,CAAC,CAAC,GAAG,GAAG,CAAC;MACtD;IACF;IACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACgC,UAAU,EAAE,EAAEhC,CAAC,EAAE;MAC9ByD,aAAa,CAACf,IAAI,CAAClC,MAAM,CAACR,CAAC,CAAC,CAAC;IAC/B;IACAuC,IAAI,CAACG,IAAI,CAACxB,MAAM,EAAE,GAAG,EAAEG,OAAO,EAAE,YAAY,EAAEoC,aAAa,CAACnB,IAAI,EAAE,EAAE,IAAI,CAAC;IACzE,KAAI,IAAItC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC4C,CAAC,EAAE,EAAE5C,CAAC,EAAE;MACrBuD,UAAU,CAACvD,CAAC,CAAC;IACf;IACA,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC4B,SAAS,EAAE,EAAE5B,CAAC,EAAE;MAC7BiC,IAAI,CAACG,IAAI,CAACjC,OAAO,CAACH,CAAC,CAAC,EAAE,IAAI,EAAEM,IAAI,CAACN,CAAC,EAACoB,KAAK,CAACkB,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;IACpD;EACF;EAEA,SAASc,eAAe,CAACjC,IAAI,EAAE;IAC7B;IACA,KAAI,IAAIzB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;MAC7B,IAAGiC,OAAO,CAACjC,CAAC,CAAC,EAAE;QACbuC,IAAI,CAACG,IAAI,CAACxC,IAAI,CAACF,CAAC,EAAC,CAAC,CAAC,EAAE,GAAG,EAAEC,IAAI,CAACD,CAAC,CAAC,EAAE,OAAO,EAAES,OAAO,CAACT,CAAC,CAAC,EAAE,IAAI,CAAC;MAC/D,CAAC,MAAM;QACLuC,IAAI,CAACG,IAAI,CAACxC,IAAI,CAACF,CAAC,EAAC,CAAC,CAAC,EAAE,GAAG,EAAEC,IAAI,CAACD,CAAC,CAAC,EAAE,GAAG,EAAES,OAAO,CAACT,CAAC,CAAC,EAAE,IAAI,CAAC;MAC3D;IACF;;IAEA;IACA,IAAIyD,aAAa,GAAG,EAAE;IACtB,KAAI,IAAIzD,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;MAC7ByD,aAAa,CAACf,IAAI,CAACxC,IAAI,CAACF,CAAC,EAAC,CAAC,CAAC,CAAC;IAC/B;IACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACgC,UAAU,EAAE,EAAEhC,CAAC,EAAE;MAC9ByD,aAAa,CAACf,IAAI,CAAClC,MAAM,CAACR,CAAC,CAAC,CAAC;IAC/B;IAEAuC,IAAI,CAACG,IAAI,CAAC7B,KAAK,CAAC,CAAC,CAAC,EAAE,GAAG,EAAEK,MAAM,EAAE,GAAG,EAAEG,OAAO,EAAE,UAAU,EAAEoC,aAAa,CAACnB,IAAI,EAAE,EAAE,IAAI,CAAC;;IAEtF;IACA,KAAI,IAAIhC,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;MAClCiC,IAAI,CAACG,IAAI,CAAC7B,KAAK,CAACP,CAAC,CAAC,EAAE,GAAG,EAAEY,MAAM,EAAE,GAAG,EAAEG,OAAO,EAAE,GAAG,EAAEN,MAAM,CAACT,CAAC,CAAC,EAAE,IAAI,CAAC;IACtE;;IAEA;IACA,IAAIqD,eAAe,GAAG,EAAE;IACxB,KAAI,IAAIrD,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;MAClCqD,eAAe,CAACjB,IAAI,CAAC,GAAG,GAAG7B,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,GAAGA,KAAK,CAACP,CAAC,CAAC,GAAG,GAAG,CAAC;IAC/D;IACAiC,IAAI,CAACG,IAAI,CAAC,KAAK,EAAEiB,eAAe,CAACrB,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC;;IAElD;IACA,IAAIsB,UAAU,GAAG,EAAE;IACnB,KAAI,IAAI5D,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACwB,SAAS,EAAE,EAAExB,CAAC,EAAE;MAC7B4D,UAAU,CAAClB,IAAI,CAAC/B,KAAK,CAACX,CAAC,CAAC,CAAC;IAC3B;IACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkC,SAAS,EAAE,EAAElC,CAAC,EAAE;MAC7B4D,UAAU,CAAClB,IAAI,CAACxC,IAAI,CAACF,CAAC,EAAC,CAAC,CAAC,CAAC;MAC1B,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;QAClC,IAAG2B,OAAO,CAACjC,CAAC,CAAC,EAAE;UACbuC,IAAI,CAACG,IAAI,CAACxC,IAAI,CAACF,CAAC,EAACM,CAAC,CAAC,EAAE,GAAG,EAAEL,IAAI,CAACD,CAAC,CAAC,EAAE,OAAO,EAAES,OAAO,CAACT,CAAC,CAAC,EAAE,GAAG,EAAEU,KAAK,CAACV,CAAC,EAACM,CAAC,CAAC,EAAE,IAAI,CAAC;QAChF,CAAC,MAAM;UACLiC,IAAI,CAACG,IAAI,CAACxC,IAAI,CAACF,CAAC,EAACM,CAAC,CAAC,EAAE,GAAG,EAAEL,IAAI,CAACD,CAAC,CAAC,EAAE,GAAG,EAAES,OAAO,CAACT,CAAC,CAAC,EAAE,GAAG,EAAEU,KAAK,CAACV,CAAC,EAACM,CAAC,CAAC,EAAE,IAAI,CAAC;QAC5E;QACAsD,UAAU,CAAClB,IAAI,CAACxC,IAAI,CAACF,CAAC,EAACM,CAAC,CAAC,CAAC;MAC5B;IACF;IACA,KAAI,IAAIN,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEwB,SAAU,EAAE,EAAExB,CAAC,EAAE;MAClC4D,UAAU,CAAClB,IAAI,CAAC7B,KAAK,CAACb,CAAC,CAAC,CAAC;IAC3B;IACA,KAAI,IAAIA,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACgC,UAAU,EAAE,EAAEhC,CAAC,EAAE;MAC9B4D,UAAU,CAAClB,IAAI,CAAClC,MAAM,CAACR,CAAC,CAAC,CAAC;IAC5B;;IAEA;IACAuC,IAAI,CAACG,IAAI,CAAC,SAAS,EAAEkB,UAAU,CAACtB,IAAI,EAAE,EAAE,IAAI,EAC1CtB,IAAI,CAAC,CAAC,CAAC,EAAE,GAAG,EAAEC,UAAU,EAAE,GAAG,EAAEI,OAAO,EAAE,IAAI,EAAEF,YAAY,EAAE,KAAK,CAAC;;IAEpE;IACA,IAAI0C,IAAI,GAAG,CAAC,CAAC,IAAErC,SAAS,IAAE,CAAC;IAC3B,IAAIsC,MAAM,GAAGjD,KAAK,CAACgD,IAAI,CAAC;IACxB,KAAI,IAAIvD,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACkB,SAAS,EAAE,EAAElB,CAAC,EAAE;MAC7B,IAAG,CAACmB,IAAI,GAAG,EAAE,CAAC,IAAEnB,CAAC,CAAC,MAAI,CAAC,EAAE;QACvB;QACA,IAAIyD,MAAM,GAAGF,IAAI,GAAE,CAAC,IAAEvD,CAAE;QACxB,IAAI0D,IAAI,GAAGnD,KAAK,CAACkD,MAAM,CAAC;QACxB,IAAIE,QAAQ,GAAG,EAAG;QAClB,KAAI,IAAIrB,CAAC,GAACmB,MAAM,EAAEnB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAEA,CAAC,GAAC,CAAC,GAAEmB,MAAM,EAAE;UACrCE,QAAQ,CAACvB,IAAI,CAACzB,UAAU,GAAG,GAAG,GAAGI,OAAO,GAAG,GAAG,GAAGN,MAAM,CAAC6B,CAAC,CAAC,GAAG,GAAG,CAAC;QACnE;QACAqB,QAAQ,CAACvB,IAAI,CAAC1B,IAAI,CAAC,CAAC,CAAC,CAAC;QACtB,KAAI,IAAI4B,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACV,SAAS,EAAE,EAAEU,CAAC,EAAE;UAC7B,IAAGtC,CAAC,GAAC,CAAC,EAAE;YACN2D,QAAQ,CAACvB,IAAI,CAACxC,IAAI,CAAC0C,CAAC,EAACiB,IAAI,CAAC,EAAE3D,IAAI,CAAC0C,CAAC,EAACmB,MAAM,CAAC,CAAC;UAC7C,CAAC,MAAM;YACLE,QAAQ,CAACvB,IAAI,CAACxC,IAAI,CAAC0C,CAAC,EAACmB,MAAM,CAAC,EAAE7D,IAAI,CAAC0C,CAAC,EAACiB,IAAI,CAAC,CAAC;UAC7C;QACF;QACA,IAAGvD,CAAC,GAAC,CAAC,EAAE;UACN2D,QAAQ,CAACvB,IAAI,CAACoB,MAAM,EAAEE,IAAI,CAAC;QAC7B,CAAC,MAAM;UACLC,QAAQ,CAACvB,IAAI,CAACsB,IAAI,EAAEF,MAAM,CAAC;QAC7B;QACA,KAAI,IAAIlB,CAAC,GAAC,CAAC,EAAEA,CAAC,GAACZ,UAAU,EAAE,EAAEY,CAAC,EAAE;UAC9BqB,QAAQ,CAACvB,IAAI,CAAClC,MAAM,CAACoC,CAAC,CAAC,CAAC;QAC1B;QACAL,IAAI,CAACG,IAAI,CAAC,KAAK,EAAEoB,MAAM,EAAE,KAAK,EAAEE,IAAI,EAAE,IAAI,EACxC,OAAO,EAAEC,QAAQ,CAAC3B,IAAI,EAAE,EAAE,IAAI,CAAC;MACnC;IACF;;IAEA;IACAC,IAAI,CAACG,IAAI,CAAC,GAAG,EACXrB,OAAO,EAAE,MAAM,CAAC;EACpB;EAEA,SAAS6C,IAAI,GAAG;IACd,KAAI,IAAI5D,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAE,CAAC,IAAEkB,SAAU,EAAE,EAAElB,CAAC,EAAE;MAClCiC,IAAI,CAACG,IAAI,CAACpB,SAAS,EAAE,GAAG,EAAEP,MAAM,CAACT,CAAC,CAAC,EAAE,GAAG,EAC9BS,MAAM,CAACT,CAAC,CAAC,EAAE,GAAG,EAAEQ,KAAK,CAACR,CAAC,CAAC,EAAE,GAAG,EAC7BQ,KAAK,CAACR,CAAC,CAAC,EAAE,GAAG,EAAEgB,SAAS,EAAE,GAAG,CAAC;IAC1C;EACF;EAEA,SAAS6C,UAAU,CAACnE,CAAC,EAAEyB,IAAI,EAAE;IAC3B,IAAGzB,CAAC,GAAG,CAAC,EAAE;MACR0D,eAAe,CAACjC,IAAI,CAAC;MACrB;IACF;IACA+B,cAAc,CAACxD,CAAC,CAAC;IACjBuC,IAAI,CAACG,IAAI,CAAC,KAAK,EAAEtC,KAAK,CAACsB,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,MAAM,EACtCW,KAAK,CAACe,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;IACzBmE,UAAU,CAACnE,CAAC,GAAC,CAAC,EAAEyB,IAAI,GAAE,CAAC,IAAEC,KAAK,CAAC1B,CAAC,CAAE,CAAC;IAEnC,KAAI,IAAIM,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC4B,SAAS,EAAE,EAAE5B,CAAC,EAAE;MAC7BiC,IAAI,CAACG,IAAI,CAACjC,OAAO,CAACH,CAAC,CAAC,EAAE,IAAI,EAAEM,IAAI,CAACN,CAAC,EAACoB,KAAK,CAAC1B,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC;IACpD;IACA,IAAGA,CAAC,KAAKwB,SAAS,GAAC,CAAC,EAAE;MACpBe,IAAI,CAACG,IAAI,CAACrB,OAAO,EAAE,KAAK,CAAC;MACzB6C,IAAI,EAAE;IACR;IACAb,YAAY,CAACrD,CAAC,EAAE,CAAC,CAAC;IAClBmE,UAAU,CAACnE,CAAC,GAAC,CAAC,EAAEyB,IAAI,CAAC;IACrB,IAAGzB,CAAC,KAAKwB,SAAS,GAAC,CAAC,EAAE;MACpBe,IAAI,CAACG,IAAI,CAAC,KAAK,EAAE/B,KAAK,CAACe,KAAK,CAACF,SAAS,GAAC,CAAC,CAAC,CAAC,EAAE,MAAM,EAChDH,OAAO,EAAE,MAAM,CAAC;MAClB6C,IAAI,EAAE;IACR;IACAX,UAAU,CAACvD,CAAC,CAAC;IACbuC,IAAI,CAACG,IAAI,CAAC,GAAG,CAAC;EAChB;EAEAyB,UAAU,CAAC3C,SAAS,GAAC,CAAC,EAAE,CAAC,CAAC;;EAE1B;EACAe,IAAI,CAACG,IAAI,CAAC,aAAa,EAAEzB,UAAU,EAAE,eAAe,EAAEC,MAAM,EAAE,IAAI,CAAC;;EAEnE;EACA,IAAIkD,aAAa,GAAG,CAClB,eAAe,EACf,WAAW,EAAE/B,QAAQ,EAAE,GAAG,EAAEI,IAAI,CAACH,IAAI,EAAE,EAAE,IAAI,EAC3C,MAAM,EAAEE,IAAI,CAACF,IAAI,EAAE,EAAE,GAAG,EACxBC,IAAI,CAACD,IAAI,CAAC,EAAE,CAAC,EACf,GAAG,EACH,SAAS,EAAED,QAAQ,CAAE,CAACC,IAAI,CAAC,EAAE,CAAC;EAEhC,IAAI+B,IAAI,GAAG,IAAIC,QAAQ,CACrB,QAAQ,EACR,MAAM,EACN,OAAO,EACP,cAAc,EACd,YAAY,EACZF,aAAa,CAAC;EAChB,OAAOC,IAAI,CACTxC,UAAU,EACVC,QAAQ,EACRC,SAAS,EACTrC,IAAI,CAAC6E,YAAY,EACjB7E,IAAI,CAAC8E,UAAU,CAAC;AACpB;AAEA,SAAS1E,sBAAsB,CAAC2C,IAAI,EAAE;EACpC,SAASgC,KAAK,CAACC,GAAG,EAAE;IAClB,MAAM,IAAItC,KAAK,CAAC,2BAA2B,GAAGsC,GAAG,CAAC;EACpD;EACA,IAAG,OAAOjC,IAAI,KAAK,QAAQ,EAAE;IAC3BgC,KAAK,CAAC,wBAAwB,CAAC;EACjC;EACA,IAAI/C,KAAK,GAAGe,IAAI,CAACf,KAAK;EACtB,IAAG,CAACiD,KAAK,CAACC,OAAO,CAAClD,KAAK,CAAC,EAAE;IACxB+C,KAAK,CAAC,oBAAoB,CAAC;EAC7B;EACA,IAAII,MAAM,GAAGpC,IAAI,CAACqC,cAAc,IAAE,CAAC;EACnC,IAAGD,MAAM,GAAG,CAAC,EAAE;IACbJ,KAAK,CAAC,uCAAuC,CAAC;EAChD;EACA,IAAIM,OAAO,GAAGtC,IAAI,CAACuC,eAAe,IAAE,CAAC;EACrC,IAAGD,OAAO,GAAG,CAAC,EAAE;IACdN,KAAK,CAAC,8BAA8B,CAAC;EACvC;EACA,IAAG,OAAOhC,IAAI,CAACwC,MAAM,KAAK,UAAU,EAAE;IACpCR,KAAK,CAAC,uCAAuC,CAAC;EAChD;EACA,IAAG,OAAOhC,IAAI,CAACyC,IAAI,KAAK,UAAU,EAAE;IAClCT,KAAK,CAAC,qCAAqC,CAAC;EAC9C;EACA,IAAG,OAAOhC,IAAI,CAAC0C,KAAK,KAAK,UAAU,EAAE;IACnCV,KAAK,CAAC,6BAA6B,CAAC;EACtC;EACA,IAAIW,OAAO,GAAG3C,IAAI,CAAC2C,OAAO,IAAI,EAAE;EAChC,IAAInD,OAAO,GAAG,IAAI0C,KAAK,CAACE,MAAM,CAAC;EAC/B,KAAI,IAAI7E,CAAC,GAAC,CAAC,EAAEA,CAAC,GAAC6E,MAAM,EAAE,EAAE7E,CAAC,EAAE;IAC1B,IAAGoF,OAAO,CAACjC,OAAO,CAACnD,CAAC,CAAC,IAAI,CAAC,EAAE;MAC1BiC,OAAO,CAACjC,CAAC,CAAC,GAAG,IAAI;IACnB,CAAC,MAAM;MACLiC,OAAO,CAACjC,CAAC,CAAC,GAAG,KAAK;IACpB;EACF;EACA,OAAO4B,uBAAuB,CAC5Ba,IAAI,CAACwC,MAAM,EACXxC,IAAI,CAACyC,IAAI,EACTzC,IAAI,CAAC0C,KAAK,EACVJ,OAAO,EACPrD,KAAK,EACLO,OAAO,CAAC;AACZ"},"metadata":{},"sourceType":"script","externalDependencies":[]}