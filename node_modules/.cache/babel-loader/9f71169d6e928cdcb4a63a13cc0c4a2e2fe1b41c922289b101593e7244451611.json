{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar counterRegex = require('../../lib/regex').counter;\nvar domainAttrs = require('../../plots/domain').attributes;\nvar cartesianIdRegex = require('../../plots/cartesian/constants').idRegex;\nvar Template = require('../../plot_api/plot_template');\nvar gridAttrs = {\n  rows: {\n    valType: 'integer',\n    min: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['The number of rows in the grid. If you provide a 2D `subplots`', 'array or a `yaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  roworder: {\n    valType: 'enumerated',\n    values: ['top to bottom', 'bottom to top'],\n    dflt: 'top to bottom',\n    role: 'info',\n    editType: 'plot',\n    description: ['Is the first row the top or the bottom? Note that columns', 'are always enumerated from left to right.'].join(' ')\n  },\n  columns: {\n    valType: 'integer',\n    min: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['The number of columns in the grid. If you provide a 2D `subplots`', 'array, the length of its longest row is used as the default.', 'If you give an `xaxes` array, its length is used as the default.', 'But it\\'s also possible to have a different length, if you', 'want to leave a row at the end for non-cartesian subplots.'].join(' ')\n  },\n  subplots: {\n    valType: 'info_array',\n    freeLength: true,\n    dimensions: 2,\n    items: {\n      valType: 'enumerated',\n      values: [counterRegex('xy').toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used for freeform grids, where some axes may be shared across subplots', 'but others are not. Each entry should be a cartesian subplot id, like', '*xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes', 'within the same column, and y axes within the same row.', 'Non-cartesian subplots and traces that support `domain` can place themselves', 'in this grid separately using the `gridcell` attribute.'].join(' ')\n  },\n  xaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.x.toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an x axis id like *x*, *x2*, etc., or ** to', 'not put an x axis in that column. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `yaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  yaxes: {\n    valType: 'info_array',\n    freeLength: true,\n    items: {\n      valType: 'enumerated',\n      values: [cartesianIdRegex.y.toString(), ''],\n      editType: 'plot'\n    },\n    role: 'info',\n    editType: 'plot',\n    description: ['Used with `yaxes` when the x and y axes are shared across columns and rows.', 'Each entry should be an y axis id like *y*, *y2*, etc., or ** to', 'not put a y axis in that row. Entries other than ** must be unique.', 'Ignored if `subplots` is present. If missing but `xaxes` is present,', 'will generate consecutive IDs.'].join(' ')\n  },\n  pattern: {\n    valType: 'enumerated',\n    values: ['independent', 'coupled'],\n    dflt: 'coupled',\n    role: 'info',\n    editType: 'plot',\n    description: ['If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,', 'we can generate defaults using consecutive axis IDs, in two ways:', '*coupled* gives one x axis per column and one y axis per row.', '*independent* uses a new xy pair for each cell, left-to-right across each row', 'then iterating rows according to `roworder`.'].join(' ')\n  },\n  xgap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['Horizontal space between grid cells, expressed as a fraction', 'of the total width available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.2 for independent grids.'].join(' ')\n  },\n  ygap: {\n    valType: 'number',\n    min: 0,\n    max: 1,\n    role: 'info',\n    editType: 'plot',\n    description: ['Vertical space between grid cells, expressed as a fraction', 'of the total height available to one cell. Defaults to 0.1', 'for coupled-axes grids and 0.3 for independent grids.'].join(' ')\n  },\n  domain: domainAttrs({\n    name: 'grid',\n    editType: 'plot',\n    noGridCell: true\n  }, {\n    description: ['The first and last cells end exactly at the domain', 'edges, with no grout around the edges.'].join(' ')\n  }),\n  xside: {\n    valType: 'enumerated',\n    values: ['bottom', 'bottom plot', 'top plot', 'top'],\n    dflt: 'bottom plot',\n    role: 'info',\n    editType: 'plot',\n    description: ['Sets where the x axis labels and titles go. *bottom* means', 'the very bottom of the grid. *bottom plot* is the lowest plot', 'that each x axis is used in. *top* and *top plot* are similar.'].join(' ')\n  },\n  yside: {\n    valType: 'enumerated',\n    values: ['left', 'left plot', 'right plot', 'right'],\n    dflt: 'left plot',\n    role: 'info',\n    editType: 'plot',\n    description: ['Sets where the y axis labels and titles go. *left* means', 'the very left edge of the grid. *left plot* is the leftmost plot', 'that each y axis is used in. *right* and *right plot* are similar.'].join(' ')\n  },\n  editType: 'plot'\n};\nfunction getAxes(layout, grid, axLetter) {\n  var gridVal = grid[axLetter + 'axes'];\n  var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});\n  if (Array.isArray(gridVal)) return gridVal;\n  if (splomVal.length) return splomVal;\n}\n\n// the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\nfunction sizeDefaults(layoutIn, layoutOut) {\n  var gridIn = layoutIn.grid || {};\n  var xAxes = getAxes(layoutOut, gridIn, 'x');\n  var yAxes = getAxes(layoutOut, gridIn, 'y');\n  if (!layoutIn.grid && !xAxes && !yAxes) return;\n  var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);\n  var hasXaxes = Array.isArray(xAxes);\n  var hasYaxes = Array.isArray(yAxes);\n  var isSplomGenerated = hasXaxes && xAxes !== gridIn.xaxes && hasYaxes && yAxes !== gridIn.yaxes;\n  var dfltRows, dfltColumns;\n  if (hasSubplotGrid) {\n    dfltRows = gridIn.subplots.length;\n    dfltColumns = gridIn.subplots[0].length;\n  } else {\n    if (hasYaxes) dfltRows = yAxes.length;\n    if (hasXaxes) dfltColumns = xAxes.length;\n  }\n  var gridOut = Template.newContainer(layoutOut, 'grid');\n  function coerce(attr, dflt) {\n    return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);\n  }\n  var rows = coerce('rows', dfltRows);\n  var columns = coerce('columns', dfltColumns);\n  if (!(rows * columns > 1)) {\n    delete layoutOut.grid;\n    return;\n  }\n  if (!hasSubplotGrid && !hasXaxes && !hasYaxes) {\n    var useDefaultSubplots = coerce('pattern') === 'independent';\n    if (useDefaultSubplots) hasSubplotGrid = true;\n  }\n  gridOut._hasSubplotGrid = hasSubplotGrid;\n  var rowOrder = coerce('roworder');\n  var reversed = rowOrder === 'top to bottom';\n  var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;\n  var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;\n  var dfltSideX, dfltSideY;\n  if (isSplomGenerated && layoutOut._splomGridDflt) {\n    dfltSideX = layoutOut._splomGridDflt.xside;\n    dfltSideY = layoutOut._splomGridDflt.yside;\n  }\n  gridOut._domains = {\n    x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),\n    y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)\n  };\n}\n\n// coerce x or y sizing attributes and return an array of domains for this direction\nfunction fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {\n  var dirGap = coerce(axLetter + 'gap', dfltGap);\n  var domain = coerce('domain.' + axLetter);\n  coerce(axLetter + 'side', dfltSide);\n  var out = new Array(len);\n  var start = domain[0];\n  var step = (domain[1] - start) / (len - dirGap);\n  var cellDomain = step * (1 - dirGap);\n  for (var i = 0; i < len; i++) {\n    var cellStart = start + step * i;\n    out[reversed ? len - 1 - i : i] = [cellStart, cellStart + cellDomain];\n  }\n  return out;\n}\n\n// the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\nfunction contentDefaults(layoutIn, layoutOut) {\n  var gridOut = layoutOut.grid;\n  // make sure we got to the end of handleGridSizing\n  if (!gridOut || !gridOut._domains) return;\n  var gridIn = layoutIn.grid || {};\n  var subplots = layoutOut._subplots;\n  var hasSubplotGrid = gridOut._hasSubplotGrid;\n  var rows = gridOut.rows;\n  var columns = gridOut.columns;\n  var useDefaultSubplots = gridOut.pattern === 'independent';\n  var i, j, xId, yId, subplotId, subplotsOut, yPos;\n  var axisMap = gridOut._axisMap = {};\n  if (hasSubplotGrid) {\n    var subplotsIn = gridIn.subplots || [];\n    subplotsOut = gridOut.subplots = new Array(rows);\n    var index = 1;\n    for (i = 0; i < rows; i++) {\n      var rowOut = subplotsOut[i] = new Array(columns);\n      var rowIn = subplotsIn[i] || [];\n      for (j = 0; j < columns; j++) {\n        if (useDefaultSubplots) {\n          subplotId = index === 1 ? 'xy' : 'x' + index + 'y' + index;\n          index++;\n        } else subplotId = rowIn[j];\n        rowOut[j] = '';\n        if (subplots.cartesian.indexOf(subplotId) !== -1) {\n          yPos = subplotId.indexOf('y');\n          xId = subplotId.slice(0, yPos);\n          yId = subplotId.slice(yPos);\n          if (axisMap[xId] !== undefined && axisMap[xId] !== j || axisMap[yId] !== undefined && axisMap[yId] !== i) {\n            continue;\n          }\n          rowOut[j] = subplotId;\n          axisMap[xId] = j;\n          axisMap[yId] = i;\n        }\n      }\n    }\n  } else {\n    var xAxes = getAxes(layoutOut, gridIn, 'x');\n    var yAxes = getAxes(layoutOut, gridIn, 'y');\n    gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');\n    gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');\n  }\n  var anchors = gridOut._anchors = {};\n  var reversed = gridOut.roworder === 'top to bottom';\n  for (var axisId in axisMap) {\n    var axLetter = axisId.charAt(0);\n    var side = gridOut[axLetter + 'side'];\n    var i0, inc, iFinal;\n    if (side.length < 8) {\n      // grid edge -  ie not \"* plot\" - make these as free axes\n      // since we're not guaranteed to have a subplot there at all\n      anchors[axisId] = 'free';\n    } else if (axLetter === 'x') {\n      if (side.charAt(0) === 't' === reversed) {\n        i0 = 0;\n        inc = 1;\n        iFinal = rows;\n      } else {\n        i0 = rows - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n      if (hasSubplotGrid) {\n        var column = axisMap[axisId];\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[i][column];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n          if (subplotId.slice(0, yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          yId = gridOut.yaxes[i];\n          if (subplots.cartesian.indexOf(axisId + yId) !== -1) {\n            anchors[axisId] = yId;\n            break;\n          }\n        }\n      }\n    } else {\n      if (side.charAt(0) === 'l') {\n        i0 = 0;\n        inc = 1;\n        iFinal = columns;\n      } else {\n        i0 = columns - 1;\n        inc = -1;\n        iFinal = -1;\n      }\n      if (hasSubplotGrid) {\n        var row = axisMap[axisId];\n        for (i = i0; i !== iFinal; i += inc) {\n          subplotId = subplotsOut[row][i];\n          if (!subplotId) continue;\n          yPos = subplotId.indexOf('y');\n          if (subplotId.slice(yPos) === axisId) {\n            anchors[axisId] = subplotId.slice(0, yPos);\n            break;\n          }\n        }\n      } else {\n        for (i = i0; i !== iFinal; i += inc) {\n          xId = gridOut.xaxes[i];\n          if (subplots.cartesian.indexOf(xId + axisId) !== -1) {\n            anchors[axisId] = xId;\n            break;\n          }\n        }\n      }\n    }\n  }\n}\nfunction fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {\n  var out = new Array(len);\n  var i;\n  function fillOneAxis(i, axisId) {\n    if (axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {\n      out[i] = axisId;\n      axisMap[axisId] = i;\n    } else out[i] = '';\n  }\n  if (Array.isArray(axesIn)) {\n    for (i = 0; i < len; i++) {\n      fillOneAxis(i, axesIn[i]);\n    }\n  } else {\n    // default axis list is the first `len` axis ids\n    fillOneAxis(0, axLetter);\n    for (i = 1; i < len; i++) {\n      fillOneAxis(i, axLetter + (i + 1));\n    }\n  }\n  return out;\n}\nmodule.exports = {\n  moduleType: 'component',\n  name: 'grid',\n  schema: {\n    layout: {\n      grid: gridAttrs\n    }\n  },\n  layoutAttributes: gridAttrs,\n  sizeDefaults: sizeDefaults,\n  contentDefaults: contentDefaults\n};","map":{"version":3,"names":["Lib","require","counterRegex","counter","domainAttrs","attributes","cartesianIdRegex","idRegex","Template","gridAttrs","rows","valType","min","role","editType","description","join","roworder","values","dflt","columns","subplots","freeLength","dimensions","items","toString","xaxes","x","yaxes","y","pattern","xgap","max","ygap","domain","name","noGridCell","xside","yside","getAxes","layout","grid","axLetter","gridVal","splomVal","Object","keys","_splomAxes","Array","isArray","length","sizeDefaults","layoutIn","layoutOut","gridIn","xAxes","yAxes","hasSubplotGrid","hasXaxes","hasYaxes","isSplomGenerated","dfltRows","dfltColumns","gridOut","newContainer","coerce","attr","useDefaultSubplots","_hasSubplotGrid","rowOrder","reversed","dfltGapX","dfltGapY","dfltSideX","dfltSideY","_splomGridDflt","_domains","fillGridPositions","dfltGap","dfltSide","len","dirGap","out","start","step","cellDomain","i","cellStart","contentDefaults","_subplots","j","xId","yId","subplotId","subplotsOut","yPos","axisMap","_axisMap","subplotsIn","index","rowOut","rowIn","cartesian","indexOf","slice","undefined","fillGridAxes","xaxis","yaxis","anchors","_anchors","axisId","charAt","side","i0","inc","iFinal","column","row","axesIn","axesAllowed","fillOneAxis","module","exports","moduleType","schema","layoutAttributes"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/components/grid/index.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar counterRegex = require('../../lib/regex').counter;\nvar domainAttrs = require('../../plots/domain').attributes;\nvar cartesianIdRegex = require('../../plots/cartesian/constants').idRegex;\nvar Template = require('../../plot_api/plot_template');\n\nvar gridAttrs = {\n    rows: {\n        valType: 'integer',\n        min: 1,\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'The number of rows in the grid. If you provide a 2D `subplots`',\n            'array or a `yaxes` array, its length is used as the default.',\n            'But it\\'s also possible to have a different length, if you',\n            'want to leave a row at the end for non-cartesian subplots.'\n        ].join(' ')\n    },\n    roworder: {\n        valType: 'enumerated',\n        values: ['top to bottom', 'bottom to top'],\n        dflt: 'top to bottom',\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Is the first row the top or the bottom? Note that columns',\n            'are always enumerated from left to right.'\n        ].join(' ')\n    },\n    columns: {\n        valType: 'integer',\n        min: 1,\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'The number of columns in the grid. If you provide a 2D `subplots`',\n            'array, the length of its longest row is used as the default.',\n            'If you give an `xaxes` array, its length is used as the default.',\n            'But it\\'s also possible to have a different length, if you',\n            'want to leave a row at the end for non-cartesian subplots.'\n        ].join(' ')\n    },\n    subplots: {\n        valType: 'info_array',\n        freeLength: true,\n        dimensions: 2,\n        items: {valType: 'enumerated', values: [counterRegex('xy').toString(), ''], editType: 'plot'},\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Used for freeform grids, where some axes may be shared across subplots',\n            'but others are not. Each entry should be a cartesian subplot id, like',\n            '*xy* or *x3y2*, or ** to leave that cell empty. You may reuse x axes',\n            'within the same column, and y axes within the same row.',\n            'Non-cartesian subplots and traces that support `domain` can place themselves',\n            'in this grid separately using the `gridcell` attribute.'\n        ].join(' ')\n    },\n    xaxes: {\n        valType: 'info_array',\n        freeLength: true,\n        items: {valType: 'enumerated', values: [cartesianIdRegex.x.toString(), ''], editType: 'plot'},\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Used with `yaxes` when the x and y axes are shared across columns and rows.',\n            'Each entry should be an x axis id like *x*, *x2*, etc., or ** to',\n            'not put an x axis in that column. Entries other than ** must be unique.',\n            'Ignored if `subplots` is present. If missing but `yaxes` is present,',\n            'will generate consecutive IDs.'\n        ].join(' ')\n    },\n    yaxes: {\n        valType: 'info_array',\n        freeLength: true,\n        items: {valType: 'enumerated', values: [cartesianIdRegex.y.toString(), ''], editType: 'plot'},\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Used with `yaxes` when the x and y axes are shared across columns and rows.',\n            'Each entry should be an y axis id like *y*, *y2*, etc., or ** to',\n            'not put a y axis in that row. Entries other than ** must be unique.',\n            'Ignored if `subplots` is present. If missing but `xaxes` is present,',\n            'will generate consecutive IDs.'\n        ].join(' ')\n    },\n    pattern: {\n        valType: 'enumerated',\n        values: ['independent', 'coupled'],\n        dflt: 'coupled',\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'If no `subplots`, `xaxes`, or `yaxes` are given but we do have `rows` and `columns`,',\n            'we can generate defaults using consecutive axis IDs, in two ways:',\n            '*coupled* gives one x axis per column and one y axis per row.',\n            '*independent* uses a new xy pair for each cell, left-to-right across each row',\n            'then iterating rows according to `roworder`.'\n        ].join(' ')\n    },\n    xgap: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Horizontal space between grid cells, expressed as a fraction',\n            'of the total width available to one cell. Defaults to 0.1',\n            'for coupled-axes grids and 0.2 for independent grids.'\n        ].join(' ')\n    },\n    ygap: {\n        valType: 'number',\n        min: 0,\n        max: 1,\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Vertical space between grid cells, expressed as a fraction',\n            'of the total height available to one cell. Defaults to 0.1',\n            'for coupled-axes grids and 0.3 for independent grids.'\n        ].join(' ')\n    },\n    domain: domainAttrs({name: 'grid', editType: 'plot', noGridCell: true}, {\n        description: [\n            'The first and last cells end exactly at the domain',\n            'edges, with no grout around the edges.'\n        ].join(' ')\n    }),\n    xside: {\n        valType: 'enumerated',\n        values: ['bottom', 'bottom plot', 'top plot', 'top'],\n        dflt: 'bottom plot',\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Sets where the x axis labels and titles go. *bottom* means',\n            'the very bottom of the grid. *bottom plot* is the lowest plot',\n            'that each x axis is used in. *top* and *top plot* are similar.'\n        ].join(' ')\n    },\n    yside: {\n        valType: 'enumerated',\n        values: ['left', 'left plot', 'right plot', 'right'],\n        dflt: 'left plot',\n        role: 'info',\n        editType: 'plot',\n        description: [\n            'Sets where the y axis labels and titles go. *left* means',\n            'the very left edge of the grid. *left plot* is the leftmost plot',\n            'that each y axis is used in. *right* and *right plot* are similar.'\n        ].join(' ')\n    },\n    editType: 'plot'\n};\n\nfunction getAxes(layout, grid, axLetter) {\n    var gridVal = grid[axLetter + 'axes'];\n    var splomVal = Object.keys((layout._splomAxes || {})[axLetter] || {});\n\n    if(Array.isArray(gridVal)) return gridVal;\n    if(splomVal.length) return splomVal;\n}\n\n// the shape of the grid - this needs to be done BEFORE supplyDataDefaults\n// so that non-subplot traces can place themselves in the grid\nfunction sizeDefaults(layoutIn, layoutOut) {\n    var gridIn = layoutIn.grid || {};\n    var xAxes = getAxes(layoutOut, gridIn, 'x');\n    var yAxes = getAxes(layoutOut, gridIn, 'y');\n\n    if(!layoutIn.grid && !xAxes && !yAxes) return;\n\n    var hasSubplotGrid = Array.isArray(gridIn.subplots) && Array.isArray(gridIn.subplots[0]);\n    var hasXaxes = Array.isArray(xAxes);\n    var hasYaxes = Array.isArray(yAxes);\n    var isSplomGenerated = (\n        hasXaxes && xAxes !== gridIn.xaxes &&\n        hasYaxes && yAxes !== gridIn.yaxes\n    );\n\n    var dfltRows, dfltColumns;\n\n    if(hasSubplotGrid) {\n        dfltRows = gridIn.subplots.length;\n        dfltColumns = gridIn.subplots[0].length;\n    }\n    else {\n        if(hasYaxes) dfltRows = yAxes.length;\n        if(hasXaxes) dfltColumns = xAxes.length;\n    }\n\n    var gridOut = Template.newContainer(layoutOut, 'grid');\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(gridIn, gridOut, gridAttrs, attr, dflt);\n    }\n\n    var rows = coerce('rows', dfltRows);\n    var columns = coerce('columns', dfltColumns);\n\n    if(!(rows * columns > 1)) {\n        delete layoutOut.grid;\n        return;\n    }\n\n    if(!hasSubplotGrid && !hasXaxes && !hasYaxes) {\n        var useDefaultSubplots = coerce('pattern') === 'independent';\n        if(useDefaultSubplots) hasSubplotGrid = true;\n    }\n    gridOut._hasSubplotGrid = hasSubplotGrid;\n\n    var rowOrder = coerce('roworder');\n    var reversed = rowOrder === 'top to bottom';\n\n    var dfltGapX = hasSubplotGrid ? 0.2 : 0.1;\n    var dfltGapY = hasSubplotGrid ? 0.3 : 0.1;\n\n    var dfltSideX, dfltSideY;\n    if(isSplomGenerated && layoutOut._splomGridDflt) {\n        dfltSideX = layoutOut._splomGridDflt.xside;\n        dfltSideY = layoutOut._splomGridDflt.yside;\n    }\n\n    gridOut._domains = {\n        x: fillGridPositions('x', coerce, dfltGapX, dfltSideX, columns),\n        y: fillGridPositions('y', coerce, dfltGapY, dfltSideY, rows, reversed)\n    };\n}\n\n// coerce x or y sizing attributes and return an array of domains for this direction\nfunction fillGridPositions(axLetter, coerce, dfltGap, dfltSide, len, reversed) {\n    var dirGap = coerce(axLetter + 'gap', dfltGap);\n    var domain = coerce('domain.' + axLetter);\n    coerce(axLetter + 'side', dfltSide);\n\n    var out = new Array(len);\n    var start = domain[0];\n    var step = (domain[1] - start) / (len - dirGap);\n    var cellDomain = step * (1 - dirGap);\n    for(var i = 0; i < len; i++) {\n        var cellStart = start + step * i;\n        out[reversed ? (len - 1 - i) : i] = [cellStart, cellStart + cellDomain];\n    }\n    return out;\n}\n\n// the (cartesian) contents of the grid - this needs to happen AFTER supplyDataDefaults\n// so that we know what cartesian subplots are available\nfunction contentDefaults(layoutIn, layoutOut) {\n    var gridOut = layoutOut.grid;\n    // make sure we got to the end of handleGridSizing\n    if(!gridOut || !gridOut._domains) return;\n\n    var gridIn = layoutIn.grid || {};\n    var subplots = layoutOut._subplots;\n    var hasSubplotGrid = gridOut._hasSubplotGrid;\n    var rows = gridOut.rows;\n    var columns = gridOut.columns;\n    var useDefaultSubplots = gridOut.pattern === 'independent';\n\n    var i, j, xId, yId, subplotId, subplotsOut, yPos;\n\n    var axisMap = gridOut._axisMap = {};\n\n    if(hasSubplotGrid) {\n        var subplotsIn = gridIn.subplots || [];\n        subplotsOut = gridOut.subplots = new Array(rows);\n        var index = 1;\n\n        for(i = 0; i < rows; i++) {\n            var rowOut = subplotsOut[i] = new Array(columns);\n            var rowIn = subplotsIn[i] || [];\n            for(j = 0; j < columns; j++) {\n                if(useDefaultSubplots) {\n                    subplotId = (index === 1) ? 'xy' : ('x' + index + 'y' + index);\n                    index++;\n                }\n                else subplotId = rowIn[j];\n\n                rowOut[j] = '';\n\n                if(subplots.cartesian.indexOf(subplotId) !== -1) {\n                    yPos = subplotId.indexOf('y');\n                    xId = subplotId.slice(0, yPos);\n                    yId = subplotId.slice(yPos);\n                    if((axisMap[xId] !== undefined && axisMap[xId] !== j) ||\n                        (axisMap[yId] !== undefined && axisMap[yId] !== i)\n                    ) {\n                        continue;\n                    }\n\n                    rowOut[j] = subplotId;\n                    axisMap[xId] = j;\n                    axisMap[yId] = i;\n                }\n            }\n        }\n    }\n    else {\n        var xAxes = getAxes(layoutOut, gridIn, 'x');\n        var yAxes = getAxes(layoutOut, gridIn, 'y');\n        gridOut.xaxes = fillGridAxes(xAxes, subplots.xaxis, columns, axisMap, 'x');\n        gridOut.yaxes = fillGridAxes(yAxes, subplots.yaxis, rows, axisMap, 'y');\n    }\n\n    var anchors = gridOut._anchors = {};\n    var reversed = gridOut.roworder === 'top to bottom';\n\n    for(var axisId in axisMap) {\n        var axLetter = axisId.charAt(0);\n        var side = gridOut[axLetter + 'side'];\n\n        var i0, inc, iFinal;\n\n        if(side.length < 8) {\n            // grid edge -  ie not \"* plot\" - make these as free axes\n            // since we're not guaranteed to have a subplot there at all\n            anchors[axisId] = 'free';\n        }\n        else if(axLetter === 'x') {\n            if((side.charAt(0) === 't') === reversed) {\n                i0 = 0;\n                inc = 1;\n                iFinal = rows;\n            }\n            else {\n                i0 = rows - 1;\n                inc = -1;\n                iFinal = -1;\n            }\n            if(hasSubplotGrid) {\n                var column = axisMap[axisId];\n                for(i = i0; i !== iFinal; i += inc) {\n                    subplotId = subplotsOut[i][column];\n                    if(!subplotId) continue;\n                    yPos = subplotId.indexOf('y');\n                    if(subplotId.slice(0, yPos) === axisId) {\n                        anchors[axisId] = subplotId.slice(yPos);\n                        break;\n                    }\n                }\n            }\n            else {\n                for(i = i0; i !== iFinal; i += inc) {\n                    yId = gridOut.yaxes[i];\n                    if(subplots.cartesian.indexOf(axisId + yId) !== -1) {\n                        anchors[axisId] = yId;\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            if((side.charAt(0) === 'l')) {\n                i0 = 0;\n                inc = 1;\n                iFinal = columns;\n            }\n            else {\n                i0 = columns - 1;\n                inc = -1;\n                iFinal = -1;\n            }\n            if(hasSubplotGrid) {\n                var row = axisMap[axisId];\n                for(i = i0; i !== iFinal; i += inc) {\n                    subplotId = subplotsOut[row][i];\n                    if(!subplotId) continue;\n                    yPos = subplotId.indexOf('y');\n                    if(subplotId.slice(yPos) === axisId) {\n                        anchors[axisId] = subplotId.slice(0, yPos);\n                        break;\n                    }\n                }\n            }\n            else {\n                for(i = i0; i !== iFinal; i += inc) {\n                    xId = gridOut.xaxes[i];\n                    if(subplots.cartesian.indexOf(xId + axisId) !== -1) {\n                        anchors[axisId] = xId;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction fillGridAxes(axesIn, axesAllowed, len, axisMap, axLetter) {\n    var out = new Array(len);\n    var i;\n\n    function fillOneAxis(i, axisId) {\n        if(axesAllowed.indexOf(axisId) !== -1 && axisMap[axisId] === undefined) {\n            out[i] = axisId;\n            axisMap[axisId] = i;\n        }\n        else out[i] = '';\n    }\n\n    if(Array.isArray(axesIn)) {\n        for(i = 0; i < len; i++) {\n            fillOneAxis(i, axesIn[i]);\n        }\n    }\n    else {\n        // default axis list is the first `len` axis ids\n        fillOneAxis(0, axLetter);\n        for(i = 1; i < len; i++) {\n            fillOneAxis(i, axLetter + (i + 1));\n        }\n    }\n\n    return out;\n}\n\nmodule.exports = {\n    moduleType: 'component',\n    name: 'grid',\n\n    schema: {\n        layout: {grid: gridAttrs}\n    },\n\n    layoutAttributes: gridAttrs,\n    sizeDefaults: sizeDefaults,\n    contentDefaults: contentDefaults\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}