{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\nvar filterOps = require('../constants/filter_ops');\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\nexports.moduleType = 'transform';\nexports.name = 'filter';\nexports.attributes = {\n  enabled: {\n    valType: 'boolean',\n    dflt: true,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether this filter transform is enabled or disabled.'].join(' ')\n  },\n  target: {\n    valType: 'string',\n    strict: true,\n    noBlank: true,\n    arrayOk: true,\n    dflt: 'x',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the filter target by which the filter is applied.', 'If a string, `target` is assumed to be a reference to a data array', 'in the parent trace object.', 'To filter about nested variables, use *.* to access them.', 'For example, set `target` to *marker.color* to filter', 'about the marker color array.', 'If an array, `target` is then the data array by which the filter is applied.'].join(' ')\n  },\n  operation: {\n    valType: 'enumerated',\n    values: [].concat(COMPARISON_OPS).concat(INTERVAL_OPS).concat(SET_OPS),\n    dflt: '=',\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the filter operation.', '*=* keeps items equal to `value`', '*!=* keeps items not equal to `value`', '*<* keeps items less than `value`', '*<=* keeps items less than or equal to `value`', '*>* keeps items greater than `value`', '*>=* keeps items greater than or equal to `value`', '*[]* keeps items inside `value[0]` to `value[1]` including both bounds', '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds', '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]', '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]', '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds', '*)(* keeps items outside `value[0]` to `value[1]`', '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`', '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`', '*{}* keeps items present in a set of values', '*}{* keeps items not present in a set of values'].join(' ')\n  },\n  value: {\n    valType: 'any',\n    dflt: 0,\n    role: 'info',\n    editType: 'calc',\n    description: ['Sets the value or values by which to filter.', 'Values are expected to be in the same type as the data linked', 'to `target`.', 'When `operation` is set to one of', 'the comparison values (' + COMPARISON_OPS + ')', '`value` is expected to be a number or a string.', 'When `operation` is set to one of the interval values', '(' + INTERVAL_OPS + ')', '`value` is expected to be 2-item array where the first item', 'is the lower bound and the second item is the upper bound.', 'When `operation`, is set to one of the set values', '(' + SET_OPS + ')', '`value` is expected to be an array with as many items as', 'the desired set elements.'].join(' ')\n  },\n  preservegaps: {\n    valType: 'boolean',\n    dflt: false,\n    role: 'info',\n    editType: 'calc',\n    description: ['Determines whether or not gaps in data arrays produced by the filter operation', 'are preserved.', 'Setting this to *true* might be useful when plotting a line chart', 'with `connectgaps` set to *false*.'].join(' ')\n  },\n  editType: 'calc'\n};\nexports.supplyDefaults = function (transformIn) {\n  var transformOut = {};\n  function coerce(attr, dflt) {\n    return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n  }\n  var enabled = coerce('enabled');\n  if (enabled) {\n    coerce('preservegaps');\n    coerce('operation');\n    coerce('value');\n    coerce('target');\n    var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n    handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n    handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n  }\n  return transformOut;\n};\nexports.calcTransform = function (gd, trace, opts) {\n  if (!opts.enabled) return;\n  var targetArray = Lib.getTargetArray(trace, opts);\n  if (!targetArray) return;\n  var target = opts.target;\n  var len = targetArray.length;\n  if (trace._length) len = Math.min(len, trace._length);\n  var targetCalendar = opts.targetcalendar;\n  var arrayAttrs = trace._arrayAttrs;\n  var preservegaps = opts.preservegaps;\n\n  // even if you provide targetcalendar, if target is a string and there\n  // is a calendar attribute matching target it will get used instead.\n  if (typeof target === 'string') {\n    var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n    if (attrTargetCalendar) targetCalendar = attrTargetCalendar;\n  }\n  var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n  var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n  var originalArrays = {};\n  var indexToPoints = {};\n  var index = 0;\n  function forAllAttrs(fn, index) {\n    for (var j = 0; j < arrayAttrs.length; j++) {\n      var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n      fn(np, index);\n    }\n  }\n  var initFn;\n  var fillFn;\n  if (preservegaps) {\n    initFn = function initFn(np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set(new Array(len));\n    };\n    fillFn = function fillFn(np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get()[index] = val;\n    };\n  } else {\n    initFn = function initFn(np) {\n      originalArrays[np.astr] = Lib.extendDeep([], np.get());\n      np.set([]);\n    };\n    fillFn = function fillFn(np, index) {\n      var val = originalArrays[np.astr][index];\n      np.get().push(val);\n    };\n  }\n\n  // copy all original array attribute values, and clear arrays in trace\n  forAllAttrs(initFn);\n  var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n  // loop through filter array, fill trace arrays if passed\n  for (var i = 0; i < len; i++) {\n    var passed = filterFunc(targetArray[i]);\n    if (passed) {\n      forAllAttrs(fillFn, i);\n      indexToPoints[index++] = originalPointsAccessor(i);\n    } else if (preservegaps) index++;\n  }\n  opts._indexToPoints = indexToPoints;\n  trace._length = index;\n};\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n  var operation = opts.operation;\n  var value = opts.value;\n  var hasArrayValue = Array.isArray(value);\n  function isOperationIn(array) {\n    return array.indexOf(operation) !== -1;\n  }\n  var d2cValue = function d2cValue(v) {\n    return d2c(v, 0, opts.valuecalendar);\n  };\n  var d2cTarget = function d2cTarget(v) {\n    return d2c(v, 0, targetCalendar);\n  };\n  var coercedValue;\n  if (isOperationIn(COMPARISON_OPS)) {\n    coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n  } else if (isOperationIn(INTERVAL_OPS)) {\n    coercedValue = hasArrayValue ? [d2cValue(value[0]), d2cValue(value[1])] : [d2cValue(value), d2cValue(value)];\n  } else if (isOperationIn(SET_OPS)) {\n    coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n  }\n  switch (operation) {\n    case '=':\n      return function (v) {\n        return d2cTarget(v) === coercedValue;\n      };\n    case '!=':\n      return function (v) {\n        return d2cTarget(v) !== coercedValue;\n      };\n    case '<':\n      return function (v) {\n        return d2cTarget(v) < coercedValue;\n      };\n    case '<=':\n      return function (v) {\n        return d2cTarget(v) <= coercedValue;\n      };\n    case '>':\n      return function (v) {\n        return d2cTarget(v) > coercedValue;\n      };\n    case '>=':\n      return function (v) {\n        return d2cTarget(v) >= coercedValue;\n      };\n    case '[]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv <= coercedValue[1];\n      };\n    case '()':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv < coercedValue[1];\n      };\n    case '[)':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv >= coercedValue[0] && cv < coercedValue[1];\n      };\n    case '(]':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv > coercedValue[0] && cv <= coercedValue[1];\n      };\n    case '][':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv >= coercedValue[1];\n      };\n    case ')(':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv > coercedValue[1];\n      };\n    case '](':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv <= coercedValue[0] || cv > coercedValue[1];\n      };\n    case ')[':\n      return function (v) {\n        var cv = d2cTarget(v);\n        return cv < coercedValue[0] || cv >= coercedValue[1];\n      };\n    case '{}':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) !== -1;\n      };\n    case '}{':\n      return function (v) {\n        return coercedValue.indexOf(d2cTarget(v)) === -1;\n      };\n  }\n}","map":{"version":3,"names":["Lib","require","Registry","Axes","pointsAccessorFunction","filterOps","COMPARISON_OPS","INTERVAL_OPS","SET_OPS","exports","moduleType","name","attributes","enabled","valType","dflt","role","editType","description","join","target","strict","noBlank","arrayOk","operation","values","concat","value","preservegaps","supplyDefaults","transformIn","transformOut","coerce","attr","handleCalendarDefaults","getComponentMethod","calcTransform","gd","trace","opts","targetArray","getTargetArray","len","length","_length","Math","min","targetCalendar","targetcalendar","arrayAttrs","_arrayAttrs","attrTargetCalendar","nestedProperty","get","d2c","getDataToCoordFunc","filterFunc","getFilterFunc","originalArrays","indexToPoints","index","forAllAttrs","fn","j","np","initFn","fillFn","astr","extendDeep","set","Array","val","push","originalPointsAccessor","transforms","i","passed","_indexToPoints","hasArrayValue","isArray","isOperationIn","array","indexOf","d2cValue","v","valuecalendar","d2cTarget","coercedValue","map","cv"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/transforms/filter.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar Registry = require('../registry');\nvar Axes = require('../plots/cartesian/axes');\nvar pointsAccessorFunction = require('./helpers').pointsAccessorFunction;\n\nvar filterOps = require('../constants/filter_ops');\nvar COMPARISON_OPS = filterOps.COMPARISON_OPS;\nvar INTERVAL_OPS = filterOps.INTERVAL_OPS;\nvar SET_OPS = filterOps.SET_OPS;\n\nexports.moduleType = 'transform';\n\nexports.name = 'filter';\n\nexports.attributes = {\n    enabled: {\n        valType: 'boolean',\n        dflt: true,\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Determines whether this filter transform is enabled or disabled.'\n        ].join(' ')\n    },\n    target: {\n        valType: 'string',\n        strict: true,\n        noBlank: true,\n        arrayOk: true,\n        dflt: 'x',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the filter target by which the filter is applied.',\n\n            'If a string, `target` is assumed to be a reference to a data array',\n            'in the parent trace object.',\n            'To filter about nested variables, use *.* to access them.',\n            'For example, set `target` to *marker.color* to filter',\n            'about the marker color array.',\n\n            'If an array, `target` is then the data array by which the filter is applied.'\n        ].join(' ')\n    },\n    operation: {\n        valType: 'enumerated',\n        values: []\n            .concat(COMPARISON_OPS)\n            .concat(INTERVAL_OPS)\n            .concat(SET_OPS),\n        dflt: '=',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the filter operation.',\n\n            '*=* keeps items equal to `value`',\n            '*!=* keeps items not equal to `value`',\n\n            '*<* keeps items less than `value`',\n            '*<=* keeps items less than or equal to `value`',\n\n            '*>* keeps items greater than `value`',\n            '*>=* keeps items greater than or equal to `value`',\n\n            '*[]* keeps items inside `value[0]` to `value[1]` including both bounds',\n            '*()* keeps items inside `value[0]` to `value[1]` excluding both bounds',\n            '*[)* keeps items inside `value[0]` to `value[1]` including `value[0]` but excluding `value[1]',\n            '*(]* keeps items inside `value[0]` to `value[1]` excluding `value[0]` but including `value[1]',\n\n            '*][* keeps items outside `value[0]` to `value[1]` and equal to both bounds',\n            '*)(* keeps items outside `value[0]` to `value[1]`',\n            '*](* keeps items outside `value[0]` to `value[1]` and equal to `value[0]`',\n            '*)[* keeps items outside `value[0]` to `value[1]` and equal to `value[1]`',\n\n            '*{}* keeps items present in a set of values',\n            '*}{* keeps items not present in a set of values'\n        ].join(' ')\n    },\n    value: {\n        valType: 'any',\n        dflt: 0,\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Sets the value or values by which to filter.',\n\n            'Values are expected to be in the same type as the data linked',\n            'to `target`.',\n\n            'When `operation` is set to one of',\n            'the comparison values (' + COMPARISON_OPS + ')',\n            '`value` is expected to be a number or a string.',\n\n            'When `operation` is set to one of the interval values',\n            '(' + INTERVAL_OPS + ')',\n            '`value` is expected to be 2-item array where the first item',\n            'is the lower bound and the second item is the upper bound.',\n\n            'When `operation`, is set to one of the set values',\n            '(' + SET_OPS + ')',\n            '`value` is expected to be an array with as many items as',\n            'the desired set elements.'\n        ].join(' ')\n    },\n    preservegaps: {\n        valType: 'boolean',\n        dflt: false,\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'Determines whether or not gaps in data arrays produced by the filter operation',\n            'are preserved.',\n            'Setting this to *true* might be useful when plotting a line chart',\n            'with `connectgaps` set to *false*.'\n        ].join(' ')\n    },\n    editType: 'calc'\n};\n\nexports.supplyDefaults = function(transformIn) {\n    var transformOut = {};\n\n    function coerce(attr, dflt) {\n        return Lib.coerce(transformIn, transformOut, exports.attributes, attr, dflt);\n    }\n\n    var enabled = coerce('enabled');\n\n    if(enabled) {\n        coerce('preservegaps');\n        coerce('operation');\n        coerce('value');\n        coerce('target');\n\n        var handleCalendarDefaults = Registry.getComponentMethod('calendars', 'handleDefaults');\n        handleCalendarDefaults(transformIn, transformOut, 'valuecalendar', null);\n        handleCalendarDefaults(transformIn, transformOut, 'targetcalendar', null);\n    }\n\n    return transformOut;\n};\n\nexports.calcTransform = function(gd, trace, opts) {\n    if(!opts.enabled) return;\n\n    var targetArray = Lib.getTargetArray(trace, opts);\n    if(!targetArray) return;\n\n    var target = opts.target;\n\n    var len = targetArray.length;\n    if(trace._length) len = Math.min(len, trace._length);\n\n    var targetCalendar = opts.targetcalendar;\n    var arrayAttrs = trace._arrayAttrs;\n    var preservegaps = opts.preservegaps;\n\n    // even if you provide targetcalendar, if target is a string and there\n    // is a calendar attribute matching target it will get used instead.\n    if(typeof target === 'string') {\n        var attrTargetCalendar = Lib.nestedProperty(trace, target + 'calendar').get();\n        if(attrTargetCalendar) targetCalendar = attrTargetCalendar;\n    }\n\n    var d2c = Axes.getDataToCoordFunc(gd, trace, target, targetArray);\n    var filterFunc = getFilterFunc(opts, d2c, targetCalendar);\n    var originalArrays = {};\n    var indexToPoints = {};\n    var index = 0;\n\n    function forAllAttrs(fn, index) {\n        for(var j = 0; j < arrayAttrs.length; j++) {\n            var np = Lib.nestedProperty(trace, arrayAttrs[j]);\n            fn(np, index);\n        }\n    }\n\n    var initFn;\n    var fillFn;\n    if(preservegaps) {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set(new Array(len));\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get()[index] = val;\n        };\n    } else {\n        initFn = function(np) {\n            originalArrays[np.astr] = Lib.extendDeep([], np.get());\n            np.set([]);\n        };\n        fillFn = function(np, index) {\n            var val = originalArrays[np.astr][index];\n            np.get().push(val);\n        };\n    }\n\n    // copy all original array attribute values, and clear arrays in trace\n    forAllAttrs(initFn);\n\n    var originalPointsAccessor = pointsAccessorFunction(trace.transforms, opts);\n\n    // loop through filter array, fill trace arrays if passed\n    for(var i = 0; i < len; i++) {\n        var passed = filterFunc(targetArray[i]);\n        if(passed) {\n            forAllAttrs(fillFn, i);\n            indexToPoints[index++] = originalPointsAccessor(i);\n        }\n        else if(preservegaps) index++;\n    }\n\n    opts._indexToPoints = indexToPoints;\n    trace._length = index;\n};\n\nfunction getFilterFunc(opts, d2c, targetCalendar) {\n    var operation = opts.operation;\n    var value = opts.value;\n    var hasArrayValue = Array.isArray(value);\n\n    function isOperationIn(array) {\n        return array.indexOf(operation) !== -1;\n    }\n\n    var d2cValue = function(v) { return d2c(v, 0, opts.valuecalendar); };\n    var d2cTarget = function(v) { return d2c(v, 0, targetCalendar); };\n\n    var coercedValue;\n\n    if(isOperationIn(COMPARISON_OPS)) {\n        coercedValue = hasArrayValue ? d2cValue(value[0]) : d2cValue(value);\n    }\n    else if(isOperationIn(INTERVAL_OPS)) {\n        coercedValue = hasArrayValue ?\n            [d2cValue(value[0]), d2cValue(value[1])] :\n            [d2cValue(value), d2cValue(value)];\n    }\n    else if(isOperationIn(SET_OPS)) {\n        coercedValue = hasArrayValue ? value.map(d2cValue) : [d2cValue(value)];\n    }\n\n    switch(operation) {\n\n        case '=':\n            return function(v) { return d2cTarget(v) === coercedValue; };\n\n        case '!=':\n            return function(v) { return d2cTarget(v) !== coercedValue; };\n\n        case '<':\n            return function(v) { return d2cTarget(v) < coercedValue; };\n\n        case '<=':\n            return function(v) { return d2cTarget(v) <= coercedValue; };\n\n        case '>':\n            return function(v) { return d2cTarget(v) > coercedValue; };\n\n        case '>=':\n            return function(v) { return d2cTarget(v) >= coercedValue; };\n\n        case '[]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '()':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '[)':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv >= coercedValue[0] && cv < coercedValue[1];\n            };\n\n        case '(]':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv > coercedValue[0] && cv <= coercedValue[1];\n            };\n\n        case '][':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case ')(':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case '](':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv <= coercedValue[0] || cv > coercedValue[1];\n            };\n\n        case ')[':\n            return function(v) {\n                var cv = d2cTarget(v);\n                return cv < coercedValue[0] || cv >= coercedValue[1];\n            };\n\n        case '{}':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) !== -1;\n            };\n\n        case '}{':\n            return function(v) {\n                return coercedValue.indexOf(d2cTarget(v)) === -1;\n            };\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}