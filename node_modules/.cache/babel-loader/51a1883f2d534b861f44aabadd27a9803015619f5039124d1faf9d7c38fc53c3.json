{"ast":null,"code":"'use strict';\n\nvar bsearch = require('binary-search-bounds');\nmodule.exports = classifyFaces;\nfunction FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n  this.cells = cells;\n  this.neighbor = neighbor;\n  this.flags = flags;\n  this.constraint = constraint;\n  this.active = active;\n  this.next = next;\n  this.boundary = boundary;\n}\nvar proto = FaceIndex.prototype;\nfunction compareCell(a, b) {\n  return a[0] - b[0] || a[1] - b[1] || a[2] - b[2];\n}\nproto.locate = function () {\n  var key = [0, 0, 0];\n  return function (a, b, c) {\n    var x = a,\n      y = b,\n      z = c;\n    if (b < c) {\n      if (b < a) {\n        x = b;\n        y = c;\n        z = a;\n      }\n    } else if (c < a) {\n      x = c;\n      y = a;\n      z = b;\n    }\n    if (x < 0) {\n      return -1;\n    }\n    key[0] = x;\n    key[1] = y;\n    key[2] = z;\n    return bsearch.eq(this.cells, key, compareCell);\n  };\n}();\nfunction indexCells(triangulation, infinity) {\n  //First get cells and canonicalize\n  var cells = triangulation.cells();\n  var nc = cells.length;\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    var x = c[0],\n      y = c[1],\n      z = c[2];\n    if (y < z) {\n      if (y < x) {\n        c[0] = y;\n        c[1] = z;\n        c[2] = x;\n      }\n    } else if (z < x) {\n      c[0] = z;\n      c[1] = x;\n      c[2] = y;\n    }\n  }\n  cells.sort(compareCell);\n\n  //Initialize flag array\n  var flags = new Array(nc);\n  for (var i = 0; i < flags.length; ++i) {\n    flags[i] = 0;\n  }\n\n  //Build neighbor index, initialize queues\n  var active = [];\n  var next = [];\n  var neighbor = new Array(3 * nc);\n  var constraint = new Array(3 * nc);\n  var boundary = null;\n  if (infinity) {\n    boundary = [];\n  }\n  var index = new FaceIndex(cells, neighbor, constraint, flags, active, next, boundary);\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    for (var j = 0; j < 3; ++j) {\n      var x = c[j],\n        y = c[(j + 1) % 3];\n      var a = neighbor[3 * i + j] = index.locate(y, x, triangulation.opposite(y, x));\n      var b = constraint[3 * i + j] = triangulation.isConstraint(x, y);\n      if (a < 0) {\n        if (b) {\n          next.push(i);\n        } else {\n          active.push(i);\n          flags[i] = 1;\n        }\n        if (infinity) {\n          boundary.push([y, x, -1]);\n        }\n      }\n    }\n  }\n  return index;\n}\nfunction filterCells(cells, flags, target) {\n  var ptr = 0;\n  for (var i = 0; i < cells.length; ++i) {\n    if (flags[i] === target) {\n      cells[ptr++] = cells[i];\n    }\n  }\n  cells.length = ptr;\n  return cells;\n}\nfunction classifyFaces(triangulation, target, infinity) {\n  var index = indexCells(triangulation, infinity);\n  if (target === 0) {\n    if (infinity) {\n      return index.cells.concat(index.boundary);\n    } else {\n      return index.cells;\n    }\n  }\n  var side = 1;\n  var active = index.active;\n  var next = index.next;\n  var flags = index.flags;\n  var cells = index.cells;\n  var constraint = index.constraint;\n  var neighbor = index.neighbor;\n  while (active.length > 0 || next.length > 0) {\n    while (active.length > 0) {\n      var t = active.pop();\n      if (flags[t] === -side) {\n        continue;\n      }\n      flags[t] = side;\n      var c = cells[t];\n      for (var j = 0; j < 3; ++j) {\n        var f = neighbor[3 * t + j];\n        if (f >= 0 && flags[f] === 0) {\n          if (constraint[3 * t + j]) {\n            next.push(f);\n          } else {\n            active.push(f);\n            flags[f] = side;\n          }\n        }\n      }\n    }\n\n    //Swap arrays and loop\n    var tmp = next;\n    next = active;\n    active = tmp;\n    next.length = 0;\n    side = -side;\n  }\n  var result = filterCells(cells, flags, target);\n  if (infinity) {\n    return result.concat(index.boundary);\n  }\n  return result;\n}","map":{"version":3,"names":["bsearch","require","module","exports","classifyFaces","FaceIndex","cells","neighbor","constraint","flags","active","next","boundary","proto","prototype","compareCell","a","b","locate","key","c","x","y","z","eq","indexCells","triangulation","infinity","nc","length","i","sort","Array","index","j","opposite","isConstraint","push","filterCells","target","ptr","concat","side","t","pop","f","tmp","result"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/cdt2d/lib/filter.js"],"sourcesContent":["'use strict'\n\nvar bsearch = require('binary-search-bounds')\n\nmodule.exports = classifyFaces\n\nfunction FaceIndex(cells, neighbor, constraint, flags, active, next, boundary) {\n  this.cells       = cells\n  this.neighbor    = neighbor\n  this.flags       = flags\n  this.constraint  = constraint\n  this.active      = active\n  this.next        = next\n  this.boundary    = boundary\n}\n\nvar proto = FaceIndex.prototype\n\nfunction compareCell(a, b) {\n  return a[0] - b[0] ||\n         a[1] - b[1] ||\n         a[2] - b[2]\n}\n\nproto.locate = (function() {\n  var key = [0,0,0]\n  return function(a, b, c) {\n    var x = a, y = b, z = c\n    if(b < c) {\n      if(b < a) {\n        x = b\n        y = c\n        z = a\n      }\n    } else if(c < a) {\n      x = c\n      y = a\n      z = b\n    }\n    if(x < 0) {\n      return -1\n    }\n    key[0] = x\n    key[1] = y\n    key[2] = z\n    return bsearch.eq(this.cells, key, compareCell)\n  }\n})()\n\nfunction indexCells(triangulation, infinity) {\n  //First get cells and canonicalize\n  var cells = triangulation.cells()\n  var nc = cells.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    var x = c[0], y = c[1], z = c[2]\n    if(y < z) {\n      if(y < x) {\n        c[0] = y\n        c[1] = z\n        c[2] = x\n      }\n    } else if(z < x) {\n      c[0] = z\n      c[1] = x\n      c[2] = y\n    }\n  }\n  cells.sort(compareCell)\n\n  //Initialize flag array\n  var flags = new Array(nc)\n  for(var i=0; i<flags.length; ++i) {\n    flags[i] = 0\n  }\n\n  //Build neighbor index, initialize queues\n  var active = []\n  var next   = []\n  var neighbor = new Array(3*nc)\n  var constraint = new Array(3*nc)\n  var boundary = null\n  if(infinity) {\n    boundary = []\n  }\n  var index = new FaceIndex(\n    cells,\n    neighbor,\n    constraint,\n    flags,\n    active,\n    next,\n    boundary)\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    for(var j=0; j<3; ++j) {\n      var x = c[j], y = c[(j+1)%3]\n      var a = neighbor[3*i+j] = index.locate(y, x, triangulation.opposite(y, x))\n      var b = constraint[3*i+j] = triangulation.isConstraint(x, y)\n      if(a < 0) {\n        if(b) {\n          next.push(i)\n        } else {\n          active.push(i)\n          flags[i] = 1\n        }\n        if(infinity) {\n          boundary.push([y, x, -1])\n        }\n      }\n    }\n  }\n  return index\n}\n\nfunction filterCells(cells, flags, target) {\n  var ptr = 0\n  for(var i=0; i<cells.length; ++i) {\n    if(flags[i] === target) {\n      cells[ptr++] = cells[i]\n    }\n  }\n  cells.length = ptr\n  return cells\n}\n\nfunction classifyFaces(triangulation, target, infinity) {\n  var index = indexCells(triangulation, infinity)\n\n  if(target === 0) {\n    if(infinity) {\n      return index.cells.concat(index.boundary)\n    } else {\n      return index.cells\n    }\n  }\n\n  var side = 1\n  var active = index.active\n  var next = index.next\n  var flags = index.flags\n  var cells = index.cells\n  var constraint = index.constraint\n  var neighbor = index.neighbor\n\n  while(active.length > 0 || next.length > 0) {\n    while(active.length > 0) {\n      var t = active.pop()\n      if(flags[t] === -side) {\n        continue\n      }\n      flags[t] = side\n      var c = cells[t]\n      for(var j=0; j<3; ++j) {\n        var f = neighbor[3*t+j]\n        if(f >= 0 && flags[f] === 0) {\n          if(constraint[3*t+j]) {\n            next.push(f)\n          } else {\n            active.push(f)\n            flags[f] = side\n          }\n        }\n      }\n    }\n\n    //Swap arrays and loop\n    var tmp = next\n    next = active\n    active = tmp\n    next.length = 0\n    side = -side\n  }\n\n  var result = filterCells(cells, flags, target)\n  if(infinity) {\n    return result.concat(index.boundary)\n  }\n  return result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}