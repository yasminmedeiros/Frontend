{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar boxCalc = require('../box/calc');\nvar helpers = require('./helpers');\nvar BADNUM = require('../../constants/numerical').BADNUM;\nmodule.exports = function calc(gd, trace) {\n  var cd = boxCalc(gd, trace);\n  if (cd[0].t.empty) return cd;\n  var fullLayout = gd._fullLayout;\n  var valAxis = Axes.getFromId(gd, trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']);\n  var spanMin = Infinity;\n  var spanMax = -Infinity;\n  var maxKDE = 0;\n  var maxCount = 0;\n  for (var i = 0; i < cd.length; i++) {\n    var cdi = cd[i];\n    var vals = cdi.pts.map(helpers.extractVal);\n    var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n    var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n    // step that well covers the bandwidth and is multiple of span distance\n    var dist = span[1] - span[0];\n    var n = Math.ceil(dist / (bandwidth / 3));\n    var step = dist / n;\n    if (!isFinite(step) || !isFinite(n)) {\n      Lib.error('Something went wrong with computing the violin span');\n      cd[0].t.empty = true;\n      return cd;\n    }\n    var kde = helpers.makeKDE(cdi, trace, vals);\n    cdi.density = new Array(n);\n    for (var k = 0, t = span[0]; t < span[1] + step / 2; k++, t += step) {\n      var v = kde(t);\n      cdi.density[k] = {\n        v: v,\n        t: t\n      };\n      maxKDE = Math.max(maxKDE, v);\n    }\n    maxCount = Math.max(maxCount, vals.length);\n    spanMin = Math.min(spanMin, span[0]);\n    spanMax = Math.max(spanMax, span[1]);\n  }\n  var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {\n    padded: true\n  });\n  trace._extremes[valAxis._id] = extremes;\n  if (trace.width) {\n    cd[0].t.maxKDE = maxKDE;\n  } else {\n    var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n    var scaleGroup = trace.scalegroup;\n    var groupStats = violinScaleGroupStats[scaleGroup];\n    if (groupStats) {\n      groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n      groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n    } else {\n      violinScaleGroupStats[scaleGroup] = {\n        maxKDE: maxKDE,\n        maxCount: maxCount\n      };\n    }\n  }\n  cd[0].t.labels.kde = Lib._(gd, 'kde:');\n  return cd;\n};\n\n// Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\nfunction silvermanRule(len, ssd, iqr) {\n  var a = Math.min(ssd, iqr / 1.349);\n  return 1.059 * a * Math.pow(len, -0.2);\n}\nfunction calcBandwidth(trace, cdi, vals) {\n  var span = cdi.max - cdi.min;\n\n  // plot single-value violin with bandwidth of 1\n  if (!span) return 1;\n\n  // Limit how small the bandwidth can be.\n  //\n  // Silverman's rule of thumb can be \"very\" small\n  // when IQR does a poor job at describing the spread\n  // of the distribution.\n  // We also want to limit custom bandwidths\n  // to not blow up kde computations.\n\n  if (trace.bandwidth) {\n    return Math.max(trace.bandwidth, span / 1e4);\n  } else {\n    var len = vals.length;\n    var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n    return Math.max(silvermanRule(len, ssd, cdi.q3 - cdi.q1), span / 100);\n  }\n}\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n  var spanmode = trace.spanmode;\n  var spanIn = trace.span || [];\n  var spanTight = [cdi.min, cdi.max];\n  var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n  var spanOut;\n  function calcSpanItem(index) {\n    var s = spanIn[index];\n    var sc = valAxis.type === 'multicategory' ? valAxis.r2c(s) : valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n    return sc === BADNUM ? spanLoose[index] : sc;\n  }\n  if (spanmode === 'soft') {\n    spanOut = spanLoose;\n  } else if (spanmode === 'hard') {\n    spanOut = spanTight;\n  } else {\n    spanOut = [calcSpanItem(0), calcSpanItem(1)];\n  }\n\n  // to reuse the equal-range-item block\n  var dummyAx = {\n    type: 'linear',\n    range: spanOut\n  };\n  Axes.setConvert(dummyAx);\n  dummyAx.cleanRange();\n  return spanOut;\n}","map":{"version":3,"names":["Lib","require","Axes","boxCalc","helpers","BADNUM","module","exports","calc","gd","trace","cd","t","empty","fullLayout","_fullLayout","valAxis","getFromId","orientation","spanMin","Infinity","spanMax","maxKDE","maxCount","i","length","cdi","vals","pts","map","extractVal","bandwidth","calcBandwidth","span","calcSpan","dist","n","Math","ceil","step","isFinite","error","kde","makeKDE","density","Array","k","v","max","min","extremes","findExtremes","padded","_extremes","_id","width","violinScaleGroupStats","_violinScaleGroupStats","scaleGroup","scalegroup","groupStats","labels","_","silvermanRule","len","ssd","iqr","a","pow","stdev","mean","q3","q1","spanmode","spanIn","spanTight","spanLoose","spanOut","calcSpanItem","index","s","sc","type","r2c","d2c","valLetter","dummyAx","range","setConvert","cleanRange"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/violin/calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar Axes = require('../../plots/cartesian/axes');\nvar boxCalc = require('../box/calc');\nvar helpers = require('./helpers');\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nmodule.exports = function calc(gd, trace) {\n    var cd = boxCalc(gd, trace);\n\n    if(cd[0].t.empty) return cd;\n\n    var fullLayout = gd._fullLayout;\n    var valAxis = Axes.getFromId(\n        gd,\n        trace[trace.orientation === 'h' ? 'xaxis' : 'yaxis']\n    );\n\n    var spanMin = Infinity;\n    var spanMax = -Infinity;\n    var maxKDE = 0;\n    var maxCount = 0;\n\n    for(var i = 0; i < cd.length; i++) {\n        var cdi = cd[i];\n        var vals = cdi.pts.map(helpers.extractVal);\n\n        var bandwidth = cdi.bandwidth = calcBandwidth(trace, cdi, vals);\n        var span = cdi.span = calcSpan(trace, cdi, valAxis, bandwidth);\n\n        // step that well covers the bandwidth and is multiple of span distance\n        var dist = span[1] - span[0];\n        var n = Math.ceil(dist / (bandwidth / 3));\n        var step = dist / n;\n\n        if(!isFinite(step) || !isFinite(n)) {\n            Lib.error('Something went wrong with computing the violin span');\n            cd[0].t.empty = true;\n            return cd;\n        }\n\n        var kde = helpers.makeKDE(cdi, trace, vals);\n        cdi.density = new Array(n);\n\n        for(var k = 0, t = span[0]; t < (span[1] + step / 2); k++, t += step) {\n            var v = kde(t);\n            cdi.density[k] = {v: v, t: t};\n            maxKDE = Math.max(maxKDE, v);\n        }\n\n        maxCount = Math.max(maxCount, vals.length);\n        spanMin = Math.min(spanMin, span[0]);\n        spanMax = Math.max(spanMax, span[1]);\n    }\n\n    var extremes = Axes.findExtremes(valAxis, [spanMin, spanMax], {padded: true});\n    trace._extremes[valAxis._id] = extremes;\n\n    if(trace.width) {\n        cd[0].t.maxKDE = maxKDE;\n    } else {\n        var violinScaleGroupStats = fullLayout._violinScaleGroupStats;\n        var scaleGroup = trace.scalegroup;\n        var groupStats = violinScaleGroupStats[scaleGroup];\n\n        if(groupStats) {\n            groupStats.maxKDE = Math.max(groupStats.maxKDE, maxKDE);\n            groupStats.maxCount = Math.max(groupStats.maxCount, maxCount);\n        } else {\n            violinScaleGroupStats[scaleGroup] = {\n                maxKDE: maxKDE,\n                maxCount: maxCount\n            };\n        }\n    }\n\n    cd[0].t.labels.kde = Lib._(gd, 'kde:');\n\n    return cd;\n};\n\n// Default to Silveman's rule of thumb\n// - https://stats.stackexchange.com/a/6671\n// - https://en.wikipedia.org/wiki/Kernel_density_estimation#A_rule-of-thumb_bandwidth_estimator\n// - https://github.com/statsmodels/statsmodels/blob/master/statsmodels/nonparametric/bandwidths.py\nfunction silvermanRule(len, ssd, iqr) {\n    var a = Math.min(ssd, iqr / 1.349);\n    return 1.059 * a * Math.pow(len, -0.2);\n}\n\nfunction calcBandwidth(trace, cdi, vals) {\n    var span = cdi.max - cdi.min;\n\n    // plot single-value violin with bandwidth of 1\n    if(!span) return 1;\n\n    // Limit how small the bandwidth can be.\n    //\n    // Silverman's rule of thumb can be \"very\" small\n    // when IQR does a poor job at describing the spread\n    // of the distribution.\n    // We also want to limit custom bandwidths\n    // to not blow up kde computations.\n\n    if(trace.bandwidth) {\n        return Math.max(trace.bandwidth, span / 1e4);\n    } else {\n        var len = vals.length;\n        var ssd = Lib.stdev(vals, len - 1, cdi.mean);\n        return Math.max(\n            silvermanRule(len, ssd, cdi.q3 - cdi.q1),\n            span / 100\n        );\n    }\n}\n\nfunction calcSpan(trace, cdi, valAxis, bandwidth) {\n    var spanmode = trace.spanmode;\n    var spanIn = trace.span || [];\n    var spanTight = [cdi.min, cdi.max];\n    var spanLoose = [cdi.min - 2 * bandwidth, cdi.max + 2 * bandwidth];\n    var spanOut;\n\n    function calcSpanItem(index) {\n        var s = spanIn[index];\n        var sc = valAxis.type === 'multicategory' ?\n            valAxis.r2c(s) :\n            valAxis.d2c(s, 0, trace[cdi.valLetter + 'calendar']);\n        return sc === BADNUM ? spanLoose[index] : sc;\n    }\n\n    if(spanmode === 'soft') {\n        spanOut = spanLoose;\n    } else if(spanmode === 'hard') {\n        spanOut = spanTight;\n    } else {\n        spanOut = [calcSpanItem(0), calcSpanItem(1)];\n    }\n\n    // to reuse the equal-range-item block\n    var dummyAx = {\n        type: 'linear',\n        range: spanOut\n    };\n    Axes.setConvert(dummyAx);\n    dummyAx.cleanRange();\n\n    return spanOut;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}