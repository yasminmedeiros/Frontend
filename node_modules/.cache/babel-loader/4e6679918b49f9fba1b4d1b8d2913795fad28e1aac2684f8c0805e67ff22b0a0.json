{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\nvar extendFlat = require('../../lib/extend').extendFlat;\nvar scatterMarkerAttrs = scatterAttrs.marker;\nvar scatterLineAttrs = scatterAttrs.line;\nvar scatterMarkerLineAttrs = scatterMarkerAttrs.line;\nmodule.exports = {\n  carpet: {\n    valType: 'string',\n    role: 'info',\n    editType: 'calc',\n    description: ['An identifier for this carpet, so that `scattercarpet` and', '`scattercontour` traces can specify a carpet plot on which', 'they lie'].join(' ')\n  },\n  a: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['Sets the quantity of component `a` in each data point.', 'If `a`, `b`, and `c` are all provided, they need not be', 'normalized, only the relative values matter. If only two', 'arrays are provided they must be normalized to match', '`ternary<i>.sum`.'].join(' ')\n  },\n  b: {\n    valType: 'data_array',\n    editType: 'calc',\n    description: ['Sets the quantity of component `a` in each data point.', 'If `a`, `b`, and `c` are all provided, they need not be', 'normalized, only the relative values matter. If only two', 'arrays are provided they must be normalized to match', '`ternary<i>.sum`.'].join(' ')\n  },\n  mode: extendFlat({}, scatterAttrs.mode, {\n    dflt: 'markers'\n  }),\n  text: extendFlat({}, scatterAttrs.text, {\n    description: ['Sets text elements associated with each (a,b,c) point.', 'If a single string, the same string appears over', 'all the data points.', 'If an array of strings, the items are mapped in order to the', 'the data points in (a,b,c).'].join(' ')\n  }),\n  line: {\n    color: scatterLineAttrs.color,\n    width: scatterLineAttrs.width,\n    dash: scatterLineAttrs.dash,\n    shape: extendFlat({}, scatterLineAttrs.shape, {\n      values: ['linear', 'spline']\n    }),\n    smoothing: scatterLineAttrs.smoothing,\n    editType: 'calc'\n  },\n  connectgaps: scatterAttrs.connectgaps,\n  fill: extendFlat({}, scatterAttrs.fill, {\n    values: ['none', 'toself', 'tonext'],\n    dflt: 'none',\n    description: ['Sets the area to fill with a solid color.', 'Use with `fillcolor` if not *none*.', 'scatterternary has a subset of the options available to scatter.', '*toself* connects the endpoints of the trace (or each segment', 'of the trace if it has gaps) into a closed shape.', '*tonext* fills the space between two traces if one completely', 'encloses the other (eg consecutive contour lines), and behaves like', '*toself* if there is no trace before it. *tonext* should not be', 'used if one trace does not enclose the other.'].join(' ')\n  }),\n  fillcolor: scatterAttrs.fillcolor,\n  marker: extendFlat({\n    symbol: scatterMarkerAttrs.symbol,\n    opacity: scatterMarkerAttrs.opacity,\n    maxdisplayed: scatterMarkerAttrs.maxdisplayed,\n    size: scatterMarkerAttrs.size,\n    sizeref: scatterMarkerAttrs.sizeref,\n    sizemin: scatterMarkerAttrs.sizemin,\n    sizemode: scatterMarkerAttrs.sizemode,\n    line: extendFlat({\n      width: scatterMarkerLineAttrs.width,\n      editType: 'calc'\n    }, colorAttributes('marker.line')),\n    gradient: scatterMarkerAttrs.gradient,\n    editType: 'calc'\n  }, colorAttributes('marker'), {\n    colorbar: colorbarAttrs\n  }),\n  textfont: scatterAttrs.textfont,\n  textposition: scatterAttrs.textposition,\n  selected: scatterAttrs.selected,\n  unselected: scatterAttrs.unselected,\n  hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n    flags: ['a', 'b', 'text', 'name']\n  }),\n  hoveron: scatterAttrs.hoveron\n};","map":{"version":3,"names":["scatterAttrs","require","plotAttrs","colorAttributes","colorbarAttrs","extendFlat","scatterMarkerAttrs","marker","scatterLineAttrs","line","scatterMarkerLineAttrs","module","exports","carpet","valType","role","editType","description","join","a","b","mode","dflt","text","color","width","dash","shape","values","smoothing","connectgaps","fill","fillcolor","symbol","opacity","maxdisplayed","size","sizeref","sizemin","sizemode","gradient","colorbar","textfont","textposition","selected","unselected","hoverinfo","flags","hoveron"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/scattercarpet/attributes.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterAttrs = require('../scatter/attributes');\nvar plotAttrs = require('../../plots/attributes');\nvar colorAttributes = require('../../components/colorscale/attributes');\nvar colorbarAttrs = require('../../components/colorbar/attributes');\n\nvar extendFlat = require('../../lib/extend').extendFlat;\n\nvar scatterMarkerAttrs = scatterAttrs.marker;\nvar scatterLineAttrs = scatterAttrs.line;\nvar scatterMarkerLineAttrs = scatterMarkerAttrs.line;\n\nmodule.exports = {\n    carpet: {\n        valType: 'string',\n        role: 'info',\n        editType: 'calc',\n        description: [\n            'An identifier for this carpet, so that `scattercarpet` and',\n            '`scattercontour` traces can specify a carpet plot on which',\n            'they lie'\n        ].join(' ')\n    },\n    a: {\n        valType: 'data_array',\n        editType: 'calc',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    b: {\n        valType: 'data_array',\n        editType: 'calc',\n        description: [\n            'Sets the quantity of component `a` in each data point.',\n            'If `a`, `b`, and `c` are all provided, they need not be',\n            'normalized, only the relative values matter. If only two',\n            'arrays are provided they must be normalized to match',\n            '`ternary<i>.sum`.'\n        ].join(' ')\n    },\n    mode: extendFlat({}, scatterAttrs.mode, {dflt: 'markers'}),\n    text: extendFlat({}, scatterAttrs.text, {\n        description: [\n            'Sets text elements associated with each (a,b,c) point.',\n            'If a single string, the same string appears over',\n            'all the data points.',\n            'If an array of strings, the items are mapped in order to the',\n            'the data points in (a,b,c).'\n        ].join(' ')\n    }),\n    line: {\n        color: scatterLineAttrs.color,\n        width: scatterLineAttrs.width,\n        dash: scatterLineAttrs.dash,\n        shape: extendFlat({}, scatterLineAttrs.shape,\n            {values: ['linear', 'spline']}),\n        smoothing: scatterLineAttrs.smoothing,\n        editType: 'calc'\n    },\n    connectgaps: scatterAttrs.connectgaps,\n    fill: extendFlat({}, scatterAttrs.fill, {\n        values: ['none', 'toself', 'tonext'],\n        dflt: 'none',\n        description: [\n            'Sets the area to fill with a solid color.',\n            'Use with `fillcolor` if not *none*.',\n            'scatterternary has a subset of the options available to scatter.',\n            '*toself* connects the endpoints of the trace (or each segment',\n            'of the trace if it has gaps) into a closed shape.',\n            '*tonext* fills the space between two traces if one completely',\n            'encloses the other (eg consecutive contour lines), and behaves like',\n            '*toself* if there is no trace before it. *tonext* should not be',\n            'used if one trace does not enclose the other.'\n        ].join(' ')\n    }),\n    fillcolor: scatterAttrs.fillcolor,\n    marker: extendFlat({\n        symbol: scatterMarkerAttrs.symbol,\n        opacity: scatterMarkerAttrs.opacity,\n        maxdisplayed: scatterMarkerAttrs.maxdisplayed,\n        size: scatterMarkerAttrs.size,\n        sizeref: scatterMarkerAttrs.sizeref,\n        sizemin: scatterMarkerAttrs.sizemin,\n        sizemode: scatterMarkerAttrs.sizemode,\n        line: extendFlat({\n            width: scatterMarkerLineAttrs.width,\n            editType: 'calc'\n        },\n            colorAttributes('marker.line')\n        ),\n        gradient: scatterMarkerAttrs.gradient,\n        editType: 'calc'\n    }, colorAttributes('marker'), {\n        colorbar: colorbarAttrs\n    }),\n\n    textfont: scatterAttrs.textfont,\n    textposition: scatterAttrs.textposition,\n\n    selected: scatterAttrs.selected,\n    unselected: scatterAttrs.unselected,\n\n    hoverinfo: extendFlat({}, plotAttrs.hoverinfo, {\n        flags: ['a', 'b', 'text', 'name']\n    }),\n    hoveron: scatterAttrs.hoveron,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}