{"ast":null,"code":"\"use strict\";\n\nmodule.exports = axesProperties;\nvar getPlanes = require(\"extract-frustum-planes\");\nvar splitPoly = require(\"split-polygon\");\nvar cubeParams = require(\"./lib/cube.js\");\nvar m4mul = require(\"gl-mat4/multiply\");\nvar m4transpose = require(\"gl-mat4/transpose\");\nvar v4transformMat4 = require(\"gl-vec4/transformMat4\");\nvar identity = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\nvar mvp = new Float32Array(16);\nfunction AxesRange3D(lo, hi, pixelsPerDataUnit) {\n  this.lo = lo;\n  this.hi = hi;\n  this.pixelsPerDataUnit = pixelsPerDataUnit;\n}\nvar SCRATCH_P = [0, 0, 0, 1];\nvar SCRATCH_Q = [0, 0, 0, 1];\nfunction gradient(result, M, v, width, height) {\n  for (var i = 0; i < 3; ++i) {\n    var p = SCRATCH_P;\n    var q = SCRATCH_Q;\n    for (var j = 0; j < 3; ++j) {\n      q[j] = p[j] = v[j];\n    }\n    q[3] = p[3] = 1;\n    q[i] += 1;\n    v4transformMat4(q, q, M);\n    if (q[3] < 0) {\n      result[i] = Infinity;\n    }\n    p[i] -= 1;\n    v4transformMat4(p, p, M);\n    if (p[3] < 0) {\n      result[i] = Infinity;\n    }\n    var dx = (p[0] / p[3] - q[0] / q[3]) * width;\n    var dy = (p[1] / p[3] - q[1] / q[3]) * height;\n    result[i] = 0.25 * Math.sqrt(dx * dx + dy * dy);\n  }\n  return result;\n}\nvar RANGES = [new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity), new AxesRange3D(Infinity, -Infinity, Infinity)];\nvar SCRATCH_X = [0, 0, 0];\nfunction axesProperties(axes, camera, width, height, params) {\n  var model = camera.model || identity;\n  var view = camera.view || identity;\n  var projection = camera.projection || identity;\n  var isOrtho = camera._ortho || false;\n  var bounds = axes.bounds;\n  var params = params || cubeParams(model, view, projection, bounds, isOrtho);\n  var axis = params.axis;\n  m4mul(mvp, view, model);\n  m4mul(mvp, projection, mvp);\n\n  //Calculate the following properties for each axis:\n  //\n  // * lo - start of visible range for each axis in tick coordinates\n  // * hi - end of visible range for each axis in tick coordinates\n  // * ticksPerPixel - pixel density of tick marks for the axis\n  //\n  var ranges = RANGES;\n  for (var i = 0; i < 3; ++i) {\n    ranges[i].lo = Infinity;\n    ranges[i].hi = -Infinity;\n    ranges[i].pixelsPerDataUnit = Infinity;\n  }\n\n  //Compute frustum planes, intersect with box\n  var frustum = getPlanes(m4transpose(mvp, mvp));\n  m4transpose(mvp, mvp);\n\n  //Loop over vertices of viewable box\n  for (var d = 0; d < 3; ++d) {\n    var u = (d + 1) % 3;\n    var v = (d + 2) % 3;\n    var x = SCRATCH_X;\n    i_loop: for (var i = 0; i < 2; ++i) {\n      var poly = [];\n      if (axis[d] < 0 === !!i) {\n        continue;\n      }\n      x[d] = bounds[i][d];\n      for (var j = 0; j < 2; ++j) {\n        x[u] = bounds[j ^ i][u];\n        for (var k = 0; k < 2; ++k) {\n          x[v] = bounds[k ^ j ^ i][v];\n          poly.push(x.slice());\n        }\n      }\n      var Q = isOrtho ? 5 : 4;\n      for (var j = Q; j === Q; ++j) {\n        // Note: using only near plane here (& for orthographic projection we use the far).\n        if (poly.length === 0) {\n          continue i_loop;\n        }\n        poly = splitPoly.positive(poly, frustum[j]);\n      }\n\n      //Loop over vertices of polygon to find extremal points\n      for (var j = 0; j < poly.length; ++j) {\n        var v = poly[j];\n        var grad = gradient(SCRATCH_X, mvp, v, width, height);\n        for (var k = 0; k < 3; ++k) {\n          ranges[k].lo = Math.min(ranges[k].lo, v[k]);\n          ranges[k].hi = Math.max(ranges[k].hi, v[k]);\n          if (k !== d) {\n            ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]));\n          }\n        }\n      }\n    }\n  }\n  return ranges;\n}","map":{"version":3,"names":["module","exports","axesProperties","getPlanes","require","splitPoly","cubeParams","m4mul","m4transpose","v4transformMat4","identity","Float32Array","mvp","AxesRange3D","lo","hi","pixelsPerDataUnit","SCRATCH_P","SCRATCH_Q","gradient","result","M","v","width","height","i","p","q","j","Infinity","dx","dy","Math","sqrt","RANGES","SCRATCH_X","axes","camera","params","model","view","projection","isOrtho","_ortho","bounds","axis","ranges","frustum","d","u","x","i_loop","poly","k","push","slice","Q","length","positive","grad","min","max","abs"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/gl-axes3d/properties.js"],"sourcesContent":["\"use strict\"\n\nmodule.exports = axesProperties\n\nvar getPlanes   = require(\"extract-frustum-planes\")\nvar splitPoly   = require(\"split-polygon\")\nvar cubeParams  = require(\"./lib/cube.js\")\nvar m4mul       = require(\"gl-mat4/multiply\")\nvar m4transpose = require(\"gl-mat4/transpose\")\nvar v4transformMat4 = require(\"gl-vec4/transformMat4\")\n\nvar identity    = new Float32Array([\n    1, 0, 0, 0,\n    0, 1, 0, 0,\n    0, 0, 1, 0,\n    0, 0, 0, 1\n  ])\n\nvar mvp         = new Float32Array(16)\n\nfunction AxesRange3D(lo, hi, pixelsPerDataUnit) {\n  this.lo = lo\n  this.hi = hi\n  this.pixelsPerDataUnit = pixelsPerDataUnit\n}\n\nvar SCRATCH_P = [0,0,0,1]\nvar SCRATCH_Q = [0,0,0,1]\n\nfunction gradient(result, M, v, width, height) {\n  for(var i=0; i<3; ++i) {\n    var p = SCRATCH_P\n    var q = SCRATCH_Q\n    for(var j=0; j<3; ++j) {\n      q[j] = p[j] = v[j]\n    }\n    q[3] = p[3] = 1\n\n    q[i] += 1\n    v4transformMat4(q, q, M)\n    if(q[3] < 0) {\n      result[i] = Infinity\n    }\n\n    p[i] -= 1\n    v4transformMat4(p, p, M)\n    if(p[3] < 0) {\n      result[i] = Infinity\n    }\n\n    var dx = (p[0]/p[3] - q[0]/q[3]) * width\n    var dy = (p[1]/p[3] - q[1]/q[3]) * height\n\n    result[i] = 0.25 * Math.sqrt(dx*dx + dy*dy)\n  }\n  return result\n}\n\nvar RANGES = [\n  new AxesRange3D(Infinity, -Infinity, Infinity),\n  new AxesRange3D(Infinity, -Infinity, Infinity),\n  new AxesRange3D(Infinity, -Infinity, Infinity)\n]\n\nvar SCRATCH_X = [0,0,0]\n\nfunction axesProperties(axes, camera, width, height, params) {\n  var model       = camera.model || identity\n  var view        = camera.view || identity\n  var projection  = camera.projection || identity\n  var isOrtho     = camera._ortho || false\n  var bounds      = axes.bounds\n  var params      = params || cubeParams(model, view, projection, bounds, isOrtho)\n  var axis        = params.axis\n\n  m4mul(mvp, view, model)\n  m4mul(mvp, projection, mvp)\n\n  //Calculate the following properties for each axis:\n  //\n  // * lo - start of visible range for each axis in tick coordinates\n  // * hi - end of visible range for each axis in tick coordinates\n  // * ticksPerPixel - pixel density of tick marks for the axis\n  //\n  var ranges = RANGES\n  for(var i=0; i<3; ++i) {\n    ranges[i].lo = Infinity\n    ranges[i].hi = -Infinity\n    ranges[i].pixelsPerDataUnit = Infinity\n  }\n\n  //Compute frustum planes, intersect with box\n  var frustum = getPlanes(m4transpose(mvp, mvp))\n  m4transpose(mvp, mvp)\n\n  //Loop over vertices of viewable box\n  for(var d=0; d<3; ++d) {\n    var u = (d+1)%3\n    var v = (d+2)%3\n    var x = SCRATCH_X\ni_loop:\n    for(var i=0; i<2; ++i) {\n      var poly = []\n\n      if((axis[d] < 0) === !!i) {\n        continue\n      }\n\n      x[d] = bounds[i][d]\n      for(var j=0; j<2; ++j) {\n        x[u] = bounds[j^i][u]\n        for(var k=0; k<2; ++k) {\n          x[v] = bounds[k^j^i][v]\n          poly.push(x.slice())\n        }\n      }\n\n      var Q = (isOrtho) ? 5 : 4\n      for(var j=Q; j===Q; ++j) { // Note: using only near plane here (& for orthographic projection we use the far).\n        if(poly.length === 0) {\n          continue i_loop\n        }\n        poly = splitPoly.positive(poly, frustum[j])\n      }\n\n      //Loop over vertices of polygon to find extremal points\n      for(var j=0; j<poly.length; ++j) {\n        var v = poly[j]\n        var grad = gradient(SCRATCH_X, mvp, v, width, height)\n        for(var k=0; k<3; ++k) {\n          ranges[k].lo = Math.min(ranges[k].lo, v[k])\n          ranges[k].hi = Math.max(ranges[k].hi, v[k])\n          if(k !== d) {\n            ranges[k].pixelsPerDataUnit = Math.min(ranges[k].pixelsPerDataUnit, Math.abs(grad[k]))\n          }\n        }\n      }\n    }\n  }\n\n  return ranges\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}