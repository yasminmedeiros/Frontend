{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\nvar fillHoverText = require('../scatter/fill_hover_text');\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isClosest = hovermode === 'closest';\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var maxSpikeDistance = pointData.maxSpikeDistance;\n  var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n  function thisBarMinPos(di) {\n    return di[posLetter] - di.w / 2;\n  }\n  function thisBarMaxPos(di) {\n    return di[posLetter] + di.w / 2;\n  }\n  var minPos = isClosest ? thisBarMinPos : function (di) {\n    /*\n     * In compare mode, accept a bar if you're on it *or* its group.\n     * Nearly always it's the group that matters, but in case the bar\n     * was explicitly set wider than its group we'd better accept the\n     * whole bar.\n     *\n     * use `bardelta` instead of `bargroupwidth` so we accept hover\n     * in the gap. That way hover doesn't flash on and off as you\n     * mouse over the plot in compare modes.\n     * In 'closest' mode though the flashing seems inevitable,\n     * without far more complex logic\n     */\n    return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n  };\n  var maxPos = isClosest ? thisBarMaxPos : function (di) {\n    return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n  };\n  function _positionFn(_minPos, _maxPos) {\n    // add a little to the pseudo-distance for wider bars, so that like scatter,\n    // if you are over two overlapping bars, the narrower one wins.\n    return Fx.inbox(_minPos - posVal, _maxPos - posVal, maxHoverDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n  }\n  function positionFn(di) {\n    return _positionFn(minPos(di), maxPos(di));\n  }\n  function thisBarPositionFn(di) {\n    return _positionFn(thisBarMinPos(di), thisBarMaxPos(di));\n  }\n  function sizeFn(di) {\n    // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n    return Fx.inbox(di.b - sizeVal, di[sizeLetter] - sizeVal, maxHoverDistance + (di[sizeLetter] - sizeVal) / (di[sizeLetter] - di.b) - 1);\n  }\n  if (trace.orientation === 'h') {\n    posVal = yval;\n    sizeVal = xval;\n    posLetter = 'y';\n    sizeLetter = 'x';\n    dx = sizeFn;\n    dy = positionFn;\n  } else {\n    posVal = xval;\n    sizeVal = yval;\n    posLetter = 'x';\n    sizeLetter = 'y';\n    dy = sizeFn;\n    dx = positionFn;\n  }\n  var pa = pointData[posLetter + 'a'];\n  var sa = pointData[sizeLetter + 'a'];\n  pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData);\n\n  // skip the rest (for this trace) if we didn't find a close point\n  if (pointData.index === false) return;\n\n  // if we get here and we're not in 'closest' mode, push min/max pos back\n  // onto the group - even though that means occasionally the mouse will be\n  // over the hover label.\n  if (!isClosest) {\n    minPos = function minPos(di) {\n      return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n    };\n    maxPos = function maxPos(di) {\n      return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n    };\n  }\n\n  // the closest data point\n  var index = pointData.index;\n  var di = cd[index];\n  var size = trace.base ? di.b + di.s : di.s;\n  pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n  pointData[sizeLetter + 'LabelVal'] = size;\n  var extent = t.extents[t.extents.round(di.p)];\n  pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n  pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n  pointData[posLetter + 'LabelVal'] = di.p;\n\n  // spikelines always want \"closest\" distance regardless of hovermode\n  pointData.spikeDistance = (sizeFn(di) + thisBarPositionFn(di)) / 2 + maxSpikeDistance - maxHoverDistance;\n  // they also want to point to the data value, regardless of where the label goes\n  // in case of bars shifted within groups\n  pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n  pointData.color = getTraceColor(trace, di);\n  fillHoverText(di, trace, pointData);\n  Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  return [pointData];\n}\nfunction getTraceColor(trace, di) {\n  var mc = di.mcc || trace.marker.color;\n  var mlc = di.mlcc || trace.marker.line.color;\n  var mlw = di.mlw || trace.marker.line.width;\n  if (Color.opacity(mc)) return mc;else if (Color.opacity(mlc) && mlw) return mlc;\n}\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  getTraceColor: getTraceColor\n};","map":{"version":3,"names":["Fx","require","Registry","Color","fillHoverText","hoverPoints","pointData","xval","yval","hovermode","cd","trace","t","isClosest","maxHoverDistance","maxSpikeDistance","posVal","sizeVal","posLetter","sizeLetter","dx","dy","pRangeCalc","thisBarMinPos","di","w","thisBarMaxPos","minPos","Math","min","p","bardelta","maxPos","max","_positionFn","_minPos","_maxPos","inbox","abs","positionFn","thisBarPositionFn","sizeFn","b","orientation","pa","sa","r2c","range","dxy","distfn","getDistanceFunction","getClosest","index","bargroupwidth","size","base","s","c2p","extent","extents","round","spikeDistance","color","getTraceColor","getComponentMethod","hovertemplate","mc","mcc","marker","mlc","mlcc","line","mlw","width","opacity","module","exports"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/bar/hover.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\nvar fillHoverText = require('../scatter/fill_hover_text');\n\nfunction hoverPoints(pointData, xval, yval, hovermode) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isClosest = (hovermode === 'closest');\n    var maxHoverDistance = pointData.maxHoverDistance;\n    var maxSpikeDistance = pointData.maxSpikeDistance;\n\n    var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n\n    function thisBarMinPos(di) { return di[posLetter] - di.w / 2; }\n    function thisBarMaxPos(di) { return di[posLetter] + di.w / 2; }\n\n    var minPos = isClosest ?\n        thisBarMinPos :\n        function(di) {\n            /*\n             * In compare mode, accept a bar if you're on it *or* its group.\n             * Nearly always it's the group that matters, but in case the bar\n             * was explicitly set wider than its group we'd better accept the\n             * whole bar.\n             *\n             * use `bardelta` instead of `bargroupwidth` so we accept hover\n             * in the gap. That way hover doesn't flash on and off as you\n             * mouse over the plot in compare modes.\n             * In 'closest' mode though the flashing seems inevitable,\n             * without far more complex logic\n             */\n            return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n        };\n\n    var maxPos = isClosest ?\n        thisBarMaxPos :\n        function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n        };\n\n    function _positionFn(_minPos, _maxPos) {\n        // add a little to the pseudo-distance for wider bars, so that like scatter,\n        // if you are over two overlapping bars, the narrower one wins.\n        return Fx.inbox(_minPos - posVal, _maxPos - posVal,\n            maxHoverDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n    }\n\n    function positionFn(di) {\n        return _positionFn(minPos(di), maxPos(di));\n    }\n\n    function thisBarPositionFn(di) {\n        return _positionFn(thisBarMinPos(di), thisBarMaxPos(di));\n    }\n\n    function sizeFn(di) {\n        // add a gradient so hovering near the end of a\n        // bar makes it a little closer match\n        return Fx.inbox(di.b - sizeVal, di[sizeLetter] - sizeVal,\n            maxHoverDistance + (di[sizeLetter] - sizeVal) / (di[sizeLetter] - di.b) - 1);\n    }\n\n    if(trace.orientation === 'h') {\n        posVal = yval;\n        sizeVal = xval;\n        posLetter = 'y';\n        sizeLetter = 'x';\n        dx = sizeFn;\n        dy = positionFn;\n    }\n    else {\n        posVal = xval;\n        sizeVal = yval;\n        posLetter = 'x';\n        sizeLetter = 'y';\n        dy = sizeFn;\n        dx = positionFn;\n    }\n\n    var pa = pointData[posLetter + 'a'];\n    var sa = pointData[sizeLetter + 'a'];\n\n    pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    // if we get here and we're not in 'closest' mode, push min/max pos back\n    // onto the group - even though that means occasionally the mouse will be\n    // over the hover label.\n    if(!isClosest) {\n        minPos = function(di) {\n            return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n        };\n        maxPos = function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n        };\n    }\n\n    // the closest data point\n    var index = pointData.index;\n    var di = cd[index];\n\n    var size = (trace.base) ? di.b + di.s : di.s;\n    pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n    pointData[sizeLetter + 'LabelVal'] = size;\n\n    var extent = t.extents[t.extents.round(di.p)];\n    pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n    pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n    pointData[posLetter + 'LabelVal'] = di.p;\n\n    // spikelines always want \"closest\" distance regardless of hovermode\n    pointData.spikeDistance = (sizeFn(di) + thisBarPositionFn(di)) / 2 + maxSpikeDistance - maxHoverDistance;\n    // they also want to point to the data value, regardless of where the label goes\n    // in case of bars shifted within groups\n    pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n\n    pointData.color = getTraceColor(trace, di);\n    fillHoverText(di, trace, pointData);\n    Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n\n    pointData.hovertemplate = trace.hovertemplate;\n    return [pointData];\n}\n\nfunction getTraceColor(trace, di) {\n    var mc = di.mcc || trace.marker.color;\n    var mlc = di.mlcc || trace.marker.line.color;\n    var mlw = di.mlw || trace.marker.line.width;\n\n    if(Color.opacity(mc)) return mc;\n    else if(Color.opacity(mlc) && mlw) return mlc;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    getTraceColor: getTraceColor\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}