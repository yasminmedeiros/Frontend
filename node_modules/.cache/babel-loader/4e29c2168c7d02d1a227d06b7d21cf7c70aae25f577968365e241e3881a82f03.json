{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar maxRowLength = require('../../lib').maxRowLength;\n\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\nmodule.exports = function findEmpties(z) {\n  var empties = [];\n  var neighborHash = {};\n  var noNeighborList = [];\n  var nextRow = z[0];\n  var row = [];\n  var blank = [0, 0, 0];\n  var rowLength = maxRowLength(z);\n  var prevRow;\n  var i;\n  var j;\n  var thisPt;\n  var p;\n  var neighborCount;\n  var newNeighborHash;\n  var foundNewNeighbors;\n  for (i = 0; i < z.length; i++) {\n    prevRow = row;\n    row = nextRow;\n    nextRow = z[i + 1] || [];\n    for (j = 0; j < rowLength; j++) {\n      if (row[j] === undefined) {\n        neighborCount = (row[j - 1] !== undefined ? 1 : 0) + (row[j + 1] !== undefined ? 1 : 0) + (prevRow[j] !== undefined ? 1 : 0) + (nextRow[j] !== undefined ? 1 : 0);\n        if (neighborCount) {\n          // for this purpose, don't count off-the-edge points\n          // as undefined neighbors\n          if (i === 0) neighborCount++;\n          if (j === 0) neighborCount++;\n          if (i === z.length - 1) neighborCount++;\n          if (j === row.length - 1) neighborCount++;\n\n          // if all neighbors that could exist do, we don't\n          // need this for finding farther neighbors\n          if (neighborCount < 4) {\n            neighborHash[[i, j]] = [i, j, neighborCount];\n          }\n          empties.push([i, j, neighborCount]);\n        } else noNeighborList.push([i, j]);\n      }\n    }\n  }\n  while (noNeighborList.length) {\n    newNeighborHash = {};\n    foundNewNeighbors = false;\n\n    // look for cells that now have neighbors but didn't before\n    for (p = noNeighborList.length - 1; p >= 0; p--) {\n      thisPt = noNeighborList[p];\n      i = thisPt[0];\n      j = thisPt[1];\n      neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] + (neighborHash[[i + 1, j]] || blank)[2] + (neighborHash[[i, j - 1]] || blank)[2] + (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n      if (neighborCount) {\n        newNeighborHash[thisPt] = [i, j, neighborCount];\n        noNeighborList.splice(p, 1);\n        foundNewNeighbors = true;\n      }\n    }\n    if (!foundNewNeighbors) {\n      throw 'findEmpties iterated with no new neighbors';\n    }\n\n    // put these new cells into the main neighbor list\n    for (thisPt in newNeighborHash) {\n      neighborHash[thisPt] = newNeighborHash[thisPt];\n      empties.push(newNeighborHash[thisPt]);\n    }\n  }\n\n  // sort the full list in descending order of neighbor count\n  return empties.sort(function (a, b) {\n    return b[2] - a[2];\n  });\n};","map":{"version":3,"names":["maxRowLength","require","module","exports","findEmpties","z","empties","neighborHash","noNeighborList","nextRow","row","blank","rowLength","prevRow","i","j","thisPt","p","neighborCount","newNeighborHash","foundNewNeighbors","length","undefined","push","splice","sort","a","b"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/plotly.js/src/traces/heatmap/find_empties.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar maxRowLength = require('../../lib').maxRowLength;\n\n/* Return a list of empty points in 2D array z\n * each empty point z[i][j] gives an array [i, j, neighborCount]\n * neighborCount is the count of 4 nearest neighbors that DO exist\n * this is to give us an order of points to evaluate for interpolation.\n * if no neighbors exist, we iteratively look for neighbors that HAVE\n * neighbors, and add a fractional neighborCount\n */\nmodule.exports = function findEmpties(z) {\n    var empties = [];\n    var neighborHash = {};\n    var noNeighborList = [];\n    var nextRow = z[0];\n    var row = [];\n    var blank = [0, 0, 0];\n    var rowLength = maxRowLength(z);\n    var prevRow;\n    var i;\n    var j;\n    var thisPt;\n    var p;\n    var neighborCount;\n    var newNeighborHash;\n    var foundNewNeighbors;\n\n    for(i = 0; i < z.length; i++) {\n        prevRow = row;\n        row = nextRow;\n        nextRow = z[i + 1] || [];\n        for(j = 0; j < rowLength; j++) {\n            if(row[j] === undefined) {\n                neighborCount = (row[j - 1] !== undefined ? 1 : 0) +\n                    (row[j + 1] !== undefined ? 1 : 0) +\n                    (prevRow[j] !== undefined ? 1 : 0) +\n                    (nextRow[j] !== undefined ? 1 : 0);\n\n                if(neighborCount) {\n                    // for this purpose, don't count off-the-edge points\n                    // as undefined neighbors\n                    if(i === 0) neighborCount++;\n                    if(j === 0) neighborCount++;\n                    if(i === z.length - 1) neighborCount++;\n                    if(j === row.length - 1) neighborCount++;\n\n                    // if all neighbors that could exist do, we don't\n                    // need this for finding farther neighbors\n                    if(neighborCount < 4) {\n                        neighborHash[[i, j]] = [i, j, neighborCount];\n                    }\n\n                    empties.push([i, j, neighborCount]);\n                }\n                else noNeighborList.push([i, j]);\n            }\n        }\n    }\n\n    while(noNeighborList.length) {\n        newNeighborHash = {};\n        foundNewNeighbors = false;\n\n        // look for cells that now have neighbors but didn't before\n        for(p = noNeighborList.length - 1; p >= 0; p--) {\n            thisPt = noNeighborList[p];\n            i = thisPt[0];\n            j = thisPt[1];\n\n            neighborCount = ((neighborHash[[i - 1, j]] || blank)[2] +\n                (neighborHash[[i + 1, j]] || blank)[2] +\n                (neighborHash[[i, j - 1]] || blank)[2] +\n                (neighborHash[[i, j + 1]] || blank)[2]) / 20;\n\n            if(neighborCount) {\n                newNeighborHash[thisPt] = [i, j, neighborCount];\n                noNeighborList.splice(p, 1);\n                foundNewNeighbors = true;\n            }\n        }\n\n        if(!foundNewNeighbors) {\n            throw 'findEmpties iterated with no new neighbors';\n        }\n\n        // put these new cells into the main neighbor list\n        for(thisPt in newNeighborHash) {\n            neighborHash[thisPt] = newNeighborHash[thisPt];\n            empties.push(newNeighborHash[thisPt]);\n        }\n    }\n\n    // sort the full list in descending order of neighbor count\n    return empties.sort(function(a, b) { return b[2] - a[2]; });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}