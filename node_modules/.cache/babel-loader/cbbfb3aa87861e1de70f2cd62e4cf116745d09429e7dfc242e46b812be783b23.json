{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar calc = require('./calc');\n\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var subplot = xa._id + ya._id;\n  var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n  if (!subplotStackOpts) return;\n  var calcTraces = gd.calcdata;\n  var i, j, k, i2, cd, cd0, posj, sumj, norm;\n  var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n  var hasAnyBlanks;\n  for (var stackGroup in subplotStackOpts) {\n    groupOpts = subplotStackOpts[stackGroup];\n    var indices = groupOpts.traceIndices;\n\n    // can get here with no indices if the stack axis is non-numeric\n    if (!indices.length) continue;\n    interpolate = groupOpts.stackgaps === 'interpolate';\n    groupnorm = groupOpts.groupnorm;\n    if (groupOpts.orientation === 'v') {\n      posAttr = 'x';\n      valAttr = 'y';\n    } else {\n      posAttr = 'y';\n      valAttr = 'x';\n    }\n    hasAnyBlanks = new Array(indices.length);\n    for (i = 0; i < hasAnyBlanks.length; i++) {\n      hasAnyBlanks[i] = false;\n    }\n\n    // Collect the complete set of all positions across ALL traces.\n    // Start with the first trace, then interleave items from later traces\n    // as needed.\n    // Fill in mising items as we go.\n    cd0 = calcTraces[indices[0]];\n    var allPositions = new Array(cd0.length);\n    for (i = 0; i < cd0.length; i++) {\n      allPositions[i] = cd0[i][posAttr];\n    }\n    for (i = 1; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      for (j = k = 0; j < cd.length; j++) {\n        posj = cd[j][posAttr];\n        for (; posj > allPositions[k] && k < allPositions.length; k++) {\n          // the current trace is missing a position from some previous trace(s)\n          insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n          j++;\n        }\n        if (posj !== allPositions[k]) {\n          // previous trace(s) are missing a position from the current trace\n          for (i2 = 0; i2 < i; i2++) {\n            insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n          }\n          allPositions.splice(k, 0, posj);\n        }\n        k++;\n      }\n      for (; k < allPositions.length; k++) {\n        insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n        j++;\n      }\n    }\n    var serieslen = allPositions.length;\n\n    // stack (and normalize)!\n    for (j = 0; j < cd0.length; j++) {\n      sumj = cd0[j][valAttr] = cd0[j].s;\n      for (i = 1; i < indices.length; i++) {\n        cd = calcTraces[indices[i]];\n        cd[0].trace._rawLength = cd[0].trace._length;\n        cd[0].trace._length = serieslen;\n        sumj += cd[j].s;\n        cd[j][valAttr] = sumj;\n      }\n      if (groupnorm) {\n        norm = (groupnorm === 'fraction' ? sumj : sumj / 100) || 1;\n        for (i = 0; i < indices.length; i++) {\n          var cdj = calcTraces[indices[i]][j];\n          cdj[valAttr] /= norm;\n          cdj.sNorm = cdj.s / norm;\n        }\n      }\n    }\n\n    // autorange\n    for (i = 0; i < indices.length; i++) {\n      cd = calcTraces[indices[i]];\n      var trace = cd[0].trace;\n      var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n      var arrayPad = Array.isArray(ppad);\n      if (ppad && hasAnyBlanks[i] || arrayPad) {\n        var ppadRaw = ppad;\n        ppad = new Array(serieslen);\n        for (j = 0; j < serieslen; j++) {\n          ppad[j] = cd[j].gap ? 0 : arrayPad ? ppadRaw[cd[j].i] : ppadRaw;\n        }\n      }\n      var x = new Array(serieslen);\n      var y = new Array(serieslen);\n      for (j = 0; j < serieslen; j++) {\n        x[j] = cd[j].x;\n        y[j] = cd[j].y;\n      }\n      calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n\n      // while we're here (in a loop over all traces in the stack)\n      // record the orientation, so hover can find it easily\n      cd[0].t.orientation = groupOpts.orientation;\n    }\n  }\n};\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n  hasAnyBlanks[traceIndex] = true;\n  var newEntry = {\n    i: null,\n    gap: true,\n    s: 0\n  };\n  newEntry[posAttr] = position;\n  calcTrace.splice(index, 0, newEntry);\n  // Even if we're not interpolating, if one trace has multiple\n  // values at the same position and this trace only has one value there,\n  // we just duplicate that one value rather than insert a zero.\n  // We also make it look like a real point - because it's ambiguous which\n  // one really is the real one!\n  if (index && position === calcTrace[index - 1][posAttr]) {\n    var prevEntry = calcTrace[index - 1];\n    newEntry.s = prevEntry.s;\n    // TODO is it going to cause any problems to have multiple\n    // calcdata points with the same index?\n    newEntry.i = prevEntry.i;\n    newEntry.gap = prevEntry.gap;\n  } else if (interpolate) {\n    newEntry.s = getInterp(calcTrace, index, position, posAttr);\n  }\n  if (!index) {\n    // t and trace need to stay on the first cd entry\n    calcTrace[0].t = calcTrace[1].t;\n    calcTrace[0].trace = calcTrace[1].trace;\n    delete calcTrace[1].t;\n    delete calcTrace[1].trace;\n  }\n}\nfunction getInterp(calcTrace, index, position, posAttr) {\n  var pt0 = calcTrace[index - 1];\n  var pt1 = calcTrace[index + 1];\n  if (!pt1) return pt0.s;\n  if (!pt0) return pt1.s;\n  return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}","map":{"version":3,"names":["calc","require","module","exports","crossTraceCalc","gd","plotinfo","xa","xaxis","ya","yaxis","subplot","_id","subplotStackOpts","_fullLayout","_scatterStackOpts","calcTraces","calcdata","i","j","k","i2","cd","cd0","posj","sumj","norm","groupOpts","interpolate","groupnorm","posAttr","valAttr","hasAnyBlanks","stackGroup","indices","traceIndices","length","stackgaps","orientation","Array","allPositions","insertBlank","splice","serieslen","s","trace","_rawLength","_length","cdj","sNorm","ppad","calcMarkerSize","arrayPad","isArray","ppadRaw","gap","x","y","calcAxisExpansion","t","calcTrace","index","position","traceIndex","newEntry","prevEntry","getInterp","pt0","pt1"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/scatter/cross_trace_calc.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar calc = require('./calc');\n\n/*\n * Scatter stacking & normalization calculations\n * runs per subplot, and can handle multiple stacking groups\n */\n\nmodule.exports = function crossTraceCalc(gd, plotinfo) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var subplot = xa._id + ya._id;\n\n    var subplotStackOpts = gd._fullLayout._scatterStackOpts[subplot];\n    if(!subplotStackOpts) return;\n\n    var calcTraces = gd.calcdata;\n\n    var i, j, k, i2, cd, cd0, posj, sumj, norm;\n    var groupOpts, interpolate, groupnorm, posAttr, valAttr;\n    var hasAnyBlanks;\n\n    for(var stackGroup in subplotStackOpts) {\n        groupOpts = subplotStackOpts[stackGroup];\n        var indices = groupOpts.traceIndices;\n\n        // can get here with no indices if the stack axis is non-numeric\n        if(!indices.length) continue;\n\n        interpolate = groupOpts.stackgaps === 'interpolate';\n        groupnorm = groupOpts.groupnorm;\n        if(groupOpts.orientation === 'v') {\n            posAttr = 'x';\n            valAttr = 'y';\n        }\n        else {\n            posAttr = 'y';\n            valAttr = 'x';\n        }\n        hasAnyBlanks = new Array(indices.length);\n        for(i = 0; i < hasAnyBlanks.length; i++) {\n            hasAnyBlanks[i] = false;\n        }\n\n        // Collect the complete set of all positions across ALL traces.\n        // Start with the first trace, then interleave items from later traces\n        // as needed.\n        // Fill in mising items as we go.\n        cd0 = calcTraces[indices[0]];\n        var allPositions = new Array(cd0.length);\n        for(i = 0; i < cd0.length; i++) {\n            allPositions[i] = cd0[i][posAttr];\n        }\n\n        for(i = 1; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n\n            for(j = k = 0; j < cd.length; j++) {\n                posj = cd[j][posAttr];\n                for(; posj > allPositions[k] && k < allPositions.length; k++) {\n                    // the current trace is missing a position from some previous trace(s)\n                    insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                    j++;\n                }\n                if(posj !== allPositions[k]) {\n                    // previous trace(s) are missing a position from the current trace\n                    for(i2 = 0; i2 < i; i2++) {\n                        insertBlank(calcTraces[indices[i2]], k, posj, i2, hasAnyBlanks, interpolate, posAttr);\n                    }\n                    allPositions.splice(k, 0, posj);\n                }\n                k++;\n            }\n            for(; k < allPositions.length; k++) {\n                insertBlank(cd, j, allPositions[k], i, hasAnyBlanks, interpolate, posAttr);\n                j++;\n            }\n        }\n\n        var serieslen = allPositions.length;\n\n        // stack (and normalize)!\n        for(j = 0; j < cd0.length; j++) {\n            sumj = cd0[j][valAttr] = cd0[j].s;\n            for(i = 1; i < indices.length; i++) {\n                cd = calcTraces[indices[i]];\n                cd[0].trace._rawLength = cd[0].trace._length;\n                cd[0].trace._length = serieslen;\n                sumj += cd[j].s;\n                cd[j][valAttr] = sumj;\n            }\n\n            if(groupnorm) {\n                norm = ((groupnorm === 'fraction') ? sumj : (sumj / 100)) || 1;\n                for(i = 0; i < indices.length; i++) {\n                    var cdj = calcTraces[indices[i]][j];\n                    cdj[valAttr] /= norm;\n                    cdj.sNorm = cdj.s / norm;\n                }\n            }\n        }\n\n        // autorange\n        for(i = 0; i < indices.length; i++) {\n            cd = calcTraces[indices[i]];\n            var trace = cd[0].trace;\n            var ppad = calc.calcMarkerSize(trace, trace._rawLength);\n            var arrayPad = Array.isArray(ppad);\n            if((ppad && hasAnyBlanks[i]) || arrayPad) {\n                var ppadRaw = ppad;\n                ppad = new Array(serieslen);\n                for(j = 0; j < serieslen; j++) {\n                    ppad[j] = cd[j].gap ? 0 : (arrayPad ? ppadRaw[cd[j].i] : ppadRaw);\n                }\n            }\n            var x = new Array(serieslen);\n            var y = new Array(serieslen);\n            for(j = 0; j < serieslen; j++) {\n                x[j] = cd[j].x;\n                y[j] = cd[j].y;\n            }\n            calc.calcAxisExpansion(gd, trace, xa, ya, x, y, ppad);\n\n            // while we're here (in a loop over all traces in the stack)\n            // record the orientation, so hover can find it easily\n            cd[0].t.orientation = groupOpts.orientation;\n        }\n    }\n};\n\nfunction insertBlank(calcTrace, index, position, traceIndex, hasAnyBlanks, interpolate, posAttr) {\n    hasAnyBlanks[traceIndex] = true;\n    var newEntry = {\n        i: null,\n        gap: true,\n        s: 0\n    };\n    newEntry[posAttr] = position;\n    calcTrace.splice(index, 0, newEntry);\n    // Even if we're not interpolating, if one trace has multiple\n    // values at the same position and this trace only has one value there,\n    // we just duplicate that one value rather than insert a zero.\n    // We also make it look like a real point - because it's ambiguous which\n    // one really is the real one!\n    if(index && position === calcTrace[index - 1][posAttr]) {\n        var prevEntry = calcTrace[index - 1];\n        newEntry.s = prevEntry.s;\n        // TODO is it going to cause any problems to have multiple\n        // calcdata points with the same index?\n        newEntry.i = prevEntry.i;\n        newEntry.gap = prevEntry.gap;\n    }\n    else if(interpolate) {\n        newEntry.s = getInterp(calcTrace, index, position, posAttr);\n    }\n    if(!index) {\n        // t and trace need to stay on the first cd entry\n        calcTrace[0].t = calcTrace[1].t;\n        calcTrace[0].trace = calcTrace[1].trace;\n        delete calcTrace[1].t;\n        delete calcTrace[1].trace;\n    }\n}\n\nfunction getInterp(calcTrace, index, position, posAttr) {\n    var pt0 = calcTrace[index - 1];\n    var pt1 = calcTrace[index + 1];\n    if(!pt1) return pt0.s;\n    if(!pt0) return pt1.s;\n    return pt0.s + (pt1.s - pt0.s) * (position - pt0[posAttr]) / (pt1[posAttr] - pt0[posAttr]);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}