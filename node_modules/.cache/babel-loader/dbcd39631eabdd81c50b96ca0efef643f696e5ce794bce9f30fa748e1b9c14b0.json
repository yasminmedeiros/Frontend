{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar scatterHover = require('../scatter/hover');\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var scatterPointData = scatterHover(pointData, xval, yval, hovermode);\n  if (!scatterPointData || scatterPointData[0].index === false) return;\n  var newPointData = scatterPointData[0];\n\n  // if hovering on a fill, we don't show any point data so the label is\n  // unchanged from what scatter gives us - except that it needs to\n  // be constrained to the trianglular plot area, not just the rectangular\n  // area defined by the synthetic x and y axes\n  // TODO: in some cases the vertical middle of the shape is not within\n  // the triangular viewport at all, so the label can become disconnected\n  // from the shape entirely. But calculating what portion of the shape\n  // is actually visible, as constrained by the diagonal axis lines, is not\n  // so easy and anyway we lost the information we would have needed to do\n  // this inside scatterHover.\n  if (newPointData.index === undefined) {\n    var yFracUp = 1 - newPointData.y0 / pointData.ya._length;\n    var xLen = pointData.xa._length;\n    var xMin = xLen * yFracUp / 2;\n    var xMax = xLen - xMin;\n    newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);\n    newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);\n    return scatterPointData;\n  }\n  var cdi = newPointData.cd[newPointData.index];\n  newPointData.a = cdi.a;\n  newPointData.b = cdi.b;\n  newPointData.xLabelVal = undefined;\n  newPointData.yLabelVal = undefined;\n  // TODO: nice formatting, and label by axis title, for a, b, and c?\n\n  var trace = newPointData.trace;\n  var carpet = trace._carpet;\n  var hoverinfo = cdi.hi || trace.hoverinfo;\n  var parts = hoverinfo.split('+');\n  var text = [];\n  function textPart(ax, val) {\n    var prefix;\n    if (ax.labelprefix && ax.labelprefix.length > 0) {\n      prefix = ax.labelprefix.replace(/ = $/, '');\n    } else {\n      prefix = ax._hovertitle;\n    }\n    text.push(prefix + ': ' + val.toFixed(3) + ax.labelsuffix);\n  }\n  if (parts.indexOf('all') !== -1) parts = ['a', 'b'];\n  if (parts.indexOf('a') !== -1) textPart(carpet.aaxis, cdi.a);\n  if (parts.indexOf('b') !== -1) textPart(carpet.baxis, cdi.b);\n  var ij = carpet.ab2ij([cdi.a, cdi.b]);\n  var i0 = Math.floor(ij[0]);\n  var ti = ij[0] - i0;\n  var j0 = Math.floor(ij[1]);\n  var tj = ij[1] - j0;\n  var xy = carpet.evalxy([], i0, j0, ti, tj);\n  text.push('y: ' + xy[1].toFixed(3));\n  newPointData.extraText = text.join('<br>');\n  return scatterPointData;\n};","map":{"version":3,"names":["scatterHover","require","module","exports","hoverPoints","pointData","xval","yval","hovermode","scatterPointData","index","newPointData","undefined","yFracUp","y0","ya","_length","xLen","xa","xMin","xMax","x0","Math","max","min","x1","cdi","cd","a","b","xLabelVal","yLabelVal","trace","carpet","_carpet","hoverinfo","hi","parts","split","text","textPart","ax","val","prefix","labelprefix","length","replace","_hovertitle","push","toFixed","labelsuffix","indexOf","aaxis","baxis","ij","ab2ij","i0","floor","ti","j0","tj","xy","evalxy","extraText","join"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/traces/scattercarpet/hover.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar scatterHover = require('../scatter/hover');\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n    var scatterPointData = scatterHover(pointData, xval, yval, hovermode);\n    if(!scatterPointData || scatterPointData[0].index === false) return;\n\n    var newPointData = scatterPointData[0];\n\n    // if hovering on a fill, we don't show any point data so the label is\n    // unchanged from what scatter gives us - except that it needs to\n    // be constrained to the trianglular plot area, not just the rectangular\n    // area defined by the synthetic x and y axes\n    // TODO: in some cases the vertical middle of the shape is not within\n    // the triangular viewport at all, so the label can become disconnected\n    // from the shape entirely. But calculating what portion of the shape\n    // is actually visible, as constrained by the diagonal axis lines, is not\n    // so easy and anyway we lost the information we would have needed to do\n    // this inside scatterHover.\n    if(newPointData.index === undefined) {\n        var yFracUp = 1 - (newPointData.y0 / pointData.ya._length);\n        var xLen = pointData.xa._length;\n        var xMin = xLen * yFracUp / 2;\n        var xMax = xLen - xMin;\n        newPointData.x0 = Math.max(Math.min(newPointData.x0, xMax), xMin);\n        newPointData.x1 = Math.max(Math.min(newPointData.x1, xMax), xMin);\n        return scatterPointData;\n    }\n\n    var cdi = newPointData.cd[newPointData.index];\n\n    newPointData.a = cdi.a;\n    newPointData.b = cdi.b;\n\n    newPointData.xLabelVal = undefined;\n    newPointData.yLabelVal = undefined;\n    // TODO: nice formatting, and label by axis title, for a, b, and c?\n\n    var trace = newPointData.trace;\n    var carpet = trace._carpet;\n    var hoverinfo = cdi.hi || trace.hoverinfo;\n    var parts = hoverinfo.split('+');\n    var text = [];\n\n    function textPart(ax, val) {\n        var prefix;\n\n        if(ax.labelprefix && ax.labelprefix.length > 0) {\n            prefix = ax.labelprefix.replace(/ = $/, '');\n        } else {\n            prefix = ax._hovertitle;\n        }\n\n        text.push(prefix + ': ' + val.toFixed(3) + ax.labelsuffix);\n    }\n\n    if(parts.indexOf('all') !== -1) parts = ['a', 'b'];\n    if(parts.indexOf('a') !== -1) textPart(carpet.aaxis, cdi.a);\n    if(parts.indexOf('b') !== -1) textPart(carpet.baxis, cdi.b);\n\n    var ij = carpet.ab2ij([cdi.a, cdi.b]);\n    var i0 = Math.floor(ij[0]);\n    var ti = ij[0] - i0;\n\n    var j0 = Math.floor(ij[1]);\n    var tj = ij[1] - j0;\n\n    var xy = carpet.evalxy([], i0, j0, ti, tj);\n    text.push('y: ' + xy[1].toFixed(3));\n\n    newPointData.extraText = text.join('<br>');\n\n    return scatterPointData;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}