{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/home/yasmin/\\xC1rea de Trabalho/Frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _slicedToArray = require(\"/home/yasmin/\\xC1rea de Trabalho/Frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar createScatter = require('regl-scatter2d');\nvar pick = require('pick-by-alias');\nvar getBounds = require('array-bounds');\nvar raf = require('raf');\nvar arrRange = require('array-range');\nvar rect = require('parse-rect');\nvar flatten = require('flatten-vertex-data');\nmodule.exports = SPLOM;\n\n// @constructor\nfunction SPLOM(regl, options) {\n  if (!(this instanceof SPLOM)) return new SPLOM(regl, options);\n\n  // render passes\n  this.traces = [];\n\n  // passes for scatter, combined across traces\n  this.passes = {};\n  this.regl = regl;\n\n  // main scatter drawing instance\n  this.scatter = createScatter(regl);\n  this.canvas = this.scatter.canvas;\n}\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function () {\n  var _this = this;\n  if (arguments.length) {\n    this.update.apply(this, arguments);\n  }\n  if (this.regl.attributes.preserveDrawingBuffer) return this.draw();\n\n  // make sure draw is not called more often than once a frame\n  if (this.dirty) {\n    if (this.planned == null) {\n      this.planned = raf(function () {\n        _this.draw();\n        _this.dirty = true;\n        _this.planned = null;\n      });\n    }\n  } else {\n    this.draw();\n    this.dirty = true;\n    raf(function () {\n      _this.dirty = false;\n    });\n  }\n  return this;\n};\n\n// update passes\nSPLOM.prototype.update = function () {\n  var _this$scatter;\n  if (!arguments.length) return;\n  for (var i = 0; i < arguments.length; i++) {\n    this.updateItem(i, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n  }\n\n  // remove nulled passes\n  this.traces = this.traces.filter(Boolean);\n\n  // FIXME: update passes independently\n  var passes = [];\n  var offset = 0;\n  for (var _i = 0; _i < this.traces.length; _i++) {\n    var trace = this.traces[_i];\n    var tracePasses = this.traces[_i].passes;\n    for (var j = 0; j < tracePasses.length; j++) {\n      passes.push(this.passes[tracePasses[j]]);\n    }\n    // save offset of passes\n    trace.passOffset = offset;\n    offset += trace.passes.length;\n  }\n  (_this$scatter = this.scatter).update.apply(_this$scatter, passes);\n  return this;\n};\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n  var regl = this.regl;\n\n  // remove pass if null\n  if (options === null) {\n    this.traces[i] = null;\n    return this;\n  }\n  if (!options) return this;\n  var o = pick(options, {\n    data: 'data items columns rows values dimensions samples x',\n    snap: 'snap cluster',\n    size: 'sizes size radius',\n    color: 'colors color fill fill-color fillColor',\n    opacity: 'opacity alpha transparency opaque',\n    borderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n    borderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n    marker: 'markers marker shape',\n    range: 'range ranges databox dataBox',\n    viewport: 'viewport viewBox viewbox',\n    domain: 'domain domains area areas',\n    padding: 'pad padding paddings pads margin margins',\n    transpose: 'transpose transposed',\n    diagonal: 'diagonal diag showDiagonal',\n    upper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n    lower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n  });\n\n  // we provide regl buffer per-trace, since trace data can be changed\n  var trace = this.traces[i] || (this.traces[i] = {\n    id: i,\n    buffer: regl.buffer({\n      usage: 'dynamic',\n      type: 'float',\n      data: new Uint8Array()\n    }),\n    color: 'black',\n    marker: null,\n    size: 12,\n    borderColor: 'transparent',\n    borderSize: 1,\n    viewport: rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n    padding: [0, 0, 0, 0],\n    opacity: 1,\n    diagonal: true,\n    upper: true,\n    lower: true\n  });\n\n  // save styles\n  if (o.color != null) {\n    trace.color = o.color;\n  }\n  if (o.size != null) {\n    trace.size = o.size;\n  }\n  if (o.marker != null) {\n    trace.marker = o.marker;\n  }\n  if (o.borderColor != null) {\n    trace.borderColor = o.borderColor;\n  }\n  if (o.borderSize != null) {\n    trace.borderSize = o.borderSize;\n  }\n  if (o.opacity != null) {\n    trace.opacity = o.opacity;\n  }\n  if (o.viewport) {\n    trace.viewport = rect(o.viewport);\n  }\n  if (o.diagonal != null) trace.diagonal = o.diagonal;\n  if (o.upper != null) trace.upper = o.upper;\n  if (o.lower != null) trace.lower = o.lower;\n\n  // put flattened data into buffer\n  if (o.data) {\n    trace.buffer(flatten(o.data));\n    trace.columns = o.data.length;\n    trace.count = o.data[0].length;\n\n    // detect bounds per-column\n    trace.bounds = [];\n    for (var _i2 = 0; _i2 < trace.columns; _i2++) {\n      trace.bounds[_i2] = getBounds(o.data[_i2], 1);\n    }\n  }\n\n  // add proper range updating markers\n  var multirange;\n  if (o.range) {\n    trace.range = o.range;\n    multirange = trace.range && typeof trace.range[0] !== 'number';\n  }\n  if (o.domain) {\n    trace.domain = o.domain;\n  }\n  var multipadding = false;\n  if (o.padding != null) {\n    // multiple paddings\n    if (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n      trace.padding = o.padding.map(getPad);\n      multipadding = true;\n    }\n    // single padding\n    else {\n      trace.padding = getPad(o.padding);\n    }\n  }\n\n  // create passes\n  var m = trace.columns;\n  var n = trace.count;\n  var w = trace.viewport.width;\n  var h = trace.viewport.height;\n  var left = trace.viewport.x;\n  var top = trace.viewport.y;\n  var iw = w / m;\n  var ih = h / m;\n  trace.passes = [];\n  for (var _i3 = 0; _i3 < m; _i3++) {\n    for (var j = 0; j < m; j++) {\n      if (!trace.diagonal && j === _i3) continue;\n      if (!trace.upper && _i3 > j) continue;\n      if (!trace.lower && _i3 < j) continue;\n      var key = passId(trace.id, _i3, j);\n      var pass = this.passes[key] || (this.passes[key] = {});\n      if (o.data) {\n        if (o.transpose) {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j,\n              count: n,\n              stride: m\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3,\n              count: n,\n              stride: m\n            }\n          };\n        } else {\n          pass.positions = {\n            x: {\n              buffer: trace.buffer,\n              offset: j * n,\n              count: n\n            },\n            y: {\n              buffer: trace.buffer,\n              offset: _i3 * n,\n              count: n\n            }\n          };\n        }\n        pass.bounds = getBox(trace.bounds, _i3, j);\n      }\n      if (o.domain || o.viewport || o.data) {\n        var pad = multipadding ? getBox(trace.padding, _i3, j) : trace.padding;\n        if (trace.domain) {\n          var _getBox = getBox(trace.domain, _i3, j),\n            _getBox2 = _slicedToArray(_getBox, 4),\n            lox = _getBox2[0],\n            loy = _getBox2[1],\n            hix = _getBox2[2],\n            hiy = _getBox2[3];\n          pass.viewport = [left + lox * w + pad[0], top + loy * h + pad[1], left + hix * w - pad[2], top + hiy * h - pad[3]];\n        }\n        // consider auto-domain equipartial\n        else {\n          pass.viewport = [left + j * iw + iw * pad[0], top + _i3 * ih + ih * pad[1], left + (j + 1) * iw - iw * pad[2], top + (_i3 + 1) * ih - ih * pad[3]];\n        }\n      }\n      if (o.color) pass.color = trace.color;\n      if (o.size) pass.size = trace.size;\n      if (o.marker) pass.marker = trace.marker;\n      if (o.borderSize) pass.borderSize = trace.borderSize;\n      if (o.borderColor) pass.borderColor = trace.borderColor;\n      if (o.opacity) pass.opacity = trace.opacity;\n      if (o.range) {\n        pass.range = multirange ? getBox(trace.range, _i3, j) : trace.range || pass.bounds;\n      }\n      trace.passes.push(key);\n    }\n  }\n  return this;\n};\n\n// draw all or passed passes\nSPLOM.prototype.draw = function () {\n  var _this2 = this;\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  if (!args.length) {\n    this.scatter.draw();\n  } else {\n    (function () {\n      var _this2$scatter;\n      var idx = [];\n      for (var i = 0; i < args.length; i++) {\n        // draw(0, 2, 5) - draw traces\n        if (typeof args[i] === 'number') {\n          var _this2$traces$args$i = _this2.traces[args[i]],\n            passes = _this2$traces$args$i.passes,\n            passOffset = _this2$traces$args$i.passOffset;\n          idx.push.apply(idx, _toConsumableArray(arrRange(passOffset, passOffset + passes.length)));\n        }\n        // draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n        else if (args[i].length) {\n          (function () {\n            var els = args[i];\n            var _this2$traces$i = _this2.traces[i],\n              passes = _this2$traces$i.passes,\n              passOffset = _this2$traces$i.passOffset;\n            passes = passes.map(function (passId, i) {\n              idx[passOffset + i] = els;\n            });\n          })();\n        }\n      }\n      (_this2$scatter = _this2.scatter).draw.apply(_this2$scatter, idx);\n    })();\n  }\n  return this;\n};\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n  this.traces.forEach(function (trace) {\n    if (trace.buffer && trace.buffer.destroy) trace.buffer.destroy();\n  });\n  this.traces = null;\n  this.passes = null;\n  this.scatter.destroy();\n  return this;\n};\n\n// return pass corresponding to trace i- j- square\nfunction passId(trace, i, j) {\n  var id = trace.id != null ? trace.id : trace;\n  var n = i;\n  var m = j;\n  var key = id << 16 | (n & 0xff) << 8 | m & 0xff;\n  return key;\n}\n\n// return bounding box corresponding to a pass\nfunction getBox(items, i, j) {\n  var ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy;\n  var iitem = items[i],\n    jitem = items[j];\n  if (iitem.length > 2) {\n    ilox = iitem[0];\n    ihix = iitem[2];\n    iloy = iitem[1];\n    ihiy = iitem[3];\n  } else if (iitem.length) {\n    ilox = iloy = iitem[0];\n    ihix = ihiy = iitem[1];\n  } else {\n    ilox = iitem.x;\n    iloy = iitem.y;\n    ihix = iitem.x + iitem.width;\n    ihiy = iitem.y + iitem.height;\n  }\n  if (jitem.length > 2) {\n    jlox = jitem[0];\n    jhix = jitem[2];\n    jloy = jitem[1];\n    jhiy = jitem[3];\n  } else if (jitem.length) {\n    jlox = jloy = jitem[0];\n    jhix = jhiy = jitem[1];\n  } else {\n    jlox = jitem.x;\n    jloy = jitem.y;\n    jhix = jitem.x + jitem.width;\n    jhiy = jitem.y + jitem.height;\n  }\n  return [jlox, iloy, jhix, ihiy];\n}\nfunction getPad(arg) {\n  if (typeof arg === 'number') return [arg, arg, arg, arg];else if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]];else {\n    var box = rect(arg);\n    return [box.x, box.y, box.x + box.width, box.y + box.height];\n  }\n}","map":{"version":3,"names":["createScatter","require","pick","getBounds","raf","arrRange","rect","flatten","module","exports","SPLOM","regl","options","traces","passes","scatter","canvas","prototype","render","length","update","attributes","preserveDrawingBuffer","draw","dirty","planned","i","updateItem","filter","Boolean","offset","trace","tracePasses","j","push","passOffset","o","data","snap","size","color","opacity","borderSize","borderColor","marker","range","viewport","domain","padding","transpose","diagonal","upper","lower","id","buffer","usage","type","Uint8Array","_gl","drawingBufferWidth","drawingBufferHeight","columns","count","bounds","multirange","multipadding","Array","isArray","map","getPad","m","n","w","width","h","height","left","x","top","y","iw","ih","key","passId","pass","positions","stride","getBox","pad","lox","loy","hix","hiy","args","idx","els","destroy","forEach","items","ilox","iloy","ihix","ihiy","jlox","jloy","jhix","jhiy","iitem","jitem","arg","box"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/regl-splom/index.js"],"sourcesContent":["'use strict'\n\n\nconst createScatter = require('regl-scatter2d')\nconst pick = require('pick-by-alias')\nconst getBounds = require('array-bounds')\nconst raf = require('raf')\nconst arrRange = require('array-range')\nconst rect = require('parse-rect')\nconst flatten = require('flatten-vertex-data')\n\n\nmodule.exports = SPLOM\n\n\n// @constructor\nfunction SPLOM (regl, options) {\n\tif (!(this instanceof SPLOM)) return new SPLOM(regl, options)\n\n\t// render passes\n\tthis.traces = []\n\n\t// passes for scatter, combined across traces\n\tthis.passes = {}\n\n\tthis.regl = regl\n\n\t// main scatter drawing instance\n\tthis.scatter = createScatter(regl)\n\n\tthis.canvas = this.scatter.canvas\n}\n\n\n// update & draw passes once per frame\nSPLOM.prototype.render = function (...args) {\n\tif (args.length) {\n\t\tthis.update(...args)\n\t}\n\n\tif (this.regl.attributes.preserveDrawingBuffer) return this.draw()\n\n\t// make sure draw is not called more often than once a frame\n\tif (this.dirty) {\n\t\tif (this.planned == null) {\n\t\t\tthis.planned = raf(() => {\n\t\t\t\tthis.draw()\n\t\t\t\tthis.dirty = true\n\t\t\t\tthis.planned = null\n\t\t\t})\n\t\t}\n\t}\n\telse {\n\t\tthis.draw()\n\t\tthis.dirty = true\n\t\traf(() => {\n\t\t\tthis.dirty = false\n\t\t})\n\t}\n\n\treturn this\n}\n\n\n// update passes\nSPLOM.prototype.update = function (...args) {\n\tif (!args.length) return\n\n\tfor (let i = 0; i < args.length; i++) {\n\t\tthis.updateItem(i, args[i])\n\t}\n\n\t// remove nulled passes\n\tthis.traces = this.traces.filter(Boolean)\n\n\t// FIXME: update passes independently\n\tlet passes = []\n\tlet offset = 0\n\tfor (let i = 0; i < this.traces.length; i++) {\n\t\tlet trace = this.traces[i]\n\t\tlet tracePasses = this.traces[i].passes\n\t\tfor (let j = 0; j < tracePasses.length; j++) {\n\t\t\tpasses.push(this.passes[tracePasses[j]])\n\t\t}\n\t\t// save offset of passes\n\t\ttrace.passOffset = offset\n\t\toffset += trace.passes.length\n\t}\n\n\tthis.scatter.update(...passes)\n\n\treturn this\n}\n\n\n// update trace by index, not supposed to be called directly\nSPLOM.prototype.updateItem = function (i, options) {\n\tlet { regl } = this\n\n\t// remove pass if null\n\tif (options === null) {\n\t\tthis.traces[i] = null\n\t\treturn this\n\t}\n\n\tif (!options) return this\n\n\tlet o = pick(options, {\n\t\tdata: 'data items columns rows values dimensions samples x',\n\t\tsnap: 'snap cluster',\n\t\tsize: 'sizes size radius',\n\t\tcolor: 'colors color fill fill-color fillColor',\n\t\topacity: 'opacity alpha transparency opaque',\n\t\tborderSize: 'borderSizes borderSize border-size bordersize borderWidth borderWidths border-width borderwidth stroke-width strokeWidth strokewidth outline',\n\t\tborderColor: 'borderColors borderColor bordercolor stroke stroke-color strokeColor',\n\t\tmarker: 'markers marker shape',\n\t\trange: 'range ranges databox dataBox',\n\t\tviewport: 'viewport viewBox viewbox',\n\t\tdomain: 'domain domains area areas',\n\t\tpadding: 'pad padding paddings pads margin margins',\n\t\ttranspose: 'transpose transposed',\n\t\tdiagonal: 'diagonal diag showDiagonal',\n\t\tupper: 'upper up top upperhalf upperHalf showupperhalf showUpper showUpperHalf',\n\t\tlower: 'lower low bottom lowerhalf lowerHalf showlowerhalf showLowerHalf showLower'\n\t})\n\n\t// we provide regl buffer per-trace, since trace data can be changed\n\tlet trace = (this.traces[i] || (this.traces[i] = {\n\t\tid: i,\n\t\tbuffer: regl.buffer({\n\t\t\tusage: 'dynamic',\n\t\t\ttype: 'float',\n\t\t\tdata: new Uint8Array()\n\t\t}),\n\t\tcolor: 'black',\n\t\tmarker: null,\n\t\tsize: 12,\n\t\tborderColor: 'transparent',\n\t\tborderSize: 1,\n\t\tviewport:  rect([regl._gl.drawingBufferWidth, regl._gl.drawingBufferHeight]),\n\t\tpadding: [0, 0, 0, 0],\n\t\topacity: 1,\n\t\tdiagonal: true,\n\t\tupper: true,\n\t\tlower: true\n\t}))\n\n\n\t// save styles\n\tif (o.color != null) {\n\t\ttrace.color = o.color\n\t}\n\tif (o.size != null) {\n\t\ttrace.size = o.size\n\t}\n\tif (o.marker != null) {\n\t\ttrace.marker = o.marker\n\t}\n\tif (o.borderColor != null) {\n\t\ttrace.borderColor = o.borderColor\n\t}\n\tif (o.borderSize != null) {\n\t\ttrace.borderSize = o.borderSize\n\t}\n\tif (o.opacity != null) {\n\t\ttrace.opacity = o.opacity\n\t}\n\tif (o.viewport) {\n\t\ttrace.viewport = rect(o.viewport)\n\t}\n\tif (o.diagonal != null) trace.diagonal = o.diagonal\n\tif (o.upper != null) trace.upper = o.upper\n\tif (o.lower != null) trace.lower = o.lower\n\n\t// put flattened data into buffer\n\tif (o.data) {\n\t\ttrace.buffer(flatten(o.data))\n\t\ttrace.columns = o.data.length\n\t\ttrace.count = o.data[0].length\n\n\t\t// detect bounds per-column\n\t\ttrace.bounds = []\n\n\t\tfor (let i = 0; i < trace.columns; i++) {\n\t\t\ttrace.bounds[i] = getBounds(o.data[i], 1)\n\t\t}\n\t}\n\n\t// add proper range updating markers\n\tlet multirange\n\tif (o.range) {\n\t\ttrace.range = o.range\n\t\tmultirange = trace.range && typeof trace.range[0] !== 'number'\n\t}\n\n\tif (o.domain) {\n\t\ttrace.domain = o.domain\n\t}\n\tlet multipadding = false\n\tif (o.padding != null) {\n\t\t// multiple paddings\n\t\tif (Array.isArray(o.padding) && o.padding.length === trace.columns && typeof o.padding[o.padding.length - 1] === 'number') {\n\t\t\ttrace.padding = o.padding.map(getPad)\n\t\t\tmultipadding = true\n\t\t}\n\t\t// single padding\n\t\telse {\n\t\t\ttrace.padding = getPad(o.padding)\n\t\t}\n\t}\n\n\t// create passes\n\tlet m = trace.columns\n\tlet n = trace.count\n\n\tlet w = trace.viewport.width\n\tlet h = trace.viewport.height\n\tlet left = trace.viewport.x\n\tlet top = trace.viewport.y\n\tlet iw = w / m\n\tlet ih = h / m\n\n\ttrace.passes = []\n\n\tfor (let i = 0; i < m; i++) {\n\t\tfor (let j = 0; j < m; j++) {\n\t\t\tif (!trace.diagonal && j === i) continue\n\t\t\tif (!trace.upper && i > j) continue\n\t\t\tif (!trace.lower && i < j) continue\n\n\t\t\tlet key = passId(trace.id, i, j)\n\n\t\t\tlet pass = this.passes[key] || (this.passes[key] = {})\n\n\t\t\tif (o.data) {\n\t\t\t\tif (o.transpose) {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j, count: n, stride: m},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i, count: n, stride: m}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpass.positions = {\n\t\t\t\t\t\tx: {buffer: trace.buffer, offset: j * n, count: n},\n\t\t\t\t\t\ty: {buffer: trace.buffer, offset: i * n, count: n}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpass.bounds = getBox(trace.bounds, i, j)\n\t\t\t}\n\n\t\t\tif (o.domain || o.viewport || o.data) {\n\t\t\t\tlet pad = multipadding ? getBox(trace.padding, i, j) : trace.padding\n\t\t\t\tif (trace.domain) {\n\t\t\t\t\tlet [lox, loy, hix, hiy] = getBox(trace.domain, i, j)\n\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + lox * w + pad[0],\n\t\t\t\t\t\ttop + loy * h + pad[1],\n\t\t\t\t\t\tleft + hix * w - pad[2],\n\t\t\t\t\t\ttop + hiy * h - pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t\t// consider auto-domain equipartial\n\t\t\t\telse {\n\t\t\t\t\tpass.viewport = [\n\t\t\t\t\t\tleft + j * iw + iw * pad[0],\n\t\t\t\t\t\ttop + i * ih + ih * pad[1],\n\t\t\t\t\t\tleft + (j + 1) * iw - iw * pad[2],\n\t\t\t\t\t\ttop + (i + 1) * ih - ih * pad[3]\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (o.color) pass.color = trace.color\n\t\t\tif (o.size) pass.size = trace.size\n\t\t\tif (o.marker) pass.marker = trace.marker\n\t\t\tif (o.borderSize) pass.borderSize = trace.borderSize\n\t\t\tif (o.borderColor) pass.borderColor = trace.borderColor\n\t\t\tif (o.opacity) pass.opacity = trace.opacity\n\n\t\t\tif (o.range) {\n\t\t\t\tpass.range = multirange ? getBox(trace.range, i, j) : trace.range || pass.bounds\n\t\t\t}\n\n\t\t\ttrace.passes.push(key)\n\t\t}\n\t}\n\n\treturn this\n}\n\n\n// draw all or passed passes\nSPLOM.prototype.draw = function (...args) {\n\tif (!args.length) {\n\t\tthis.scatter.draw()\n\t}\n\telse {\n\t\tlet idx = []\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t// draw(0, 2, 5) - draw traces\n\t\t\tif (typeof args[i] === 'number' ) {\n\t\t\t\tlet { passes, passOffset } = this.traces[args[i]]\n\t\t\t\tidx.push(...arrRange(passOffset, passOffset + passes.length))\n\t\t\t}\n\t\t\t// draw([0, 1, 2 ...], [3, 4, 5]) - draw points\n\t\t\telse if (args[i].length) {\n\t\t\t\tlet els = args[i]\n\t\t\t\tlet { passes, passOffset } = this.traces[i]\n\t\t\t\tpasses = passes.map((passId, i) => {\n\t\t\t\t\tidx[passOffset + i] = els\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t\tthis.scatter.draw(...idx)\n\t}\n\n\treturn this\n}\n\n\n// dispose resources\nSPLOM.prototype.destroy = function () {\n\tthis.traces.forEach(trace => {\n\t\tif (trace.buffer && trace.buffer.destroy) trace.buffer.destroy()\n\t})\n\tthis.traces = null\n\tthis.passes = null\n\n\tthis.scatter.destroy()\n\n\treturn this\n}\n\n\n// return pass corresponding to trace i- j- square\nfunction passId (trace, i, j) {\n\tlet id = (trace.id != null ? trace.id : trace)\n\tlet n = i\n\tlet m = j\n\tlet key = id << 16 | (n & 0xff) << 8 | m & 0xff\n\n\treturn key\n}\n\n\n// return bounding box corresponding to a pass\nfunction getBox (items, i, j) {\n\tlet ilox, iloy, ihix, ihiy, jlox, jloy, jhix, jhiy\n\tlet iitem = items[i], jitem = items[j]\n\n\tif (iitem.length > 2) {\n\t\tilox = iitem[0]\n\t\tihix = iitem[2]\n\t\tiloy = iitem[1]\n\t\tihiy = iitem[3]\n\t}\n\telse if (iitem.length) {\n\t\tilox = iloy = iitem[0]\n\t\tihix = ihiy = iitem[1]\n\t}\n\telse {\n\t\tilox = iitem.x\n\t\tiloy = iitem.y\n\t\tihix = iitem.x + iitem.width\n\t\tihiy = iitem.y + iitem.height\n\t}\n\n\tif (jitem.length > 2) {\n\t\tjlox = jitem[0]\n\t\tjhix = jitem[2]\n\t\tjloy = jitem[1]\n\t\tjhiy = jitem[3]\n\t}\n\telse if (jitem.length) {\n\t\tjlox = jloy = jitem[0]\n\t\tjhix = jhiy = jitem[1]\n\t}\n\telse {\n\t\tjlox = jitem.x\n\t\tjloy = jitem.y\n\t\tjhix = jitem.x + jitem.width\n\t\tjhiy = jitem.y + jitem.height\n\t}\n\n\treturn [ jlox, iloy, jhix, ihiy ]\n}\n\n\nfunction getPad (arg) {\n\tif (typeof arg === 'number') return [arg, arg, arg, arg]\n\telse if (arg.length === 2) return [arg[0], arg[1], arg[0], arg[1]]\n\telse {\n\t\tlet box = rect(arg)\n\t\treturn [box.x, box.y, box.x + box.width, box.y + box.height]\n\t}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}