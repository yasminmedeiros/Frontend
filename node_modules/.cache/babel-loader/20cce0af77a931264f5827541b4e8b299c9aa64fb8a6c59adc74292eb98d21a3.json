{"ast":null,"code":"\"use strict\";\n\n//High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\nmodule.exports = incrementalConvexHull;\nvar orient = require(\"robust-orientation\");\nvar compareCell = require(\"simplicial-complex\").compareCells;\nfunction compareInt(a, b) {\n  return a - b;\n}\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices;\n  this.adjacent = adjacent;\n  this.boundary = boundary;\n  this.lastVisited = -1;\n}\nSimplex.prototype.flip = function () {\n  var t = this.vertices[0];\n  this.vertices[0] = this.vertices[1];\n  this.vertices[1] = t;\n  var u = this.adjacent[0];\n  this.adjacent[0] = this.adjacent[1];\n  this.adjacent[1] = u;\n};\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices;\n  this.cell = cell;\n  this.index = index;\n}\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices);\n}\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"];\n  for (var i = 0; i <= d; ++i) {\n    if (i > 0) {\n      code.push(\",\");\n    }\n    code.push(\"tuple[\", i, \"]\");\n  }\n  code.push(\")}return orient\");\n  var proc = new Function(\"test\", code.join(\"\"));\n  var test = orient[d + 1];\n  if (!test) {\n    test = orient;\n  }\n  return proc(test);\n}\nvar BAKED = [];\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension;\n  this.vertices = vertices;\n  this.simplices = simplices;\n  this.interior = simplices.filter(function (c) {\n    return !c.boundary;\n  });\n  this.tuple = new Array(dimension + 1);\n  for (var i = 0; i <= dimension; ++i) {\n    this.tuple[i] = this.vertices[i];\n  }\n  var o = BAKED[dimension];\n  if (!o) {\n    o = BAKED[dimension] = bakeOrient(dimension);\n  }\n  this.orient = o;\n}\nvar proto = Triangulation.prototype;\n\n//Degenerate situation where we are on boundary, but coplanar to face\nproto.handleBoundaryDegeneracy = function (cell, point) {\n  var d = this.dimension;\n  var n = this.vertices.length - 1;\n  var tuple = this.tuple;\n  var verts = this.vertices;\n\n  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n  var toVisit = [cell];\n  cell.lastVisited = -n;\n  while (toVisit.length > 0) {\n    cell = toVisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n      if (!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue;\n      }\n      var nv = neighbor.vertices;\n      for (var j = 0; j <= d; ++j) {\n        var vv = nv[j];\n        if (vv < 0) {\n          tuple[j] = point;\n        } else {\n          tuple[j] = verts[vv];\n        }\n      }\n      var o = this.orient();\n      if (o > 0) {\n        return neighbor;\n      }\n      neighbor.lastVisited = -n;\n      if (o === 0) {\n        toVisit.push(neighbor);\n      }\n    }\n  }\n  return null;\n};\nproto.walk = function (point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple;\n\n  //Compute initial jump cell\n  var initIndex = random ? this.interior.length * Math.random() | 0 : this.interior.length - 1;\n  var cell = this.interior[initIndex];\n\n  //Start walking\n  outerLoop: while (!cell.boundary) {\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    for (var i = 0; i <= d; ++i) {\n      tuple[i] = verts[cellVerts[i]];\n    }\n    cell.lastVisited = n;\n\n    //Find farthest adjacent cell\n    for (var i = 0; i <= d; ++i) {\n      var neighbor = cellAdj[i];\n      if (neighbor.lastVisited >= n) {\n        continue;\n      }\n      var prev = tuple[i];\n      tuple[i] = point;\n      var o = this.orient();\n      tuple[i] = prev;\n      if (o < 0) {\n        cell = neighbor;\n        continue outerLoop;\n      } else {\n        if (!neighbor.boundary) {\n          neighbor.lastVisited = n;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n    }\n    return;\n  }\n  return cell;\n};\nproto.addPeaks = function (point, cell) {\n  var n = this.vertices.length - 1;\n  var d = this.dimension;\n  var verts = this.vertices;\n  var tuple = this.tuple;\n  var interior = this.interior;\n  var simplices = this.simplices;\n\n  //Walking finished at boundary, time to add peaks\n  var tovisit = [cell];\n\n  //Stretch initial boundary cell into a peak\n  cell.lastVisited = n;\n  cell.vertices[cell.vertices.indexOf(-1)] = n;\n  cell.boundary = false;\n  interior.push(cell);\n\n  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n  var glueFacets = [];\n\n  //Do a traversal of the boundary walking outward from starting peak\n  while (tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop();\n    var cellVerts = cell.vertices;\n    var cellAdj = cell.adjacent;\n    var indexOfN = cellVerts.indexOf(n);\n    if (indexOfN < 0) {\n      continue;\n    }\n    for (var i = 0; i <= d; ++i) {\n      if (i === indexOfN) {\n        continue;\n      }\n\n      //For each boundary neighbor of the cell\n      var neighbor = cellAdj[i];\n      if (!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue;\n      }\n      var nv = neighbor.vertices;\n\n      //Test if neighbor is a peak\n      if (neighbor.lastVisited !== -n) {\n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0;\n        for (var j = 0; j <= d; ++j) {\n          if (nv[j] < 0) {\n            indexOfNeg1 = j;\n            tuple[j] = point;\n          } else {\n            tuple[j] = verts[nv[j]];\n          }\n        }\n        var o = this.orient();\n\n        //Test if neighbor cell is also a peak\n        if (o > 0) {\n          nv[indexOfNeg1] = n;\n          neighbor.boundary = false;\n          interior.push(neighbor);\n          tovisit.push(neighbor);\n          neighbor.lastVisited = n;\n          continue;\n        } else {\n          neighbor.lastVisited = -n;\n        }\n      }\n      var na = neighbor.adjacent;\n\n      //Otherwise, replace neighbor with new face\n      var vverts = cellVerts.slice();\n      var vadj = cellAdj.slice();\n      var ncell = new Simplex(vverts, vadj, true);\n      simplices.push(ncell);\n\n      //Connect to neighbor\n      var opposite = na.indexOf(cell);\n      if (opposite < 0) {\n        continue;\n      }\n      na[opposite] = ncell;\n      vadj[indexOfN] = neighbor;\n\n      //Connect to cell\n      vverts[i] = -1;\n      vadj[i] = cell;\n      cellAdj[i] = ncell;\n\n      //Flip facet\n      ncell.flip();\n\n      //Add to glue list\n      for (var j = 0; j <= d; ++j) {\n        var uu = vverts[j];\n        if (uu < 0 || uu === n) {\n          continue;\n        }\n        var nface = new Array(d - 1);\n        var nptr = 0;\n        for (var k = 0; k <= d; ++k) {\n          var vv = vverts[k];\n          if (vv < 0 || k === j) {\n            continue;\n          }\n          nface[nptr++] = vv;\n        }\n        glueFacets.push(new GlueFacet(nface, ncell, j));\n      }\n    }\n  }\n\n  //Glue boundary facets together\n  glueFacets.sort(compareGlue);\n  for (var i = 0; i + 1 < glueFacets.length; i += 2) {\n    var a = glueFacets[i];\n    var b = glueFacets[i + 1];\n    var ai = a.index;\n    var bi = b.index;\n    if (ai < 0 || bi < 0) {\n      continue;\n    }\n    a.cell.adjacent[a.index] = b.cell;\n    b.cell.adjacent[b.index] = a.cell;\n  }\n};\nproto.insert = function (point, random) {\n  //Add point\n  var verts = this.vertices;\n  verts.push(point);\n  var cell = this.walk(point, random);\n  if (!cell) {\n    return;\n  }\n\n  //Alias local properties\n  var d = this.dimension;\n  var tuple = this.tuple;\n\n  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n  for (var i = 0; i <= d; ++i) {\n    var vv = cell.vertices[i];\n    if (vv < 0) {\n      tuple[i] = point;\n    } else {\n      tuple[i] = verts[vv];\n    }\n  }\n  var o = this.orient(tuple);\n  if (o < 0) {\n    return;\n  } else if (o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point);\n    if (!cell) {\n      return;\n    }\n  }\n\n  //Add peaks\n  this.addPeaks(point, cell);\n};\n\n//Extract all boundary cells\nproto.boundary = function () {\n  var d = this.dimension;\n  var boundary = [];\n  var cells = this.simplices;\n  var nc = cells.length;\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    if (c.boundary) {\n      var bcell = new Array(d);\n      var cv = c.vertices;\n      var ptr = 0;\n      var parity = 0;\n      for (var j = 0; j <= d; ++j) {\n        if (cv[j] >= 0) {\n          bcell[ptr++] = cv[j];\n        } else {\n          parity = j & 1;\n        }\n      }\n      if (parity === (d & 1)) {\n        var t = bcell[0];\n        bcell[0] = bcell[1];\n        bcell[1] = t;\n      }\n      boundary.push(bcell);\n    }\n  }\n  return boundary;\n};\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length;\n  if (n === 0) {\n    throw new Error(\"Must have at least d+1 points\");\n  }\n  var d = points[0].length;\n  if (n <= d) {\n    throw new Error(\"Must input at least d+1 points\");\n  }\n\n  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n  var initialSimplex = points.slice(0, d + 1);\n\n  //Make sure initial simplex is positively oriented\n  var o = orient.apply(void 0, initialSimplex);\n  if (o === 0) {\n    throw new Error(\"Input not in general position\");\n  }\n  var initialCoords = new Array(d + 1);\n  for (var i = 0; i <= d; ++i) {\n    initialCoords[i] = i;\n  }\n  if (o < 0) {\n    initialCoords[0] = 1;\n    initialCoords[1] = 0;\n  }\n\n  //Create initial topological index, glue pointers together (kind of messy)\n  var initialCell = new Simplex(initialCoords, new Array(d + 1), false);\n  var boundary = initialCell.adjacent;\n  var list = new Array(d + 2);\n  for (var i = 0; i <= d; ++i) {\n    var verts = initialCoords.slice();\n    for (var j = 0; j <= d; ++j) {\n      if (j === i) {\n        verts[j] = -1;\n      }\n    }\n    var t = verts[0];\n    verts[0] = verts[1];\n    verts[1] = t;\n    var cell = new Simplex(verts, new Array(d + 1), true);\n    boundary[i] = cell;\n    list[i] = cell;\n  }\n  list[d + 1] = initialCell;\n  for (var i = 0; i <= d; ++i) {\n    var verts = boundary[i].vertices;\n    var adj = boundary[i].adjacent;\n    for (var j = 0; j <= d; ++j) {\n      var v = verts[j];\n      if (v < 0) {\n        adj[j] = initialCell;\n        continue;\n      }\n      for (var k = 0; k <= d; ++k) {\n        if (boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k];\n        }\n      }\n    }\n  }\n\n  //Initialize triangles\n  var triangles = new Triangulation(d, initialSimplex, list);\n\n  //Insert remaining points\n  var useRandom = !!randomSearch;\n  for (var i = d + 1; i < n; ++i) {\n    triangles.insert(points[i], useRandom);\n  }\n\n  //Extract boundary cells\n  return triangles.boundary();\n}","map":{"version":3,"names":["module","exports","incrementalConvexHull","orient","require","compareCell","compareCells","compareInt","a","b","Simplex","vertices","adjacent","boundary","lastVisited","prototype","flip","t","u","GlueFacet","cell","index","compareGlue","bakeOrient","d","code","i","push","proc","Function","join","test","BAKED","Triangulation","dimension","simplices","interior","filter","c","tuple","Array","o","proto","handleBoundaryDegeneracy","point","n","length","verts","toVisit","pop","cellVerts","cellAdj","neighbor","nv","j","vv","walk","random","initIndex","Math","outerLoop","prev","addPeaks","tovisit","indexOf","glueFacets","indexOfN","indexOfNeg1","na","vverts","slice","vadj","ncell","opposite","uu","nface","nptr","k","sort","ai","bi","insert","cells","nc","bcell","cv","ptr","parity","points","randomSearch","Error","initialSimplex","apply","initialCoords","initialCell","list","adj","v","triangles","useRandom"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/incremental-convex-hull/ich.js"],"sourcesContent":["\"use strict\"\n\n//High level idea:\n// 1. Use Clarkson's incremental construction to find convex hull\n// 2. Point location in triangulation by jump and walk\n\nmodule.exports = incrementalConvexHull\n\nvar orient = require(\"robust-orientation\")\nvar compareCell = require(\"simplicial-complex\").compareCells\n\nfunction compareInt(a, b) {\n  return a - b\n}\n\nfunction Simplex(vertices, adjacent, boundary) {\n  this.vertices = vertices\n  this.adjacent = adjacent\n  this.boundary = boundary\n  this.lastVisited = -1\n}\n\nSimplex.prototype.flip = function() {\n  var t = this.vertices[0]\n  this.vertices[0] = this.vertices[1]\n  this.vertices[1] = t\n  var u = this.adjacent[0]\n  this.adjacent[0] = this.adjacent[1]\n  this.adjacent[1] = u\n}\n\nfunction GlueFacet(vertices, cell, index) {\n  this.vertices = vertices\n  this.cell = cell\n  this.index = index\n}\n\nfunction compareGlue(a, b) {\n  return compareCell(a.vertices, b.vertices)\n}\n\nfunction bakeOrient(d) {\n  var code = [\"function orient(){var tuple=this.tuple;return test(\"]\n  for(var i=0; i<=d; ++i) {\n    if(i > 0) {\n      code.push(\",\")\n    }\n    code.push(\"tuple[\", i, \"]\")\n  }\n  code.push(\")}return orient\")\n  var proc = new Function(\"test\", code.join(\"\"))\n  var test = orient[d+1]\n  if(!test) {\n    test = orient\n  }\n  return proc(test)\n}\n\nvar BAKED = []\n\nfunction Triangulation(dimension, vertices, simplices) {\n  this.dimension = dimension\n  this.vertices = vertices\n  this.simplices = simplices\n  this.interior = simplices.filter(function(c) {\n    return !c.boundary\n  })\n\n  this.tuple = new Array(dimension+1)\n  for(var i=0; i<=dimension; ++i) {\n    this.tuple[i] = this.vertices[i]\n  }\n\n  var o = BAKED[dimension]\n  if(!o) {\n    o = BAKED[dimension] = bakeOrient(dimension)\n  }\n  this.orient = o\n}\n\nvar proto = Triangulation.prototype\n\n//Degenerate situation where we are on boundary, but coplanar to face\nproto.handleBoundaryDegeneracy = function(cell, point) {\n  var d = this.dimension\n  var n = this.vertices.length - 1\n  var tuple = this.tuple\n  var verts = this.vertices\n\n  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate\n  var toVisit = [ cell ]\n  cell.lastVisited = -n\n  while(toVisit.length > 0) {\n    cell = toVisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited <= -n) {\n        continue\n      }\n      var nv = neighbor.vertices\n      for(var j=0; j<=d; ++j) {\n        var vv = nv[j]\n        if(vv < 0) {\n          tuple[j] = point\n        } else {\n          tuple[j] = verts[vv]\n        }\n      }\n      var o = this.orient()\n      if(o > 0) {\n        return neighbor\n      }\n      neighbor.lastVisited = -n\n      if(o === 0) {\n        toVisit.push(neighbor)\n      }\n    }\n  }\n  return null\n}\n\nproto.walk = function(point, random) {\n  //Alias local properties\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n\n  //Compute initial jump cell\n  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)\n  var cell = this.interior[ initIndex ]\n\n  //Start walking\nouterLoop:\n  while(!cell.boundary) {\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n\n    for(var i=0; i<=d; ++i) {\n      tuple[i] = verts[cellVerts[i]]\n    }\n    cell.lastVisited = n\n\n    //Find farthest adjacent cell\n    for(var i=0; i<=d; ++i) {\n      var neighbor = cellAdj[i]\n      if(neighbor.lastVisited >= n) {\n        continue\n      }\n      var prev = tuple[i]\n      tuple[i] = point\n      var o = this.orient()\n      tuple[i] = prev\n      if(o < 0) {\n        cell = neighbor\n        continue outerLoop\n      } else {\n        if(!neighbor.boundary) {\n          neighbor.lastVisited = n\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n    }\n    return\n  }\n\n  return cell\n}\n\nproto.addPeaks = function(point, cell) {\n  var n = this.vertices.length - 1\n  var d = this.dimension\n  var verts = this.vertices\n  var tuple = this.tuple\n  var interior = this.interior\n  var simplices = this.simplices\n\n  //Walking finished at boundary, time to add peaks\n  var tovisit = [ cell ]\n\n  //Stretch initial boundary cell into a peak\n  cell.lastVisited = n\n  cell.vertices[cell.vertices.indexOf(-1)] = n\n  cell.boundary = false\n  interior.push(cell)\n\n  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done\n  var glueFacets = []\n\n  //Do a traversal of the boundary walking outward from starting peak\n  while(tovisit.length > 0) {\n    //Pop off peak and walk over adjacent cells\n    var cell = tovisit.pop()\n    var cellVerts = cell.vertices\n    var cellAdj = cell.adjacent\n    var indexOfN = cellVerts.indexOf(n)\n    if(indexOfN < 0) {\n      continue\n    }\n\n    for(var i=0; i<=d; ++i) {\n      if(i === indexOfN) {\n        continue\n      }\n\n      //For each boundary neighbor of the cell\n      var neighbor = cellAdj[i]\n      if(!neighbor.boundary || neighbor.lastVisited >= n) {\n        continue\n      }\n\n      var nv = neighbor.vertices\n\n      //Test if neighbor is a peak\n      if(neighbor.lastVisited !== -n) {      \n        //Compute orientation of p relative to each boundary peak\n        var indexOfNeg1 = 0\n        for(var j=0; j<=d; ++j) {\n          if(nv[j] < 0) {\n            indexOfNeg1 = j\n            tuple[j] = point\n          } else {\n            tuple[j] = verts[nv[j]]\n          }\n        }\n        var o = this.orient()\n\n        //Test if neighbor cell is also a peak\n        if(o > 0) {\n          nv[indexOfNeg1] = n\n          neighbor.boundary = false\n          interior.push(neighbor)\n          tovisit.push(neighbor)\n          neighbor.lastVisited = n\n          continue\n        } else {\n          neighbor.lastVisited = -n\n        }\n      }\n\n      var na = neighbor.adjacent\n\n      //Otherwise, replace neighbor with new face\n      var vverts = cellVerts.slice()\n      var vadj = cellAdj.slice()\n      var ncell = new Simplex(vverts, vadj, true)\n      simplices.push(ncell)\n\n      //Connect to neighbor\n      var opposite = na.indexOf(cell)\n      if(opposite < 0) {\n        continue\n      }\n      na[opposite] = ncell\n      vadj[indexOfN] = neighbor\n\n      //Connect to cell\n      vverts[i] = -1\n      vadj[i] = cell\n      cellAdj[i] = ncell\n\n      //Flip facet\n      ncell.flip()\n\n      //Add to glue list\n      for(var j=0; j<=d; ++j) {\n        var uu = vverts[j]\n        if(uu < 0 || uu === n) {\n          continue\n        }\n        var nface = new Array(d-1)\n        var nptr = 0\n        for(var k=0; k<=d; ++k) {\n          var vv = vverts[k]\n          if(vv < 0 || k === j) {\n            continue\n          }\n          nface[nptr++] = vv\n        }\n        glueFacets.push(new GlueFacet(nface, ncell, j))\n      }\n    }\n  }\n\n  //Glue boundary facets together\n  glueFacets.sort(compareGlue)\n\n  for(var i=0; i+1<glueFacets.length; i+=2) {\n    var a = glueFacets[i]\n    var b = glueFacets[i+1]\n    var ai = a.index\n    var bi = b.index\n    if(ai < 0 || bi < 0) {\n      continue\n    }\n    a.cell.adjacent[a.index] = b.cell\n    b.cell.adjacent[b.index] = a.cell\n  }\n}\n\nproto.insert = function(point, random) {\n  //Add point\n  var verts = this.vertices\n  verts.push(point)\n\n  var cell = this.walk(point, random)\n  if(!cell) {\n    return\n  }\n\n  //Alias local properties\n  var d = this.dimension\n  var tuple = this.tuple\n\n  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary\n  for(var i=0; i<=d; ++i) {\n    var vv = cell.vertices[i]\n    if(vv < 0) {\n      tuple[i] = point\n    } else {\n      tuple[i] = verts[vv]\n    }\n  }\n  var o = this.orient(tuple)\n  if(o < 0) {\n    return\n  } else if(o === 0) {\n    cell = this.handleBoundaryDegeneracy(cell, point)\n    if(!cell) {\n      return\n    }\n  }\n\n  //Add peaks\n  this.addPeaks(point, cell)\n}\n\n//Extract all boundary cells\nproto.boundary = function() {\n  var d = this.dimension\n  var boundary = []\n  var cells = this.simplices\n  var nc = cells.length\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.boundary) {\n      var bcell = new Array(d)\n      var cv = c.vertices\n      var ptr = 0\n      var parity = 0\n      for(var j=0; j<=d; ++j) {\n        if(cv[j] >= 0) {\n          bcell[ptr++] = cv[j]\n        } else {\n          parity = j&1\n        }\n      }\n      if(parity === (d&1)) {\n        var t = bcell[0]\n        bcell[0] = bcell[1]\n        bcell[1] = t\n      }\n      boundary.push(bcell)\n    }\n  }\n  return boundary\n}\n\nfunction incrementalConvexHull(points, randomSearch) {\n  var n = points.length\n  if(n === 0) {\n    throw new Error(\"Must have at least d+1 points\")\n  }\n  var d = points[0].length\n  if(n <= d) {\n    throw new Error(\"Must input at least d+1 points\")\n  }\n\n  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process\n  var initialSimplex = points.slice(0, d+1)\n\n  //Make sure initial simplex is positively oriented\n  var o = orient.apply(void 0, initialSimplex)\n  if(o === 0) {\n    throw new Error(\"Input not in general position\")\n  }\n  var initialCoords = new Array(d+1)\n  for(var i=0; i<=d; ++i) {\n    initialCoords[i] = i\n  }\n  if(o < 0) {\n    initialCoords[0] = 1\n    initialCoords[1] = 0\n  }\n\n  //Create initial topological index, glue pointers together (kind of messy)\n  var initialCell = new Simplex(initialCoords, new Array(d+1), false)\n  var boundary = initialCell.adjacent\n  var list = new Array(d+2)\n  for(var i=0; i<=d; ++i) {\n    var verts = initialCoords.slice()\n    for(var j=0; j<=d; ++j) {\n      if(j === i) {\n        verts[j] = -1\n      }\n    }\n    var t = verts[0]\n    verts[0] = verts[1]\n    verts[1] = t\n    var cell = new Simplex(verts, new Array(d+1), true)\n    boundary[i] = cell\n    list[i] = cell\n  }\n  list[d+1] = initialCell\n  for(var i=0; i<=d; ++i) {\n    var verts = boundary[i].vertices\n    var adj = boundary[i].adjacent\n    for(var j=0; j<=d; ++j) {\n      var v = verts[j]\n      if(v < 0) {\n        adj[j] = initialCell\n        continue\n      }\n      for(var k=0; k<=d; ++k) {\n        if(boundary[k].vertices.indexOf(v) < 0) {\n          adj[j] = boundary[k]\n        }\n      }\n    }\n  }\n\n  //Initialize triangles\n  var triangles = new Triangulation(d, initialSimplex, list)\n\n  //Insert remaining points\n  var useRandom = !!randomSearch\n  for(var i=d+1; i<n; ++i) {\n    triangles.insert(points[i], useRandom)\n  }\n  \n  //Extract boundary cells\n  return triangles.boundary()\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}