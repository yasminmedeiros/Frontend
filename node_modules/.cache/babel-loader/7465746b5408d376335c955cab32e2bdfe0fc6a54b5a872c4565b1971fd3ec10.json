{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar isPlainObject = require('../lib/is_plain_object');\nvar noop = require('../lib/noop');\nvar Loggers = require('../lib/loggers');\nvar sorterAsc = require('../lib/search').sorterAsc;\nvar Registry = require('../registry');\nexports.containerArrayMatch = require('./container_array_match');\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\n  return val === 'add' || isPlainObject(val);\n};\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\n  return val === null || val === 'remove';\n};\n\n/*\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\n * handles them all with a consistent interface.\n *\n * Here are the supported actions -> relayout calls -> edits we get here\n * (as prepared in _relayout):\n *\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\n *               -> {'annotations[2]': null} -> {2: {'': null}}\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\n *                        -> {'annotations': null} -> {'': {'': null}}\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\n *\n * You can combine many edits to different objects. Objects are added and edited\n * in ascending order, then removed in descending order.\n * For example, starting with [a, b, c], if you want to:\n * - replace b with d:\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\n * - add a new item d between a and b, and edit b:\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\n * - delete b and edit c:\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\n *\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\n *\n * @param {HTMLDivElement} gd\n *  the DOM element of the graph container div\n * @param {Lib.nestedProperty} componentType: the array we are editing\n * @param {Object} edits\n *  the changes to make; keys are indices to edit, values are themselves objects:\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\n *  in special values of the empty attr)\n * @param {Object} flags\n *  the flags for which actions we're going to perform to display these (and\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\n *  individual items\n * @param {function} _nestedProperty\n *  a (possibly modified for gui edits) nestedProperty constructor\n *  The modified version takes a 3rd argument, for a prefix to the attribute\n *  string necessary for storing GUI edits\n *\n * @returns {bool} `true` if it managed to complete drawing of the changes\n *  `false` would mean the parent should replot.\n */\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {\n  var componentType = np.astr;\n  var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');\n  var draw = Registry.getComponentMethod(componentType, 'draw');\n  var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n  var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  if (edits['']) {\n    if (Object.keys(edits).length > 1) {\n      Loggers.warn('Full array edits are incompatible with other edits', componentType);\n    }\n    var fullVal = edits[''][''];\n    if (isRemoveVal(fullVal)) np.set(null);else if (Array.isArray(fullVal)) np.set(fullVal);else {\n      Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\n      return true;\n    }\n    if (replotLater) return false;\n    supplyComponentDefaults(layout, fullLayout);\n    draw(gd);\n    return true;\n  }\n  var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);\n  var componentArrayIn = np.get();\n  var componentArray = componentArrayIn || [];\n  // componentArrayFull is used just to keep splices in line between\n  // full and input arrays, so private keys can be copied over after\n  // redoing supplyDefaults\n  // TODO: this assumes componentArray is in gd.layout - which will not be\n  // true after we extend this to restyle\n  var componentArrayFull = _nestedProperty(fullLayout, componentType).get();\n  var deletes = [];\n  var firstIndexChange = -1;\n  var maxIndex = componentArray.length;\n  var i;\n  var j;\n  var componentNum;\n  var objEdits;\n  var objKeys;\n  var objVal;\n  var adding, prefix;\n\n  // first make the add and edit changes\n  for (i = 0; i < componentNums.length; i++) {\n    componentNum = componentNums[i];\n    objEdits = edits[componentNum];\n    objKeys = Object.keys(objEdits);\n    objVal = objEdits[''], adding = isAddVal(objVal);\n    if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\n      Loggers.warn('index out of range', componentType, componentNum);\n      continue;\n    }\n    if (objVal !== undefined) {\n      if (objKeys.length > 1) {\n        Loggers.warn('Insertion & removal are incompatible with edits to the same index.', componentType, componentNum);\n      }\n      if (isRemoveVal(objVal)) {\n        deletes.push(componentNum);\n      } else if (adding) {\n        if (objVal === 'add') objVal = {};\n        componentArray.splice(componentNum, 0, objVal);\n        if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\n      } else {\n        Loggers.warn('Unrecognized full object edit value', componentType, componentNum, objVal);\n      }\n      if (firstIndexChange === -1) firstIndexChange = componentNum;\n    } else {\n      for (j = 0; j < objKeys.length; j++) {\n        prefix = componentType + '[' + componentNum + '].';\n        _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);\n      }\n    }\n  }\n\n  // now do deletes\n  for (i = deletes.length - 1; i >= 0; i--) {\n    componentArray.splice(deletes[i], 1);\n    // TODO: this drops private keys that had been stored in componentArrayFull\n    // does this have any ill effects?\n    if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);\n  }\n  if (!componentArray.length) np.set(null);else if (!componentArrayIn) np.set(componentArray);\n  if (replotLater) return false;\n  supplyComponentDefaults(layout, fullLayout);\n\n  // finally draw all the components we need to\n  // if we added or removed any, redraw all after it\n  if (drawOne !== noop) {\n    var indicesToDraw;\n    if (firstIndexChange === -1) {\n      // there's no re-indexing to do, so only redraw components that changed\n      indicesToDraw = componentNums;\n    } else {\n      // in case the component array was shortened, we still need do call\n      // drawOne on the latter items so they get properly removed\n      maxIndex = Math.max(componentArray.length, maxIndex);\n      indicesToDraw = [];\n      for (i = 0; i < componentNums.length; i++) {\n        componentNum = componentNums[i];\n        if (componentNum >= firstIndexChange) break;\n        indicesToDraw.push(componentNum);\n      }\n      for (i = firstIndexChange; i < maxIndex; i++) {\n        indicesToDraw.push(i);\n      }\n    }\n    for (i = 0; i < indicesToDraw.length; i++) {\n      drawOne(gd, indicesToDraw[i]);\n    }\n  } else draw(gd);\n  return true;\n};","map":{"version":3,"names":["isPlainObject","require","noop","Loggers","sorterAsc","Registry","exports","containerArrayMatch","isAddVal","val","isRemoveVal","applyContainerArrayChanges","gd","np","edits","flags","_nestedProperty","componentType","astr","supplyComponentDefaults","getComponentMethod","draw","drawOne","replotLater","replot","recalc","layout","fullLayout","_fullLayout","Object","keys","length","warn","fullVal","set","Array","isArray","componentNums","map","Number","sort","componentArrayIn","get","componentArray","componentArrayFull","deletes","firstIndexChange","maxIndex","i","j","componentNum","objEdits","objKeys","objVal","adding","prefix","undefined","push","splice","indicesToDraw","Math","max"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plot_api/manage_arrays.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar isPlainObject = require('../lib/is_plain_object');\nvar noop = require('../lib/noop');\nvar Loggers = require('../lib/loggers');\nvar sorterAsc = require('../lib/search').sorterAsc;\nvar Registry = require('../registry');\n\n\nexports.containerArrayMatch = require('./container_array_match');\n\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\n    return val === 'add' || isPlainObject(val);\n};\n\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\n    return val === null || val === 'remove';\n};\n\n/*\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\n * handles them all with a consistent interface.\n *\n * Here are the supported actions -> relayout calls -> edits we get here\n * (as prepared in _relayout):\n *\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\n *               -> {'annotations[2]': null} -> {2: {'': null}}\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\n *                        -> {'annotations': null} -> {'': {'': null}}\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\n *\n * You can combine many edits to different objects. Objects are added and edited\n * in ascending order, then removed in descending order.\n * For example, starting with [a, b, c], if you want to:\n * - replace b with d:\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\n * - add a new item d between a and b, and edit b:\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\n * - delete b and edit c:\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\n *\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\n *\n * @param {HTMLDivElement} gd\n *  the DOM element of the graph container div\n * @param {Lib.nestedProperty} componentType: the array we are editing\n * @param {Object} edits\n *  the changes to make; keys are indices to edit, values are themselves objects:\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\n *  in special values of the empty attr)\n * @param {Object} flags\n *  the flags for which actions we're going to perform to display these (and\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\n *  individual items\n * @param {function} _nestedProperty\n *  a (possibly modified for gui edits) nestedProperty constructor\n *  The modified version takes a 3rd argument, for a prefix to the attribute\n *  string necessary for storing GUI edits\n *\n * @returns {bool} `true` if it managed to complete drawing of the changes\n *  `false` would mean the parent should replot.\n */\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {\n    var componentType = np.astr;\n    var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');\n    var draw = Registry.getComponentMethod(componentType, 'draw');\n    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n    var replotLater = flags.replot || flags.recalc || (supplyComponentDefaults === noop) || (draw === noop);\n    var layout = gd.layout;\n    var fullLayout = gd._fullLayout;\n\n    if(edits['']) {\n        if(Object.keys(edits).length > 1) {\n            Loggers.warn('Full array edits are incompatible with other edits',\n                componentType);\n        }\n\n        var fullVal = edits[''][''];\n\n        if(isRemoveVal(fullVal)) np.set(null);\n        else if(Array.isArray(fullVal)) np.set(fullVal);\n        else {\n            Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\n            return true;\n        }\n\n        if(replotLater) return false;\n\n        supplyComponentDefaults(layout, fullLayout);\n        draw(gd);\n        return true;\n    }\n\n    var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);\n    var componentArrayIn = np.get();\n    var componentArray = componentArrayIn || [];\n    // componentArrayFull is used just to keep splices in line between\n    // full and input arrays, so private keys can be copied over after\n    // redoing supplyDefaults\n    // TODO: this assumes componentArray is in gd.layout - which will not be\n    // true after we extend this to restyle\n    var componentArrayFull = _nestedProperty(fullLayout, componentType).get();\n\n    var deletes = [];\n    var firstIndexChange = -1;\n    var maxIndex = componentArray.length;\n    var i;\n    var j;\n    var componentNum;\n    var objEdits;\n    var objKeys;\n    var objVal;\n    var adding, prefix;\n\n    // first make the add and edit changes\n    for(i = 0; i < componentNums.length; i++) {\n        componentNum = componentNums[i];\n        objEdits = edits[componentNum];\n        objKeys = Object.keys(objEdits);\n        objVal = objEdits[''],\n        adding = isAddVal(objVal);\n\n        if(componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\n            Loggers.warn('index out of range', componentType, componentNum);\n            continue;\n        }\n\n        if(objVal !== undefined) {\n            if(objKeys.length > 1) {\n                Loggers.warn(\n                    'Insertion & removal are incompatible with edits to the same index.',\n                    componentType, componentNum);\n            }\n\n            if(isRemoveVal(objVal)) {\n                deletes.push(componentNum);\n            }\n            else if(adding) {\n                if(objVal === 'add') objVal = {};\n                componentArray.splice(componentNum, 0, objVal);\n                if(componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\n            }\n            else {\n                Loggers.warn('Unrecognized full object edit value',\n                    componentType, componentNum, objVal);\n            }\n\n            if(firstIndexChange === -1) firstIndexChange = componentNum;\n        }\n        else {\n            for(j = 0; j < objKeys.length; j++) {\n                prefix = componentType + '[' + componentNum + '].';\n                _nestedProperty(componentArray[componentNum], objKeys[j], prefix)\n                    .set(objEdits[objKeys[j]]);\n            }\n        }\n    }\n\n    // now do deletes\n    for(i = deletes.length - 1; i >= 0; i--) {\n        componentArray.splice(deletes[i], 1);\n        // TODO: this drops private keys that had been stored in componentArrayFull\n        // does this have any ill effects?\n        if(componentArrayFull) componentArrayFull.splice(deletes[i], 1);\n    }\n\n    if(!componentArray.length) np.set(null);\n    else if(!componentArrayIn) np.set(componentArray);\n\n    if(replotLater) return false;\n\n    supplyComponentDefaults(layout, fullLayout);\n\n    // finally draw all the components we need to\n    // if we added or removed any, redraw all after it\n    if(drawOne !== noop) {\n        var indicesToDraw;\n        if(firstIndexChange === -1) {\n            // there's no re-indexing to do, so only redraw components that changed\n            indicesToDraw = componentNums;\n        }\n        else {\n            // in case the component array was shortened, we still need do call\n            // drawOne on the latter items so they get properly removed\n            maxIndex = Math.max(componentArray.length, maxIndex);\n            indicesToDraw = [];\n            for(i = 0; i < componentNums.length; i++) {\n                componentNum = componentNums[i];\n                if(componentNum >= firstIndexChange) break;\n                indicesToDraw.push(componentNum);\n            }\n            for(i = firstIndexChange; i < maxIndex; i++) {\n                indicesToDraw.push(i);\n            }\n        }\n        for(i = 0; i < indicesToDraw.length; i++) {\n            drawOne(gd, indicesToDraw[i]);\n        }\n    }\n    else draw(gd);\n\n    return true;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}