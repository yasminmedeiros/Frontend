{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\nfunction copyArgArray(gd, args) {\n  var copy = [];\n  var arg;\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (arg === gd) copy[i] = arg;else if (typeof arg === 'object') {\n      copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);\n    } else copy[i] = arg;\n  }\n  return copy;\n}\n\n// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\nvar queue = {};\n\n// TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\nqueue.add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n  var queueObj, queueIndex;\n\n  // make sure we have the queue and our position in it\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  queueIndex = gd.undoQueue.index;\n\n  // if we're already playing an undo or redo, or if this is an auto operation\n  // (like pane resize... any others?) then we don't save this to the undo queue\n  if (gd.autoplay) {\n    if (!gd.undoQueue.inSequence) gd.autoplay = false;\n    return;\n  }\n\n  // if we're not in a sequence or are just starting, we need a new queue item\n  if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n    queueObj = {\n      undo: {\n        calls: [],\n        args: []\n      },\n      redo: {\n        calls: [],\n        args: []\n      }\n    };\n    gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n    gd.undoQueue.index += 1;\n  } else {\n    queueObj = gd.undoQueue.queue[queueIndex - 1];\n  }\n  gd.undoQueue.beginSequence = false;\n\n  // we unshift to handle calls for undo in a forward for loop later\n  if (queueObj) {\n    queueObj.undo.calls.unshift(undoFunc);\n    queueObj.undo.args.unshift(undoArgs);\n    queueObj.redo.calls.push(redoFunc);\n    queueObj.redo.args.push(redoArgs);\n  }\n  if (gd.undoQueue.queue.length > dfltConfig.queueLength) {\n    gd.undoQueue.queue.shift();\n    gd.undoQueue.index--;\n  }\n};\n\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\nqueue.startSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = true;\n  gd.undoQueue.beginSequence = true;\n};\n\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\nqueue.stopSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = false;\n  gd.undoQueue.beginSequence = false;\n};\n\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\nqueue.undo = function undo(gd) {\n  var queueObj, i;\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.undo();\n    return;\n  }\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {\n    return;\n  }\n\n  // index is pointing to next *forward* queueObj, point to the one we're undoing\n  gd.undoQueue.index--;\n\n  // get the queueObj for instructions on how to undo\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n  // this sequence keeps things from adding to the queue during undo/redo\n  gd.undoQueue.inSequence = true;\n  for (i = 0; i < queueObj.undo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n  }\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false;\n};\n\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\nqueue.redo = function redo(gd) {\n  var queueObj, i;\n  if (gd.framework && gd.framework.isPolar) {\n    gd.framework.redo();\n    return;\n  }\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {\n    return;\n  }\n\n  // get the queueObj for instructions on how to undo\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n  // this sequence keeps things from adding to the queue during undo/redo\n  gd.undoQueue.inSequence = true;\n  for (i = 0; i < queueObj.redo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n  }\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false;\n\n  // index is pointing to the thing we just redid, move it\n  gd.undoQueue.index++;\n};\n\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\nqueue.plotDo = function (gd, func, args) {\n  gd.autoplay = true;\n\n  // this *won't* copy gd and it preserves `undefined` properties!\n  args = copyArgArray(gd, args);\n\n  // call the supplied function\n  func.apply(null, args);\n};\nmodule.exports = queue;","map":{"version":3,"names":["Lib","require","dfltConfig","copyArgArray","gd","args","copy","arg","i","length","Array","isArray","extendDeep","extendDeepAll","queue","add","undoFunc","undoArgs","redoFunc","redoArgs","queueObj","queueIndex","undoQueue","index","sequence","autoplay","inSequence","beginSequence","undo","calls","redo","splice","unshift","push","queueLength","shift","startSequence","stopSequence","framework","isPolar","undefined","isNaN","plotDo","func","apply","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/lib/queue.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../lib');\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n\n/**\n * Copy arg array *without* removing `undefined` values from objects.\n *\n * @param gd\n * @param args\n * @returns {Array}\n */\nfunction copyArgArray(gd, args) {\n    var copy = [];\n    var arg;\n\n    for(var i = 0; i < args.length; i++) {\n        arg = args[i];\n\n        if(arg === gd) copy[i] = arg;\n        else if(typeof arg === 'object') {\n            copy[i] = Array.isArray(arg) ?\n                Lib.extendDeep([], arg) :\n                Lib.extendDeepAll({}, arg);\n        }\n        else copy[i] = arg;\n    }\n\n    return copy;\n}\n\n\n// -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {};\n\n// TODO: disable/enable undo and redo buttons appropriately\n\n/**\n * Add an item to the undoQueue for a graphDiv\n *\n * @param gd\n * @param undoFunc Function undo this operation\n * @param undoArgs Args to supply undoFunc with\n * @param redoFunc Function to redo this operation\n * @param redoArgs Args to supply redoFunc with\n */\nqueue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n    var queueObj,\n        queueIndex;\n\n    // make sure we have the queue and our position in it\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    queueIndex = gd.undoQueue.index;\n\n    // if we're already playing an undo or redo, or if this is an auto operation\n    // (like pane resize... any others?) then we don't save this to the undo queue\n    if(gd.autoplay) {\n        if(!gd.undoQueue.inSequence) gd.autoplay = false;\n        return;\n    }\n\n    // if we're not in a sequence or are just starting, we need a new queue item\n    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};\n        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n        gd.undoQueue.index += 1;\n    } else {\n        queueObj = gd.undoQueue.queue[queueIndex - 1];\n    }\n    gd.undoQueue.beginSequence = false;\n\n    // we unshift to handle calls for undo in a forward for loop later\n    if(queueObj) {\n        queueObj.undo.calls.unshift(undoFunc);\n        queueObj.undo.args.unshift(undoArgs);\n        queueObj.redo.calls.push(redoFunc);\n        queueObj.redo.args.push(redoArgs);\n    }\n\n    if(gd.undoQueue.queue.length > dfltConfig.queueLength) {\n        gd.undoQueue.queue.shift();\n        gd.undoQueue.index--;\n    }\n};\n\n/**\n * Begin a sequence of undoQueue changes\n *\n * @param gd\n */\nqueue.startSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = true;\n    gd.undoQueue.beginSequence = true;\n};\n\n/**\n * Stop a sequence of undoQueue changes\n *\n * Call this *after* you're sure your undo chain has ended\n *\n * @param gd\n */\nqueue.stopSequence = function(gd) {\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\n    gd.undoQueue.sequence = false;\n    gd.undoQueue.beginSequence = false;\n};\n\n/**\n * Move one step back in the undo queue, and undo the object there.\n *\n * @param gd\n */\nqueue.undo = function undo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.undo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index <= 0) {\n        return;\n    }\n\n    // index is pointing to next *forward* queueObj, point to the one we're undoing\n    gd.undoQueue.index--;\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.undo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n};\n\n/**\n * Redo the current object in the undo, then move forward in the queue.\n *\n * @param gd\n */\nqueue.redo = function redo(gd) {\n    var queueObj, i;\n\n    if(gd.framework && gd.framework.isPolar) {\n        gd.framework.redo();\n        return;\n    }\n    if(gd.undoQueue === undefined ||\n            isNaN(gd.undoQueue.index) ||\n            gd.undoQueue.index >= gd.undoQueue.queue.length) {\n        return;\n    }\n\n    // get the queueObj for instructions on how to undo\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\n\n    // this sequence keeps things from adding to the queue during undo/redo\n    gd.undoQueue.inSequence = true;\n    for(i = 0; i < queueObj.redo.calls.length; i++) {\n        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n    }\n    gd.undoQueue.inSequence = false;\n    gd.autoplay = false;\n\n    // index is pointing to the thing we just redid, move it\n    gd.undoQueue.index++;\n};\n\n/**\n * Called by undo/redo to make the actual changes.\n *\n * Not meant to be called publically, but included for mocking out in tests.\n *\n * @param gd\n * @param func\n * @param args\n */\nqueue.plotDo = function(gd, func, args) {\n    gd.autoplay = true;\n\n    // this *won't* copy gd and it preserves `undefined` properties!\n    args = copyArgArray(gd, args);\n\n    // call the supplied function\n    func.apply(null, args);\n};\n\nmodule.exports = queue;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}