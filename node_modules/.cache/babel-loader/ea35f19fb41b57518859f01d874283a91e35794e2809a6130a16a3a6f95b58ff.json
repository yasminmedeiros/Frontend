{"ast":null,"code":"/*eslint new-cap:0*/\nvar dtype = require('dtype');\nmodule.exports = flattenVertexData;\nfunction flattenVertexData(data, output, offset) {\n  if (!data) throw new TypeError('must specify data as first parameter');\n  offset = +(offset || 0) | 0;\n  if (Array.isArray(data) && data[0] && typeof data[0][0] === 'number') {\n    var dim = data[0].length;\n    var length = data.length * dim;\n    var i, j, k, l;\n\n    // no output specified, create a new typed array\n    if (!output || typeof output === 'string') {\n      output = new (dtype(output || 'float32'))(length + offset);\n    }\n    var dstLength = output.length - offset;\n    if (length !== dstLength) {\n      throw new Error('source length ' + length + ' (' + dim + 'x' + data.length + ')' + ' does not match destination length ' + dstLength);\n    }\n    for (i = 0, k = offset; i < data.length; i++) {\n      for (j = 0; j < dim; j++) {\n        output[k++] = data[i][j] === null ? NaN : data[i][j];\n      }\n    }\n  } else {\n    if (!output || typeof output === 'string') {\n      // no output, create a new one\n      var Ctor = dtype(output || 'float32');\n\n      // handle arrays separately due to possible nulls\n      if (Array.isArray(data) || output === 'array') {\n        output = new Ctor(data.length + offset);\n        for (i = 0, k = offset, l = output.length; k < l; k++, i++) {\n          output[k] = data[i] === null ? NaN : data[i];\n        }\n      } else {\n        if (offset === 0) {\n          output = new Ctor(data);\n        } else {\n          output = new Ctor(data.length + offset);\n          output.set(data, offset);\n        }\n      }\n    } else {\n      // store output in existing array\n      output.set(data, offset);\n    }\n  }\n  return output;\n}","map":{"version":3,"names":["dtype","require","module","exports","flattenVertexData","data","output","offset","TypeError","Array","isArray","dim","length","i","j","k","l","dstLength","Error","NaN","Ctor","set"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/flatten-vertex-data/index.js"],"sourcesContent":["/*eslint new-cap:0*/\nvar dtype = require('dtype')\n\nmodule.exports = flattenVertexData\n\nfunction flattenVertexData (data, output, offset) {\n  if (!data) throw new TypeError('must specify data as first parameter')\n  offset = +(offset || 0) | 0\n\n  if (Array.isArray(data) && (data[0] && typeof data[0][0] === 'number')) {\n    var dim = data[0].length\n    var length = data.length * dim\n    var i, j, k, l\n\n    // no output specified, create a new typed array\n    if (!output || typeof output === 'string') {\n      output = new (dtype(output || 'float32'))(length + offset)\n    }\n\n    var dstLength = output.length - offset\n    if (length !== dstLength) {\n      throw new Error('source length ' + length + ' (' + dim + 'x' + data.length + ')' +\n        ' does not match destination length ' + dstLength)\n    }\n\n    for (i = 0, k = offset; i < data.length; i++) {\n      for (j = 0; j < dim; j++) {\n        output[k++] = data[i][j] === null ? NaN : data[i][j]\n      }\n    }\n  } else {\n    if (!output || typeof output === 'string') {\n      // no output, create a new one\n      var Ctor = dtype(output || 'float32')\n\n      // handle arrays separately due to possible nulls\n      if (Array.isArray(data) || output === 'array') {\n        output = new Ctor(data.length + offset)\n        for (i = 0, k = offset, l = output.length; k < l; k++, i++) {\n          output[k] = data[i] === null ? NaN : data[i]\n        }\n      } else {\n        if (offset === 0) {\n          output = new Ctor(data)\n        } else {\n          output = new Ctor(data.length + offset)\n\n          output.set(data, offset)\n        }\n      }\n    } else {\n      // store output in existing array\n      output.set(data, offset)\n    }\n  }\n\n  return output\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}