{"ast":null,"code":"// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n  // convert a GeoJSON object to a PolyBool polygon\n  toPolygon: function toPolygon(PolyBool, geojson) {\n    // converts list of LineString's to segments\n    function GeoPoly(coords) {\n      // check for empty coords\n      if (coords.length <= 0) return PolyBool.segments({\n        inverted: false,\n        regions: []\n      });\n\n      // convert LineString to segments\n      function LineString(ls) {\n        // remove tail which should be the same as head\n        var reg = ls.slice(0, ls.length - 1);\n        return PolyBool.segments({\n          inverted: false,\n          regions: [reg]\n        });\n      }\n\n      // the first LineString is considered the outside\n      var out = LineString(coords[0]);\n\n      // the rest of the LineStrings are considered interior holes, so subtract them from the\n      // current result\n      for (var i = 1; i < coords.length; i++) {\n        out = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n      }\n      return out;\n    }\n    if (geojson.type === 'Polygon') {\n      // single polygon, so just convert it and we're done\n      return PolyBool.polygon(GeoPoly(geojson.coordinates));\n    } else if (geojson.type === 'MultiPolygon') {\n      // multiple polygons, so union all the polygons together\n      var out = PolyBool.segments({\n        inverted: false,\n        regions: []\n      });\n      for (var i = 0; i < geojson.coordinates.length; i++) {\n        out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n      }\n      return PolyBool.polygon(out);\n    }\n    throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n  },\n  // convert a PolyBool polygon to a GeoJSON object\n  fromPolygon: function fromPolygon(PolyBool, eps, poly) {\n    // make sure out polygon is clean\n    poly = PolyBool.polygon(PolyBool.segments(poly));\n\n    // test if r1 is inside r2\n    function regionInsideRegion(r1, r2) {\n      // we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n      // could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n      // edge of the first line, which cannot be on an edge\n      return eps.pointInsideRegion([(r1[0][0] + r1[1][0]) * 0.5, (r1[0][1] + r1[1][1]) * 0.5], r2);\n    }\n\n    // calculate inside heirarchy\n    //\n    //  _____________________   _______    roots -> A       -> F\n    // |          A          | |   F   |            |          |\n    // |  _______   _______  | |  ___  |            +-- B      +-- G\n    // | |   B   | |   C   | | | |   | |            |   |\n    // | |  ___  | |  ___  | | | |   | |            |   +-- D\n    // | | | D | | | | E | | | | | G | |            |\n    // | | |___| | | |___| | | | |   | |            +-- C\n    // | |_______| |_______| | | |___| |                |\n    // |_____________________| |_______|                +-- E\n\n    function newNode(region) {\n      return {\n        region: region,\n        children: []\n      };\n    }\n    var roots = newNode(null);\n    function addChild(root, region) {\n      // first check if we're inside any children\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n        if (regionInsideRegion(region, child.region)) {\n          // we are, so insert inside them instead\n          addChild(child, region);\n          return;\n        }\n      }\n\n      // not inside any children, so check to see if any children are inside us\n      var node = newNode(region);\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n        if (regionInsideRegion(child.region, region)) {\n          // oops... move the child beneath us, and remove them from root\n          node.children.push(child);\n          root.children.splice(i, 1);\n          i--;\n        }\n      }\n\n      // now we can add ourselves\n      root.children.push(node);\n    }\n\n    // add all regions to the root\n    for (var i = 0; i < poly.regions.length; i++) {\n      var region = poly.regions[i];\n      if (region.length < 3)\n        // regions must have at least 3 points (sanity check)\n        continue;\n      addChild(roots, region);\n    }\n\n    // with our heirarchy, we can distinguish between exterior borders, and interior holes\n    // the root nodes are exterior, children are interior, children's children are exterior,\n    // children's children's children are interior, etc\n\n    // while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n    function forceWinding(region, clockwise) {\n      // first, see if we're clockwise or counter-clockwise\n      // https://en.wikipedia.org/wiki/Shoelace_formula\n      var winding = 0;\n      var last_x = region[region.length - 1][0];\n      var last_y = region[region.length - 1][1];\n      var copy = [];\n      for (var i = 0; i < region.length; i++) {\n        var curr_x = region[i][0];\n        var curr_y = region[i][1];\n        copy.push([curr_x, curr_y]); // create a copy while we're at it\n        winding += curr_y * last_x - curr_x * last_y;\n        last_x = curr_x;\n        last_y = curr_y;\n      }\n      // this assumes Cartesian coordinates (Y is positive going up)\n      var isclockwise = winding < 0;\n      if (isclockwise !== clockwise) copy.reverse();\n      // while we're here, the last point must be the first point...\n      copy.push([copy[0][0], copy[0][1]]);\n      return copy;\n    }\n    var geopolys = [];\n    function addExterior(node) {\n      var poly = [forceWinding(node.region, false)];\n      geopolys.push(poly);\n      // children of exteriors are interior\n      for (var i = 0; i < node.children.length; i++) {\n        poly.push(getInterior(node.children[i]));\n      }\n    }\n    function getInterior(node) {\n      // children of interiors are exterior\n      for (var i = 0; i < node.children.length; i++) {\n        addExterior(node.children[i]);\n      }\n      // return the clockwise interior\n      return forceWinding(node.region, true);\n    }\n\n    // root nodes are exterior\n    for (var i = 0; i < roots.children.length; i++) {\n      addExterior(roots.children[i]);\n    }\n\n    // lastly, construct the approrpriate GeoJSON object\n\n    if (geopolys.length <= 0)\n      // empty GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: []\n      };\n    if (geopolys.length == 1)\n      // use a GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: geopolys[0]\n      };\n    return {\n      // otherwise, use a GeoJSON MultiPolygon\n      type: 'MultiPolygon',\n      coordinates: geopolys\n    };\n  }\n};\nmodule.exports = GeoJSON;","map":{"version":3,"names":["GeoJSON","toPolygon","PolyBool","geojson","GeoPoly","coords","length","segments","inverted","regions","LineString","ls","reg","slice","out","i","selectDifference","combine","type","polygon","coordinates","selectUnion","Error","fromPolygon","eps","poly","regionInsideRegion","r1","r2","pointInsideRegion","newNode","region","children","roots","addChild","root","child","node","push","splice","forceWinding","clockwise","winding","last_x","last_y","copy","curr_x","curr_y","isclockwise","reverse","geopolys","addExterior","getInterior","module","exports"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/polybooljs/lib/geojson.js"],"sourcesContent":["// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\n\nvar GeoJSON = {\n\t// convert a GeoJSON object to a PolyBool polygon\n\ttoPolygon: function(PolyBool, geojson){\n\n\t\t// converts list of LineString's to segments\n\t\tfunction GeoPoly(coords){\n\t\t\t// check for empty coords\n\t\t\tif (coords.length <= 0)\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\n\n\t\t\t// convert LineString to segments\n\t\t\tfunction LineString(ls){\n\t\t\t\t// remove tail which should be the same as head\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\n\t\t\t}\n\n\t\t\t// the first LineString is considered the outside\n\t\t\tvar out = LineString(coords[0]);\n\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\n\t\t\t// current result\n\t\t\tfor (var i = 1; i < coords.length; i++)\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n\t\t\treturn out;\n\t\t}\n\n\t\tif (geojson.type === 'Polygon'){\n\t\t\t// single polygon, so just convert it and we're done\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\n\t\t}\n\t\telse if (geojson.type === 'MultiPolygon'){\n\t\t\t// multiple polygons, so union all the polygons together\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\t\t\treturn PolyBool.polygon(out);\n\t\t}\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n\t},\n\n\t// convert a PolyBool polygon to a GeoJSON object\n\tfromPolygon: function(PolyBool, eps, poly){\n\t\t// make sure out polygon is clean\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\n\n\t\t// test if r1 is inside r2\n\t\tfunction regionInsideRegion(r1, r2){\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n\t\t\t// edge of the first line, which cannot be on an edge\n\t\t\treturn eps.pointInsideRegion([\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\n\t\t\t], r2);\n\t\t}\n\n\t\t// calculate inside heirarchy\n\t\t//\n\t\t//  _____________________   _______    roots -> A       -> F\n\t\t// |          A          | |   F   |            |          |\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\n\t\t// | |   B   | |   C   | | | |   | |            |   |\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\n\t\t// | | | D | | | | E | | | | | G | |            |\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\n\t\t// | |_______| |_______| | | |___| |                |\n\t\t// |_____________________| |_______|                +-- E\n\n\t\tfunction newNode(region){\n\t\t\treturn {\n\t\t\t\tregion: region,\n\t\t\t\tchildren: []\n\t\t\t};\n\t\t}\n\n\t\tvar roots = newNode(null);\n\n\t\tfunction addChild(root, region){\n\t\t\t// first check if we're inside any children\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(region, child.region)){\n\t\t\t\t\t// we are, so insert inside them instead\n\t\t\t\t\taddChild(child, region);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not inside any children, so check to see if any children are inside us\n\t\t\tvar node = newNode(region);\n\t\t\tfor (var i = 0; i < root.children.length; i++){\n\t\t\t\tvar child = root.children[i];\n\t\t\t\tif (regionInsideRegion(child.region, region)){\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\n\t\t\t\t\tnode.children.push(child);\n\t\t\t\t\troot.children.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// now we can add ourselves\n\t\t\troot.children.push(node);\n\t\t}\n\n\t\t// add all regions to the root\n\t\tfor (var i = 0; i < poly.regions.length; i++){\n\t\t\tvar region = poly.regions[i];\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\n\t\t\t\tcontinue;\n\t\t\taddChild(roots, region);\n\t\t}\n\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\n\t\t// children's children's children are interior, etc\n\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\t\tfunction forceWinding(region, clockwise){\n\t\t\t// first, see if we're clockwise or counter-clockwise\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\n\t\t\tvar winding = 0;\n\t\t\tvar last_x = region[region.length - 1][0];\n\t\t\tvar last_y = region[region.length - 1][1];\n\t\t\tvar copy = [];\n\t\t\tfor (var i = 0; i < region.length; i++){\n\t\t\t\tvar curr_x = region[i][0];\n\t\t\t\tvar curr_y = region[i][1];\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\n\t\t\t\tlast_x = curr_x;\n\t\t\t\tlast_y = curr_y;\n\t\t\t}\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\n\t\t\tvar isclockwise = winding < 0;\n\t\t\tif (isclockwise !== clockwise)\n\t\t\t\tcopy.reverse();\n\t\t\t// while we're here, the last point must be the first point...\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\n\t\t\treturn copy;\n\t\t}\n\n\t\tvar geopolys = [];\n\n\t\tfunction addExterior(node){\n\t\t\tvar poly = [forceWinding(node.region, false)];\n\t\t\tgeopolys.push(poly);\n\t\t\t// children of exteriors are interior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\tpoly.push(getInterior(node.children[i]));\n\t\t}\n\n\t\tfunction getInterior(node){\n\t\t\t// children of interiors are exterior\n\t\t\tfor (var i = 0; i < node.children.length; i++)\n\t\t\t\taddExterior(node.children[i]);\n\t\t\t// return the clockwise interior\n\t\t\treturn forceWinding(node.region, true);\n\t\t}\n\n\t\t// root nodes are exterior\n\t\tfor (var i = 0; i < roots.children.length; i++)\n\t\t\taddExterior(roots.children[i]);\n\n\t\t// lastly, construct the approrpriate GeoJSON object\n\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: [] };\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\n\t\t\ttype: 'MultiPolygon',\n\t\t\tcoordinates: geopolys\n\t\t};\n\t}\n};\n\nmodule.exports = GeoJSON;\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,IAAIA,OAAO,GAAG;EACb;EACAC,SAAS,EAAE,mBAASC,QAAQ,EAAEC,OAAO,EAAC;IAErC;IACA,SAASC,OAAO,CAACC,MAAM,EAAC;MACvB;MACA,IAAIA,MAAM,CAACC,MAAM,IAAI,CAAC,EACrB,OAAOJ,QAAQ,CAACK,QAAQ,CAAC;QAAEC,QAAQ,EAAE,KAAK;QAAEC,OAAO,EAAE;MAAG,CAAC,CAAC;;MAE3D;MACA,SAASC,UAAU,CAACC,EAAE,EAAC;QACtB;QACA,IAAIC,GAAG,GAAGD,EAAE,CAACE,KAAK,CAAC,CAAC,EAAEF,EAAE,CAACL,MAAM,GAAG,CAAC,CAAC;QACpC,OAAOJ,QAAQ,CAACK,QAAQ,CAAC;UAAEC,QAAQ,EAAE,KAAK;UAAEC,OAAO,EAAE,CAACG,GAAG;QAAE,CAAC,CAAC;MAC9D;;MAEA;MACA,IAAIE,GAAG,GAAGJ,UAAU,CAACL,MAAM,CAAC,CAAC,CAAC,CAAC;;MAE/B;MACA;MACA,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,MAAM,CAACC,MAAM,EAAES,CAAC,EAAE;QACrCD,GAAG,GAAGZ,QAAQ,CAACc,gBAAgB,CAACd,QAAQ,CAACe,OAAO,CAACH,GAAG,EAAEJ,UAAU,CAACL,MAAM,CAACU,CAAC,CAAC,CAAC,CAAC,CAAC;MAAC;MAE/E,OAAOD,GAAG;IACX;IAEA,IAAIX,OAAO,CAACe,IAAI,KAAK,SAAS,EAAC;MAC9B;MACA,OAAOhB,QAAQ,CAACiB,OAAO,CAACf,OAAO,CAACD,OAAO,CAACiB,WAAW,CAAC,CAAC;IACtD,CAAC,MACI,IAAIjB,OAAO,CAACe,IAAI,KAAK,cAAc,EAAC;MACxC;MACA,IAAIJ,GAAG,GAAGZ,QAAQ,CAACK,QAAQ,CAAC;QAAEC,QAAQ,EAAE,KAAK;QAAEC,OAAO,EAAE;MAAG,CAAC,CAAC;MAC7D,KAAK,IAAIM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,OAAO,CAACiB,WAAW,CAACd,MAAM,EAAES,CAAC,EAAE;QAClDD,GAAG,GAAGZ,QAAQ,CAACmB,WAAW,CAACnB,QAAQ,CAACe,OAAO,CAACH,GAAG,EAAEV,OAAO,CAACD,OAAO,CAACiB,WAAW,CAACL,CAAC,CAAC,CAAC,CAAC,CAAC;MAAC;MACpF,OAAOb,QAAQ,CAACiB,OAAO,CAACL,GAAG,CAAC;IAC7B;IACA,MAAM,IAAIQ,KAAK,CAAC,6DAA6D,CAAC;EAC/E,CAAC;EAED;EACAC,WAAW,EAAE,qBAASrB,QAAQ,EAAEsB,GAAG,EAAEC,IAAI,EAAC;IACzC;IACAA,IAAI,GAAGvB,QAAQ,CAACiB,OAAO,CAACjB,QAAQ,CAACK,QAAQ,CAACkB,IAAI,CAAC,CAAC;;IAEhD;IACA,SAASC,kBAAkB,CAACC,EAAE,EAAEC,EAAE,EAAC;MAClC;MACA;MACA;MACA,OAAOJ,GAAG,CAACK,iBAAiB,CAAC,CAC5B,CAACF,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,EAC3B,CAACA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGA,EAAE,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,GAAG,CAC3B,EAAEC,EAAE,CAAC;IACP;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,SAASE,OAAO,CAACC,MAAM,EAAC;MACvB,OAAO;QACNA,MAAM,EAAEA,MAAM;QACdC,QAAQ,EAAE;MACX,CAAC;IACF;IAEA,IAAIC,KAAK,GAAGH,OAAO,CAAC,IAAI,CAAC;IAEzB,SAASI,QAAQ,CAACC,IAAI,EAAEJ,MAAM,EAAC;MAC9B;MACA,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,IAAI,CAACH,QAAQ,CAAC1B,MAAM,EAAES,CAAC,EAAE,EAAC;QAC7C,IAAIqB,KAAK,GAAGD,IAAI,CAACH,QAAQ,CAACjB,CAAC,CAAC;QAC5B,IAAIW,kBAAkB,CAACK,MAAM,EAAEK,KAAK,CAACL,MAAM,CAAC,EAAC;UAC5C;UACAG,QAAQ,CAACE,KAAK,EAAEL,MAAM,CAAC;UACvB;QACD;MACD;;MAEA;MACA,IAAIM,IAAI,GAAGP,OAAO,CAACC,MAAM,CAAC;MAC1B,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGoB,IAAI,CAACH,QAAQ,CAAC1B,MAAM,EAAES,CAAC,EAAE,EAAC;QAC7C,IAAIqB,KAAK,GAAGD,IAAI,CAACH,QAAQ,CAACjB,CAAC,CAAC;QAC5B,IAAIW,kBAAkB,CAACU,KAAK,CAACL,MAAM,EAAEA,MAAM,CAAC,EAAC;UAC5C;UACAM,IAAI,CAACL,QAAQ,CAACM,IAAI,CAACF,KAAK,CAAC;UACzBD,IAAI,CAACH,QAAQ,CAACO,MAAM,CAACxB,CAAC,EAAE,CAAC,CAAC;UAC1BA,CAAC,EAAE;QACJ;MACD;;MAEA;MACAoB,IAAI,CAACH,QAAQ,CAACM,IAAI,CAACD,IAAI,CAAC;IACzB;;IAEA;IACA,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGU,IAAI,CAAChB,OAAO,CAACH,MAAM,EAAES,CAAC,EAAE,EAAC;MAC5C,IAAIgB,MAAM,GAAGN,IAAI,CAAChB,OAAO,CAACM,CAAC,CAAC;MAC5B,IAAIgB,MAAM,CAACzB,MAAM,GAAG,CAAC;QAAE;QACtB;MACD4B,QAAQ,CAACD,KAAK,EAAEF,MAAM,CAAC;IACxB;;IAEA;IACA;IACA;;IAEA;;IAEA,SAASS,YAAY,CAACT,MAAM,EAAEU,SAAS,EAAC;MACvC;MACA;MACA,IAAIC,OAAO,GAAG,CAAC;MACf,IAAIC,MAAM,GAAGZ,MAAM,CAACA,MAAM,CAACzB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACzC,IAAIsC,MAAM,GAAGb,MAAM,CAACA,MAAM,CAACzB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;MACzC,IAAIuC,IAAI,GAAG,EAAE;MACb,KAAK,IAAI9B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGgB,MAAM,CAACzB,MAAM,EAAES,CAAC,EAAE,EAAC;QACtC,IAAI+B,MAAM,GAAGf,MAAM,CAAChB,CAAC,CAAC,CAAC,CAAC,CAAC;QACzB,IAAIgC,MAAM,GAAGhB,MAAM,CAAChB,CAAC,CAAC,CAAC,CAAC,CAAC;QACzB8B,IAAI,CAACP,IAAI,CAAC,CAACQ,MAAM,EAAEC,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7BL,OAAO,IAAIK,MAAM,GAAGJ,MAAM,GAAGG,MAAM,GAAGF,MAAM;QAC5CD,MAAM,GAAGG,MAAM;QACfF,MAAM,GAAGG,MAAM;MAChB;MACA;MACA,IAAIC,WAAW,GAAGN,OAAO,GAAG,CAAC;MAC7B,IAAIM,WAAW,KAAKP,SAAS,EAC5BI,IAAI,CAACI,OAAO,EAAE;MACf;MACAJ,IAAI,CAACP,IAAI,CAAC,CAACO,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,EAAEA,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;MACnC,OAAOA,IAAI;IACZ;IAEA,IAAIK,QAAQ,GAAG,EAAE;IAEjB,SAASC,WAAW,CAACd,IAAI,EAAC;MACzB,IAAIZ,IAAI,GAAG,CAACe,YAAY,CAACH,IAAI,CAACN,MAAM,EAAE,KAAK,CAAC,CAAC;MAC7CmB,QAAQ,CAACZ,IAAI,CAACb,IAAI,CAAC;MACnB;MACA,KAAK,IAAIV,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,IAAI,CAACL,QAAQ,CAAC1B,MAAM,EAAES,CAAC,EAAE;QAC5CU,IAAI,CAACa,IAAI,CAACc,WAAW,CAACf,IAAI,CAACL,QAAQ,CAACjB,CAAC,CAAC,CAAC,CAAC;MAAC;IAC3C;IAEA,SAASqC,WAAW,CAACf,IAAI,EAAC;MACzB;MACA,KAAK,IAAItB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGsB,IAAI,CAACL,QAAQ,CAAC1B,MAAM,EAAES,CAAC,EAAE;QAC5CoC,WAAW,CAACd,IAAI,CAACL,QAAQ,CAACjB,CAAC,CAAC,CAAC;MAAC;MAC/B;MACA,OAAOyB,YAAY,CAACH,IAAI,CAACN,MAAM,EAAE,IAAI,CAAC;IACvC;;IAEA;IACA,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGkB,KAAK,CAACD,QAAQ,CAAC1B,MAAM,EAAES,CAAC,EAAE;MAC7CoC,WAAW,CAAClB,KAAK,CAACD,QAAQ,CAACjB,CAAC,CAAC,CAAC;IAAC;;IAEhC;;IAEA,IAAImC,QAAQ,CAAC5C,MAAM,IAAI,CAAC;MAAE;MACzB,OAAO;QAAEY,IAAI,EAAE,SAAS;QAAEE,WAAW,EAAE;MAAG,CAAC;IAC5C,IAAI8B,QAAQ,CAAC5C,MAAM,IAAI,CAAC;MAAE;MACzB,OAAO;QAAEY,IAAI,EAAE,SAAS;QAAEE,WAAW,EAAE8B,QAAQ,CAAC,CAAC;MAAE,CAAC;IACrD,OAAO;MAAE;MACRhC,IAAI,EAAE,cAAc;MACpBE,WAAW,EAAE8B;IACd,CAAC;EACF;AACD,CAAC;AAEDG,MAAM,CAACC,OAAO,GAAGtD,OAAO"},"metadata":{},"sourceType":"script","externalDependencies":[]}