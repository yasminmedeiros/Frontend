{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\nvar Drawing = require('../../components/drawing');\nvar subTypes = require('./subtypes');\nvar linePoints = require('./line_points');\nvar linkTraces = require('./link_traces');\nvar polygonTester = require('../../lib/polygon').tester;\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n  var join, onComplete;\n\n  // If transition config is provided, then it is only a partial replot and traces not\n  // updated are removed.\n  var isFullReplot = !transitionOpts;\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n  // Link traces so the z-order of fill layers is correct\n  var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n  join = scatterLayer.selectAll('g.trace').data(cdscatterSorted, function (d) {\n    return d[0].trace.uid;\n  });\n\n  // Append new traces:\n  join.enter().append('g').attr('class', function (d) {\n    return 'trace scatter trace' + d[0].trace.uid;\n  }).style('stroke-miterlimit', 2);\n  join.order();\n  createFills(gd, join, plotinfo);\n  if (hasTransition) {\n    if (makeOnCompleteCallback) {\n      // If it was passed a callback to register completion, make a callback. If\n      // this is created, then it must be executed on completion, otherwise the\n      // pos-transition redraw will not execute:\n      onComplete = makeOnCompleteCallback();\n    }\n    var transition = d3.transition().duration(transitionOpts.duration).ease(transitionOpts.easing).each('end', function () {\n      onComplete && onComplete();\n    }).each('interrupt', function () {\n      onComplete && onComplete();\n    });\n    transition.each(function () {\n      // Must run the selection again since otherwise enters/updates get grouped together\n      // and these get executed out of order. Except we need them in order!\n      scatterLayer.selectAll('g.trace').each(function (d, i) {\n        plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n      });\n    });\n  } else {\n    join.each(function (d, i) {\n      plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n    });\n  }\n  if (isFullReplot) {\n    join.exit().remove();\n  }\n\n  // remove paths that didn't get used\n  scatterLayer.selectAll('path:not([d])').remove();\n};\nfunction createFills(gd, traceJoin, plotinfo) {\n  traceJoin.each(function (d) {\n    var fills = ensureSingle(d3.select(this), 'g', 'fills');\n    Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n    var trace = d[0].trace;\n    var fillData = [];\n    if (trace._ownfill) fillData.push('_ownFill');\n    if (trace._nexttrace) fillData.push('_nextFill');\n    var fillJoin = fills.selectAll('g').data(fillData, identity);\n    fillJoin.enter().append('g');\n    fillJoin.exit().each(function (d) {\n      trace[d] = null;\n    }).remove();\n    fillJoin.order().each(function (d) {\n      // make a path element inside the fill group, just so\n      // we can give it its own data later on and the group can\n      // keep its simple '_*Fill' data\n      trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n    });\n  });\n}\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n  var i;\n\n  // Since this has been reorganized and we're executing this on individual traces,\n  // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n  // since it does an internal n^2 loop over comparisons with other traces:\n  selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n  var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n  function transition(selection) {\n    return hasTransition ? selection.transition() : selection;\n  }\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var trace = cdscatter[0].trace;\n  var line = trace.line;\n  var tr = d3.select(element);\n  var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n  var lines = ensureSingle(tr, 'g', 'lines');\n  var points = ensureSingle(tr, 'g', 'points');\n  var text = ensureSingle(tr, 'g', 'text');\n\n  // error bars are at the bottom\n  Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n  if (trace.visible !== true) return;\n  transition(tr).style('opacity', trace.opacity);\n\n  // BUILD LINES AND FILLS\n  var ownFillEl3, tonext;\n  var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n  if (ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';\n\n  // store node for tweaking by selectPoints\n  if (!plotinfo.isRangePlot) cdscatter[0].node3 = tr;\n  var prevRevpath = '';\n  var prevPolygons = [];\n  var prevtrace = trace._prevtrace;\n  if (prevtrace) {\n    prevRevpath = prevtrace._prevRevpath || '';\n    tonext = prevtrace._nextFill;\n    prevPolygons = prevtrace._polygons;\n  }\n  var thispath;\n  var thisrevpath;\n  // fullpath is all paths for this curve, joined together straight\n  // across gaps, for filling\n  var fullpath = '';\n  // revpath is fullpath reversed, for fill-to-next\n  var revpath = '';\n  // functions for converting a point array to a path\n  var pathfn, revpathbase, revpathfn;\n  // variables used before and after the data join\n  var pt0, lastSegment, pt1, thisPolygons;\n\n  // initialize line join data / method\n  var segments = [];\n  var makeUpdate = Lib.noop;\n  ownFillEl3 = trace._ownFill;\n  if (subTypes.hasLines(trace) || trace.fill !== 'none') {\n    if (tonext) {\n      // This tells .style which trace to use for fill information:\n      tonext.datum(cdscatter);\n    }\n    if (['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n      pathfn = Drawing.steps(line.shape);\n      revpathbase = Drawing.steps(line.shape.split('').reverse().join(''));\n    } else if (line.shape === 'spline') {\n      pathfn = revpathbase = function revpathbase(pts) {\n        var pLast = pts[pts.length - 1];\n        if (pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n          // identical start and end points: treat it as a\n          // closed curve so we don't get a kink\n          return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n        } else {\n          return Drawing.smoothopen(pts, line.smoothing);\n        }\n      };\n    } else {\n      pathfn = revpathbase = function revpathbase(pts) {\n        return 'M' + pts.join('L');\n      };\n    }\n    revpathfn = function revpathfn(pts) {\n      // note: this is destructive (reverses pts in place) so can't use pts after this\n      return revpathbase(pts.reverse());\n    };\n    segments = linePoints(cdscatter, {\n      xaxis: xa,\n      yaxis: ya,\n      connectGaps: trace.connectgaps,\n      baseTolerance: Math.max(line.width || 1, 3) / 4,\n      shape: line.shape,\n      simplify: line.simplify\n    });\n\n    // since we already have the pixel segments here, use them to make\n    // polygons for hover on fill\n    // TODO: can we skip this if hoveron!=fills? That would mean we\n    // need to redraw when you change hoveron...\n    thisPolygons = trace._polygons = new Array(segments.length);\n    for (i = 0; i < segments.length; i++) {\n      trace._polygons[i] = polygonTester(segments[i]);\n    }\n    if (segments.length) {\n      pt0 = segments[0][0];\n      lastSegment = segments[segments.length - 1];\n      pt1 = lastSegment[lastSegment.length - 1];\n    }\n    makeUpdate = function makeUpdate(isEnter) {\n      return function (pts) {\n        thispath = pathfn(pts);\n        thisrevpath = revpathfn(pts);\n        if (!fullpath) {\n          fullpath = thispath;\n          revpath = thisrevpath;\n        } else if (ownFillDir) {\n          fullpath += 'L' + thispath.substr(1);\n          revpath = thisrevpath + ('L' + revpath.substr(1));\n        } else {\n          fullpath += 'Z' + thispath;\n          revpath = thisrevpath + 'Z' + revpath;\n        }\n        if (subTypes.hasLines(trace) && pts.length > 1) {\n          var el = d3.select(this);\n\n          // This makes the coloring work correctly:\n          el.datum(cdscatter);\n          if (isEnter) {\n            transition(el.style('opacity', 0).attr('d', thispath).call(Drawing.lineGroupStyle)).style('opacity', 1);\n          } else {\n            var sel = transition(el);\n            sel.attr('d', thispath);\n            Drawing.singleLineStyle(cdscatter, sel);\n          }\n        }\n      };\n    };\n  }\n  var lineJoin = lines.selectAll('.js-line').data(segments);\n  transition(lineJoin.exit()).style('opacity', 0).remove();\n  lineJoin.each(makeUpdate(false));\n  lineJoin.enter().append('path').classed('js-line', true).style('vector-effect', 'non-scaling-stroke').call(Drawing.lineGroupStyle).each(makeUpdate(true));\n  Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n  function clearFill(selection) {\n    transition(selection).attr('d', 'M0,0Z');\n  }\n  if (segments.length) {\n    if (ownFillEl3) {\n      ownFillEl3.datum(cdscatter);\n      if (pt0 && pt1) {\n        if (ownFillDir) {\n          if (ownFillDir === 'y') {\n            pt0[1] = pt1[1] = ya.c2p(0, true);\n          } else if (ownFillDir === 'x') {\n            pt0[0] = pt1[0] = xa.c2p(0, true);\n          }\n\n          // fill to zero: full trace path, plus extension of\n          // the endpoints to the appropriate axis\n          // For the sake of animations, wrap the points around so that\n          // the points on the axes are the first two points. Otherwise\n          // animations get a little crazy if the number of points changes.\n          transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1)).call(Drawing.singleFillStyle);\n        } else {\n          // fill to self: just join the path to itself\n          transition(ownFillEl3).attr('d', fullpath + 'Z').call(Drawing.singleFillStyle);\n        }\n      }\n    } else if (tonext) {\n      if (trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n        // fill to next: full trace path, plus the previous path reversed\n        if (trace.fill === 'tonext') {\n          // tonext: for use by concentric shapes, like manually constructed\n          // contours, we just add the two paths closed on themselves.\n          // This makes strange results if one path is *not* entirely\n          // inside the other, but then that is a strange usage.\n          transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z').call(Drawing.singleFillStyle);\n        } else {\n          // tonextx/y: for now just connect endpoints with lines. This is\n          // the correct behavior if the endpoints are at the same value of\n          // y/x, but if they *aren't*, we should ideally do more complicated\n          // things depending on whether the new endpoint projects onto the\n          // existing curve or off the end of it\n          transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z').call(Drawing.singleFillStyle);\n        }\n        trace._polygons = trace._polygons.concat(prevPolygons);\n      } else {\n        clearFill(tonext);\n        trace._polygons = null;\n      }\n    }\n    trace._prevRevpath = revpath;\n    trace._prevPolygons = thisPolygons;\n  } else {\n    if (ownFillEl3) clearFill(ownFillEl3);else if (tonext) clearFill(tonext);\n    trace._polygons = trace._prevRevpath = trace._prevPolygons = null;\n  }\n  function visFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap && v.vis;\n    });\n  }\n  function visFilterWithGaps(d) {\n    return d.filter(function (v) {\n      return v.vis;\n    });\n  }\n  function gapFilter(d) {\n    return d.filter(function (v) {\n      return !v.gap;\n    });\n  }\n  function keyFunc(d) {\n    return d.id;\n  }\n\n  // Returns a function if the trace is keyed, otherwise returns undefined\n  function getKeyFunc(trace) {\n    if (trace.ids) {\n      return keyFunc;\n    }\n  }\n  function hideFilter() {\n    return false;\n  }\n  function makePoints(points, text, cdscatter) {\n    var join, selection, hasNode;\n    var trace = cdscatter[0].trace;\n    var showMarkers = subTypes.hasMarkers(trace);\n    var showText = subTypes.hasText(trace);\n    var keyFunc = getKeyFunc(trace);\n    var markerFilter = hideFilter;\n    var textFilter = hideFilter;\n    if (showMarkers || showText) {\n      var showFilter = identity;\n      // if we're stacking, \"infer zero\" gap mode gets markers in the\n      // gap points - because we've inferred a zero there - but other\n      // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n      // we don't draw generated markers\n      var stackGroup = trace.stackgroup;\n      var isInferZero = stackGroup && gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero';\n      if (trace.marker.maxdisplayed || trace._needsCull) {\n        showFilter = isInferZero ? visFilterWithGaps : visFilter;\n      } else if (stackGroup && !isInferZero) {\n        showFilter = gapFilter;\n      }\n      if (showMarkers) markerFilter = showFilter;\n      if (showText) textFilter = showFilter;\n    }\n\n    // marker points\n\n    selection = points.selectAll('path.point');\n    join = selection.data(markerFilter, keyFunc);\n    var enter = join.enter().append('path').classed('point', true);\n    if (hasTransition) {\n      enter.call(Drawing.pointStyle, trace, gd).call(Drawing.translatePoints, xa, ya).style('opacity', 0).transition().style('opacity', 1);\n    }\n    join.order();\n    var styleFns;\n    if (showMarkers) {\n      styleFns = Drawing.makePointStyleFns(trace);\n    }\n    join.each(function (d) {\n      var el = d3.select(this);\n      var sel = transition(el);\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n      if (hasNode) {\n        Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n        if (trace.customdata) {\n          el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n        }\n      } else {\n        sel.remove();\n      }\n    });\n    if (hasTransition) {\n      join.exit().transition().style('opacity', 0).remove();\n    } else {\n      join.exit().remove();\n    }\n\n    // text points\n    selection = text.selectAll('g');\n    join = selection.data(textFilter, keyFunc);\n\n    // each text needs to go in its own 'g' in case\n    // it gets converted to mathjax\n    join.enter().append('g').classed('textpoint', true).append('text');\n    join.order();\n    join.each(function (d) {\n      var g = d3.select(this);\n      var sel = transition(g.select('text'));\n      hasNode = Drawing.translatePoint(d, sel, xa, ya);\n      if (hasNode) {\n        if (plotinfo.layerClipId) {\n          Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n        }\n      } else {\n        g.remove();\n      }\n    });\n    join.selectAll('text').call(Drawing.textPointStyle, trace, gd).each(function (d) {\n      // This just *has* to be totally custom becuase of SVG text positioning :(\n      // It's obviously copied from translatePoint; we just can't use that\n      var x = xa.c2p(d.x);\n      var y = ya.c2p(d.y);\n      d3.select(this).selectAll('tspan.line').each(function () {\n        transition(d3.select(this)).attr({\n          x: x,\n          y: y\n        });\n      });\n    });\n    join.exit().remove();\n  }\n  points.datum(cdscatter);\n  text.datum(cdscatter);\n  makePoints(points, text, cdscatter);\n\n  // lastly, clip points groups of `cliponaxis !== false` traces\n  // on `plotinfo._hasClipOnAxisFalse === true` subplots\n  var hasClipOnAxisFalse = trace.cliponaxis === false;\n  var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n  Drawing.setClipUrl(points, clipUrl, gd);\n  Drawing.setClipUrl(text, clipUrl, gd);\n}\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n  var xa = plotinfo.xaxis;\n  var ya = plotinfo.yaxis;\n  var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n  var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n  var trace = cdscatter[0].trace;\n  if (!subTypes.hasMarkers(trace)) return;\n  // if marker.maxdisplayed is used, select a maximum of\n  // mnum markers to show, from the set that are in the viewport\n  var mnum = trace.marker.maxdisplayed;\n\n  // TODO: remove some as we get away from the viewport?\n  if (mnum === 0) return;\n  var cd = cdscatter.filter(function (v) {\n    return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n  });\n  var inc = Math.ceil(cd.length / mnum);\n  var tnum = 0;\n  cdscatterAll.forEach(function (cdj, j) {\n    var tracei = cdj[0].trace;\n    if (subTypes.hasMarkers(tracei) && tracei.marker.maxdisplayed > 0 && j < idx) {\n      tnum++;\n    }\n  });\n\n  // if multiple traces use maxdisplayed, stagger which markers we\n  // display this formula offsets successive traces by 1/3 of the\n  // increment, adding an extra small amount after each triplet so\n  // it's not quite periodic\n  var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);\n\n  // for error bars: save in cd which markers to show\n  // so we don't have to repeat this\n  cdscatter.forEach(function (v) {\n    delete v.vis;\n  });\n  cd.forEach(function (v, i) {\n    if (Math.round((i + i0) % inc) === 0) v.vis = true;\n  });\n}","map":{"version":3,"names":["d3","require","Registry","Lib","ensureSingle","identity","Drawing","subTypes","linePoints","linkTraces","polygonTester","tester","module","exports","plot","gd","plotinfo","cdscatter","scatterLayer","transitionOpts","makeOnCompleteCallback","join","onComplete","isFullReplot","hasTransition","duration","cdscatterSorted","selectAll","data","d","trace","uid","enter","append","attr","style","order","createFills","transition","ease","easing","each","i","plotOne","exit","remove","traceJoin","fills","select","setClipUrl","layerClipId","fillData","_ownfill","push","_nexttrace","fillJoin","idx","cdscatterAll","element","selectMarkers","selection","xa","xaxis","ya","yaxis","line","tr","errorBarGroup","lines","points","text","getComponentMethod","visible","opacity","ownFillEl3","tonext","ownFillDir","fill","charAt","length","isRangePlot","node3","prevRevpath","prevPolygons","prevtrace","_prevtrace","_prevRevpath","_nextFill","_polygons","thispath","thisrevpath","fullpath","revpath","pathfn","revpathbase","revpathfn","pt0","lastSegment","pt1","thisPolygons","segments","makeUpdate","noop","_ownFill","hasLines","datum","indexOf","shape","steps","split","reverse","pts","pLast","smoothclosed","slice","smoothing","smoothopen","connectGaps","connectgaps","baseTolerance","Math","max","width","simplify","Array","isEnter","substr","el","call","lineGroupStyle","sel","singleLineStyle","lineJoin","classed","clearFill","c2p","singleFillStyle","concat","_prevPolygons","visFilter","filter","v","gap","vis","visFilterWithGaps","gapFilter","keyFunc","id","getKeyFunc","ids","hideFilter","makePoints","hasNode","showMarkers","hasMarkers","showText","hasText","markerFilter","textFilter","showFilter","stackGroup","stackgroup","isInferZero","_fullLayout","_scatterStackOpts","_id","stackgaps","marker","maxdisplayed","_needsCull","pointStyle","translatePoints","styleFns","makePointStyleFns","translatePoint","singlePointStyle","hideOutsideRangePoint","xcalendar","ycalendar","customdata","undefined","g","textPointStyle","x","y","hasClipOnAxisFalse","cliponaxis","clipUrl","xr","extent","simpleMap","range","r2c","yr","mnum","cd","inc","ceil","tnum","forEach","cdj","j","tracei","i0","round","floor"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/scatter/plot.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar d3 = require('d3');\n\nvar Registry = require('../../registry');\nvar Lib = require('../../lib');\nvar ensureSingle = Lib.ensureSingle;\nvar identity = Lib.identity;\nvar Drawing = require('../../components/drawing');\n\nvar subTypes = require('./subtypes');\nvar linePoints = require('./line_points');\nvar linkTraces = require('./link_traces');\nvar polygonTester = require('../../lib/polygon').tester;\n\nmodule.exports = function plot(gd, plotinfo, cdscatter, scatterLayer, transitionOpts, makeOnCompleteCallback) {\n    var join, onComplete;\n\n    // If transition config is provided, then it is only a partial replot and traces not\n    // updated are removed.\n    var isFullReplot = !transitionOpts;\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    // Link traces so the z-order of fill layers is correct\n    var cdscatterSorted = linkTraces(gd, plotinfo, cdscatter);\n\n    join = scatterLayer.selectAll('g.trace')\n        .data(cdscatterSorted, function(d) { return d[0].trace.uid; });\n\n    // Append new traces:\n    join.enter().append('g')\n        .attr('class', function(d) {\n            return 'trace scatter trace' + d[0].trace.uid;\n        })\n        .style('stroke-miterlimit', 2);\n    join.order();\n\n    createFills(gd, join, plotinfo);\n\n    if(hasTransition) {\n        if(makeOnCompleteCallback) {\n            // If it was passed a callback to register completion, make a callback. If\n            // this is created, then it must be executed on completion, otherwise the\n            // pos-transition redraw will not execute:\n            onComplete = makeOnCompleteCallback();\n        }\n\n        var transition = d3.transition()\n            .duration(transitionOpts.duration)\n            .ease(transitionOpts.easing)\n            .each('end', function() {\n                onComplete && onComplete();\n            })\n            .each('interrupt', function() {\n                onComplete && onComplete();\n            });\n\n        transition.each(function() {\n            // Must run the selection again since otherwise enters/updates get grouped together\n            // and these get executed out of order. Except we need them in order!\n            scatterLayer.selectAll('g.trace').each(function(d, i) {\n                plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n            });\n        });\n    } else {\n        join.each(function(d, i) {\n            plotOne(gd, i, plotinfo, d, cdscatterSorted, this, transitionOpts);\n        });\n    }\n\n    if(isFullReplot) {\n        join.exit().remove();\n    }\n\n    // remove paths that didn't get used\n    scatterLayer.selectAll('path:not([d])').remove();\n};\n\nfunction createFills(gd, traceJoin, plotinfo) {\n    traceJoin.each(function(d) {\n        var fills = ensureSingle(d3.select(this), 'g', 'fills');\n        Drawing.setClipUrl(fills, plotinfo.layerClipId, gd);\n\n        var trace = d[0].trace;\n\n        var fillData = [];\n        if(trace._ownfill) fillData.push('_ownFill');\n        if(trace._nexttrace) fillData.push('_nextFill');\n\n        var fillJoin = fills.selectAll('g').data(fillData, identity);\n\n        fillJoin.enter().append('g');\n\n        fillJoin.exit()\n            .each(function(d) { trace[d] = null; })\n            .remove();\n\n        fillJoin.order().each(function(d) {\n            // make a path element inside the fill group, just so\n            // we can give it its own data later on and the group can\n            // keep its simple '_*Fill' data\n            trace[d] = ensureSingle(d3.select(this), 'path', 'js-fill');\n        });\n    });\n}\n\nfunction plotOne(gd, idx, plotinfo, cdscatter, cdscatterAll, element, transitionOpts) {\n    var i;\n\n    // Since this has been reorganized and we're executing this on individual traces,\n    // we need to pass it the full list of cdscatter as well as this trace's index (idx)\n    // since it does an internal n^2 loop over comparisons with other traces:\n    selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll);\n\n    var hasTransition = !!transitionOpts && transitionOpts.duration > 0;\n\n    function transition(selection) {\n        return hasTransition ? selection.transition() : selection;\n    }\n\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n\n    var trace = cdscatter[0].trace;\n    var line = trace.line;\n    var tr = d3.select(element);\n\n    var errorBarGroup = ensureSingle(tr, 'g', 'errorbars');\n    var lines = ensureSingle(tr, 'g', 'lines');\n    var points = ensureSingle(tr, 'g', 'points');\n    var text = ensureSingle(tr, 'g', 'text');\n\n    // error bars are at the bottom\n    Registry.getComponentMethod('errorbars', 'plot')(gd, errorBarGroup, plotinfo, transitionOpts);\n\n    if(trace.visible !== true) return;\n\n    transition(tr).style('opacity', trace.opacity);\n\n    // BUILD LINES AND FILLS\n    var ownFillEl3, tonext;\n    var ownFillDir = trace.fill.charAt(trace.fill.length - 1);\n    if(ownFillDir !== 'x' && ownFillDir !== 'y') ownFillDir = '';\n\n    // store node for tweaking by selectPoints\n    if(!plotinfo.isRangePlot) cdscatter[0].node3 = tr;\n\n    var prevRevpath = '';\n    var prevPolygons = [];\n    var prevtrace = trace._prevtrace;\n\n    if(prevtrace) {\n        prevRevpath = prevtrace._prevRevpath || '';\n        tonext = prevtrace._nextFill;\n        prevPolygons = prevtrace._polygons;\n    }\n\n    var thispath;\n    var thisrevpath;\n    // fullpath is all paths for this curve, joined together straight\n    // across gaps, for filling\n    var fullpath = '';\n    // revpath is fullpath reversed, for fill-to-next\n    var revpath = '';\n    // functions for converting a point array to a path\n    var pathfn, revpathbase, revpathfn;\n    // variables used before and after the data join\n    var pt0, lastSegment, pt1, thisPolygons;\n\n    // initialize line join data / method\n    var segments = [];\n    var makeUpdate = Lib.noop;\n\n    ownFillEl3 = trace._ownFill;\n\n    if(subTypes.hasLines(trace) || trace.fill !== 'none') {\n\n        if(tonext) {\n            // This tells .style which trace to use for fill information:\n            tonext.datum(cdscatter);\n        }\n\n        if(['hv', 'vh', 'hvh', 'vhv'].indexOf(line.shape) !== -1) {\n            pathfn = Drawing.steps(line.shape);\n            revpathbase = Drawing.steps(\n                line.shape.split('').reverse().join('')\n            );\n        }\n        else if(line.shape === 'spline') {\n            pathfn = revpathbase = function(pts) {\n                var pLast = pts[pts.length - 1];\n                if(pts.length > 1 && pts[0][0] === pLast[0] && pts[0][1] === pLast[1]) {\n                    // identical start and end points: treat it as a\n                    // closed curve so we don't get a kink\n                    return Drawing.smoothclosed(pts.slice(1), line.smoothing);\n                }\n                else {\n                    return Drawing.smoothopen(pts, line.smoothing);\n                }\n            };\n        }\n        else {\n            pathfn = revpathbase = function(pts) {\n                return 'M' + pts.join('L');\n            };\n        }\n\n        revpathfn = function(pts) {\n            // note: this is destructive (reverses pts in place) so can't use pts after this\n            return revpathbase(pts.reverse());\n        };\n\n        segments = linePoints(cdscatter, {\n            xaxis: xa,\n            yaxis: ya,\n            connectGaps: trace.connectgaps,\n            baseTolerance: Math.max(line.width || 1, 3) / 4,\n            shape: line.shape,\n            simplify: line.simplify\n        });\n\n        // since we already have the pixel segments here, use them to make\n        // polygons for hover on fill\n        // TODO: can we skip this if hoveron!=fills? That would mean we\n        // need to redraw when you change hoveron...\n        thisPolygons = trace._polygons = new Array(segments.length);\n        for(i = 0; i < segments.length; i++) {\n            trace._polygons[i] = polygonTester(segments[i]);\n        }\n\n        if(segments.length) {\n            pt0 = segments[0][0];\n            lastSegment = segments[segments.length - 1];\n            pt1 = lastSegment[lastSegment.length - 1];\n        }\n\n        makeUpdate = function(isEnter) {\n            return function(pts) {\n                thispath = pathfn(pts);\n                thisrevpath = revpathfn(pts);\n                if(!fullpath) {\n                    fullpath = thispath;\n                    revpath = thisrevpath;\n                }\n                else if(ownFillDir) {\n                    fullpath += 'L' + thispath.substr(1);\n                    revpath = thisrevpath + ('L' + revpath.substr(1));\n                }\n                else {\n                    fullpath += 'Z' + thispath;\n                    revpath = thisrevpath + 'Z' + revpath;\n                }\n\n                if(subTypes.hasLines(trace) && pts.length > 1) {\n                    var el = d3.select(this);\n\n                    // This makes the coloring work correctly:\n                    el.datum(cdscatter);\n\n                    if(isEnter) {\n                        transition(el.style('opacity', 0)\n                            .attr('d', thispath)\n                            .call(Drawing.lineGroupStyle))\n                                .style('opacity', 1);\n                    } else {\n                        var sel = transition(el);\n                        sel.attr('d', thispath);\n                        Drawing.singleLineStyle(cdscatter, sel);\n                    }\n                }\n            };\n        };\n    }\n\n    var lineJoin = lines.selectAll('.js-line').data(segments);\n\n    transition(lineJoin.exit())\n        .style('opacity', 0)\n        .remove();\n\n    lineJoin.each(makeUpdate(false));\n\n    lineJoin.enter().append('path')\n        .classed('js-line', true)\n        .style('vector-effect', 'non-scaling-stroke')\n        .call(Drawing.lineGroupStyle)\n        .each(makeUpdate(true));\n\n    Drawing.setClipUrl(lineJoin, plotinfo.layerClipId, gd);\n\n    function clearFill(selection) {\n        transition(selection).attr('d', 'M0,0Z');\n    }\n\n    if(segments.length) {\n        if(ownFillEl3) {\n            ownFillEl3.datum(cdscatter);\n            if(pt0 && pt1) {\n                if(ownFillDir) {\n                    if(ownFillDir === 'y') {\n                        pt0[1] = pt1[1] = ya.c2p(0, true);\n                    }\n                    else if(ownFillDir === 'x') {\n                        pt0[0] = pt1[0] = xa.c2p(0, true);\n                    }\n\n                    // fill to zero: full trace path, plus extension of\n                    // the endpoints to the appropriate axis\n                    // For the sake of animations, wrap the points around so that\n                    // the points on the axes are the first two points. Otherwise\n                    // animations get a little crazy if the number of points changes.\n                    transition(ownFillEl3).attr('d', 'M' + pt1 + 'L' + pt0 + 'L' + fullpath.substr(1))\n                        .call(Drawing.singleFillStyle);\n                } else {\n                    // fill to self: just join the path to itself\n                    transition(ownFillEl3).attr('d', fullpath + 'Z')\n                        .call(Drawing.singleFillStyle);\n                }\n            }\n        }\n        else if(tonext) {\n            if(trace.fill.substr(0, 6) === 'tonext' && fullpath && prevRevpath) {\n                // fill to next: full trace path, plus the previous path reversed\n                if(trace.fill === 'tonext') {\n                    // tonext: for use by concentric shapes, like manually constructed\n                    // contours, we just add the two paths closed on themselves.\n                    // This makes strange results if one path is *not* entirely\n                    // inside the other, but then that is a strange usage.\n                    transition(tonext).attr('d', fullpath + 'Z' + prevRevpath + 'Z')\n                        .call(Drawing.singleFillStyle);\n                }\n                else {\n                    // tonextx/y: for now just connect endpoints with lines. This is\n                    // the correct behavior if the endpoints are at the same value of\n                    // y/x, but if they *aren't*, we should ideally do more complicated\n                    // things depending on whether the new endpoint projects onto the\n                    // existing curve or off the end of it\n                    transition(tonext).attr('d', fullpath + 'L' + prevRevpath.substr(1) + 'Z')\n                        .call(Drawing.singleFillStyle);\n                }\n                trace._polygons = trace._polygons.concat(prevPolygons);\n            }\n            else {\n                clearFill(tonext);\n                trace._polygons = null;\n            }\n        }\n        trace._prevRevpath = revpath;\n        trace._prevPolygons = thisPolygons;\n    }\n    else {\n        if(ownFillEl3) clearFill(ownFillEl3);\n        else if(tonext) clearFill(tonext);\n        trace._polygons = trace._prevRevpath = trace._prevPolygons = null;\n    }\n\n\n    function visFilter(d) {\n        return d.filter(function(v) { return !v.gap && v.vis; });\n    }\n\n    function visFilterWithGaps(d) {\n        return d.filter(function(v) { return v.vis; });\n    }\n\n    function gapFilter(d) {\n        return d.filter(function(v) { return !v.gap; });\n    }\n\n    function keyFunc(d) {\n        return d.id;\n    }\n\n    // Returns a function if the trace is keyed, otherwise returns undefined\n    function getKeyFunc(trace) {\n        if(trace.ids) {\n            return keyFunc;\n        }\n    }\n\n    function hideFilter() {\n        return false;\n    }\n\n    function makePoints(points, text, cdscatter) {\n        var join, selection, hasNode;\n\n        var trace = cdscatter[0].trace;\n        var showMarkers = subTypes.hasMarkers(trace);\n        var showText = subTypes.hasText(trace);\n\n        var keyFunc = getKeyFunc(trace);\n        var markerFilter = hideFilter;\n        var textFilter = hideFilter;\n\n        if(showMarkers || showText) {\n            var showFilter = identity;\n            // if we're stacking, \"infer zero\" gap mode gets markers in the\n            // gap points - because we've inferred a zero there - but other\n            // modes (currently \"interpolate\", later \"interrupt\" hopefully)\n            // we don't draw generated markers\n            var stackGroup = trace.stackgroup;\n            var isInferZero = stackGroup && (\n                gd._fullLayout._scatterStackOpts[xa._id + ya._id][stackGroup].stackgaps === 'infer zero');\n            if(trace.marker.maxdisplayed || trace._needsCull) {\n                showFilter = isInferZero ? visFilterWithGaps : visFilter;\n            }\n            else if(stackGroup && !isInferZero) {\n                showFilter = gapFilter;\n            }\n\n            if(showMarkers) markerFilter = showFilter;\n            if(showText) textFilter = showFilter;\n        }\n\n        // marker points\n\n        selection = points.selectAll('path.point');\n\n        join = selection.data(markerFilter, keyFunc);\n\n        var enter = join.enter().append('path')\n            .classed('point', true);\n\n        if(hasTransition) {\n            enter\n                .call(Drawing.pointStyle, trace, gd)\n                .call(Drawing.translatePoints, xa, ya)\n                .style('opacity', 0)\n                .transition()\n                .style('opacity', 1);\n        }\n\n        join.order();\n\n        var styleFns;\n        if(showMarkers) {\n            styleFns = Drawing.makePointStyleFns(trace);\n        }\n\n        join.each(function(d) {\n            var el = d3.select(this);\n            var sel = transition(el);\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                Drawing.singlePointStyle(d, sel, trace, styleFns, gd);\n\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, sel, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n\n                if(trace.customdata) {\n                    el.classed('plotly-customdata', d.data !== null && d.data !== undefined);\n                }\n            } else {\n                sel.remove();\n            }\n        });\n\n        if(hasTransition) {\n            join.exit().transition()\n                .style('opacity', 0)\n                .remove();\n        } else {\n            join.exit().remove();\n        }\n\n        // text points\n        selection = text.selectAll('g');\n        join = selection.data(textFilter, keyFunc);\n\n        // each text needs to go in its own 'g' in case\n        // it gets converted to mathjax\n        join.enter().append('g').classed('textpoint', true).append('text');\n\n        join.order();\n\n        join.each(function(d) {\n            var g = d3.select(this);\n            var sel = transition(g.select('text'));\n            hasNode = Drawing.translatePoint(d, sel, xa, ya);\n\n            if(hasNode) {\n                if(plotinfo.layerClipId) {\n                    Drawing.hideOutsideRangePoint(d, g, xa, ya, trace.xcalendar, trace.ycalendar);\n                }\n            } else {\n                g.remove();\n            }\n        });\n\n        join.selectAll('text')\n            .call(Drawing.textPointStyle, trace, gd)\n            .each(function(d) {\n                // This just *has* to be totally custom becuase of SVG text positioning :(\n                // It's obviously copied from translatePoint; we just can't use that\n                var x = xa.c2p(d.x);\n                var y = ya.c2p(d.y);\n\n                d3.select(this).selectAll('tspan.line').each(function() {\n                    transition(d3.select(this)).attr({x: x, y: y});\n                });\n            });\n\n        join.exit().remove();\n    }\n\n    points.datum(cdscatter);\n    text.datum(cdscatter);\n    makePoints(points, text, cdscatter);\n\n    // lastly, clip points groups of `cliponaxis !== false` traces\n    // on `plotinfo._hasClipOnAxisFalse === true` subplots\n    var hasClipOnAxisFalse = trace.cliponaxis === false;\n    var clipUrl = hasClipOnAxisFalse ? null : plotinfo.layerClipId;\n    Drawing.setClipUrl(points, clipUrl, gd);\n    Drawing.setClipUrl(text, clipUrl, gd);\n}\n\nfunction selectMarkers(gd, idx, plotinfo, cdscatter, cdscatterAll) {\n    var xa = plotinfo.xaxis;\n    var ya = plotinfo.yaxis;\n    var xr = d3.extent(Lib.simpleMap(xa.range, xa.r2c));\n    var yr = d3.extent(Lib.simpleMap(ya.range, ya.r2c));\n\n    var trace = cdscatter[0].trace;\n    if(!subTypes.hasMarkers(trace)) return;\n    // if marker.maxdisplayed is used, select a maximum of\n    // mnum markers to show, from the set that are in the viewport\n    var mnum = trace.marker.maxdisplayed;\n\n    // TODO: remove some as we get away from the viewport?\n    if(mnum === 0) return;\n\n    var cd = cdscatter.filter(function(v) {\n        return v.x >= xr[0] && v.x <= xr[1] && v.y >= yr[0] && v.y <= yr[1];\n    });\n    var inc = Math.ceil(cd.length / mnum);\n    var tnum = 0;\n    cdscatterAll.forEach(function(cdj, j) {\n        var tracei = cdj[0].trace;\n        if(subTypes.hasMarkers(tracei) &&\n                tracei.marker.maxdisplayed > 0 && j < idx) {\n            tnum++;\n        }\n    });\n\n    // if multiple traces use maxdisplayed, stagger which markers we\n    // display this formula offsets successive traces by 1/3 of the\n    // increment, adding an extra small amount after each triplet so\n    // it's not quite periodic\n    var i0 = Math.round(tnum * inc / 3 + Math.floor(tnum / 3) * inc / 7.1);\n\n    // for error bars: save in cd which markers to show\n    // so we don't have to repeat this\n    cdscatter.forEach(function(v) { delete v.vis; });\n    cd.forEach(function(v, i) {\n        if(Math.round((i + i0) % inc) === 0) v.vis = true;\n    });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}