{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\nvar Lib = require('../../lib');\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar Registry = require('../../registry');\nvar helpers = require('./helpers');\nvar constants = require('./constants');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n  gd = Lib.getGraphDiv(gd);\n  Lib.throttle(gd._fullLayout._uid + constants.HOVERID, constants.HOVERMINTIME, function () {\n    _hover(gd, evt, subplot, noHoverEvent);\n  });\n};\n\n/*\n * Draw a single hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n */\nexports.loneHover = function loneHover(hoverItem, opts) {\n  var pointData = {\n    color: hoverItem.color || Color.defaultLine,\n    x0: hoverItem.x0 || hoverItem.x || 0,\n    x1: hoverItem.x1 || hoverItem.x || 0,\n    y0: hoverItem.y0 || hoverItem.y || 0,\n    y1: hoverItem.y1 || hoverItem.y || 0,\n    xLabel: hoverItem.xLabel,\n    yLabel: hoverItem.yLabel,\n    zLabel: hoverItem.zLabel,\n    text: hoverItem.text,\n    name: hoverItem.name,\n    idealAlign: hoverItem.idealAlign,\n    // optional extra bits of styling\n    borderColor: hoverItem.borderColor,\n    fontFamily: hoverItem.fontFamily,\n    fontSize: hoverItem.fontSize,\n    fontColor: hoverItem.fontColor,\n    // filler to make createHoverText happy\n    trace: hoverItem.trace || {\n      index: 0,\n      hoverinfo: ''\n    },\n    xa: {\n      _offset: 0\n    },\n    ya: {\n      _offset: 0\n    },\n    index: 0,\n    hovertemplate: hoverItem.hovertemplate || false,\n    eventData: hoverItem.eventData || false,\n    hovertemplateLabels: hoverItem.hovertemplateLabels || false\n  };\n  var container3 = d3.select(opts.container);\n  var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n  var fullOpts = {\n    hovermode: 'closest',\n    rotateLabels: false,\n    bgColor: opts.bgColor || Color.background,\n    container: container3,\n    outerContainer: outerContainer3\n  };\n  var hoverLabel = createHoverText([pointData], fullOpts, opts.gd);\n  alignHoverText(hoverLabel, fullOpts.rotateLabels);\n  return hoverLabel.node();\n};\nexports.multiHovers = function multiHovers(hoverItems, opts) {\n  if (!Array.isArray(hoverItems)) {\n    hoverItems = [hoverItems];\n  }\n  var pointsData = hoverItems.map(function (hoverItem) {\n    return {\n      color: hoverItem.color || Color.defaultLine,\n      x0: hoverItem.x0 || hoverItem.x || 0,\n      x1: hoverItem.x1 || hoverItem.x || 0,\n      y0: hoverItem.y0 || hoverItem.y || 0,\n      y1: hoverItem.y1 || hoverItem.y || 0,\n      xLabel: hoverItem.xLabel,\n      yLabel: hoverItem.yLabel,\n      zLabel: hoverItem.zLabel,\n      text: hoverItem.text,\n      name: hoverItem.name,\n      idealAlign: hoverItem.idealAlign,\n      // optional extra bits of styling\n      borderColor: hoverItem.borderColor,\n      fontFamily: hoverItem.fontFamily,\n      fontSize: hoverItem.fontSize,\n      fontColor: hoverItem.fontColor,\n      // filler to make createHoverText happy\n      trace: hoverItem.trace || {\n        index: 0,\n        hoverinfo: ''\n      },\n      xa: {\n        _offset: 0\n      },\n      ya: {\n        _offset: 0\n      },\n      index: 0,\n      hovertemplate: hoverItem.hovertemplate || false,\n      eventData: hoverItem.eventData || false,\n      hovertemplateLabels: hoverItem.hovertemplateLabels || false\n    };\n  });\n  var container3 = d3.select(opts.container);\n  var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n  var fullOpts = {\n    hovermode: 'closest',\n    rotateLabels: false,\n    bgColor: opts.bgColor || Color.background,\n    container: container3,\n    outerContainer: outerContainer3\n  };\n  var hoverLabel = createHoverText(pointsData, fullOpts, opts.gd);\n\n  // Fix vertical overlap\n  var tooltipSpacing = 5;\n  var lastBottomY = 0;\n  hoverLabel.sort(function (a, b) {\n    return a.y0 - b.y0;\n  }).each(function (d) {\n    var topY = d.y0 - d.by / 2;\n    if (topY - tooltipSpacing < lastBottomY) {\n      d.offset = lastBottomY - topY + tooltipSpacing;\n    } else {\n      d.offset = 0;\n    }\n    lastBottomY = topY + d.by + d.offset;\n  });\n  alignHoverText(hoverLabel, fullOpts.rotateLabels);\n  return hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n  if (!subplot) subplot = 'xy';\n\n  // if the user passed in an array of subplots,\n  // use those instead of finding overlayed plots\n  var subplots = Array.isArray(subplot) ? subplot : [subplot];\n  var fullLayout = gd._fullLayout;\n  var plots = fullLayout._plots || [];\n  var plotinfo = plots[subplot];\n  var hasCartesian = fullLayout._has('cartesian');\n\n  // list of all overlaid subplots to look at\n  if (plotinfo) {\n    var overlayedSubplots = plotinfo.overlays.map(function (pi) {\n      return pi.id;\n    });\n    subplots = subplots.concat(overlayedSubplots);\n  }\n  var len = subplots.length;\n  var xaArray = new Array(len);\n  var yaArray = new Array(len);\n  var supportsCompare = false;\n  for (var i = 0; i < len; i++) {\n    var spId = subplots[i];\n\n    // 'cartesian' case\n    var plotObj = plots[spId];\n    if (plotObj) {\n      supportsCompare = true;\n\n      // TODO make sure that fullLayout_plots axis refs\n      // get updated properly so that we don't have\n      // to use Axes.getFromId in general.\n\n      xaArray[i] = Axes.getFromId(gd, plotObj.xaxis._id);\n      yaArray[i] = Axes.getFromId(gd, plotObj.yaxis._id);\n      continue;\n    }\n\n    // other subplot types\n    var _subplot = fullLayout[spId]._subplot;\n    xaArray[i] = _subplot.xaxis;\n    yaArray[i] = _subplot.yaxis;\n  }\n  var hovermode = evt.hovermode || fullLayout.hovermode;\n  if (hovermode && !supportsCompare) hovermode = 'closest';\n  if (['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata || gd.querySelector('.zoombox') || gd._dragging) {\n    return dragElement.unhoverRaw(gd, evt);\n  }\n  var hoverdistance = fullLayout.hoverdistance === -1 ? Infinity : fullLayout.hoverdistance;\n  var spikedistance = fullLayout.spikedistance === -1 ? Infinity : fullLayout.spikedistance;\n\n  // hoverData: the set of candidate points we've found to highlight\n  var hoverData = [];\n\n  // searchData: the data to search in. Mostly this is just a copy of\n  // gd.calcdata, filtered to the subplot and overlays we're on\n  // but if a point array is supplied it will be a mapping\n  // of indicated curves\n  var searchData = [];\n\n  // [x|y]valArray: the axis values of the hover event\n  // mapped onto each of the currently selected overlaid subplots\n  var xvalArray, yvalArray;\n  var itemnum, curvenum, cd, trace, subplotId, subploti, mode, xval, yval, pointData, closedataPreviousLength;\n\n  // spikePoints: the set of candidate points we've found to draw spikes to\n  var spikePoints = {\n    hLinePoint: null,\n    vLinePoint: null\n  };\n\n  // does subplot have one (or more) horizontal traces?\n  // This is used to determine whether we rotate the labels or not\n  var hasOneHorizontalTrace = false;\n\n  // Figure out what we're hovering on:\n  // mouse location or user-supplied data\n\n  if (Array.isArray(evt)) {\n    // user specified an array of points to highlight\n    hovermode = 'array';\n    for (itemnum = 0; itemnum < evt.length; itemnum++) {\n      cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n      if (cd) {\n        trace = cd[0].trace;\n        if (cd[0].trace.hoverinfo !== 'skip') {\n          searchData.push(cd);\n          if (trace.orientation === 'h') {\n            hasOneHorizontalTrace = true;\n          }\n        }\n      }\n    }\n  } else {\n    for (curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n      cd = gd.calcdata[curvenum];\n      trace = cd[0].trace;\n      if (trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n        searchData.push(cd);\n        if (trace.orientation === 'h') {\n          hasOneHorizontalTrace = true;\n        }\n      }\n    }\n\n    // [x|y]px: the pixels (from top left) of the mouse location\n    // on the currently selected plot area\n    // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n    var hasUserCalledHover = !evt.target;\n    var xpx, ypx;\n    if (hasUserCalledHover) {\n      if ('xpx' in evt) xpx = evt.xpx;else xpx = xaArray[0]._length / 2;\n      if ('ypx' in evt) ypx = evt.ypx;else ypx = yaArray[0]._length / 2;\n    } else {\n      // fire the beforehover event and quit if it returns false\n      // note that we're only calling this on real mouse events, so\n      // manual calls to fx.hover will always run.\n      if (Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n        return;\n      }\n      var dbb = evt.target.getBoundingClientRect();\n      xpx = evt.clientX - dbb.left;\n      ypx = evt.clientY - dbb.top;\n\n      // in case hover was called from mouseout into hovertext,\n      // it's possible you're not actually over the plot anymore\n      if (xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n        return dragElement.unhoverRaw(gd, evt);\n      }\n    }\n    evt.pointerX = xpx + xaArray[0]._offset;\n    evt.pointerY = ypx + yaArray[0]._offset;\n    if ('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);else xvalArray = helpers.p2c(xaArray, xpx);\n    if ('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);else yvalArray = helpers.p2c(yaArray, ypx);\n    if (!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n      Lib.warn('Fx.hover failed', evt, gd);\n      return dragElement.unhoverRaw(gd, evt);\n    }\n  }\n\n  // the pixel distance to beat as a matching point\n  // in 'x' or 'y' mode this resets for each trace\n  var distance = Infinity;\n\n  // find the closest point in each trace\n  // this is minimum dx and/or dy, depending on mode\n  // and the pixel position for the label (labelXpx, labelYpx)\n  for (curvenum = 0; curvenum < searchData.length; curvenum++) {\n    cd = searchData[curvenum];\n\n    // filter out invisible or broken data\n    if (!cd || !cd[0] || !cd[0].trace || cd[0].trace.visible !== true) continue;\n    trace = cd[0].trace;\n\n    // Explicitly bail out for these two. I don't know how to otherwise prevent\n    // the rest of this function from running and failing\n    if (['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n    if (trace.type === 'splom') {\n      // splom traces do not generate overlay subplots,\n      // it is safe to assume here splom traces correspond to the 0th subplot\n      subploti = 0;\n      subplotId = subplots[subploti];\n    } else {\n      subplotId = helpers.getSubplot(trace);\n      subploti = subplots.indexOf(subplotId);\n    }\n\n    // within one trace mode can sometimes be overridden\n    mode = hovermode;\n\n    // container for new point, also used to pass info into module.hoverPoints\n    pointData = {\n      // trace properties\n      cd: cd,\n      trace: trace,\n      xa: xaArray[subploti],\n      ya: yaArray[subploti],\n      // max distances for hover and spikes - for points that want to show but do not\n      // want to override other points, set distance/spikeDistance equal to max*Distance\n      // and it will not get filtered out but it will be guaranteed to have a greater\n      // distance than any point that calculated a real distance.\n      maxHoverDistance: hoverdistance,\n      maxSpikeDistance: spikedistance,\n      // point properties - override all of these\n      index: false,\n      // point index in trace - only used by plotly.js hoverdata consumers\n      distance: Math.min(distance, hoverdistance),\n      // pixel distance or pseudo-distance\n\n      // distance/pseudo-distance for spikes. This distance should always be calculated\n      // as if in \"closest\" mode, and should only be set if this point should\n      // generate a spike.\n      spikeDistance: Infinity,\n      // in some cases the spikes have different positioning from the hover label\n      // they don't need x0/x1, just one position\n      xSpike: undefined,\n      ySpike: undefined,\n      // where and how to display the hover label\n      color: Color.defaultLine,\n      // trace color\n      name: trace.name,\n      x0: undefined,\n      x1: undefined,\n      y0: undefined,\n      y1: undefined,\n      xLabelVal: undefined,\n      yLabelVal: undefined,\n      zLabelVal: undefined,\n      text: undefined\n    };\n\n    // add ref to subplot object (non-cartesian case)\n    if (fullLayout[subplotId]) {\n      pointData.subplot = fullLayout[subplotId]._subplot;\n    }\n    // add ref to splom scene\n    if (fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n      pointData.scene = fullLayout._splomScenes[trace.uid];\n    }\n    closedataPreviousLength = hoverData.length;\n\n    // for a highlighting array, figure out what\n    // we're searching for with this element\n    if (mode === 'array') {\n      var selection = evt[curvenum];\n      if ('pointNumber' in selection) {\n        pointData.index = selection.pointNumber;\n        mode = 'closest';\n      } else {\n        mode = '';\n        if ('xval' in selection) {\n          xval = selection.xval;\n          mode = 'x';\n        }\n        if ('yval' in selection) {\n          yval = selection.yval;\n          mode = mode ? 'closest' : 'y';\n        }\n      }\n    } else {\n      xval = xvalArray[subploti];\n      yval = yvalArray[subploti];\n    }\n\n    // Now if there is range to look in, find the points to hover.\n    if (hoverdistance !== 0) {\n      if (trace._module && trace._module.hoverPoints) {\n        var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode, fullLayout._hoverlayer);\n        if (newPoints) {\n          var newPoint;\n          for (var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n            newPoint = newPoints[newPointNum];\n            if (isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n              hoverData.push(cleanPoint(newPoint, hovermode));\n            }\n          }\n        }\n      } else {\n        Lib.log('Unrecognized trace type in hover:', trace);\n      }\n    }\n\n    // in closest mode, remove any existing (farther) points\n    // and don't look any farther than this latest point (or points, some\n    // traces like box & violin make multiple hover labels at once)\n    if (hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n      hoverData.splice(0, closedataPreviousLength);\n      distance = hoverData[0].distance;\n    }\n\n    // Now if there is range to look in, find the points to draw the spikelines\n    // Do it only if there is no hoverData\n    if (hasCartesian && spikedistance !== 0) {\n      if (hoverData.length === 0) {\n        pointData.distance = spikedistance;\n        pointData.index = false;\n        var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', fullLayout._hoverlayer);\n        if (closestPoints) {\n          closestPoints = closestPoints.filter(function (point) {\n            // some hover points, like scatter fills, do not allow spikes,\n            // so will generate a hover point but without a valid spikeDistance\n            return point.spikeDistance <= spikedistance;\n          });\n        }\n        if (closestPoints && closestPoints.length) {\n          var tmpPoint;\n          var closestVPoints = closestPoints.filter(function (point) {\n            return point.xa.showspikes;\n          });\n          if (closestVPoints.length) {\n            var closestVPt = closestVPoints[0];\n            if (isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n              tmpPoint = fillSpikePoint(closestVPt);\n              if (!spikePoints.vLinePoint || spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.vLinePoint = tmpPoint;\n              }\n            }\n          }\n          var closestHPoints = closestPoints.filter(function (point) {\n            return point.ya.showspikes;\n          });\n          if (closestHPoints.length) {\n            var closestHPt = closestHPoints[0];\n            if (isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n              tmpPoint = fillSpikePoint(closestHPt);\n              if (!spikePoints.hLinePoint || spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance) {\n                spikePoints.hLinePoint = tmpPoint;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  function selectClosestPoint(pointsData, spikedistance) {\n    var resultPoint = null;\n    var minDistance = Infinity;\n    var thisSpikeDistance;\n    for (var i = 0; i < pointsData.length; i++) {\n      thisSpikeDistance = pointsData[i].spikeDistance;\n      if (thisSpikeDistance < minDistance && thisSpikeDistance <= spikedistance) {\n        resultPoint = pointsData[i];\n        minDistance = thisSpikeDistance;\n      }\n    }\n    return resultPoint;\n  }\n  function fillSpikePoint(point) {\n    if (!point) return null;\n    return {\n      xa: point.xa,\n      ya: point.ya,\n      x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n      y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n      distance: point.distance,\n      spikeDistance: point.spikeDistance,\n      curveNumber: point.trace.index,\n      color: point.color,\n      pointNumber: point.index\n    };\n  }\n  var spikelineOpts = {\n    fullLayout: fullLayout,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    event: evt\n  };\n  var oldspikepoints = gd._spikepoints;\n  var newspikepoints = {\n    vLinePoint: spikePoints.vLinePoint,\n    hLinePoint: spikePoints.hLinePoint\n  };\n  gd._spikepoints = newspikepoints;\n\n  // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n  if (hasCartesian && spikedistance !== 0) {\n    if (hoverData.length !== 0) {\n      var tmpHPointData = hoverData.filter(function (point) {\n        return point.ya.showspikes;\n      });\n      var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance);\n      spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n      var tmpVPointData = hoverData.filter(function (point) {\n        return point.xa.showspikes;\n      });\n      var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance);\n      spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n    }\n  }\n\n  // if hoverData is empty check for the spikes to draw and quit if there are none\n  if (hoverData.length === 0) {\n    var result = dragElement.unhoverRaw(gd, evt);\n    if (hasCartesian && (spikePoints.hLinePoint !== null || spikePoints.vLinePoint !== null)) {\n      if (spikesChanged(oldspikepoints)) {\n        createSpikelines(spikePoints, spikelineOpts);\n      }\n    }\n    return result;\n  }\n  if (hasCartesian) {\n    if (spikesChanged(oldspikepoints)) {\n      createSpikelines(spikePoints, spikelineOpts);\n    }\n  }\n  hoverData.sort(function (d1, d2) {\n    return d1.distance - d2.distance;\n  });\n\n  // lastly, emit custom hover/unhover events\n  var oldhoverdata = gd._hoverdata;\n  var newhoverdata = [];\n\n  // pull out just the data that's useful to\n  // other people and send it to the event\n  for (itemnum = 0; itemnum < hoverData.length; itemnum++) {\n    var pt = hoverData[itemnum];\n    var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n    var ht = false;\n    if (pt.cd[pt.index] && pt.cd[pt.index].ht) ht = pt.cd[pt.index].ht;\n    hoverData[itemnum].hovertemplate = ht || pt.trace.hovertemplate || false;\n    hoverData[itemnum].eventData = [eventData];\n    newhoverdata.push(eventData);\n  }\n  gd._hoverdata = newhoverdata;\n  var rotateLabels = hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1) || hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1;\n  var bgColor = Color.combine(fullLayout.plot_bgcolor || Color.background, fullLayout.paper_bgcolor);\n  var labelOpts = {\n    hovermode: hovermode,\n    rotateLabels: rotateLabels,\n    bgColor: bgColor,\n    container: fullLayout._hoverlayer,\n    outerContainer: fullLayout._paperdiv,\n    commonLabelOpts: fullLayout.hoverlabel,\n    hoverdistance: fullLayout.hoverdistance\n  };\n  var hoverLabels = createHoverText(hoverData, labelOpts, gd);\n  hoverAvoidOverlaps(hoverData, rotateLabels ? 'xa' : 'ya', fullLayout);\n  alignHoverText(hoverLabels, rotateLabels);\n\n  // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n  // we should improve the \"fx\" API so other plots can use it without these hack.\n  if (evt.target && evt.target.tagName) {\n    var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n    overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n  }\n\n  // don't emit events if called manually\n  if (!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n  if (oldhoverdata) {\n    gd.emit('plotly_unhover', {\n      event: evt,\n      points: oldhoverdata\n    });\n  }\n  gd.emit('plotly_hover', {\n    event: evt,\n    points: gd._hoverdata,\n    xaxes: xaArray,\n    yaxes: yaArray,\n    xvals: xvalArray,\n    yvals: yvalArray\n  });\n}\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\nfunction createHoverText(hoverData, opts, gd) {\n  var hovermode = opts.hovermode;\n  var rotateLabels = opts.rotateLabels;\n  var bgColor = opts.bgColor;\n  var container = opts.container;\n  var outerContainer = opts.outerContainer;\n  var commonLabelOpts = opts.commonLabelOpts || {};\n\n  // opts.fontFamily/Size are used for the common label\n  // and as defaults for each hover label, though the individual labels\n  // can override this.\n  var fontFamily = opts.fontFamily || constants.HOVERFONT;\n  var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n  var c0 = hoverData[0];\n  var xa = c0.xa;\n  var ya = c0.ya;\n  var commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel';\n  var t0 = c0[commonAttr];\n  var t00 = (String(t0) || '').split(' ')[0];\n  var outerContainerBB = outerContainer.node().getBoundingClientRect();\n  var outerTop = outerContainerBB.top;\n  var outerWidth = outerContainerBB.width;\n  var outerHeight = outerContainerBB.height;\n\n  // show the common label, if any, on the axis\n  // never show a common label in array mode,\n  // even if sometimes there could be one\n  var showCommonLabel = t0 !== undefined && c0.distance <= opts.hoverdistance && (hovermode === 'x' || hovermode === 'y');\n\n  // all hover traces hoverinfo must contain the hovermode\n  // to have common labels\n  if (showCommonLabel) {\n    var allHaveZ = true;\n    var i, traceHoverinfo;\n    for (i = 0; i < hoverData.length; i++) {\n      if (allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n      traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n      if (traceHoverinfo) {\n        var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n        if (parts.indexOf('all') === -1 && parts.indexOf(hovermode) === -1) {\n          showCommonLabel = false;\n          break;\n        }\n      }\n    }\n\n    // xyz labels put all info in their main label, so have no need of a common label\n    if (allHaveZ) showCommonLabel = false;\n  }\n  var commonLabel = container.selectAll('g.axistext').data(showCommonLabel ? [0] : []);\n  commonLabel.enter().append('g').classed('axistext', true);\n  commonLabel.exit().remove();\n  commonLabel.each(function () {\n    var label = d3.select(this);\n    var lpath = Lib.ensureSingle(label, 'path', '', function (s) {\n      s.style({\n        'stroke-width': '1px'\n      });\n    });\n    var ltext = Lib.ensureSingle(label, 'text', '', function (s) {\n      // prohibit tex interpretation until we can handle\n      // tex and regular text together\n      s.attr('data-notex', 1);\n    });\n    var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n    var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n    var contrastColor = Color.contrast(commonBgColor);\n    lpath.style({\n      fill: commonBgColor,\n      stroke: commonStroke\n    });\n    ltext.text(t0).call(Drawing.font, commonLabelOpts.font.family || fontFamily, commonLabelOpts.font.size || fontSize, commonLabelOpts.font.color || contrastColor).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    label.attr('transform', '');\n    var tbb = ltext.node().getBoundingClientRect();\n    if (hovermode === 'x') {\n      ltext.attr('text-anchor', 'middle').call(svgTextUtils.positionText, 0, xa.side === 'top' ? outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD : outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD);\n      var topsign = xa.side === 'top' ? '-' : '';\n      lpath.attr('d', 'M0,0' + 'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE + 'H' + (HOVERTEXTPAD + tbb.width / 2) + 'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) + 'H-' + (HOVERTEXTPAD + tbb.width / 2) + 'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n      label.attr('transform', 'translate(' + (xa._offset + (c0.x0 + c0.x1) / 2) + ',' + (ya._offset + (xa.side === 'top' ? 0 : ya._length)) + ')');\n    } else {\n      ltext.attr('text-anchor', ya.side === 'right' ? 'start' : 'end').call(svgTextUtils.positionText, (ya.side === 'right' ? 1 : -1) * (HOVERTEXTPAD + HOVERARROWSIZE), outerTop - tbb.top - tbb.height / 2);\n      var leftsign = ya.side === 'right' ? '' : '-';\n      lpath.attr('d', 'M0,0' + 'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE + 'V' + (HOVERTEXTPAD + tbb.height / 2) + 'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) + 'V-' + (HOVERTEXTPAD + tbb.height / 2) + 'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n      label.attr('transform', 'translate(' + (xa._offset + (ya.side === 'right' ? xa._length : 0)) + ',' + (ya._offset + (c0.y0 + c0.y1) / 2) + ')');\n    }\n    // remove the \"close but not quite\" points\n    // because of error bars, only take up to a space\n    hoverData = hoverData.filter(function (d) {\n      return d.zLabelVal !== undefined || (d[commonAttr] || '').split(' ')[0] === t00;\n    });\n  });\n\n  // show all the individual labels\n\n  // first create the objects\n  var hoverLabels = container.selectAll('g.hovertext').data(hoverData, function (d) {\n    return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n  });\n  hoverLabels.enter().append('g').classed('hovertext', true).each(function () {\n    var g = d3.select(this);\n    // trace name label (rect and text.name)\n    g.append('rect').call(Color.fill, Color.addOpacity(bgColor, 0.8));\n    g.append('text').classed('name', true);\n    // trace data label (path and text.nums)\n    g.append('path').style('stroke-width', '1px');\n    g.append('text').classed('nums', true).call(Drawing.font, fontFamily, fontSize);\n  });\n  hoverLabels.exit().remove();\n\n  // then put the text in, position the pointer to the data,\n  // and figure out sizes\n  hoverLabels.each(function (d) {\n    var g = d3.select(this).attr('transform', '');\n    var name = '';\n    var text = '';\n\n    // combine possible non-opaque trace color with bgColor\n    var color0 = d.bgcolor || d.color;\n    // color for 'nums' part of the label\n    var numsColor = Color.combine(Color.opacity(color0) ? color0 : Color.defaultLine, bgColor);\n    // color for 'name' part of the label\n    var nameColor = Color.combine(Color.opacity(d.color) ? d.color : Color.defaultLine, bgColor);\n    // find a contrasting color for border and text\n    var contrastColor = d.borderColor || Color.contrast(numsColor);\n\n    // to get custom 'name' labels pass cleanPoint\n    if (d.nameOverride !== undefined) d.name = d.nameOverride;\n    if (d.name) {\n      name = svgTextUtils.plainText(d.name || '', {\n        len: d.nameLength,\n        allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n      });\n    }\n    if (d.zLabel !== undefined) {\n      if (d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n      if (d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n      text += (text ? 'z: ' : '') + d.zLabel;\n    } else if (showCommonLabel && d[hovermode + 'Label'] === t0) {\n      text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n    } else if (d.xLabel === undefined) {\n      if (d.yLabel !== undefined) text = d.yLabel;\n    } else if (d.yLabel === undefined) text = d.xLabel;else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n    if ((d.text || d.text === 0) && !Array.isArray(d.text)) {\n      text += (text ? '<br>' : '') + d.text;\n    }\n\n    // used by other modules (initially just ternary) that\n    // manage their own hoverinfo independent of cleanPoint\n    // the rest of this will still apply, so such modules\n    // can still put things in (x|y|z)Label, text, and name\n    // and hoverinfo will still determine their visibility\n    if (d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n    // if 'text' is empty at this point,\n    // and hovertemplate is not defined,\n    // put 'name' in main label and don't show secondary label\n    if (text === '' && !d.hovertemplate) {\n      // if 'name' is also empty, remove entire label\n      if (name === '') g.remove();\n      text = name;\n    }\n\n    // hovertemplate\n    var hovertemplate = d.hovertemplate || false;\n    var hovertemplateLabels = d.hovertemplateLabels || d;\n    var eventData = d.eventData[0] || {};\n    if (hovertemplate) {\n      text = Lib.hovertemplateString(hovertemplate, hovertemplateLabels, eventData);\n      text = text.replace(EXTRA_STRING_REGEX, function (match, extra) {\n        name = extra; // Assign name for secondary text label\n        return ''; // Remove from main text label\n      });\n    }\n\n    // main label\n    var tx = g.select('text.nums').call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, d.fontColor || contrastColor).text(text).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n    var tx2 = g.select('text.name');\n    var tx2width = 0;\n    var tx2height = 0;\n\n    // secondary label for non-empty 'name'\n    if (name && name !== text) {\n      tx2.call(Drawing.font, d.fontFamily || fontFamily, d.fontSize || fontSize, nameColor).text(name).attr('data-notex', 1).call(svgTextUtils.positionText, 0, 0).call(svgTextUtils.convertToTspans, gd);\n      var t2bb = tx2.node().getBoundingClientRect();\n      tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n      tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n    } else {\n      tx2.remove();\n      g.select('rect').remove();\n    }\n    g.select('path').style({\n      fill: numsColor,\n      stroke: contrastColor\n    });\n    var tbb = tx.node().getBoundingClientRect();\n    var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n    var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n    var dx = Math.abs(d.x1 - d.x0);\n    var dy = Math.abs(d.y1 - d.y0);\n    var txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width;\n    var anchorStartOK, anchorEndOK;\n    d.ty0 = outerTop - tbb.top;\n    d.bx = tbb.width + 2 * HOVERTEXTPAD;\n    d.by = Math.max(tbb.height + 2 * HOVERTEXTPAD, tx2height);\n    d.anchor = 'start';\n    d.txwidth = tbb.width;\n    d.tx2width = tx2width;\n    d.offset = 0;\n    if (rotateLabels) {\n      d.pos = htx;\n      anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n      anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n      if ((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n        hty -= dy / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        hty += dy / 2;\n        d.anchor = 'start';\n      } else d.anchor = 'middle';\n    } else {\n      d.pos = hty;\n      anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n      anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n      if ((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n        htx -= dx / 2;\n        d.anchor = 'end';\n      } else if (anchorStartOK) {\n        htx += dx / 2;\n        d.anchor = 'start';\n      } else d.anchor = 'middle';\n    }\n    tx.attr('text-anchor', d.anchor);\n    if (tx2width) tx2.attr('text-anchor', d.anchor);\n    g.attr('transform', 'translate(' + htx + ',' + hty + ')' + (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n  });\n  return hoverLabels;\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverData, ax, fullLayout) {\n  var nummoves = 0;\n  var axSign = 1;\n\n  // make groups of touching points\n  var pointgroups = hoverData.map(function (d, i) {\n    var axis = d[ax];\n    var axIsX = axis._id.charAt(0) === 'x';\n    var rng = axis.range;\n    if (!i && rng && rng[0] > rng[1] !== axIsX) axSign = -1;\n    return [{\n      i: i,\n      traceIndex: d.trace.index,\n      dp: 0,\n      pos: d.pos,\n      posref: d.posref,\n      size: d.by * (axIsX ? YFACTOR : 1) / 2,\n      pmin: 0,\n      pmax: axIsX ? fullLayout.width : fullLayout.height\n    }];\n  }).sort(function (a, b) {\n    return a[0].posref - b[0].posref ||\n    // for equal positions, sort trace indices increasing or decreasing\n    // depending on whether the axis is reversed or not... so stacked\n    // traces will generally keep their order even if one trace adds\n    // nothing to the stack.\n    axSign * (b[0].traceIndex - a[0].traceIndex);\n  });\n  var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n  function constrainGroup(grp) {\n    var minPt = grp[0];\n    var maxPt = grp[grp.length - 1];\n\n    // overlap with the top - positive vals are overlaps\n    topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n    // overlap with the bottom - positive vals are overlaps\n    bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n    // check for min overlap first, so that we always\n    // see the largest labels\n    // allow for .01px overlap, so we don't get an\n    // infinite loop from rounding errors\n    if (topOverlap > 0.01) {\n      for (j = grp.length - 1; j >= 0; j--) {\n        grp[j].dp += topOverlap;\n      }\n      donepositioning = false;\n    }\n    if (bottomOverlap < 0.01) return;\n    if (topOverlap < -0.01) {\n      // make sure we're not pushing back and forth\n      for (j = grp.length - 1; j >= 0; j--) {\n        grp[j].dp -= bottomOverlap;\n      }\n      donepositioning = false;\n    }\n    if (!donepositioning) return;\n\n    // no room to fix positioning, delete off-screen points\n\n    // first see how many points we need to delete\n    var deleteCount = 0;\n    for (i = 0; i < grp.length; i++) {\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n    }\n\n    // start by deleting points whose data is off screen\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n      if (pti.pos > minPt.pmax - 1) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n    for (i = 0; i < grp.length; i++) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n\n      // pos has already been constrained to [pmin,pmax]\n      // so look for points close to that to delete\n      if (pti.pos < minPt.pmin + 1) {\n        pti.del = true;\n        deleteCount--;\n\n        // shift the whole group minus into this new space\n        bottomOverlap = pti.size * 2;\n        for (j = grp.length - 1; j >= 0; j--) {\n          grp[j].dp -= bottomOverlap;\n        }\n      }\n    }\n    // then delete points that go off the bottom\n    for (i = grp.length - 1; i >= 0; i--) {\n      if (deleteCount <= 0) break;\n      pti = grp[i];\n      if (pti.pos + pti.dp + pti.size > minPt.pmax) {\n        pti.del = true;\n        deleteCount--;\n      }\n    }\n  }\n\n  // loop through groups, combining them if they overlap,\n  // until nothing moves\n  while (!donepositioning && nummoves <= hoverData.length) {\n    // to avoid infinite loops, don't move more times\n    // than there are traces\n    nummoves++;\n\n    // assume nothing will move in this iteration,\n    // reverse this if it does\n    donepositioning = true;\n    i = 0;\n    while (i < pointgroups.length - 1) {\n      // the higher (g0) and lower (g1) point group\n      var g0 = pointgroups[i];\n      var g1 = pointgroups[i + 1];\n\n      // the lowest point in the higher group (p0)\n      // the highest point in the lower group (p1)\n      var p0 = g0[g0.length - 1];\n      var p1 = g1[0];\n      topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n      // Only group points that lie on the same axes\n      if (topOverlap > 0.01 && p0.pmin === p1.pmin && p0.pmax === p1.pmax) {\n        // push the new point(s) added to this group out of the way\n        for (j = g1.length - 1; j >= 0; j--) {\n          g1[j].dp += topOverlap;\n        }\n\n        // add them to the group\n        g0.push.apply(g0, g1);\n        pointgroups.splice(i + 1, 1);\n\n        // adjust for minimum average movement\n        sumdp = 0;\n        for (j = g0.length - 1; j >= 0; j--) {\n          sumdp += g0[j].dp;\n        }\n        bottomOverlap = sumdp / g0.length;\n        for (j = g0.length - 1; j >= 0; j--) {\n          g0[j].dp -= bottomOverlap;\n        }\n        donepositioning = false;\n      } else i++;\n    }\n\n    // check if we're going off the plot on either side and fix\n    pointgroups.forEach(constrainGroup);\n  }\n\n  // now put these offsets into hoverData\n  for (i = pointgroups.length - 1; i >= 0; i--) {\n    var grp = pointgroups[i];\n    for (j = grp.length - 1; j >= 0; j--) {\n      var pt = grp[j];\n      var hoverPt = hoverData[pt.i];\n      hoverPt.offset = pt.dp;\n      hoverPt.del = pt.del;\n    }\n  }\n}\nfunction alignHoverText(hoverLabels, rotateLabels) {\n  // finally set the text positioning relative to the data and draw the\n  // box around it\n  hoverLabels.each(function (d) {\n    var g = d3.select(this);\n    if (d.del) {\n      g.remove();\n      return;\n    }\n    var horzSign = d.anchor === 'end' ? -1 : 1;\n    var tx = g.select('text.nums');\n    var alignShift = {\n      start: 1,\n      end: -1,\n      middle: 0\n    }[d.anchor];\n    var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n    var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n    var offsetX = 0;\n    var offsetY = d.offset;\n    if (d.anchor === 'middle') {\n      txx -= d.tx2width / 2;\n      tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n    }\n    if (rotateLabels) {\n      offsetY *= -YSHIFTY;\n      offsetX = d.offset * YSHIFTX;\n    }\n    g.select('path').attr('d', d.anchor === 'middle' ?\n    // middle aligned: rect centered on data\n    'M-' + (d.bx / 2 + d.tx2width / 2) + ',' + (offsetY - d.by / 2) + 'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z' :\n    // left or right aligned: side rect with arrow to data\n    'M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) + 'v' + (d.by / 2 - HOVERARROWSIZE) + 'h' + horzSign * d.bx + 'v-' + d.by + 'H' + (horzSign * HOVERARROWSIZE + offsetX) + 'V' + (offsetY - HOVERARROWSIZE) + 'Z');\n    tx.call(svgTextUtils.positionText, txx + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n    if (d.tx2width) {\n      g.select('text.name').call(svgTextUtils.positionText, tx2x + alignShift * HOVERTEXTPAD + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n      g.select('rect').call(Drawing.setRect, tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX, offsetY - d.by / 2 - 1, d.tx2width, d.by + 2);\n    }\n  });\n}\nfunction cleanPoint(d, hovermode) {\n  var index = d.index;\n  var trace = d.trace || {};\n  var cd0 = d.cd[0];\n  var cd = d.cd[index] || {};\n  var getVal = Array.isArray(index) ? function (calcKey, traceKey) {\n    return Lib.castOption(cd0, index, calcKey) || Lib.extractOption({}, trace, '', traceKey);\n  } : function (calcKey, traceKey) {\n    return Lib.extractOption(cd, trace, calcKey, traceKey);\n  };\n  function fill(key, calcKey, traceKey) {\n    var val = getVal(calcKey, traceKey);\n    if (val) d[key] = val;\n  }\n  fill('hoverinfo', 'hi', 'hoverinfo');\n  fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n  fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n  fill('fontFamily', 'htf', 'hoverlabel.font.family');\n  fill('fontSize', 'hts', 'hoverlabel.font.size');\n  fill('fontColor', 'htc', 'hoverlabel.font.color');\n  fill('nameLength', 'hnl', 'hoverlabel.namelength');\n  d.posref = hovermode === 'y' || hovermode === 'closest' && trace.orientation === 'h' ? d.xa._offset + (d.x0 + d.x1) / 2 : d.ya._offset + (d.y0 + d.y1) / 2;\n\n  // then constrain all the positions to be on the plot\n  d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n  d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n  d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n  d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n  // and convert the x and y label values into formatted text\n  if (d.xLabelVal !== undefined) {\n    d.xLabel = 'xLabel' in d ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal);\n    d.xVal = d.xa.c2d(d.xLabelVal);\n  }\n  if (d.yLabelVal !== undefined) {\n    d.yLabel = 'yLabel' in d ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal);\n    d.yVal = d.ya.c2d(d.yLabelVal);\n  }\n\n  // Traces like heatmaps generate the zLabel in their hoverPoints function\n  if (d.zLabelVal !== undefined && d.zLabel === undefined) {\n    d.zLabel = String(d.zLabelVal);\n  }\n\n  // for box means and error bars, add the range to the label\n  if (!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n    var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n    if (d.xerrneg !== undefined) {\n      d.xLabel += ' +' + xeText + ' / -' + Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n    } else d.xLabel += ' ± ' + xeText;\n\n    // small distance penalty for error bars, so that if there are\n    // traces with errors and some without, the error bar label will\n    // hoist up to the point\n    if (hovermode === 'x') d.distance += 1;\n  }\n  if (!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n    var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n    if (d.yerrneg !== undefined) {\n      d.yLabel += ' +' + yeText + ' / -' + Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n    } else d.yLabel += ' ± ' + yeText;\n    if (hovermode === 'y') d.distance += 1;\n  }\n  var infomode = d.hoverinfo || d.trace.hoverinfo;\n  if (infomode && infomode !== 'all') {\n    infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n    if (infomode.indexOf('x') === -1) d.xLabel = undefined;\n    if (infomode.indexOf('y') === -1) d.yLabel = undefined;\n    if (infomode.indexOf('z') === -1) d.zLabel = undefined;\n    if (infomode.indexOf('text') === -1) d.text = undefined;\n    if (infomode.indexOf('name') === -1) d.name = undefined;\n  }\n  return d;\n}\nfunction createSpikelines(closestPoints, opts) {\n  var container = opts.container;\n  var fullLayout = opts.fullLayout;\n  var evt = opts.event;\n  var showY = !!closestPoints.hLinePoint;\n  var showX = !!closestPoints.vLinePoint;\n  var xa, ya;\n\n  // Remove old spikeline items\n  container.selectAll('.spikeline').remove();\n  if (!(showX || showY)) return;\n  var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n  // Horizontal line (to y-axis)\n  if (showY) {\n    var hLinePoint = closestPoints.hLinePoint;\n    var hLinePointX, hLinePointY;\n    xa = hLinePoint && hLinePoint.xa;\n    ya = hLinePoint && hLinePoint.ya;\n    var ySnap = ya.spikesnap;\n    if (ySnap === 'cursor') {\n      hLinePointX = evt.pointerX;\n      hLinePointY = evt.pointerY;\n    } else {\n      hLinePointX = xa._offset + hLinePoint.x;\n      hLinePointY = ya._offset + hLinePoint.y;\n    }\n    var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : hLinePoint.color;\n    var yMode = ya.spikemode;\n    var yThickness = ya.spikethickness;\n    var yColor = ya.spikecolor || dfltHLineColor;\n    var yBB = ya._boundingBox;\n    var xEdge = (yBB.left + yBB.right) / 2 < hLinePointX ? yBB.right : yBB.left;\n    var xBase, xEndSpike;\n    if (yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n      if (yMode.indexOf('toaxis') !== -1) {\n        xBase = xEdge;\n        xEndSpike = hLinePointX;\n      }\n      if (yMode.indexOf('across') !== -1) {\n        xBase = ya._counterSpan[0];\n        xEndSpike = ya._counterSpan[1];\n      }\n\n      // Foreground horizontal line (to y-axis)\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness,\n        stroke: yColor,\n        'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n      }).classed('spikeline', true).classed('crisp', true);\n\n      // Background horizontal Line (to y-axis)\n      container.insert('line', ':first-child').attr({\n        x1: xBase,\n        x2: xEndSpike,\n        y1: hLinePointY,\n        y2: hLinePointY,\n        'stroke-width': yThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    }\n    // Y axis marker\n    if (yMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n        cy: hLinePointY,\n        r: yThickness,\n        fill: yColor\n      }).classed('spikeline', true);\n    }\n  }\n  if (showX) {\n    var vLinePoint = closestPoints.vLinePoint;\n    var vLinePointX, vLinePointY;\n    xa = vLinePoint && vLinePoint.xa;\n    ya = vLinePoint && vLinePoint.ya;\n    var xSnap = xa.spikesnap;\n    if (xSnap === 'cursor') {\n      vLinePointX = evt.pointerX;\n      vLinePointY = evt.pointerY;\n    } else {\n      vLinePointX = xa._offset + vLinePoint.x;\n      vLinePointY = ya._offset + vLinePoint.y;\n    }\n    var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ? Color.contrast(contrastColor) : vLinePoint.color;\n    var xMode = xa.spikemode;\n    var xThickness = xa.spikethickness;\n    var xColor = xa.spikecolor || dfltVLineColor;\n    var xBB = xa._boundingBox;\n    var yEdge = (xBB.top + xBB.bottom) / 2 < vLinePointY ? xBB.bottom : xBB.top;\n    var yBase, yEndSpike;\n    if (xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n      if (xMode.indexOf('toaxis') !== -1) {\n        yBase = yEdge;\n        yEndSpike = vLinePointY;\n      }\n      if (xMode.indexOf('across') !== -1) {\n        yBase = xa._counterSpan[0];\n        yEndSpike = xa._counterSpan[1];\n      }\n\n      // Foreground vertical line (to x-axis)\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness,\n        stroke: xColor,\n        'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n      }).classed('spikeline', true).classed('crisp', true);\n\n      // Background vertical line (to x-axis)\n      container.insert('line', ':first-child').attr({\n        x1: vLinePointX,\n        x2: vLinePointX,\n        y1: yBase,\n        y2: yEndSpike,\n        'stroke-width': xThickness + 2,\n        stroke: contrastColor\n      }).classed('spikeline', true).classed('crisp', true);\n    }\n\n    // X axis marker\n    if (xMode.indexOf('marker') !== -1) {\n      container.insert('circle', ':first-child').attr({\n        cx: vLinePointX,\n        cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n        r: xThickness,\n        fill: xColor\n      }).classed('spikeline', true);\n    }\n  }\n}\nfunction hoverChanged(gd, evt, oldhoverdata) {\n  // don't emit any events if nothing changed\n  if (!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n  for (var i = oldhoverdata.length - 1; i >= 0; i--) {\n    var oldPt = oldhoverdata[i];\n    var newPt = gd._hoverdata[i];\n    if (oldPt.curveNumber !== newPt.curveNumber || String(oldPt.pointNumber) !== String(newPt.pointNumber) || String(oldPt.pointNumbers) !== String(newPt.pointNumbers)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction spikesChanged(gd, oldspikepoints) {\n  // don't relayout the plot because of new spikelines if spikelines points didn't change\n  if (!oldspikepoints) return true;\n  if (oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint || oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint) return true;\n  return false;\n}","map":{"version":3,"names":["d3","require","isNumeric","tinycolor","Lib","Events","svgTextUtils","overrideCursor","Drawing","Color","dragElement","Axes","Registry","helpers","constants","YANGLE","YA_RADIANS","Math","PI","YFACTOR","sin","YSHIFTX","cos","YSHIFTY","HOVERARROWSIZE","HOVERTEXTPAD","exports","hover","gd","evt","subplot","noHoverEvent","getGraphDiv","throttle","_fullLayout","_uid","HOVERID","HOVERMINTIME","_hover","loneHover","hoverItem","opts","pointData","color","defaultLine","x0","x","x1","y0","y","y1","xLabel","yLabel","zLabel","text","name","idealAlign","borderColor","fontFamily","fontSize","fontColor","trace","index","hoverinfo","xa","_offset","ya","hovertemplate","eventData","hovertemplateLabels","container3","select","container","outerContainer3","outerContainer","fullOpts","hovermode","rotateLabels","bgColor","background","hoverLabel","createHoverText","alignHoverText","node","multiHovers","hoverItems","Array","isArray","pointsData","map","tooltipSpacing","lastBottomY","sort","a","b","each","d","topY","by","offset","subplots","fullLayout","plots","_plots","plotinfo","hasCartesian","_has","overlayedSubplots","overlays","pi","id","concat","len","length","xaArray","yaArray","supportsCompare","i","spId","plotObj","getFromId","xaxis","_id","yaxis","_subplot","indexOf","calcdata","querySelector","_dragging","unhoverRaw","hoverdistance","Infinity","spikedistance","hoverData","searchData","xvalArray","yvalArray","itemnum","curvenum","cd","subplotId","subploti","mode","xval","yval","closedataPreviousLength","spikePoints","hLinePoint","vLinePoint","hasOneHorizontalTrace","curveNumber","push","orientation","isTraceInSubplots","hasUserCalledHover","target","xpx","ypx","_length","triggerHandler","dbb","getBoundingClientRect","clientX","left","clientY","top","pointerX","pointerY","flat","p2c","warn","distance","visible","_module","type","getSubplot","maxHoverDistance","maxSpikeDistance","min","spikeDistance","xSpike","undefined","ySpike","xLabelVal","yLabelVal","zLabelVal","_splomScenes","uid","scene","selection","pointNumber","hoverPoints","newPoints","_hoverlayer","newPoint","newPointNum","cleanPoint","log","splice","closestPoints","filter","point","tmpPoint","closestVPoints","showspikes","closestVPt","fillSpikePoint","closestHPoints","closestHPt","selectClosestPoint","resultPoint","minDistance","thisSpikeDistance","spikelineOpts","_paperdiv","event","oldspikepoints","_spikepoints","newspikepoints","tmpHPointData","tmpHPoint","tmpVPointData","tmpVPoint","result","spikesChanged","createSpikelines","d1","d2","oldhoverdata","_hoverdata","newhoverdata","pt","makeEventData","ht","combine","plot_bgcolor","paper_bgcolor","labelOpts","commonLabelOpts","hoverlabel","hoverLabels","hoverAvoidOverlaps","tagName","hasClickToShow","getComponentMethod","hoverChanged","emit","points","xaxes","yaxes","xvals","yvals","EXTRA_STRING_REGEX","HOVERFONT","HOVERFONTSIZE","c0","commonAttr","t0","t00","String","split","outerContainerBB","outerTop","outerWidth","width","outerHeight","height","showCommonLabel","allHaveZ","traceHoverinfo","parts","commonLabel","selectAll","data","enter","append","classed","exit","remove","label","lpath","ensureSingle","s","style","ltext","attr","commonBgColor","bgcolor","commonStroke","bordercolor","contrast","contrastColor","fill","stroke","call","font","family","size","positionText","convertToTspans","tbb","side","bottom","topsign","leftsign","join","g","addOpacity","color0","numsColor","opacity","nameColor","nameOverride","plainText","nameLength","allowedTags","extraText","hovertemplateString","replace","match","extra","tx","tx2","tx2width","tx2height","t2bb","htx","hty","dx","abs","dy","txTotalWidth","anchorStartOK","anchorEndOK","ty0","bx","max","anchor","txwidth","pos","ax","nummoves","axSign","pointgroups","axis","axIsX","charAt","rng","range","traceIndex","dp","posref","pmin","pmax","donepositioning","topOverlap","bottomOverlap","j","pti","sumdp","constrainGroup","grp","minPt","maxPt","deleteCount","del","g0","g1","p0","p1","apply","forEach","hoverPt","horzSign","alignShift","start","end","middle","txx","tx2x","offsetX","offsetY","setRect","cd0","getVal","calcKey","traceKey","castOption","extractOption","key","val","constrain","hoverLabelText","xVal","c2d","yVal","isNaN","xerr","xeText","tickText","c2l","xerrneg","yerr","yeText","yerrneg","infomode","showY","showX","hLinePointX","hLinePointY","ySnap","spikesnap","dfltHLineColor","readability","yMode","spikemode","yThickness","spikethickness","yColor","spikecolor","yBB","_boundingBox","xEdge","right","xBase","xEndSpike","_counterSpan","insert","x2","y2","dashStyle","spikedash","cx","cy","r","vLinePointX","vLinePointY","xSnap","dfltVLineColor","xMode","xThickness","xColor","xBB","yEdge","yBase","yEndSpike","oldPt","newPt","pointNumbers"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/components/fx/hover.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar d3 = require('d3');\nvar isNumeric = require('fast-isnumeric');\nvar tinycolor = require('tinycolor2');\n\nvar Lib = require('../../lib');\nvar Events = require('../../lib/events');\nvar svgTextUtils = require('../../lib/svg_text_utils');\nvar overrideCursor = require('../../lib/override_cursor');\nvar Drawing = require('../drawing');\nvar Color = require('../color');\nvar dragElement = require('../dragelement');\nvar Axes = require('../../plots/cartesian/axes');\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\nvar constants = require('./constants');\n\n// hover labels for multiple horizontal bars get tilted by some angle,\n// then need to be offset differently if they overlap\nvar YANGLE = constants.YANGLE;\nvar YA_RADIANS = Math.PI * YANGLE / 180;\n\n// expansion of projected height\nvar YFACTOR = 1 / Math.sin(YA_RADIANS);\n\n// to make the appropriate post-rotation x offset,\n// you need both x and y offsets\nvar YSHIFTX = Math.cos(YA_RADIANS);\nvar YSHIFTY = Math.sin(YA_RADIANS);\n\n// size and display constants for hover text\nvar HOVERARROWSIZE = constants.HOVERARROWSIZE;\nvar HOVERTEXTPAD = constants.HOVERTEXTPAD;\n\n// fx.hover: highlight data on hover\n// evt can be a mousemove event, or an object with data about what points\n//   to hover on\n//      {xpx,ypx[,hovermode]} - pixel locations from top left\n//          (with optional overriding hovermode)\n//      {xval,yval[,hovermode]} - data values\n//      [{curveNumber,(pointNumber|xval and/or yval)}] -\n//              array of specific points to highlight\n//          pointNumber is a single integer if gd.data[curveNumber] is 1D,\n//              or a two-element array if it's 2D\n//          xval and yval are data values,\n//              1D data may specify either or both,\n//              2D data must specify both\n// subplot is an id string (default \"xy\")\n// makes use of gl.hovermode, which can be:\n//      x (find the points with the closest x values, ie a column),\n//      closest (find the single closest point)\n//    internally there are two more that occasionally get used:\n//      y (pick out a row - only used for multiple horizontal bar charts)\n//      array (used when the user specifies an explicit\n//          array of points to hover on)\n//\n// We wrap the hovers in a timer, to limit their frequency.\n// The actual rendering is done by private function _hover.\nexports.hover = function hover(gd, evt, subplot, noHoverEvent) {\n    gd = Lib.getGraphDiv(gd);\n\n    Lib.throttle(\n        gd._fullLayout._uid + constants.HOVERID,\n        constants.HOVERMINTIME,\n        function() { _hover(gd, evt, subplot, noHoverEvent); }\n    );\n};\n\n/*\n * Draw a single hover item in a pre-existing svg container somewhere\n * hoverItem should have keys:\n *    - x and y (or x0, x1, y0, and y1):\n *      the pixel position to mark, relative to opts.container\n *    - xLabel, yLabel, zLabel, text, and name:\n *      info to go in the label\n *    - color:\n *      the background color for the label.\n *    - idealAlign (optional):\n *      'left' or 'right' for which side of the x/y box to try to put this on first\n *    - borderColor (optional):\n *      color for the border, defaults to strongest contrast with color\n *    - fontFamily (optional):\n *      string, the font for this label, defaults to constants.HOVERFONT\n *    - fontSize (optional):\n *      the label font size, defaults to constants.HOVERFONTSIZE\n *    - fontColor (optional):\n *      defaults to borderColor\n * opts should have keys:\n *    - bgColor:\n *      the background color this is against, used if the trace is\n *      non-opaque, and for the name, which goes outside the box\n *    - container:\n *      a <svg> or <g> element to add the hover label to\n *    - outerContainer:\n *      normally a parent of `container`, sets the bounding box to use to\n *      constrain the hover label and determine whether to show it on the left or right\n */\nexports.loneHover = function loneHover(hoverItem, opts) {\n    var pointData = {\n        color: hoverItem.color || Color.defaultLine,\n        x0: hoverItem.x0 || hoverItem.x || 0,\n        x1: hoverItem.x1 || hoverItem.x || 0,\n        y0: hoverItem.y0 || hoverItem.y || 0,\n        y1: hoverItem.y1 || hoverItem.y || 0,\n        xLabel: hoverItem.xLabel,\n        yLabel: hoverItem.yLabel,\n        zLabel: hoverItem.zLabel,\n        text: hoverItem.text,\n        name: hoverItem.name,\n        idealAlign: hoverItem.idealAlign,\n\n        // optional extra bits of styling\n        borderColor: hoverItem.borderColor,\n        fontFamily: hoverItem.fontFamily,\n        fontSize: hoverItem.fontSize,\n        fontColor: hoverItem.fontColor,\n\n        // filler to make createHoverText happy\n        trace: hoverItem.trace || {\n            index: 0,\n            hoverinfo: ''\n        },\n        xa: {_offset: 0},\n        ya: {_offset: 0},\n        index: 0,\n\n        hovertemplate: hoverItem.hovertemplate || false,\n        eventData: hoverItem.eventData || false,\n        hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n    };\n\n    var container3 = d3.select(opts.container);\n    var outerContainer3 = opts.outerContainer ?\n        d3.select(opts.outerContainer) : container3;\n\n    var fullOpts = {\n        hovermode: 'closest',\n        rotateLabels: false,\n        bgColor: opts.bgColor || Color.background,\n        container: container3,\n        outerContainer: outerContainer3\n    };\n    var hoverLabel = createHoverText([pointData], fullOpts, opts.gd);\n    alignHoverText(hoverLabel, fullOpts.rotateLabels);\n\n    return hoverLabel.node();\n};\n\nexports.multiHovers = function multiHovers(hoverItems, opts) {\n\n    if(!Array.isArray(hoverItems)) {\n        hoverItems = [hoverItems];\n    }\n\n    var pointsData = hoverItems.map(function(hoverItem) {\n        return {\n            color: hoverItem.color || Color.defaultLine,\n            x0: hoverItem.x0 || hoverItem.x || 0,\n            x1: hoverItem.x1 || hoverItem.x || 0,\n            y0: hoverItem.y0 || hoverItem.y || 0,\n            y1: hoverItem.y1 || hoverItem.y || 0,\n            xLabel: hoverItem.xLabel,\n            yLabel: hoverItem.yLabel,\n            zLabel: hoverItem.zLabel,\n            text: hoverItem.text,\n            name: hoverItem.name,\n            idealAlign: hoverItem.idealAlign,\n\n            // optional extra bits of styling\n            borderColor: hoverItem.borderColor,\n            fontFamily: hoverItem.fontFamily,\n            fontSize: hoverItem.fontSize,\n            fontColor: hoverItem.fontColor,\n\n            // filler to make createHoverText happy\n            trace: hoverItem.trace || {\n                index: 0,\n                hoverinfo: ''\n            },\n            xa: {_offset: 0},\n            ya: {_offset: 0},\n            index: 0,\n\n            hovertemplate: hoverItem.hovertemplate || false,\n            eventData: hoverItem.eventData || false,\n            hovertemplateLabels: hoverItem.hovertemplateLabels || false,\n        };\n    });\n\n\n    var container3 = d3.select(opts.container);\n    var outerContainer3 = opts.outerContainer ? d3.select(opts.outerContainer) : container3;\n\n    var fullOpts = {\n        hovermode: 'closest',\n        rotateLabels: false,\n        bgColor: opts.bgColor || Color.background,\n        container: container3,\n        outerContainer: outerContainer3\n    };\n\n    var hoverLabel = createHoverText(pointsData, fullOpts, opts.gd);\n\n    // Fix vertical overlap\n    var tooltipSpacing = 5;\n    var lastBottomY = 0;\n    hoverLabel\n        .sort(function(a, b) {return a.y0 - b.y0;})\n        .each(function(d) {\n            var topY = d.y0 - d.by / 2;\n\n            if((topY - tooltipSpacing) < lastBottomY) {\n                d.offset = (lastBottomY - topY) + tooltipSpacing;\n            } else {\n                d.offset = 0;\n            }\n\n            lastBottomY = topY + d.by + d.offset;\n        });\n\n\n    alignHoverText(hoverLabel, fullOpts.rotateLabels);\n\n    return hoverLabel.node();\n};\n\n// The actual implementation is here:\nfunction _hover(gd, evt, subplot, noHoverEvent) {\n    if(!subplot) subplot = 'xy';\n\n    // if the user passed in an array of subplots,\n    // use those instead of finding overlayed plots\n    var subplots = Array.isArray(subplot) ? subplot : [subplot];\n\n    var fullLayout = gd._fullLayout;\n    var plots = fullLayout._plots || [];\n    var plotinfo = plots[subplot];\n    var hasCartesian = fullLayout._has('cartesian');\n\n    // list of all overlaid subplots to look at\n    if(plotinfo) {\n        var overlayedSubplots = plotinfo.overlays.map(function(pi) {\n            return pi.id;\n        });\n\n        subplots = subplots.concat(overlayedSubplots);\n    }\n\n    var len = subplots.length;\n    var xaArray = new Array(len);\n    var yaArray = new Array(len);\n    var supportsCompare = false;\n\n    for(var i = 0; i < len; i++) {\n        var spId = subplots[i];\n\n        // 'cartesian' case\n        var plotObj = plots[spId];\n        if(plotObj) {\n            supportsCompare = true;\n\n            // TODO make sure that fullLayout_plots axis refs\n            // get updated properly so that we don't have\n            // to use Axes.getFromId in general.\n\n            xaArray[i] = Axes.getFromId(gd, plotObj.xaxis._id);\n            yaArray[i] = Axes.getFromId(gd, plotObj.yaxis._id);\n            continue;\n        }\n\n        // other subplot types\n        var _subplot = fullLayout[spId]._subplot;\n        xaArray[i] = _subplot.xaxis;\n        yaArray[i] = _subplot.yaxis;\n    }\n\n    var hovermode = evt.hovermode || fullLayout.hovermode;\n\n    if(hovermode && !supportsCompare) hovermode = 'closest';\n\n    if(['x', 'y', 'closest'].indexOf(hovermode) === -1 || !gd.calcdata ||\n            gd.querySelector('.zoombox') || gd._dragging) {\n        return dragElement.unhoverRaw(gd, evt);\n    }\n\n    var hoverdistance = fullLayout.hoverdistance === -1 ? Infinity : fullLayout.hoverdistance;\n    var spikedistance = fullLayout.spikedistance === -1 ? Infinity : fullLayout.spikedistance;\n\n    // hoverData: the set of candidate points we've found to highlight\n    var hoverData = [];\n\n    // searchData: the data to search in. Mostly this is just a copy of\n    // gd.calcdata, filtered to the subplot and overlays we're on\n    // but if a point array is supplied it will be a mapping\n    // of indicated curves\n    var searchData = [];\n\n    // [x|y]valArray: the axis values of the hover event\n    // mapped onto each of the currently selected overlaid subplots\n    var xvalArray, yvalArray;\n\n    var itemnum, curvenum, cd, trace, subplotId, subploti, mode,\n        xval, yval, pointData, closedataPreviousLength;\n\n    // spikePoints: the set of candidate points we've found to draw spikes to\n    var spikePoints = {\n        hLinePoint: null,\n        vLinePoint: null\n    };\n\n    // does subplot have one (or more) horizontal traces?\n    // This is used to determine whether we rotate the labels or not\n    var hasOneHorizontalTrace = false;\n\n    // Figure out what we're hovering on:\n    // mouse location or user-supplied data\n\n    if(Array.isArray(evt)) {\n        // user specified an array of points to highlight\n        hovermode = 'array';\n        for(itemnum = 0; itemnum < evt.length; itemnum++) {\n            cd = gd.calcdata[evt[itemnum].curveNumber || 0];\n            if(cd) {\n                trace = cd[0].trace;\n                if(cd[0].trace.hoverinfo !== 'skip') {\n                    searchData.push(cd);\n                    if(trace.orientation === 'h') {\n                        hasOneHorizontalTrace = true;\n                    }\n                }\n            }\n        }\n    }\n    else {\n        for(curvenum = 0; curvenum < gd.calcdata.length; curvenum++) {\n            cd = gd.calcdata[curvenum];\n            trace = cd[0].trace;\n            if(trace.hoverinfo !== 'skip' && helpers.isTraceInSubplots(trace, subplots)) {\n                searchData.push(cd);\n                if(trace.orientation === 'h') {\n                    hasOneHorizontalTrace = true;\n                }\n            }\n        }\n\n        // [x|y]px: the pixels (from top left) of the mouse location\n        // on the currently selected plot area\n        // add pointerX|Y property for drawing the spikes in spikesnap 'cursor' situation\n        var hasUserCalledHover = !evt.target;\n        var xpx, ypx;\n\n        if(hasUserCalledHover) {\n            if('xpx' in evt) xpx = evt.xpx;\n            else xpx = xaArray[0]._length / 2;\n\n            if('ypx' in evt) ypx = evt.ypx;\n            else ypx = yaArray[0]._length / 2;\n        }\n        else {\n            // fire the beforehover event and quit if it returns false\n            // note that we're only calling this on real mouse events, so\n            // manual calls to fx.hover will always run.\n            if(Events.triggerHandler(gd, 'plotly_beforehover', evt) === false) {\n                return;\n            }\n\n            var dbb = evt.target.getBoundingClientRect();\n\n            xpx = evt.clientX - dbb.left;\n            ypx = evt.clientY - dbb.top;\n\n            // in case hover was called from mouseout into hovertext,\n            // it's possible you're not actually over the plot anymore\n            if(xpx < 0 || xpx > xaArray[0]._length || ypx < 0 || ypx > yaArray[0]._length) {\n                return dragElement.unhoverRaw(gd, evt);\n            }\n        }\n\n        evt.pointerX = xpx + xaArray[0]._offset;\n        evt.pointerY = ypx + yaArray[0]._offset;\n\n        if('xval' in evt) xvalArray = helpers.flat(subplots, evt.xval);\n        else xvalArray = helpers.p2c(xaArray, xpx);\n\n        if('yval' in evt) yvalArray = helpers.flat(subplots, evt.yval);\n        else yvalArray = helpers.p2c(yaArray, ypx);\n\n        if(!isNumeric(xvalArray[0]) || !isNumeric(yvalArray[0])) {\n            Lib.warn('Fx.hover failed', evt, gd);\n            return dragElement.unhoverRaw(gd, evt);\n        }\n    }\n\n    // the pixel distance to beat as a matching point\n    // in 'x' or 'y' mode this resets for each trace\n    var distance = Infinity;\n\n    // find the closest point in each trace\n    // this is minimum dx and/or dy, depending on mode\n    // and the pixel position for the label (labelXpx, labelYpx)\n    for(curvenum = 0; curvenum < searchData.length; curvenum++) {\n        cd = searchData[curvenum];\n\n        // filter out invisible or broken data\n        if(!cd || !cd[0] || !cd[0].trace || cd[0].trace.visible !== true) continue;\n\n        trace = cd[0].trace;\n\n        // Explicitly bail out for these two. I don't know how to otherwise prevent\n        // the rest of this function from running and failing\n        if(['carpet', 'contourcarpet'].indexOf(trace._module.name) !== -1) continue;\n\n        if(trace.type === 'splom') {\n            // splom traces do not generate overlay subplots,\n            // it is safe to assume here splom traces correspond to the 0th subplot\n            subploti = 0;\n            subplotId = subplots[subploti];\n        } else {\n            subplotId = helpers.getSubplot(trace);\n            subploti = subplots.indexOf(subplotId);\n        }\n\n        // within one trace mode can sometimes be overridden\n        mode = hovermode;\n\n        // container for new point, also used to pass info into module.hoverPoints\n        pointData = {\n            // trace properties\n            cd: cd,\n            trace: trace,\n            xa: xaArray[subploti],\n            ya: yaArray[subploti],\n\n            // max distances for hover and spikes - for points that want to show but do not\n            // want to override other points, set distance/spikeDistance equal to max*Distance\n            // and it will not get filtered out but it will be guaranteed to have a greater\n            // distance than any point that calculated a real distance.\n            maxHoverDistance: hoverdistance,\n            maxSpikeDistance: spikedistance,\n\n            // point properties - override all of these\n            index: false, // point index in trace - only used by plotly.js hoverdata consumers\n            distance: Math.min(distance, hoverdistance), // pixel distance or pseudo-distance\n\n            // distance/pseudo-distance for spikes. This distance should always be calculated\n            // as if in \"closest\" mode, and should only be set if this point should\n            // generate a spike.\n            spikeDistance: Infinity,\n\n            // in some cases the spikes have different positioning from the hover label\n            // they don't need x0/x1, just one position\n            xSpike: undefined,\n            ySpike: undefined,\n\n            // where and how to display the hover label\n            color: Color.defaultLine, // trace color\n            name: trace.name,\n            x0: undefined,\n            x1: undefined,\n            y0: undefined,\n            y1: undefined,\n            xLabelVal: undefined,\n            yLabelVal: undefined,\n            zLabelVal: undefined,\n            text: undefined\n        };\n\n        // add ref to subplot object (non-cartesian case)\n        if(fullLayout[subplotId]) {\n            pointData.subplot = fullLayout[subplotId]._subplot;\n        }\n        // add ref to splom scene\n        if(fullLayout._splomScenes && fullLayout._splomScenes[trace.uid]) {\n            pointData.scene = fullLayout._splomScenes[trace.uid];\n        }\n\n        closedataPreviousLength = hoverData.length;\n\n        // for a highlighting array, figure out what\n        // we're searching for with this element\n        if(mode === 'array') {\n            var selection = evt[curvenum];\n            if('pointNumber' in selection) {\n                pointData.index = selection.pointNumber;\n                mode = 'closest';\n            }\n            else {\n                mode = '';\n                if('xval' in selection) {\n                    xval = selection.xval;\n                    mode = 'x';\n                }\n                if('yval' in selection) {\n                    yval = selection.yval;\n                    mode = mode ? 'closest' : 'y';\n                }\n            }\n        }\n        else {\n            xval = xvalArray[subploti];\n            yval = yvalArray[subploti];\n        }\n\n        // Now if there is range to look in, find the points to hover.\n        if(hoverdistance !== 0) {\n            if(trace._module && trace._module.hoverPoints) {\n                var newPoints = trace._module.hoverPoints(pointData, xval, yval, mode, fullLayout._hoverlayer);\n                if(newPoints) {\n                    var newPoint;\n                    for(var newPointNum = 0; newPointNum < newPoints.length; newPointNum++) {\n                        newPoint = newPoints[newPointNum];\n                        if(isNumeric(newPoint.x0) && isNumeric(newPoint.y0)) {\n                            hoverData.push(cleanPoint(newPoint, hovermode));\n                        }\n                    }\n                }\n            }\n            else {\n                Lib.log('Unrecognized trace type in hover:', trace);\n            }\n        }\n\n        // in closest mode, remove any existing (farther) points\n        // and don't look any farther than this latest point (or points, some\n        // traces like box & violin make multiple hover labels at once)\n        if(hovermode === 'closest' && hoverData.length > closedataPreviousLength) {\n            hoverData.splice(0, closedataPreviousLength);\n            distance = hoverData[0].distance;\n        }\n\n        // Now if there is range to look in, find the points to draw the spikelines\n        // Do it only if there is no hoverData\n        if(hasCartesian && (spikedistance !== 0)) {\n            if(hoverData.length === 0) {\n                pointData.distance = spikedistance;\n                pointData.index = false;\n                var closestPoints = trace._module.hoverPoints(pointData, xval, yval, 'closest', fullLayout._hoverlayer);\n                if(closestPoints) {\n                    closestPoints = closestPoints.filter(function(point) {\n                        // some hover points, like scatter fills, do not allow spikes,\n                        // so will generate a hover point but without a valid spikeDistance\n                        return point.spikeDistance <= spikedistance;\n                    });\n                }\n                if(closestPoints && closestPoints.length) {\n                    var tmpPoint;\n                    var closestVPoints = closestPoints.filter(function(point) {\n                        return point.xa.showspikes;\n                    });\n                    if(closestVPoints.length) {\n                        var closestVPt = closestVPoints[0];\n                        if(isNumeric(closestVPt.x0) && isNumeric(closestVPt.y0)) {\n                            tmpPoint = fillSpikePoint(closestVPt);\n                            if(!spikePoints.vLinePoint || (spikePoints.vLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                spikePoints.vLinePoint = tmpPoint;\n                            }\n                        }\n                    }\n\n                    var closestHPoints = closestPoints.filter(function(point) {\n                        return point.ya.showspikes;\n                    });\n                    if(closestHPoints.length) {\n                        var closestHPt = closestHPoints[0];\n                        if(isNumeric(closestHPt.x0) && isNumeric(closestHPt.y0)) {\n                            tmpPoint = fillSpikePoint(closestHPt);\n                            if(!spikePoints.hLinePoint || (spikePoints.hLinePoint.spikeDistance > tmpPoint.spikeDistance)) {\n                                spikePoints.hLinePoint = tmpPoint;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    function selectClosestPoint(pointsData, spikedistance) {\n        var resultPoint = null;\n        var minDistance = Infinity;\n        var thisSpikeDistance;\n        for(var i = 0; i < pointsData.length; i++) {\n            thisSpikeDistance = pointsData[i].spikeDistance;\n            if(thisSpikeDistance < minDistance && thisSpikeDistance <= spikedistance) {\n                resultPoint = pointsData[i];\n                minDistance = thisSpikeDistance;\n            }\n        }\n        return resultPoint;\n    }\n\n    function fillSpikePoint(point) {\n        if(!point) return null;\n        return {\n            xa: point.xa,\n            ya: point.ya,\n            x: point.xSpike !== undefined ? point.xSpike : (point.x0 + point.x1) / 2,\n            y: point.ySpike !== undefined ? point.ySpike : (point.y0 + point.y1) / 2,\n            distance: point.distance,\n            spikeDistance: point.spikeDistance,\n            curveNumber: point.trace.index,\n            color: point.color,\n            pointNumber: point.index\n        };\n    }\n\n    var spikelineOpts = {\n        fullLayout: fullLayout,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paperdiv,\n        event: evt\n    };\n    var oldspikepoints = gd._spikepoints;\n    var newspikepoints = {\n        vLinePoint: spikePoints.vLinePoint,\n        hLinePoint: spikePoints.hLinePoint\n    };\n    gd._spikepoints = newspikepoints;\n\n    // Now if it is not restricted by spikedistance option, set the points to draw the spikelines\n    if(hasCartesian && (spikedistance !== 0)) {\n        if(hoverData.length !== 0) {\n            var tmpHPointData = hoverData.filter(function(point) {\n                return point.ya.showspikes;\n            });\n            var tmpHPoint = selectClosestPoint(tmpHPointData, spikedistance);\n            spikePoints.hLinePoint = fillSpikePoint(tmpHPoint);\n\n            var tmpVPointData = hoverData.filter(function(point) {\n                return point.xa.showspikes;\n            });\n            var tmpVPoint = selectClosestPoint(tmpVPointData, spikedistance);\n            spikePoints.vLinePoint = fillSpikePoint(tmpVPoint);\n        }\n    }\n\n    // if hoverData is empty check for the spikes to draw and quit if there are none\n    if(hoverData.length === 0) {\n        var result = dragElement.unhoverRaw(gd, evt);\n        if(hasCartesian && ((spikePoints.hLinePoint !== null) || (spikePoints.vLinePoint !== null))) {\n            if(spikesChanged(oldspikepoints)) {\n                createSpikelines(spikePoints, spikelineOpts);\n            }\n        }\n        return result;\n    }\n\n    if(hasCartesian) {\n        if(spikesChanged(oldspikepoints)) {\n            createSpikelines(spikePoints, spikelineOpts);\n        }\n    }\n\n    hoverData.sort(function(d1, d2) { return d1.distance - d2.distance; });\n\n    // lastly, emit custom hover/unhover events\n    var oldhoverdata = gd._hoverdata;\n    var newhoverdata = [];\n\n    // pull out just the data that's useful to\n    // other people and send it to the event\n    for(itemnum = 0; itemnum < hoverData.length; itemnum++) {\n        var pt = hoverData[itemnum];\n        var eventData = helpers.makeEventData(pt, pt.trace, pt.cd);\n\n        var ht = false;\n        if(pt.cd[pt.index] && pt.cd[pt.index].ht) ht = pt.cd[pt.index].ht;\n        hoverData[itemnum].hovertemplate = ht || pt.trace.hovertemplate || false;\n        hoverData[itemnum].eventData = [eventData];\n\n        newhoverdata.push(eventData);\n    }\n\n    gd._hoverdata = newhoverdata;\n\n    var rotateLabels = (\n        (hovermode === 'y' && (searchData.length > 1 || hoverData.length > 1)) ||\n        (hovermode === 'closest' && hasOneHorizontalTrace && hoverData.length > 1)\n    );\n\n    var bgColor = Color.combine(\n        fullLayout.plot_bgcolor || Color.background,\n        fullLayout.paper_bgcolor\n    );\n\n    var labelOpts = {\n        hovermode: hovermode,\n        rotateLabels: rotateLabels,\n        bgColor: bgColor,\n        container: fullLayout._hoverlayer,\n        outerContainer: fullLayout._paperdiv,\n        commonLabelOpts: fullLayout.hoverlabel,\n        hoverdistance: fullLayout.hoverdistance\n    };\n\n    var hoverLabels = createHoverText(hoverData, labelOpts, gd);\n\n    hoverAvoidOverlaps(hoverData, rotateLabels ? 'xa' : 'ya', fullLayout);\n\n    alignHoverText(hoverLabels, rotateLabels);\n\n    // TODO: tagName hack is needed to appease geo.js's hack of using evt.target=true\n    // we should improve the \"fx\" API so other plots can use it without these hack.\n    if(evt.target && evt.target.tagName) {\n        var hasClickToShow = Registry.getComponentMethod('annotations', 'hasClickToShow')(gd, newhoverdata);\n        overrideCursor(d3.select(evt.target), hasClickToShow ? 'pointer' : '');\n    }\n\n    // don't emit events if called manually\n    if(!evt.target || noHoverEvent || !hoverChanged(gd, evt, oldhoverdata)) return;\n\n    if(oldhoverdata) {\n        gd.emit('plotly_unhover', {\n            event: evt,\n            points: oldhoverdata\n        });\n    }\n\n    gd.emit('plotly_hover', {\n        event: evt,\n        points: gd._hoverdata,\n        xaxes: xaArray,\n        yaxes: yaArray,\n        xvals: xvalArray,\n        yvals: yvalArray\n    });\n}\n\nvar EXTRA_STRING_REGEX = /<extra>([\\s\\S]*)<\\/extra>/;\n\nfunction createHoverText(hoverData, opts, gd) {\n    var hovermode = opts.hovermode;\n    var rotateLabels = opts.rotateLabels;\n    var bgColor = opts.bgColor;\n    var container = opts.container;\n    var outerContainer = opts.outerContainer;\n    var commonLabelOpts = opts.commonLabelOpts || {};\n\n    // opts.fontFamily/Size are used for the common label\n    // and as defaults for each hover label, though the individual labels\n    // can override this.\n    var fontFamily = opts.fontFamily || constants.HOVERFONT;\n    var fontSize = opts.fontSize || constants.HOVERFONTSIZE;\n\n    var c0 = hoverData[0];\n    var xa = c0.xa;\n    var ya = c0.ya;\n    var commonAttr = hovermode === 'y' ? 'yLabel' : 'xLabel';\n    var t0 = c0[commonAttr];\n    var t00 = (String(t0) || '').split(' ')[0];\n    var outerContainerBB = outerContainer.node().getBoundingClientRect();\n    var outerTop = outerContainerBB.top;\n    var outerWidth = outerContainerBB.width;\n    var outerHeight = outerContainerBB.height;\n\n    // show the common label, if any, on the axis\n    // never show a common label in array mode,\n    // even if sometimes there could be one\n    var showCommonLabel = (\n        (t0 !== undefined) &&\n        (c0.distance <= opts.hoverdistance) &&\n        (hovermode === 'x' || hovermode === 'y')\n    );\n\n    // all hover traces hoverinfo must contain the hovermode\n    // to have common labels\n    if(showCommonLabel) {\n        var allHaveZ = true;\n        var i, traceHoverinfo;\n        for(i = 0; i < hoverData.length; i++) {\n            if(allHaveZ && hoverData[i].zLabel === undefined) allHaveZ = false;\n\n            traceHoverinfo = hoverData[i].hoverinfo || hoverData[i].trace.hoverinfo;\n            if(traceHoverinfo) {\n                var parts = Array.isArray(traceHoverinfo) ? traceHoverinfo : traceHoverinfo.split('+');\n                if(parts.indexOf('all') === -1 &&\n                    parts.indexOf(hovermode) === -1) {\n                    showCommonLabel = false;\n                    break;\n                }\n            }\n        }\n\n        // xyz labels put all info in their main label, so have no need of a common label\n        if(allHaveZ) showCommonLabel = false;\n    }\n\n    var commonLabel = container.selectAll('g.axistext')\n        .data(showCommonLabel ? [0] : []);\n    commonLabel.enter().append('g')\n        .classed('axistext', true);\n    commonLabel.exit().remove();\n\n    commonLabel.each(function() {\n        var label = d3.select(this);\n        var lpath = Lib.ensureSingle(label, 'path', '', function(s) {\n            s.style({'stroke-width': '1px'});\n        });\n        var ltext = Lib.ensureSingle(label, 'text', '', function(s) {\n            // prohibit tex interpretation until we can handle\n            // tex and regular text together\n            s.attr('data-notex', 1);\n        });\n\n        var commonBgColor = commonLabelOpts.bgcolor || Color.defaultLine;\n        var commonStroke = commonLabelOpts.bordercolor || Color.contrast(commonBgColor);\n        var contrastColor = Color.contrast(commonBgColor);\n\n        lpath.style({\n            fill: commonBgColor,\n            stroke: commonStroke\n        });\n\n        ltext.text(t0)\n            .call(Drawing.font,\n                commonLabelOpts.font.family || fontFamily,\n                commonLabelOpts.font.size || fontSize,\n                commonLabelOpts.font.color || contrastColor\n             )\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        label.attr('transform', '');\n\n        var tbb = ltext.node().getBoundingClientRect();\n        if(hovermode === 'x') {\n            ltext.attr('text-anchor', 'middle')\n                .call(svgTextUtils.positionText, 0, (xa.side === 'top' ?\n                    (outerTop - tbb.bottom - HOVERARROWSIZE - HOVERTEXTPAD) :\n                    (outerTop - tbb.top + HOVERARROWSIZE + HOVERTEXTPAD)));\n\n            var topsign = xa.side === 'top' ? '-' : '';\n            lpath.attr('d', 'M0,0' +\n                'L' + HOVERARROWSIZE + ',' + topsign + HOVERARROWSIZE +\n                'H' + (HOVERTEXTPAD + tbb.width / 2) +\n                'v' + topsign + (HOVERTEXTPAD * 2 + tbb.height) +\n                'H-' + (HOVERTEXTPAD + tbb.width / 2) +\n                'V' + topsign + HOVERARROWSIZE + 'H-' + HOVERARROWSIZE + 'Z');\n\n            label.attr('transform', 'translate(' +\n                (xa._offset + (c0.x0 + c0.x1) / 2) + ',' +\n                (ya._offset + (xa.side === 'top' ? 0 : ya._length)) + ')');\n        }\n        else {\n            ltext.attr('text-anchor', ya.side === 'right' ? 'start' : 'end')\n                .call(svgTextUtils.positionText,\n                    (ya.side === 'right' ? 1 : -1) * (HOVERTEXTPAD + HOVERARROWSIZE),\n                    outerTop - tbb.top - tbb.height / 2);\n\n            var leftsign = ya.side === 'right' ? '' : '-';\n            lpath.attr('d', 'M0,0' +\n                'L' + leftsign + HOVERARROWSIZE + ',' + HOVERARROWSIZE +\n                'V' + (HOVERTEXTPAD + tbb.height / 2) +\n                'h' + leftsign + (HOVERTEXTPAD * 2 + tbb.width) +\n                'V-' + (HOVERTEXTPAD + tbb.height / 2) +\n                'H' + leftsign + HOVERARROWSIZE + 'V-' + HOVERARROWSIZE + 'Z');\n\n            label.attr('transform', 'translate(' +\n                (xa._offset + (ya.side === 'right' ? xa._length : 0)) + ',' +\n                (ya._offset + (c0.y0 + c0.y1) / 2) + ')');\n        }\n        // remove the \"close but not quite\" points\n        // because of error bars, only take up to a space\n        hoverData = hoverData.filter(function(d) {\n            return (d.zLabelVal !== undefined) ||\n                (d[commonAttr] || '').split(' ')[0] === t00;\n        });\n    });\n\n    // show all the individual labels\n\n    // first create the objects\n    var hoverLabels = container.selectAll('g.hovertext')\n        .data(hoverData, function(d) {\n            return [d.trace.index, d.index, d.x0, d.y0, d.name, d.attr, d.xa, d.ya || ''].join(',');\n        });\n    hoverLabels.enter().append('g')\n        .classed('hovertext', true)\n        .each(function() {\n            var g = d3.select(this);\n            // trace name label (rect and text.name)\n            g.append('rect')\n                .call(Color.fill, Color.addOpacity(bgColor, 0.8));\n            g.append('text').classed('name', true);\n            // trace data label (path and text.nums)\n            g.append('path')\n                .style('stroke-width', '1px');\n            g.append('text').classed('nums', true)\n                .call(Drawing.font, fontFamily, fontSize);\n        });\n    hoverLabels.exit().remove();\n\n    // then put the text in, position the pointer to the data,\n    // and figure out sizes\n    hoverLabels.each(function(d) {\n        var g = d3.select(this).attr('transform', '');\n        var name = '';\n        var text = '';\n\n        // combine possible non-opaque trace color with bgColor\n        var color0 = d.bgcolor || d.color;\n        // color for 'nums' part of the label\n        var numsColor = Color.combine(\n            Color.opacity(color0) ? color0 : Color.defaultLine,\n            bgColor\n        );\n        // color for 'name' part of the label\n        var nameColor = Color.combine(\n            Color.opacity(d.color) ? d.color : Color.defaultLine,\n            bgColor\n        );\n        // find a contrasting color for border and text\n        var contrastColor = d.borderColor || Color.contrast(numsColor);\n\n        // to get custom 'name' labels pass cleanPoint\n        if(d.nameOverride !== undefined) d.name = d.nameOverride;\n\n        if(d.name) {\n            name = svgTextUtils.plainText(d.name || '', {\n                len: d.nameLength,\n                allowedTags: ['br', 'sub', 'sup', 'b', 'i', 'em']\n            });\n        }\n\n        if(d.zLabel !== undefined) {\n            if(d.xLabel !== undefined) text += 'x: ' + d.xLabel + '<br>';\n            if(d.yLabel !== undefined) text += 'y: ' + d.yLabel + '<br>';\n            text += (text ? 'z: ' : '') + d.zLabel;\n        }\n        else if(showCommonLabel && d[hovermode + 'Label'] === t0) {\n            text = d[(hovermode === 'x' ? 'y' : 'x') + 'Label'] || '';\n        }\n        else if(d.xLabel === undefined) {\n            if(d.yLabel !== undefined) text = d.yLabel;\n        }\n        else if(d.yLabel === undefined) text = d.xLabel;\n        else text = '(' + d.xLabel + ', ' + d.yLabel + ')';\n\n        if((d.text || d.text === 0) && !Array.isArray(d.text)) {\n            text += (text ? '<br>' : '') + d.text;\n        }\n\n        // used by other modules (initially just ternary) that\n        // manage their own hoverinfo independent of cleanPoint\n        // the rest of this will still apply, so such modules\n        // can still put things in (x|y|z)Label, text, and name\n        // and hoverinfo will still determine their visibility\n        if(d.extraText !== undefined) text += (text ? '<br>' : '') + d.extraText;\n\n        // if 'text' is empty at this point,\n        // and hovertemplate is not defined,\n        // put 'name' in main label and don't show secondary label\n        if(text === '' && !d.hovertemplate) {\n            // if 'name' is also empty, remove entire label\n            if(name === '') g.remove();\n            text = name;\n        }\n\n        // hovertemplate\n        var hovertemplate = d.hovertemplate || false;\n        var hovertemplateLabels = d.hovertemplateLabels || d;\n        var eventData = d.eventData[0] || {};\n        if(hovertemplate) {\n            text = Lib.hovertemplateString(hovertemplate, hovertemplateLabels, eventData);\n\n            text = text.replace(EXTRA_STRING_REGEX, function(match, extra) {\n                name = extra; // Assign name for secondary text label\n                return ''; // Remove from main text label\n            });\n        }\n\n        // main label\n        var tx = g.select('text.nums')\n            .call(Drawing.font,\n                d.fontFamily || fontFamily,\n                d.fontSize || fontSize,\n                d.fontColor || contrastColor)\n            .text(text)\n            .attr('data-notex', 1)\n            .call(svgTextUtils.positionText, 0, 0)\n            .call(svgTextUtils.convertToTspans, gd);\n\n        var tx2 = g.select('text.name');\n        var tx2width = 0;\n        var tx2height = 0;\n\n        // secondary label for non-empty 'name'\n        if(name && name !== text) {\n            tx2.call(Drawing.font,\n                    d.fontFamily || fontFamily,\n                    d.fontSize || fontSize,\n                    nameColor)\n                .text(name)\n                .attr('data-notex', 1)\n                .call(svgTextUtils.positionText, 0, 0)\n                .call(svgTextUtils.convertToTspans, gd);\n\n            var t2bb = tx2.node().getBoundingClientRect();\n            tx2width = t2bb.width + 2 * HOVERTEXTPAD;\n            tx2height = t2bb.height + 2 * HOVERTEXTPAD;\n        } else {\n            tx2.remove();\n            g.select('rect').remove();\n        }\n\n        g.select('path').style({\n            fill: numsColor,\n            stroke: contrastColor\n        });\n\n        var tbb = tx.node().getBoundingClientRect();\n        var htx = d.xa._offset + (d.x0 + d.x1) / 2;\n        var hty = d.ya._offset + (d.y0 + d.y1) / 2;\n        var dx = Math.abs(d.x1 - d.x0);\n        var dy = Math.abs(d.y1 - d.y0);\n        var txTotalWidth = tbb.width + HOVERARROWSIZE + HOVERTEXTPAD + tx2width;\n        var anchorStartOK, anchorEndOK;\n\n        d.ty0 = outerTop - tbb.top;\n        d.bx = tbb.width + 2 * HOVERTEXTPAD;\n        d.by = Math.max(tbb.height + 2 * HOVERTEXTPAD, tx2height);\n        d.anchor = 'start';\n        d.txwidth = tbb.width;\n        d.tx2width = tx2width;\n        d.offset = 0;\n\n        if(rotateLabels) {\n            d.pos = htx;\n            anchorStartOK = hty + dy / 2 + txTotalWidth <= outerHeight;\n            anchorEndOK = hty - dy / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'top' || !anchorStartOK) && anchorEndOK) {\n                hty -= dy / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                hty += dy / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        }\n        else {\n            d.pos = hty;\n            anchorStartOK = htx + dx / 2 + txTotalWidth <= outerWidth;\n            anchorEndOK = htx - dx / 2 - txTotalWidth >= 0;\n            if((d.idealAlign === 'left' || !anchorStartOK) && anchorEndOK) {\n                htx -= dx / 2;\n                d.anchor = 'end';\n            } else if(anchorStartOK) {\n                htx += dx / 2;\n                d.anchor = 'start';\n            } else d.anchor = 'middle';\n        }\n\n        tx.attr('text-anchor', d.anchor);\n        if(tx2width) tx2.attr('text-anchor', d.anchor);\n        g.attr('transform', 'translate(' + htx + ',' + hty + ')' +\n            (rotateLabels ? 'rotate(' + YANGLE + ')' : ''));\n    });\n\n    return hoverLabels;\n}\n\n// Make groups of touching points, and within each group\n// move each point so that no labels overlap, but the average\n// label position is the same as it was before moving. Indicentally,\n// this is equivalent to saying all the labels are on equal linear\n// springs about their initial position. Initially, each point is\n// its own group, but as we find overlaps we will clump the points.\n//\n// Also, there are hard constraints at the edges of the graphs,\n// that push all groups to the middle so they are visible. I don't\n// know what happens if the group spans all the way from one edge to\n// the other, though it hardly matters - there's just too much\n// information then.\nfunction hoverAvoidOverlaps(hoverData, ax, fullLayout) {\n    var nummoves = 0;\n    var axSign = 1;\n\n    // make groups of touching points\n    var pointgroups = hoverData.map(function(d, i) {\n        var axis = d[ax];\n        var axIsX = axis._id.charAt(0) === 'x';\n        var rng = axis.range;\n        if(!i && rng && ((rng[0] > rng[1]) !== axIsX)) axSign = -1;\n        return [{\n            i: i,\n            traceIndex: d.trace.index,\n            dp: 0,\n            pos: d.pos,\n            posref: d.posref,\n            size: d.by * (axIsX ? YFACTOR : 1) / 2,\n            pmin: 0,\n            pmax: (axIsX ? fullLayout.width : fullLayout.height)\n        }];\n    })\n    .sort(function(a, b) {\n        return (a[0].posref - b[0].posref) ||\n            // for equal positions, sort trace indices increasing or decreasing\n            // depending on whether the axis is reversed or not... so stacked\n            // traces will generally keep their order even if one trace adds\n            // nothing to the stack.\n            (axSign * (b[0].traceIndex - a[0].traceIndex));\n    });\n\n    var donepositioning, topOverlap, bottomOverlap, i, j, pti, sumdp;\n\n    function constrainGroup(grp) {\n        var minPt = grp[0];\n        var maxPt = grp[grp.length - 1];\n\n        // overlap with the top - positive vals are overlaps\n        topOverlap = minPt.pmin - minPt.pos - minPt.dp + minPt.size;\n\n        // overlap with the bottom - positive vals are overlaps\n        bottomOverlap = maxPt.pos + maxPt.dp + maxPt.size - minPt.pmax;\n\n        // check for min overlap first, so that we always\n        // see the largest labels\n        // allow for .01px overlap, so we don't get an\n        // infinite loop from rounding errors\n        if(topOverlap > 0.01) {\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp += topOverlap;\n            donepositioning = false;\n        }\n        if(bottomOverlap < 0.01) return;\n        if(topOverlap < -0.01) {\n            // make sure we're not pushing back and forth\n            for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            donepositioning = false;\n        }\n        if(!donepositioning) return;\n\n        // no room to fix positioning, delete off-screen points\n\n        // first see how many points we need to delete\n        var deleteCount = 0;\n        for(i = 0; i < grp.length; i++) {\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) deleteCount++;\n        }\n\n        // start by deleting points whose data is off screen\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos > minPt.pmax - 1) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n        for(i = 0; i < grp.length; i++) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n\n            // pos has already been constrained to [pmin,pmax]\n            // so look for points close to that to delete\n            if(pti.pos < minPt.pmin + 1) {\n                pti.del = true;\n                deleteCount--;\n\n                // shift the whole group minus into this new space\n                bottomOverlap = pti.size * 2;\n                for(j = grp.length - 1; j >= 0; j--) grp[j].dp -= bottomOverlap;\n            }\n        }\n        // then delete points that go off the bottom\n        for(i = grp.length - 1; i >= 0; i--) {\n            if(deleteCount <= 0) break;\n            pti = grp[i];\n            if(pti.pos + pti.dp + pti.size > minPt.pmax) {\n                pti.del = true;\n                deleteCount--;\n            }\n        }\n    }\n\n    // loop through groups, combining them if they overlap,\n    // until nothing moves\n    while(!donepositioning && nummoves <= hoverData.length) {\n        // to avoid infinite loops, don't move more times\n        // than there are traces\n        nummoves++;\n\n        // assume nothing will move in this iteration,\n        // reverse this if it does\n        donepositioning = true;\n        i = 0;\n        while(i < pointgroups.length - 1) {\n                // the higher (g0) and lower (g1) point group\n            var g0 = pointgroups[i];\n            var g1 = pointgroups[i + 1];\n\n            // the lowest point in the higher group (p0)\n            // the highest point in the lower group (p1)\n            var p0 = g0[g0.length - 1];\n            var p1 = g1[0];\n            topOverlap = p0.pos + p0.dp + p0.size - p1.pos - p1.dp + p1.size;\n\n            // Only group points that lie on the same axes\n            if(topOverlap > 0.01 && (p0.pmin === p1.pmin) && (p0.pmax === p1.pmax)) {\n                // push the new point(s) added to this group out of the way\n                for(j = g1.length - 1; j >= 0; j--) g1[j].dp += topOverlap;\n\n                // add them to the group\n                g0.push.apply(g0, g1);\n                pointgroups.splice(i + 1, 1);\n\n                // adjust for minimum average movement\n                sumdp = 0;\n                for(j = g0.length - 1; j >= 0; j--) sumdp += g0[j].dp;\n                bottomOverlap = sumdp / g0.length;\n                for(j = g0.length - 1; j >= 0; j--) g0[j].dp -= bottomOverlap;\n                donepositioning = false;\n            }\n            else i++;\n        }\n\n        // check if we're going off the plot on either side and fix\n        pointgroups.forEach(constrainGroup);\n    }\n\n    // now put these offsets into hoverData\n    for(i = pointgroups.length - 1; i >= 0; i--) {\n        var grp = pointgroups[i];\n        for(j = grp.length - 1; j >= 0; j--) {\n            var pt = grp[j];\n            var hoverPt = hoverData[pt.i];\n            hoverPt.offset = pt.dp;\n            hoverPt.del = pt.del;\n        }\n    }\n}\n\nfunction alignHoverText(hoverLabels, rotateLabels) {\n    // finally set the text positioning relative to the data and draw the\n    // box around it\n    hoverLabels.each(function(d) {\n        var g = d3.select(this);\n        if(d.del) {\n            g.remove();\n            return;\n        }\n\n        var horzSign = d.anchor === 'end' ? -1 : 1;\n        var tx = g.select('text.nums');\n        var alignShift = {start: 1, end: -1, middle: 0}[d.anchor];\n        var txx = alignShift * (HOVERARROWSIZE + HOVERTEXTPAD);\n        var tx2x = txx + alignShift * (d.txwidth + HOVERTEXTPAD);\n        var offsetX = 0;\n        var offsetY = d.offset;\n\n        if(d.anchor === 'middle') {\n            txx -= d.tx2width / 2;\n            tx2x += d.txwidth / 2 + HOVERTEXTPAD;\n        }\n        if(rotateLabels) {\n            offsetY *= -YSHIFTY;\n            offsetX = d.offset * YSHIFTX;\n        }\n\n        g.select('path').attr('d', d.anchor === 'middle' ?\n            // middle aligned: rect centered on data\n            ('M-' + (d.bx / 2 + d.tx2width / 2) + ',' + (offsetY - d.by / 2) +\n              'h' + d.bx + 'v' + d.by + 'h-' + d.bx + 'Z') :\n            // left or right aligned: side rect with arrow to data\n            ('M0,0L' + (horzSign * HOVERARROWSIZE + offsetX) + ',' + (HOVERARROWSIZE + offsetY) +\n                'v' + (d.by / 2 - HOVERARROWSIZE) +\n                'h' + (horzSign * d.bx) +\n                'v-' + d.by +\n                'H' + (horzSign * HOVERARROWSIZE + offsetX) +\n                'V' + (offsetY - HOVERARROWSIZE) +\n                'Z'));\n\n        tx.call(svgTextUtils.positionText,\n            txx + offsetX, offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n\n        if(d.tx2width) {\n            g.select('text.name')\n                .call(svgTextUtils.positionText,\n                    tx2x + alignShift * HOVERTEXTPAD + offsetX,\n                    offsetY + d.ty0 - d.by / 2 + HOVERTEXTPAD);\n            g.select('rect')\n                .call(Drawing.setRect,\n                    tx2x + (alignShift - 1) * d.tx2width / 2 + offsetX,\n                    offsetY - d.by / 2 - 1,\n                    d.tx2width, d.by + 2);\n        }\n    });\n}\n\nfunction cleanPoint(d, hovermode) {\n    var index = d.index;\n    var trace = d.trace || {};\n    var cd0 = d.cd[0];\n    var cd = d.cd[index] || {};\n\n    var getVal = Array.isArray(index) ?\n        function(calcKey, traceKey) {\n            return Lib.castOption(cd0, index, calcKey) ||\n                Lib.extractOption({}, trace, '', traceKey);\n        } :\n        function(calcKey, traceKey) {\n            return Lib.extractOption(cd, trace, calcKey, traceKey);\n        };\n\n    function fill(key, calcKey, traceKey) {\n        var val = getVal(calcKey, traceKey);\n        if(val) d[key] = val;\n    }\n\n    fill('hoverinfo', 'hi', 'hoverinfo');\n    fill('bgcolor', 'hbg', 'hoverlabel.bgcolor');\n    fill('borderColor', 'hbc', 'hoverlabel.bordercolor');\n    fill('fontFamily', 'htf', 'hoverlabel.font.family');\n    fill('fontSize', 'hts', 'hoverlabel.font.size');\n    fill('fontColor', 'htc', 'hoverlabel.font.color');\n    fill('nameLength', 'hnl', 'hoverlabel.namelength');\n\n    d.posref = (hovermode === 'y' || (hovermode === 'closest' && trace.orientation === 'h')) ?\n        (d.xa._offset + (d.x0 + d.x1) / 2) :\n        (d.ya._offset + (d.y0 + d.y1) / 2);\n\n    // then constrain all the positions to be on the plot\n    d.x0 = Lib.constrain(d.x0, 0, d.xa._length);\n    d.x1 = Lib.constrain(d.x1, 0, d.xa._length);\n    d.y0 = Lib.constrain(d.y0, 0, d.ya._length);\n    d.y1 = Lib.constrain(d.y1, 0, d.ya._length);\n\n    // and convert the x and y label values into formatted text\n    if(d.xLabelVal !== undefined) {\n        d.xLabel = ('xLabel' in d) ? d.xLabel : Axes.hoverLabelText(d.xa, d.xLabelVal);\n        d.xVal = d.xa.c2d(d.xLabelVal);\n    }\n    if(d.yLabelVal !== undefined) {\n        d.yLabel = ('yLabel' in d) ? d.yLabel : Axes.hoverLabelText(d.ya, d.yLabelVal);\n        d.yVal = d.ya.c2d(d.yLabelVal);\n    }\n\n    // Traces like heatmaps generate the zLabel in their hoverPoints function\n    if(d.zLabelVal !== undefined && d.zLabel === undefined) {\n        d.zLabel = String(d.zLabelVal);\n    }\n\n    // for box means and error bars, add the range to the label\n    if(!isNaN(d.xerr) && !(d.xa.type === 'log' && d.xerr <= 0)) {\n        var xeText = Axes.tickText(d.xa, d.xa.c2l(d.xerr), 'hover').text;\n        if(d.xerrneg !== undefined) {\n            d.xLabel += ' +' + xeText + ' / -' +\n                Axes.tickText(d.xa, d.xa.c2l(d.xerrneg), 'hover').text;\n        }\n        else d.xLabel += ' ± ' + xeText;\n\n        // small distance penalty for error bars, so that if there are\n        // traces with errors and some without, the error bar label will\n        // hoist up to the point\n        if(hovermode === 'x') d.distance += 1;\n    }\n    if(!isNaN(d.yerr) && !(d.ya.type === 'log' && d.yerr <= 0)) {\n        var yeText = Axes.tickText(d.ya, d.ya.c2l(d.yerr), 'hover').text;\n        if(d.yerrneg !== undefined) {\n            d.yLabel += ' +' + yeText + ' / -' +\n                Axes.tickText(d.ya, d.ya.c2l(d.yerrneg), 'hover').text;\n        }\n        else d.yLabel += ' ± ' + yeText;\n\n        if(hovermode === 'y') d.distance += 1;\n    }\n\n    var infomode = d.hoverinfo || d.trace.hoverinfo;\n\n    if(infomode && infomode !== 'all') {\n        infomode = Array.isArray(infomode) ? infomode : infomode.split('+');\n        if(infomode.indexOf('x') === -1) d.xLabel = undefined;\n        if(infomode.indexOf('y') === -1) d.yLabel = undefined;\n        if(infomode.indexOf('z') === -1) d.zLabel = undefined;\n        if(infomode.indexOf('text') === -1) d.text = undefined;\n        if(infomode.indexOf('name') === -1) d.name = undefined;\n    }\n\n    return d;\n}\n\nfunction createSpikelines(closestPoints, opts) {\n    var container = opts.container;\n    var fullLayout = opts.fullLayout;\n    var evt = opts.event;\n    var showY = !!closestPoints.hLinePoint;\n    var showX = !!closestPoints.vLinePoint;\n\n    var xa, ya;\n\n    // Remove old spikeline items\n    container.selectAll('.spikeline').remove();\n\n    if(!(showX || showY)) return;\n\n    var contrastColor = Color.combine(fullLayout.plot_bgcolor, fullLayout.paper_bgcolor);\n\n    // Horizontal line (to y-axis)\n    if(showY) {\n        var hLinePoint = closestPoints.hLinePoint;\n        var hLinePointX, hLinePointY;\n\n        xa = hLinePoint && hLinePoint.xa;\n        ya = hLinePoint && hLinePoint.ya;\n        var ySnap = ya.spikesnap;\n\n        if(ySnap === 'cursor') {\n            hLinePointX = evt.pointerX;\n            hLinePointY = evt.pointerY;\n        } else {\n            hLinePointX = xa._offset + hLinePoint.x;\n            hLinePointY = ya._offset + hLinePoint.y;\n        }\n        var dfltHLineColor = tinycolor.readability(hLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : hLinePoint.color;\n        var yMode = ya.spikemode;\n        var yThickness = ya.spikethickness;\n        var yColor = ya.spikecolor || dfltHLineColor;\n        var yBB = ya._boundingBox;\n        var xEdge = ((yBB.left + yBB.right) / 2) < hLinePointX ? yBB.right : yBB.left;\n        var xBase, xEndSpike;\n\n        if(yMode.indexOf('toaxis') !== -1 || yMode.indexOf('across') !== -1) {\n            if(yMode.indexOf('toaxis') !== -1) {\n                xBase = xEdge;\n                xEndSpike = hLinePointX;\n            }\n            if(yMode.indexOf('across') !== -1) {\n                xBase = ya._counterSpan[0];\n                xEndSpike = ya._counterSpan[1];\n            }\n\n            // Foreground horizontal line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness,\n                    stroke: yColor,\n                    'stroke-dasharray': Drawing.dashStyle(ya.spikedash, yThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background horizontal Line (to y-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: xBase,\n                    x2: xEndSpike,\n                    y1: hLinePointY,\n                    y2: hLinePointY,\n                    'stroke-width': yThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n        // Y axis marker\n        if(yMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: xEdge + (ya.side !== 'right' ? yThickness : -yThickness),\n                    cy: hLinePointY,\n                    r: yThickness,\n                    fill: yColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n\n    if(showX) {\n        var vLinePoint = closestPoints.vLinePoint;\n        var vLinePointX, vLinePointY;\n\n        xa = vLinePoint && vLinePoint.xa;\n        ya = vLinePoint && vLinePoint.ya;\n        var xSnap = xa.spikesnap;\n\n        if(xSnap === 'cursor') {\n            vLinePointX = evt.pointerX;\n            vLinePointY = evt.pointerY;\n        } else {\n            vLinePointX = xa._offset + vLinePoint.x;\n            vLinePointY = ya._offset + vLinePoint.y;\n        }\n        var dfltVLineColor = tinycolor.readability(vLinePoint.color, contrastColor) < 1.5 ?\n            Color.contrast(contrastColor) : vLinePoint.color;\n        var xMode = xa.spikemode;\n        var xThickness = xa.spikethickness;\n        var xColor = xa.spikecolor || dfltVLineColor;\n        var xBB = xa._boundingBox;\n        var yEdge = ((xBB.top + xBB.bottom) / 2) < vLinePointY ? xBB.bottom : xBB.top;\n        var yBase, yEndSpike;\n\n        if(xMode.indexOf('toaxis') !== -1 || xMode.indexOf('across') !== -1) {\n            if(xMode.indexOf('toaxis') !== -1) {\n                yBase = yEdge;\n                yEndSpike = vLinePointY;\n            }\n            if(xMode.indexOf('across') !== -1) {\n                yBase = xa._counterSpan[0];\n                yEndSpike = xa._counterSpan[1];\n            }\n\n            // Foreground vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness,\n                    stroke: xColor,\n                    'stroke-dasharray': Drawing.dashStyle(xa.spikedash, xThickness)\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n\n            // Background vertical line (to x-axis)\n            container.insert('line', ':first-child')\n                .attr({\n                    x1: vLinePointX,\n                    x2: vLinePointX,\n                    y1: yBase,\n                    y2: yEndSpike,\n                    'stroke-width': xThickness + 2,\n                    stroke: contrastColor\n                })\n                .classed('spikeline', true)\n                .classed('crisp', true);\n        }\n\n        // X axis marker\n        if(xMode.indexOf('marker') !== -1) {\n            container.insert('circle', ':first-child')\n                .attr({\n                    cx: vLinePointX,\n                    cy: yEdge - (xa.side !== 'top' ? xThickness : -xThickness),\n                    r: xThickness,\n                    fill: xColor\n                })\n                .classed('spikeline', true);\n        }\n    }\n}\n\nfunction hoverChanged(gd, evt, oldhoverdata) {\n    // don't emit any events if nothing changed\n    if(!oldhoverdata || oldhoverdata.length !== gd._hoverdata.length) return true;\n\n    for(var i = oldhoverdata.length - 1; i >= 0; i--) {\n        var oldPt = oldhoverdata[i];\n        var newPt = gd._hoverdata[i];\n\n        if(oldPt.curveNumber !== newPt.curveNumber ||\n            String(oldPt.pointNumber) !== String(newPt.pointNumber) ||\n            String(oldPt.pointNumbers) !== String(newPt.pointNumbers)\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction spikesChanged(gd, oldspikepoints) {\n    // don't relayout the plot because of new spikelines if spikelines points didn't change\n    if(!oldspikepoints) return true;\n    if(oldspikepoints.vLinePoint !== gd._spikepoints.vLinePoint ||\n        oldspikepoints.hLinePoint !== gd._spikepoints.hLinePoint\n    ) return true;\n    return false;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}