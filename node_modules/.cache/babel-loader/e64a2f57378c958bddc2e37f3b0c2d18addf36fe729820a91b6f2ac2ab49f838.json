{"ast":null,"code":"\"use strict\";\n\nmodule.exports = simplifyPolygon;\nvar orient = require(\"robust-orientation\");\nvar sc = require(\"simplicial-complex\");\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b));\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1] - b[1], 2));\n  return area / perim;\n}\nfunction simplifyPolygon(cells, positions, minArea) {\n  var n = positions.length;\n  var nc = cells.length;\n  var inv = new Array(n);\n  var outv = new Array(n);\n  var weights = new Array(n);\n  var dead = new Array(n);\n\n  //Initialize tables\n  for (var i = 0; i < n; ++i) {\n    inv[i] = outv[i] = -1;\n    weights[i] = Infinity;\n    dead[i] = false;\n  }\n\n  //Compute neighbors\n  for (var i = 0; i < nc; ++i) {\n    var c = cells[i];\n    if (c.length !== 2) {\n      throw new Error(\"Input must be a graph\");\n    }\n    var s = c[1];\n    var t = c[0];\n    if (outv[t] !== -1) {\n      outv[t] = -2;\n    } else {\n      outv[t] = s;\n    }\n    if (inv[s] !== -1) {\n      inv[s] = -2;\n    } else {\n      inv[s] = t;\n    }\n  }\n\n  //Updates the weight for vertex i\n  function computeWeight(i) {\n    if (dead[i]) {\n      return Infinity;\n    }\n    //TODO: Check that the line segment doesn't cross once simplified\n    var s = inv[i];\n    var t = outv[i];\n    if (s < 0 || t < 0) {\n      return Infinity;\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t]);\n    }\n  }\n\n  //Swaps two nodes on the heap (i,j) are the index of the nodes\n  function heapSwap(i, j) {\n    var a = heap[i];\n    var b = heap[j];\n    heap[i] = b;\n    heap[j] = a;\n    index[a] = j;\n    index[b] = i;\n  }\n\n  //Returns the weight of node i on the heap\n  function heapWeight(i) {\n    return weights[heap[i]];\n  }\n  function heapParent(i) {\n    if (i & 1) {\n      return i - 1 >> 1;\n    }\n    return (i >> 1) - 1;\n  }\n\n  //Bubble element i down the heap\n  function heapDown(i) {\n    var w = heapWeight(i);\n    while (true) {\n      var tw = w;\n      var left = 2 * i + 1;\n      var right = 2 * (i + 1);\n      var next = i;\n      if (left < heapCount) {\n        var lw = heapWeight(left);\n        if (lw < tw) {\n          next = left;\n          tw = lw;\n        }\n      }\n      if (right < heapCount) {\n        var rw = heapWeight(right);\n        if (rw < tw) {\n          next = right;\n        }\n      }\n      if (next === i) {\n        return i;\n      }\n      heapSwap(i, next);\n      i = next;\n    }\n  }\n\n  //Bubbles element i up the heap\n  function heapUp(i) {\n    var w = heapWeight(i);\n    while (i > 0) {\n      var parent = heapParent(i);\n      if (parent >= 0) {\n        var pw = heapWeight(parent);\n        if (w < pw) {\n          heapSwap(i, parent);\n          i = parent;\n          continue;\n        }\n      }\n      return i;\n    }\n  }\n\n  //Pop minimum element\n  function heapPop() {\n    if (heapCount > 0) {\n      var head = heap[0];\n      heapSwap(0, heapCount - 1);\n      heapCount -= 1;\n      heapDown(0);\n      return head;\n    }\n    return -1;\n  }\n\n  //Update heap item i\n  function heapUpdate(i, w) {\n    var a = heap[i];\n    if (weights[a] === w) {\n      return i;\n    }\n    weights[a] = -Infinity;\n    heapUp(i);\n    heapPop();\n    weights[a] = w;\n    heapCount += 1;\n    return heapUp(heapCount - 1);\n  }\n\n  //Kills a vertex (assume vertex already removed from heap)\n  function kill(i) {\n    if (dead[i]) {\n      return;\n    }\n    //Kill vertex\n    dead[i] = true;\n    //Fixup topology\n    var s = inv[i];\n    var t = outv[i];\n    if (inv[t] >= 0) {\n      inv[t] = s;\n    }\n    if (outv[s] >= 0) {\n      outv[s] = t;\n    }\n\n    //Update weights on s and t\n    if (index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s));\n    }\n    if (index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t));\n    }\n  }\n\n  //Initialize weights and heap\n  var heap = [];\n  var index = new Array(n);\n  for (var i = 0; i < n; ++i) {\n    var w = weights[i] = computeWeight(i);\n    if (w < Infinity) {\n      index[i] = heap.length;\n      heap.push(i);\n    } else {\n      index[i] = -1;\n    }\n  }\n  var heapCount = heap.length;\n  for (var i = heapCount >> 1; i >= 0; --i) {\n    heapDown(i);\n  }\n\n  //Kill vertices\n  while (true) {\n    var hmin = heapPop();\n    if (hmin < 0 || weights[hmin] > minArea) {\n      break;\n    }\n    kill(hmin);\n  }\n\n  //Build collapsed vertex table\n  var npositions = [];\n  for (var i = 0; i < n; ++i) {\n    if (!dead[i]) {\n      index[i] = npositions.length;\n      npositions.push(positions[i].slice());\n    }\n  }\n  var nv = npositions.length;\n  function tortoiseHare(seq, start) {\n    if (seq[start] < 0) {\n      return start;\n    }\n    var t = start;\n    var h = start;\n    do {\n      //Walk two steps with h\n      var nh = seq[h];\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n      h = nh;\n      nh = seq[h];\n      if (!dead[h] || nh < 0 || nh === h) {\n        break;\n      }\n      h = nh;\n\n      //Walk one step with t\n      t = seq[t];\n    } while (t !== h);\n    //Compress cycles\n    for (var v = start; v !== h; v = seq[v]) {\n      seq[v] = h;\n    }\n    return h;\n  }\n  var ncells = [];\n  cells.forEach(function (c) {\n    var tin = tortoiseHare(inv, c[0]);\n    var tout = tortoiseHare(outv, c[1]);\n    if (tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin];\n      var cout = index[tout];\n      if (cin !== cout) {\n        ncells.push([cin, cout]);\n      }\n    }\n  });\n\n  //Normalize result\n  sc.unique(sc.normalize(ncells));\n\n  //Return final list of cells\n  return {\n    positions: npositions,\n    edges: ncells\n  };\n}","map":{"version":3,"names":["module","exports","simplifyPolygon","orient","require","sc","errorWeight","base","a","b","area","Math","abs","perim","sqrt","pow","cells","positions","minArea","n","length","nc","inv","Array","outv","weights","dead","i","Infinity","c","Error","s","t","computeWeight","heapSwap","j","heap","index","heapWeight","heapParent","heapDown","w","tw","left","right","next","heapCount","lw","rw","heapUp","parent","pw","heapPop","head","heapUpdate","kill","push","hmin","npositions","slice","nv","tortoiseHare","seq","start","h","nh","v","ncells","forEach","tin","tout","cin","cout","unique","normalize","edges"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/simplify-planar-graph/simplify.js"],"sourcesContent":["\"use strict\"\n\nmodule.exports = simplifyPolygon\n\nvar orient = require(\"robust-orientation\")\nvar sc = require(\"simplicial-complex\")\n\nfunction errorWeight(base, a, b) {\n  var area = Math.abs(orient(base, a, b))\n  var perim = Math.sqrt(Math.pow(a[0] - b[0], 2) + Math.pow(a[1]-b[1], 2))\n  return area / perim\n}\n\nfunction simplifyPolygon(cells, positions, minArea) {\n\n  var n = positions.length\n  var nc = cells.length\n  var inv = new Array(n)\n  var outv = new Array(n)\n  var weights = new Array(n)\n  var dead = new Array(n)\n  \n  //Initialize tables\n  for(var i=0; i<n; ++i) {\n    inv[i] = outv[i] = -1\n    weights[i] = Infinity\n    dead[i] = false\n  }\n\n  //Compute neighbors\n  for(var i=0; i<nc; ++i) {\n    var c = cells[i]\n    if(c.length !== 2) {\n      throw new Error(\"Input must be a graph\")\n    }\n    var s = c[1]\n    var t = c[0]\n    if(outv[t] !== -1) {\n      outv[t] = -2\n    } else {\n      outv[t] = s\n    }\n    if(inv[s] !== -1) {\n      inv[s] = -2\n    } else {\n      inv[s] = t\n    }\n  }\n\n  //Updates the weight for vertex i\n  function computeWeight(i) {\n    if(dead[i]) {\n      return Infinity\n    }\n    //TODO: Check that the line segment doesn't cross once simplified\n    var s = inv[i]\n    var t = outv[i]\n    if((s<0) || (t<0)) {\n      return Infinity\n    } else {\n      return errorWeight(positions[i], positions[s], positions[t])\n    }\n  }\n\n  //Swaps two nodes on the heap (i,j) are the index of the nodes\n  function heapSwap(i,j) {\n    var a = heap[i]\n    var b = heap[j]\n    heap[i] = b\n    heap[j] = a\n    index[a] = j\n    index[b] = i\n  }\n\n  //Returns the weight of node i on the heap\n  function heapWeight(i) {\n    return weights[heap[i]]\n  }\n\n  function heapParent(i) {\n    if(i & 1) {\n      return (i - 1) >> 1\n    }\n    return (i >> 1) - 1\n  }\n\n  //Bubble element i down the heap\n  function heapDown(i) {\n    var w = heapWeight(i)\n    while(true) {\n      var tw = w\n      var left  = 2*i + 1\n      var right = 2*(i + 1)\n      var next = i\n      if(left < heapCount) {\n        var lw = heapWeight(left)\n        if(lw < tw) {\n          next = left\n          tw = lw\n        }\n      }\n      if(right < heapCount) {\n        var rw = heapWeight(right)\n        if(rw < tw) {\n          next = right\n        }\n      }\n      if(next === i) {\n        return i\n      }\n      heapSwap(i, next)\n      i = next      \n    }\n  }\n\n  //Bubbles element i up the heap\n  function heapUp(i) {\n    var w = heapWeight(i)\n    while(i > 0) {\n      var parent = heapParent(i)\n      if(parent >= 0) {\n        var pw = heapWeight(parent)\n        if(w < pw) {\n          heapSwap(i, parent)\n          i = parent\n          continue\n        }\n      }\n      return i\n    }\n  }\n\n  //Pop minimum element\n  function heapPop() {\n    if(heapCount > 0) {\n      var head = heap[0]\n      heapSwap(0, heapCount-1)\n      heapCount -= 1\n      heapDown(0)\n      return head\n    }\n    return -1\n  }\n\n  //Update heap item i\n  function heapUpdate(i, w) {\n    var a = heap[i]\n    if(weights[a] === w) {\n      return i\n    }\n    weights[a] = -Infinity\n    heapUp(i)\n    heapPop()\n    weights[a] = w\n    heapCount += 1\n    return heapUp(heapCount-1)\n  }\n\n  //Kills a vertex (assume vertex already removed from heap)\n  function kill(i) {\n    if(dead[i]) {\n      return\n    }\n    //Kill vertex\n    dead[i] = true\n    //Fixup topology\n    var s = inv[i]\n    var t = outv[i]\n    if(inv[t] >= 0) {\n      inv[t] = s\n    }\n    if(outv[s] >= 0) {\n      outv[s] = t\n    }\n\n    //Update weights on s and t\n    if(index[s] >= 0) {\n      heapUpdate(index[s], computeWeight(s))\n    }\n    if(index[t] >= 0) {\n      heapUpdate(index[t], computeWeight(t))\n    }\n  }\n\n  //Initialize weights and heap\n  var heap = []\n  var index = new Array(n)\n  for(var i=0; i<n; ++i) {\n    var w = weights[i] = computeWeight(i)\n    if(w < Infinity) {\n      index[i] = heap.length\n      heap.push(i)\n    } else {\n      index[i] = -1\n    }\n  }\n  var heapCount = heap.length\n  for(var i=heapCount>>1; i>=0; --i) {\n    heapDown(i)\n  }\n  \n  //Kill vertices\n  while(true) {\n    var hmin = heapPop()\n    if((hmin < 0) || (weights[hmin] > minArea)) {\n      break\n    }\n    kill(hmin)\n  }\n\n  //Build collapsed vertex table\n  var npositions = []\n  for(var i=0; i<n; ++i) {\n    if(!dead[i]) {\n      index[i] = npositions.length\n      npositions.push(positions[i].slice())\n    }\n  }\n  var nv = npositions.length\n\n  function tortoiseHare(seq, start) {\n    if(seq[start] < 0) {\n      return start\n    }\n    var t = start\n    var h = start\n    do {\n      //Walk two steps with h\n      var nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n      nh = seq[h]\n      if(!dead[h] || nh < 0 || nh === h) {\n        break\n      }\n      h = nh\n\n      //Walk one step with t\n      t = seq[t]\n    } while(t !== h)\n    //Compress cycles\n    for(var v=start; v!==h; v = seq[v]) {\n      seq[v] = h\n    }\n    return h\n  }\n\n  var ncells = []\n  cells.forEach(function(c) {\n    var tin = tortoiseHare(inv, c[0])\n    var tout = tortoiseHare(outv, c[1])\n    if(tin >= 0 && tout >= 0 && tin !== tout) {\n      var cin = index[tin]\n      var cout = index[tout]\n      if(cin !== cout) {\n        ncells.push([ cin, cout ])\n      }\n    }\n  })\n\n  //Normalize result\n  sc.unique(sc.normalize(ncells))\n\n  //Return final list of cells\n  return {\n    positions: npositions,\n    edges: ncells\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}