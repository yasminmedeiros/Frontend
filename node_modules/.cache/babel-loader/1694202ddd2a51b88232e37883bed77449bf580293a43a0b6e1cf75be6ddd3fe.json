{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar constants = require('./constants');\nvar Lib = require('../../lib');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function (ax) {\n  return ax.type === 'log' ? ax.r2d : function (v) {\n    return v;\n  };\n};\nexports.shapePositionToRange = function (ax) {\n  return ax.type === 'log' ? ax.d2r : function (v) {\n    return v;\n  };\n};\nexports.decodeDate = function (convertToPx) {\n  return function (v) {\n    if (v.replace) v = v.replace('_', ' ');\n    return convertToPx(v);\n  };\n};\nexports.encodeDate = function (convertToDate) {\n  return function (v) {\n    return convertToDate(v).replace(' ', '_');\n  };\n};\nexports.extractPathCoords = function (path, paramsToUse) {\n  var extractedCoordinates = [];\n  var segments = path.match(constants.segmentRE);\n  segments.forEach(function (segment) {\n    var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n    if (relevantParamIdx === undefined) return;\n    var params = segment.substr(1).match(constants.paramRE);\n    if (!params || params.length < relevantParamIdx) return;\n    extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n  });\n  return extractedCoordinates;\n};\nexports.getDataToPixel = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var dataToPixel;\n  if (axis) {\n    var d2r = exports.shapePositionToRange(axis);\n    dataToPixel = function dataToPixel(v) {\n      return axis._offset + axis.r2p(d2r(v, true));\n    };\n    if (axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n  } else if (isVertical) {\n    dataToPixel = function dataToPixel(v) {\n      return gs.t + gs.h * (1 - v);\n    };\n  } else {\n    dataToPixel = function dataToPixel(v) {\n      return gs.l + gs.w * v;\n    };\n  }\n  return dataToPixel;\n};\nexports.getPixelToData = function (gd, axis, isVertical) {\n  var gs = gd._fullLayout._size;\n  var pixelToData;\n  if (axis) {\n    var r2d = exports.rangeToShapePosition(axis);\n    pixelToData = function pixelToData(p) {\n      return r2d(axis.p2r(p - axis._offset));\n    };\n  } else if (isVertical) {\n    pixelToData = function pixelToData(p) {\n      return 1 - (p - gs.t) / gs.h;\n    };\n  } else {\n    pixelToData = function pixelToData(p) {\n      return (p - gs.l) / gs.w;\n    };\n  }\n  return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function (pos, strokeWidth) {\n  var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n  var posValAsInt = Math.round(pos);\n  return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};","map":{"version":3,"names":["constants","require","Lib","exports","rangeToShapePosition","ax","type","r2d","v","shapePositionToRange","d2r","decodeDate","convertToPx","replace","encodeDate","convertToDate","extractPathCoords","path","paramsToUse","extractedCoordinates","segments","match","segmentRE","forEach","segment","relevantParamIdx","charAt","drawn","undefined","params","substr","paramRE","length","push","cleanNumber","getDataToPixel","gd","axis","isVertical","gs","_fullLayout","_size","dataToPixel","_offset","r2p","t","h","l","w","getPixelToData","pixelToData","p","p2r","roundPositionForSharpStrokeRendering","pos","strokeWidth","strokeWidthIsOdd","Math","round","posValAsInt"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/components/shapes/helpers.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar constants = require('./constants');\n\nvar Lib = require('../../lib');\n\n// special position conversion functions... category axis positions can't be\n// specified by their data values, because they don't make a continuous mapping.\n// so these have to be specified in terms of the category serial numbers,\n// but can take fractional values. Other axis types we specify position based on\n// the actual data values.\n// TODO: in V2.0 (when log axis ranges are in data units) range and shape position\n// will be identical, so rangeToShapePosition and shapePositionToRange can be\n// removed entirely.\n\nexports.rangeToShapePosition = function(ax) {\n    return (ax.type === 'log') ? ax.r2d : function(v) { return v; };\n};\n\nexports.shapePositionToRange = function(ax) {\n    return (ax.type === 'log') ? ax.d2r : function(v) { return v; };\n};\n\nexports.decodeDate = function(convertToPx) {\n    return function(v) {\n        if(v.replace) v = v.replace('_', ' ');\n        return convertToPx(v);\n    };\n};\n\nexports.encodeDate = function(convertToDate) {\n    return function(v) { return convertToDate(v).replace(' ', '_'); };\n};\n\nexports.extractPathCoords = function(path, paramsToUse) {\n    var extractedCoordinates = [];\n\n    var segments = path.match(constants.segmentRE);\n    segments.forEach(function(segment) {\n        var relevantParamIdx = paramsToUse[segment.charAt(0)].drawn;\n        if(relevantParamIdx === undefined) return;\n\n        var params = segment.substr(1).match(constants.paramRE);\n        if(!params || params.length < relevantParamIdx) return;\n\n        extractedCoordinates.push(Lib.cleanNumber(params[relevantParamIdx]));\n    });\n\n    return extractedCoordinates;\n};\n\nexports.getDataToPixel = function(gd, axis, isVertical) {\n    var gs = gd._fullLayout._size;\n    var dataToPixel;\n\n    if(axis) {\n        var d2r = exports.shapePositionToRange(axis);\n\n        dataToPixel = function(v) {\n            return axis._offset + axis.r2p(d2r(v, true));\n        };\n\n        if(axis.type === 'date') dataToPixel = exports.decodeDate(dataToPixel);\n    }\n    else if(isVertical) {\n        dataToPixel = function(v) { return gs.t + gs.h * (1 - v); };\n    }\n    else {\n        dataToPixel = function(v) { return gs.l + gs.w * v; };\n    }\n\n    return dataToPixel;\n};\n\nexports.getPixelToData = function(gd, axis, isVertical) {\n    var gs = gd._fullLayout._size;\n    var pixelToData;\n\n    if(axis) {\n        var r2d = exports.rangeToShapePosition(axis);\n        pixelToData = function(p) { return r2d(axis.p2r(p - axis._offset)); };\n    }\n    else if(isVertical) {\n        pixelToData = function(p) { return 1 - (p - gs.t) / gs.h; };\n    }\n    else {\n        pixelToData = function(p) { return (p - gs.l) / gs.w; };\n    }\n\n    return pixelToData;\n};\n\n/**\n * Based on the given stroke width, rounds the passed\n * position value to represent either a full or half pixel.\n *\n * In case of an odd stroke width (e.g. 1), this measure ensures\n * that a stroke positioned at the returned position isn't rendered\n * blurry due to anti-aliasing.\n *\n * In case of an even stroke width (e.g. 2), this measure ensures\n * that the position value is transformed to a full pixel value\n * so that anti-aliasing doesn't take effect either.\n *\n * @param {number} pos The raw position value to be transformed\n * @param {number} strokeWidth The stroke width\n * @returns {number} either an integer or a .5 decimal number\n */\nexports.roundPositionForSharpStrokeRendering = function(pos, strokeWidth) {\n    var strokeWidthIsOdd = Math.round(strokeWidth % 2) === 1;\n    var posValAsInt = Math.round(pos);\n\n    return strokeWidthIsOdd ? posValAsInt + 0.5 : posValAsInt;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}