{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar nestedProperty = Lib.nestedProperty;\nvar attributes = require('./attributes');\nvar BINATTRS = {\n  x: [{\n    aStr: 'xbins.start',\n    name: 'start'\n  }, {\n    aStr: 'xbins.end',\n    name: 'end'\n  }, {\n    aStr: 'xbins.size',\n    name: 'size'\n  }, {\n    aStr: 'nbinsx',\n    name: 'nbins'\n  }],\n  y: [{\n    aStr: 'ybins.start',\n    name: 'start'\n  }, {\n    aStr: 'ybins.end',\n    name: 'end'\n  }, {\n    aStr: 'ybins.size',\n    name: 'size'\n  }, {\n    aStr: 'nbinsy',\n    name: 'nbins'\n  }]\n};\n\n// handle bin attrs and relink auto-determined values so fullData is complete\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n  var allBinOpts = fullLayout._histogramBinOpts = {};\n  var isOverlay = fullLayout.barmode === 'overlay';\n  var i, j, traceOut, traceIn, binDirection, group, binOpts;\n  function coerce(attr) {\n    return Lib.coerce(traceOut._input, traceOut, attributes, attr);\n  }\n  for (i = 0; i < fullData.length; i++) {\n    traceOut = fullData[i];\n    if (traceOut.type !== 'histogram') continue;\n\n    // TODO: this shouldn't be relinked as it's only used within calc\n    // https://github.com/plotly/plotly.js/issues/749\n    delete traceOut._autoBinFinished;\n    binDirection = traceOut.orientation === 'v' ? 'x' : 'y';\n    // in overlay mode make a separate group for each trace\n    // otherwise collect all traces of the same subplot & orientation\n    group = isOverlay ? traceOut.uid : traceOut.xaxis + traceOut.yaxis + binDirection;\n    traceOut._groupName = group;\n    binOpts = allBinOpts[group];\n    if (binOpts) {\n      binOpts.traces.push(traceOut);\n    } else {\n      binOpts = allBinOpts[group] = {\n        traces: [traceOut],\n        direction: binDirection\n      };\n    }\n  }\n  for (group in allBinOpts) {\n    binOpts = allBinOpts[group];\n    binDirection = binOpts.direction;\n    var attrs = BINATTRS[binDirection];\n    for (j = 0; j < attrs.length; j++) {\n      var attrSpec = attrs[j];\n      var attr = attrSpec.name;\n\n      // nbins(x|y) is moot if we have a size. This depends on\n      // nbins coming after size in binAttrs.\n      if (attr === 'nbins' && binOpts.sizeFound) continue;\n      var aStr = attrSpec.aStr;\n      for (i = 0; i < binOpts.traces.length; i++) {\n        traceOut = binOpts.traces[i];\n        traceIn = traceOut._input;\n        if (nestedProperty(traceIn, aStr).get() !== undefined) {\n          binOpts[attr] = coerce(aStr);\n          binOpts[attr + 'Found'] = true;\n          break;\n        }\n        var autoVals = traceOut._autoBin;\n        if (autoVals && autoVals[attr]) {\n          // if this is the *first* autoval\n          nestedProperty(traceOut, aStr).set(autoVals[attr]);\n        }\n      }\n      // start and end we need to coerce anyway, after having collected the\n      // first of each into binOpts, in case a trace wants to restrict its\n      // data to a certain range\n      if (attr === 'start' || attr === 'end') {\n        for (; i < binOpts.traces.length; i++) {\n          traceOut = binOpts.traces[i];\n          coerce(aStr, (traceOut._autoBin || {})[attr]);\n        }\n      }\n      if (attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n        traceOut = binOpts.traces[0];\n        binOpts[attr] = coerce(aStr);\n      }\n    }\n  }\n};","map":{"version":3,"names":["Lib","require","nestedProperty","attributes","BINATTRS","x","aStr","name","y","module","exports","crossTraceDefaults","fullData","fullLayout","allBinOpts","_histogramBinOpts","isOverlay","barmode","i","j","traceOut","traceIn","binDirection","group","binOpts","coerce","attr","_input","length","type","_autoBinFinished","orientation","uid","xaxis","yaxis","_groupName","traces","push","direction","attrs","attrSpec","sizeFound","get","undefined","autoVals","_autoBin","set","nbinsFound"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/traces/histogram/cross_trace_defaults.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar nestedProperty = Lib.nestedProperty;\n\nvar attributes = require('./attributes');\n\nvar BINATTRS = {\n    x: [\n        {aStr: 'xbins.start', name: 'start'},\n        {aStr: 'xbins.end', name: 'end'},\n        {aStr: 'xbins.size', name: 'size'},\n        {aStr: 'nbinsx', name: 'nbins'}\n    ],\n    y: [\n        {aStr: 'ybins.start', name: 'start'},\n        {aStr: 'ybins.end', name: 'end'},\n        {aStr: 'ybins.size', name: 'size'},\n        {aStr: 'nbinsy', name: 'nbins'}\n    ]\n};\n\n// handle bin attrs and relink auto-determined values so fullData is complete\nmodule.exports = function crossTraceDefaults(fullData, fullLayout) {\n    var allBinOpts = fullLayout._histogramBinOpts = {};\n    var isOverlay = fullLayout.barmode === 'overlay';\n    var i, j, traceOut, traceIn, binDirection, group, binOpts;\n\n    function coerce(attr) {\n        return Lib.coerce(traceOut._input, traceOut, attributes, attr);\n    }\n\n    for(i = 0; i < fullData.length; i++) {\n        traceOut = fullData[i];\n        if(traceOut.type !== 'histogram') continue;\n\n        // TODO: this shouldn't be relinked as it's only used within calc\n        // https://github.com/plotly/plotly.js/issues/749\n        delete traceOut._autoBinFinished;\n\n        binDirection = traceOut.orientation === 'v' ? 'x' : 'y';\n        // in overlay mode make a separate group for each trace\n        // otherwise collect all traces of the same subplot & orientation\n        group = isOverlay ? traceOut.uid : (traceOut.xaxis + traceOut.yaxis + binDirection);\n        traceOut._groupName = group;\n\n        binOpts = allBinOpts[group];\n\n        if(binOpts) {\n            binOpts.traces.push(traceOut);\n        }\n        else {\n            binOpts = allBinOpts[group] = {\n                traces: [traceOut],\n                direction: binDirection\n            };\n        }\n    }\n\n    for(group in allBinOpts) {\n        binOpts = allBinOpts[group];\n        binDirection = binOpts.direction;\n        var attrs = BINATTRS[binDirection];\n        for(j = 0; j < attrs.length; j++) {\n            var attrSpec = attrs[j];\n            var attr = attrSpec.name;\n\n            // nbins(x|y) is moot if we have a size. This depends on\n            // nbins coming after size in binAttrs.\n            if(attr === 'nbins' && binOpts.sizeFound) continue;\n\n            var aStr = attrSpec.aStr;\n            for(i = 0; i < binOpts.traces.length; i++) {\n                traceOut = binOpts.traces[i];\n                traceIn = traceOut._input;\n                if(nestedProperty(traceIn, aStr).get() !== undefined) {\n                    binOpts[attr] = coerce(aStr);\n                    binOpts[attr + 'Found'] = true;\n                    break;\n                }\n                var autoVals = traceOut._autoBin;\n                if(autoVals && autoVals[attr]) {\n                    // if this is the *first* autoval\n                    nestedProperty(traceOut, aStr).set(autoVals[attr]);\n                }\n            }\n            // start and end we need to coerce anyway, after having collected the\n            // first of each into binOpts, in case a trace wants to restrict its\n            // data to a certain range\n            if(attr === 'start' || attr === 'end') {\n                for(; i < binOpts.traces.length; i++) {\n                    traceOut = binOpts.traces[i];\n                    coerce(aStr, (traceOut._autoBin || {})[attr]);\n                }\n            }\n\n            if(attr === 'nbins' && !binOpts.sizeFound && !binOpts.nbinsFound) {\n                traceOut = binOpts.traces[0];\n                binOpts[attr] = coerce(aStr);\n            }\n        }\n    }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}