{"ast":null,"code":"\"use strict\";\n\nvar vec3 = require('gl-vec3');\nvar vec4 = require('gl-vec4');\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\nvar streamToTube = function streamToTube(stream, maxDivergence, minDistance, maxNorm) {\n  var points = stream.points;\n  var velocities = stream.velocities;\n  var divergences = stream.divergences;\n  var verts = [];\n  var faces = [];\n  var vectors = [];\n  var previousVerts = [];\n  var currentVerts = [];\n  var intensities = [];\n  var previousIntensity = 0;\n  var currentIntensity = 0;\n  var currentVector = vec4.create();\n  var previousVector = vec4.create();\n  var facets = 8;\n  for (var i = 0; i < points.length; i++) {\n    var p = points[i];\n    var fwd = velocities[i];\n    var r = divergences[i];\n    if (maxDivergence === 0) {\n      r = minDistance * 0.05;\n    }\n    currentIntensity = vec3.length(fwd) / maxNorm;\n    currentVector = vec4.create();\n    vec3.copy(currentVector, fwd);\n    currentVector[3] = r;\n    for (var a = 0; a < facets; a++) {\n      currentVerts[a] = [p[0], p[1], p[2], a];\n    }\n    if (previousVerts.length > 0) {\n      for (var a = 0; a < facets; a++) {\n        var a1 = (a + 1) % facets;\n        verts.push(previousVerts[a], currentVerts[a], currentVerts[a1], currentVerts[a1], previousVerts[a1], previousVerts[a]);\n        vectors.push(previousVector, currentVector, currentVector, currentVector, previousVector, previousVector);\n        intensities.push(previousIntensity, currentIntensity, currentIntensity, currentIntensity, previousIntensity, previousIntensity);\n        var len = verts.length;\n        faces.push([len - 6, len - 5, len - 4], [len - 3, len - 2, len - 1]);\n      }\n    }\n    var tmp1 = previousVerts;\n    previousVerts = currentVerts;\n    currentVerts = tmp1;\n    var tmp2 = previousVector;\n    previousVector = currentVector;\n    currentVector = tmp2;\n    var tmp3 = previousIntensity;\n    previousIntensity = currentIntensity;\n    currentIntensity = tmp3;\n  }\n  return {\n    positions: verts,\n    cells: faces,\n    vectors: vectors,\n    vertexIntensity: intensities\n  };\n};\nvar createTubes = function createTubes(streams, colormap, maxDivergence, minDistance) {\n  var maxNorm = 0;\n  for (var i = 0; i < streams.length; i++) {\n    var velocities = streams[i].velocities;\n    for (var j = 0; j < velocities.length; j++) {\n      maxNorm = Math.max(maxNorm, vec3.length(velocities[j]));\n    }\n  }\n  var tubes = streams.map(function (s) {\n    return streamToTube(s, maxDivergence, minDistance, maxNorm);\n  });\n  var positions = [];\n  var cells = [];\n  var vectors = [];\n  var vertexIntensity = [];\n  for (var i = 0; i < tubes.length; i++) {\n    var tube = tubes[i];\n    var offset = positions.length;\n    positions = positions.concat(tube.positions);\n    vectors = vectors.concat(tube.vectors);\n    vertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n    for (var j = 0; j < tube.cells.length; j++) {\n      var cell = tube.cells[j];\n      var newCell = [];\n      cells.push(newCell);\n      for (var k = 0; k < cell.length; k++) {\n        newCell.push(cell[k] + offset);\n      }\n    }\n  }\n  return {\n    positions: positions,\n    cells: cells,\n    vectors: vectors,\n    vertexIntensity: vertexIntensity,\n    colormap: colormap\n  };\n};\nvar findLastSmallerIndex = function findLastSmallerIndex(points, v) {\n  var len = points.length;\n  var i;\n  for (i = 0; i < len; i++) {\n    var p = points[i];\n    if (p === v) return i;else if (p > v) return i - 1;\n  }\n  return i;\n};\nvar clamp = function clamp(v, min, max) {\n  return v < min ? min : v > max ? max : v;\n};\nvar sampleMeshgrid = function sampleMeshgrid(point, vectorField, gridInfo) {\n  var vectors = vectorField.vectors;\n  var meshgrid = vectorField.meshgrid;\n  var x = point[0];\n  var y = point[1];\n  var z = point[2];\n  var w = meshgrid[0].length;\n  var h = meshgrid[1].length;\n  var d = meshgrid[2].length;\n\n  // Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n  // The nearest smaller value index for x is the index x0 such that\n  // meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n  var x0 = findLastSmallerIndex(meshgrid[0], x);\n  var y0 = findLastSmallerIndex(meshgrid[1], y);\n  var z0 = findLastSmallerIndex(meshgrid[2], z);\n\n  // Get the nearest larger meshgrid value indices.\n  // From the above \"nearest smaller value\", we know that\n  //   meshgrid[0][x0] < x\n  //   meshgrid[0][x0+1] >= x\n  var x1 = x0 + 1;\n  var y1 = y0 + 1;\n  var z1 = z0 + 1;\n  x0 = clamp(x0, 0, w - 1);\n  x1 = clamp(x1, 0, w - 1);\n  y0 = clamp(y0, 0, h - 1);\n  y1 = clamp(y1, 0, h - 1);\n  z0 = clamp(z0, 0, d - 1);\n  z1 = clamp(z1, 0, d - 1);\n\n  // Reject points outside the meshgrid, return a zero vector.\n  if (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w - 1 || y1 > h - 1 || z1 > d - 1) {\n    return vec3.create();\n  }\n\n  // Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n  var mX0 = meshgrid[0][x0];\n  var mX1 = meshgrid[0][x1];\n  var mY0 = meshgrid[1][y0];\n  var mY1 = meshgrid[1][y1];\n  var mZ0 = meshgrid[2][z0];\n  var mZ1 = meshgrid[2][z1];\n  var xf = (x - mX0) / (mX1 - mX0);\n  var yf = (y - mY0) / (mY1 - mY0);\n  var zf = (z - mZ0) / (mZ1 - mZ0);\n  if (!isFinite(xf)) xf = 0.5;\n  if (!isFinite(yf)) yf = 0.5;\n  if (!isFinite(zf)) zf = 0.5;\n  var x0off;\n  var x1off;\n  var y0off;\n  var y1off;\n  var z0off;\n  var z1off;\n  if (gridInfo.reversedX) {\n    x0 = w - 1 - x0;\n    x1 = w - 1 - x1;\n  }\n  if (gridInfo.reversedY) {\n    y0 = h - 1 - y0;\n    y1 = h - 1 - y1;\n  }\n  if (gridInfo.reversedZ) {\n    z0 = d - 1 - z0;\n    z1 = d - 1 - z1;\n  }\n  switch (gridInfo.filled) {\n    case 5:\n      // 'zyx'\n      z0off = z0;\n      z1off = z1;\n      y0off = y0 * d;\n      y1off = y1 * d;\n      x0off = x0 * d * h;\n      x1off = x1 * d * h;\n      break;\n    case 4:\n      // 'zxy'\n      z0off = z0;\n      z1off = z1;\n      x0off = x0 * d;\n      x1off = x1 * d;\n      y0off = y0 * d * w;\n      y1off = y1 * d * w;\n      break;\n    case 3:\n      // 'yzx'\n      y0off = y0;\n      y1off = y1;\n      z0off = z0 * h;\n      z1off = z1 * h;\n      x0off = x0 * h * d;\n      x1off = x1 * h * d;\n      break;\n    case 2:\n      // 'yxz'\n      y0off = y0;\n      y1off = y1;\n      x0off = x0 * h;\n      x1off = x1 * h;\n      z0off = z0 * h * w;\n      z1off = z1 * h * w;\n      break;\n    case 1:\n      // 'xzy'\n      x0off = x0;\n      x1off = x1;\n      z0off = z0 * w;\n      z1off = z1 * w;\n      y0off = y0 * w * d;\n      y1off = y1 * w * d;\n      break;\n    default:\n      // case 0: // 'xyz'\n      x0off = x0;\n      x1off = x1;\n      y0off = y0 * w;\n      y1off = y1 * w;\n      z0off = z0 * w * h;\n      z1off = z1 * w * h;\n      break;\n  }\n\n  // Sample data vectors around the (x,y,z) point.\n  var v000 = vectors[x0off + y0off + z0off];\n  var v001 = vectors[x0off + y0off + z1off];\n  var v010 = vectors[x0off + y1off + z0off];\n  var v011 = vectors[x0off + y1off + z1off];\n  var v100 = vectors[x1off + y0off + z0off];\n  var v101 = vectors[x1off + y0off + z1off];\n  var v110 = vectors[x1off + y1off + z0off];\n  var v111 = vectors[x1off + y1off + z1off];\n  var c00 = vec3.create();\n  var c01 = vec3.create();\n  var c10 = vec3.create();\n  var c11 = vec3.create();\n  vec3.lerp(c00, v000, v100, xf);\n  vec3.lerp(c01, v001, v101, xf);\n  vec3.lerp(c10, v010, v110, xf);\n  vec3.lerp(c11, v011, v111, xf);\n  var c0 = vec3.create();\n  var c1 = vec3.create();\n  vec3.lerp(c0, c00, c10, yf);\n  vec3.lerp(c1, c01, c11, yf);\n  var c = vec3.create();\n  vec3.lerp(c, c0, c1, zf);\n  return c;\n};\nvar vabs = function vabs(dst, v) {\n  var x = v[0];\n  var y = v[1];\n  var z = v[2];\n  dst[0] = x < 0 ? -x : x;\n  dst[1] = y < 0 ? -y : y;\n  dst[2] = z < 0 ? -z : z;\n  return dst;\n};\nvar findMinSeparation = function findMinSeparation(xs) {\n  var minSeparation = Infinity;\n  xs.sort(function (a, b) {\n    return a - b;\n  });\n  var len = xs.length;\n  for (var i = 1; i < len; i++) {\n    var d = Math.abs(xs[i] - xs[i - 1]);\n    if (d < minSeparation) {\n      minSeparation = d;\n    }\n  }\n  return minSeparation;\n};\n\n// Finds the minimum per-component distance in positions.\n//\nvar calculateMinPositionDistance = function calculateMinPositionDistance(positions) {\n  var xs = [],\n    ys = [],\n    zs = [];\n  var xi = {},\n    yi = {},\n    zi = {};\n  var len = positions.length;\n  for (var i = 0; i < len; i++) {\n    var p = positions[i];\n    var x = p[0],\n      y = p[1],\n      z = p[2];\n\n    // Split the positions array into arrays of unique component values.\n    //\n    // Why go through the trouble of using a uniqueness hash table vs\n    // sort and uniq:\n    //\n    // Suppose you've got a million positions in a 100x100x100 grid.\n    //\n    // Using a uniqueness hash table, you're doing 1M array reads,\n    // 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n    // sorting three 100-element arrays and iterating over them.\n    // Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n    //          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n    //          =~ 15M\n    //\n    // Sort and uniq solution would do 1M array reads, 3M array inserts,\n    // sort three 1M-element arrays and iterate over them.\n    // Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n    //          1M + 3M + 41.4M + 3M\n    //          =~ 48.4M\n    //\n    // Guessing that a hard-coded sort & uniq would be faster due to not having\n    // to run a hashing function on everything. More memory usage though\n    // (bunch of small hash tables vs. duplicating the input array.)\n    //\n    // In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n    // maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n    // Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n    //\n    // ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n    //\n    if (!xi[x]) {\n      xs.push(x);\n      xi[x] = true;\n    }\n    if (!yi[y]) {\n      ys.push(y);\n      yi[y] = true;\n    }\n    if (!zi[z]) {\n      zs.push(z);\n      zi[z] = true;\n    }\n  }\n  var xSep = findMinSeparation(xs);\n  var ySep = findMinSeparation(ys);\n  var zSep = findMinSeparation(zs);\n  var minSeparation = Math.min(xSep, ySep, zSep);\n  return isFinite(minSeparation) ? minSeparation : 1;\n};\nmodule.exports = function (vectorField, bounds) {\n  var positions = vectorField.startingPositions;\n  var maxLength = vectorField.maxLength || 1000;\n  var tubeSize = vectorField.tubeSize || 1;\n  var absoluteTubeSize = vectorField.absoluteTubeSize;\n  var gridFill = vectorField.gridFill || '+x+y+z';\n  var gridInfo = {};\n  if (gridFill.indexOf('-x') !== -1) {\n    gridInfo.reversedX = true;\n  }\n  if (gridFill.indexOf('-y') !== -1) {\n    gridInfo.reversedY = true;\n  }\n  if (gridFill.indexOf('-z') !== -1) {\n    gridInfo.reversedZ = true;\n  }\n  gridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n  var getVelocity = vectorField.getVelocity || function (p) {\n    return sampleMeshgrid(p, vectorField, gridInfo);\n  };\n  var getDivergence = vectorField.getDivergence || function (p, v0) {\n    var dp = vec3.create();\n    var e = 0.0001;\n    vec3.add(dp, p, [e, 0, 0]);\n    var vx = getVelocity(dp);\n    vec3.subtract(vx, vx, v0);\n    vec3.scale(vx, vx, 1 / e);\n    vec3.add(dp, p, [0, e, 0]);\n    var vy = getVelocity(dp);\n    vec3.subtract(vy, vy, v0);\n    vec3.scale(vy, vy, 1 / e);\n    vec3.add(dp, p, [0, 0, e]);\n    var vz = getVelocity(dp);\n    vec3.subtract(vz, vz, v0);\n    vec3.scale(vz, vz, 1 / e);\n    vec3.add(dp, vx, vy);\n    vec3.add(dp, dp, vz);\n    return dp;\n  };\n  var streams = [];\n  var minX = bounds[0][0],\n    minY = bounds[0][1],\n    minZ = bounds[0][2];\n  var maxX = bounds[1][0],\n    maxY = bounds[1][1],\n    maxZ = bounds[1][2];\n  var inBounds = function inBounds(p) {\n    var x = p[0];\n    var y = p[1];\n    var z = p[2];\n    return !(x < minX || x > maxX || y < minY || y > maxY || z < minZ || z > maxZ);\n  };\n  var boundsSize = vec3.distance(bounds[0], bounds[1]);\n  var maxStepSize = 10 * boundsSize / maxLength;\n  var maxStepSizeSq = maxStepSize * maxStepSize;\n  var minDistance = 1;\n  var maxDivergence = 0; // For component-wise divergence vec3.create();\n\n  // In case we need to do component-wise divergence visualization\n  // var tmp = vec3.create();\n\n  var len = positions.length;\n  if (len > 1) {\n    minDistance = calculateMinPositionDistance(positions);\n  }\n  for (var i = 0; i < len; i++) {\n    var p = vec3.create();\n    vec3.copy(p, positions[i]);\n    var stream = [p];\n    var velocities = [];\n    var v = getVelocity(p);\n    var op = p;\n    velocities.push(v);\n    var divergences = [];\n    var dv = getDivergence(p, v);\n    var dvLength = vec3.length(dv);\n    if (isFinite(dvLength) && dvLength > maxDivergence) {\n      maxDivergence = dvLength;\n    }\n    // In case we need to do component-wise divergence visualization\n    // vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n    divergences.push(dvLength);\n    streams.push({\n      points: stream,\n      velocities: velocities,\n      divergences: divergences\n    });\n    var j = 0;\n    while (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n      j++;\n      var np = vec3.clone(v);\n      var sqLen = vec3.squaredLength(np);\n      if (sqLen === 0) {\n        break;\n      } else if (sqLen > maxStepSizeSq) {\n        vec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n      }\n      vec3.add(np, np, p);\n      v = getVelocity(np);\n      if (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n        stream.push(np);\n        op = np;\n        velocities.push(v);\n        var dv = getDivergence(np, v);\n        var dvLength = vec3.length(dv);\n        if (isFinite(dvLength) && dvLength > maxDivergence) {\n          maxDivergence = dvLength;\n        }\n        // In case we need to do component-wise divergence visualization\n        //vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n        divergences.push(dvLength);\n      }\n      p = np;\n    }\n  }\n  var tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n  if (absoluteTubeSize) {\n    tubes.tubeScale = absoluteTubeSize;\n  } else {\n    // Avoid division by zero.\n    if (maxDivergence === 0) {\n      maxDivergence = 1;\n    }\n    tubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n  }\n  return tubes;\n};\nvar shaders = require('./lib/shaders');\nvar createMesh = require('gl-cone3d').createMesh;\nmodule.exports.createTubeMesh = function (gl, params) {\n  return createMesh(gl, params, {\n    shaders: shaders,\n    traceType: 'streamtube'\n  });\n};","map":{"version":3,"names":["vec3","require","vec4","GRID_TYPES","streamToTube","stream","maxDivergence","minDistance","maxNorm","points","velocities","divergences","verts","faces","vectors","previousVerts","currentVerts","intensities","previousIntensity","currentIntensity","currentVector","create","previousVector","facets","i","length","p","fwd","r","copy","a","a1","push","len","tmp1","tmp2","tmp3","positions","cells","vertexIntensity","createTubes","streams","colormap","j","Math","max","tubes","map","s","tube","offset","concat","cell","newCell","k","findLastSmallerIndex","v","clamp","min","sampleMeshgrid","point","vectorField","gridInfo","meshgrid","x","y","z","w","h","d","x0","y0","z0","x1","y1","z1","mX0","mX1","mY0","mY1","mZ0","mZ1","xf","yf","zf","isFinite","x0off","x1off","y0off","y1off","z0off","z1off","reversedX","reversedY","reversedZ","filled","v000","v001","v010","v011","v100","v101","v110","v111","c00","c01","c10","c11","lerp","c0","c1","c","vabs","dst","findMinSeparation","xs","minSeparation","Infinity","sort","b","abs","calculateMinPositionDistance","ys","zs","xi","yi","zi","xSep","ySep","zSep","module","exports","bounds","startingPositions","maxLength","tubeSize","absoluteTubeSize","gridFill","indexOf","replace","getVelocity","getDivergence","v0","dp","e","add","vx","subtract","scale","vy","vz","minX","minY","minZ","maxX","maxY","maxZ","inBounds","boundsSize","distance","maxStepSize","maxStepSizeSq","op","dv","dvLength","np","clone","sqLen","squaredLength","sqrt","squaredDistance","tubeScale","shaders","createMesh","createTubeMesh","gl","params","traceType"],"sources":["/home/yasmin/√Årea de Trabalho/Frontend/node_modules/gl-streamtube3d/streamtube.js"],"sourcesContent":["\"use strict\";\n\nvar vec3 = require('gl-vec3');\nvar vec4 = require('gl-vec4');\nvar GRID_TYPES = ['xyz', 'xzy', 'yxz', 'yzx', 'zxy', 'zyx'];\n\nvar streamToTube = function(stream, maxDivergence, minDistance, maxNorm) {\n\tvar points = stream.points;\n\tvar velocities = stream.velocities;\n\tvar divergences = stream.divergences;\n\n\tvar verts = [];\n\tvar faces = [];\n\tvar vectors = [];\n\tvar previousVerts = [];\n\tvar currentVerts = [];\n\tvar intensities = [];\n\tvar previousIntensity = 0;\n\tvar currentIntensity = 0;\n\tvar currentVector = vec4.create();\n\tvar previousVector = vec4.create();\n\n\tvar facets = 8;\n\n\tfor (var i = 0; i < points.length; i++) {\n\t\tvar p = points[i];\n\t\tvar fwd = velocities[i];\n\t\tvar r = divergences[i];\n\t\tif (maxDivergence === 0) {\n\t\t\tr = minDistance * 0.05;\n\t\t}\n\t\tcurrentIntensity = vec3.length(fwd) / maxNorm;\n\n\t\tcurrentVector = vec4.create();\n\t\tvec3.copy(currentVector, fwd);\n\t\tcurrentVector[3] = r;\n\n\t\tfor (var a = 0; a < facets; a++) {\n\t\t\tcurrentVerts[a] = [p[0], p[1], p[2], a];\n\t\t}\n\t\tif (previousVerts.length > 0) {\n\t\t\tfor (var a = 0; a < facets; a++) {\n\t\t\t\tvar a1 = (a+1) % facets;\n\t\t\t\tverts.push(\n\t\t\t\t\tpreviousVerts[a],\n\t\t\t\t\tcurrentVerts[a],\n\t\t\t\t\tcurrentVerts[a1],\n\n\t\t\t\t\tcurrentVerts[a1],\n\t\t\t\t\tpreviousVerts[a1],\n\t\t\t\t\tpreviousVerts[a]\n\t\t\t\t);\n\t\t\t\tvectors.push(\n\t\t\t\t\tpreviousVector,\n\t\t\t\t\tcurrentVector,\n\t\t\t\t\tcurrentVector,\n\n\t\t\t\t\tcurrentVector,\n\t\t\t\t\tpreviousVector,\n\t\t\t\t\tpreviousVector\n\t\t\t\t);\n\t\t\t\tintensities.push(\n\t\t\t\t\tpreviousIntensity,\n\t\t\t\t\tcurrentIntensity,\n\t\t\t\t\tcurrentIntensity,\n\n\t\t\t\t\tcurrentIntensity,\n\t\t\t\t\tpreviousIntensity,\n\t\t\t\t\tpreviousIntensity\n\t\t\t\t);\n\n\t\t\t\tvar len = verts.length;\n\t\t\t\tfaces.push(\n\t\t\t\t\t[len-6, len-5, len-4],\n\t\t\t\t\t[len-3, len-2, len-1]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tvar tmp1 = previousVerts;\n\t\tpreviousVerts = currentVerts;\n\t\tcurrentVerts = tmp1;\n\n\t\tvar tmp2 = previousVector;\n\t\tpreviousVector = currentVector;\n\t\tcurrentVector = tmp2;\n\n\t\tvar tmp3 = previousIntensity;\n\t\tpreviousIntensity = currentIntensity;\n\t\tcurrentIntensity = tmp3;\n\t}\n\treturn {\n\t\tpositions: verts,\n\t\tcells: faces,\n\t\tvectors: vectors,\n\t\tvertexIntensity: intensities\n\t};\n};\n\nvar createTubes = function(streams, colormap, maxDivergence, minDistance) {\n\n\tvar maxNorm = 0;\n\tfor (var i=0; i<streams.length; i++) {\n\t\tvar velocities = streams[i].velocities;\n\t\tfor (var j=0; j<velocities.length; j++) {\n\t\t\tmaxNorm = Math.max(maxNorm,\n\t\t\t\tvec3.length(velocities[j])\n\t\t\t);\n\t\t}\n\t}\n\n\tvar tubes = streams.map(function(s) {\n\t\treturn streamToTube(s, maxDivergence, minDistance, maxNorm);\n\t});\n\n\tvar positions = [];\n\tvar cells = [];\n\tvar vectors = [];\n\tvar vertexIntensity = [];\n\tfor (var i=0; i < tubes.length; i++) {\n\t\tvar tube = tubes[i];\n\t\tvar offset = positions.length;\n\t\tpositions = positions.concat(tube.positions);\n\t\tvectors = vectors.concat(tube.vectors);\n\t\tvertexIntensity = vertexIntensity.concat(tube.vertexIntensity);\n\t\tfor (var j=0; j<tube.cells.length; j++) {\n\t\t\tvar cell = tube.cells[j];\n\t\t\tvar newCell = [];\n\t\t\tcells.push(newCell);\n\t\t\tfor (var k=0; k<cell.length; k++) {\n\t\t\t\tnewCell.push(cell[k] + offset);\n\t\t\t}\n\t\t}\n\t}\n\treturn {\n\t\tpositions: positions,\n\t\tcells: cells,\n\t\tvectors: vectors,\n\t\tvertexIntensity: vertexIntensity,\n\t\tcolormap: colormap\n\t};\n};\n\nvar findLastSmallerIndex = function(points, v) {\n  var len = points.length;\n  var i;\n  for (i=0; i<len; i++) {\n  \tvar p = points[i];\n  \tif (p === v) return i;\n    else if (p > v) return i-1;\n  }\n  return i;\n};\n\nvar clamp = function(v, min, max) {\n\treturn v < min ? min : (v > max ? max : v);\n};\n\nvar sampleMeshgrid = function(point, vectorField, gridInfo) {\n\tvar vectors = vectorField.vectors;\n\tvar meshgrid = vectorField.meshgrid;\n\n\tvar x = point[0];\n\tvar y = point[1];\n\tvar z = point[2];\n\n\tvar w = meshgrid[0].length;\n\tvar h = meshgrid[1].length;\n\tvar d = meshgrid[2].length;\n\n\t// Find the index of the nearest smaller value in the meshgrid for each coordinate of (x,y,z).\n\t// The nearest smaller value index for x is the index x0 such that\n\t// meshgrid[0][x0] < x and for all x1 > x0, meshgrid[0][x1] >= x.\n\tvar x0 = findLastSmallerIndex(meshgrid[0], x);\n\tvar y0 = findLastSmallerIndex(meshgrid[1], y);\n\tvar z0 = findLastSmallerIndex(meshgrid[2], z);\n\n\t// Get the nearest larger meshgrid value indices.\n\t// From the above \"nearest smaller value\", we know that\n\t//   meshgrid[0][x0] < x\n\t//   meshgrid[0][x0+1] >= x\n\tvar x1 = x0 + 1;\n\tvar y1 = y0 + 1;\n\tvar z1 = z0 + 1;\n\n\tx0 = clamp(x0, 0, w-1);\n\tx1 = clamp(x1, 0, w-1);\n\ty0 = clamp(y0, 0, h-1);\n\ty1 = clamp(y1, 0, h-1);\n\tz0 = clamp(z0, 0, d-1);\n\tz1 = clamp(z1, 0, d-1);\n\n\t// Reject points outside the meshgrid, return a zero vector.\n\tif (x0 < 0 || y0 < 0 || z0 < 0 || x1 > w-1 || y1 > h-1 || z1 > d-1) {\n\t\treturn vec3.create();\n\t}\n\n\t// Normalize point coordinates to 0..1 scaling factor between x0 and x1.\n\tvar mX0 = meshgrid[0][x0];\n\tvar mX1 = meshgrid[0][x1];\n\tvar mY0 = meshgrid[1][y0];\n\tvar mY1 = meshgrid[1][y1];\n\tvar mZ0 = meshgrid[2][z0];\n\tvar mZ1 = meshgrid[2][z1];\n\tvar xf = (x - mX0) / (mX1 - mX0);\n\tvar yf = (y - mY0) / (mY1 - mY0);\n\tvar zf = (z - mZ0) / (mZ1 - mZ0);\n\n\tif (!isFinite(xf)) xf = 0.5;\n\tif (!isFinite(yf)) yf = 0.5;\n\tif (!isFinite(zf)) zf = 0.5;\n\n\tvar x0off;\n\tvar x1off;\n\tvar y0off;\n\tvar y1off;\n\tvar z0off;\n\tvar z1off;\n\n\tif(gridInfo.reversedX) {\n\t\tx0 = w - 1 - x0;\n\t\tx1 = w - 1 - x1;\n\t}\n\n\tif(gridInfo.reversedY) {\n\t\ty0 = h - 1 - y0;\n\t\ty1 = h - 1 - y1;\n\t}\n\n\tif(gridInfo.reversedZ) {\n\t\tz0 = d - 1 - z0;\n\t\tz1 = d - 1 - z1;\n\t}\n\n\tswitch(gridInfo.filled) {\n\t\tcase 5: // 'zyx'\n\t\t\tz0off = z0;\n\t\t\tz1off = z1;\n\t\t\ty0off = y0*d;\n\t\t\ty1off = y1*d;\n\t\t\tx0off = x0*d*h;\n\t\t\tx1off = x1*d*h;\n\t\t\tbreak;\n\n\t\tcase 4: // 'zxy'\n\t\t\tz0off = z0;\n\t\t\tz1off = z1;\n\t\t\tx0off = x0*d;\n\t\t\tx1off = x1*d;\n\t\t\ty0off = y0*d*w;\n\t\t\ty1off = y1*d*w;\n\t\t\tbreak;\n\n\t\tcase 3: // 'yzx'\n\t\t\ty0off = y0;\n\t\t\ty1off = y1;\n\t\t\tz0off = z0*h;\n\t\t\tz1off = z1*h;\n\t\t\tx0off = x0*h*d;\n\t\t\tx1off = x1*h*d;\n\t\t\tbreak;\n\n\t\tcase 2: // 'yxz'\n\t\t\ty0off = y0;\n\t\t\ty1off = y1;\n\t\t\tx0off = x0*h;\n\t\t\tx1off = x1*h;\n\t\t\tz0off = z0*h*w;\n\t\t\tz1off = z1*h*w;\n\t\t\tbreak;\n\n\t\tcase 1: // 'xzy'\n\t\t\tx0off = x0;\n\t\t\tx1off = x1;\n\t\t\tz0off = z0*w;\n\t\t\tz1off = z1*w;\n\t\t\ty0off = y0*w*d;\n\t\t\ty1off = y1*w*d;\n\t\t\tbreak;\n\n\t\tdefault: // case 0: // 'xyz'\n\t\t\tx0off = x0;\n\t\t\tx1off = x1;\n\t\t\ty0off = y0*w;\n\t\t\ty1off = y1*w;\n\t\t\tz0off = z0*w*h;\n\t\t\tz1off = z1*w*h;\n\t\t\tbreak;\n\t}\n\n\t// Sample data vectors around the (x,y,z) point.\n\tvar v000 = vectors[x0off + y0off + z0off];\n\tvar v001 = vectors[x0off + y0off + z1off];\n\tvar v010 = vectors[x0off + y1off + z0off];\n\tvar v011 = vectors[x0off + y1off + z1off];\n\tvar v100 = vectors[x1off + y0off + z0off];\n\tvar v101 = vectors[x1off + y0off + z1off];\n\tvar v110 = vectors[x1off + y1off + z0off];\n\tvar v111 = vectors[x1off + y1off + z1off];\n\n\tvar c00 = vec3.create();\n\tvar c01 = vec3.create();\n\tvar c10 = vec3.create();\n\tvar c11 = vec3.create();\n\n\tvec3.lerp(c00, v000, v100, xf);\n\tvec3.lerp(c01, v001, v101, xf);\n\tvec3.lerp(c10, v010, v110, xf);\n\tvec3.lerp(c11, v011, v111, xf);\n\n\tvar c0 = vec3.create();\n\tvar c1 = vec3.create();\n\n\tvec3.lerp(c0, c00, c10, yf);\n\tvec3.lerp(c1, c01, c11, yf);\n\n\tvar c = vec3.create();\n\n\tvec3.lerp(c, c0, c1, zf);\n\n\treturn c;\n};\n\n\nvar vabs = function(dst, v) {\n\tvar x = v[0];\n\tvar y = v[1];\n\tvar z = v[2];\n\tdst[0] = x < 0 ? -x : x;\n\tdst[1] = y < 0 ? -y : y;\n\tdst[2] = z < 0 ? -z : z;\n\treturn dst;\n};\n\nvar findMinSeparation = function(xs) {\n\tvar minSeparation = Infinity;\n\txs.sort(function(a, b) { return a - b; });\n\tvar len = xs.length;\n\tfor (var i=1; i<len; i++) {\n\t\tvar d = Math.abs(xs[i] - xs[i-1]);\n\t\tif (d < minSeparation) {\n\t\t\tminSeparation = d;\n\t\t}\n\t}\n\treturn minSeparation;\n};\n\n// Finds the minimum per-component distance in positions.\n//\nvar calculateMinPositionDistance = function(positions) {\n\tvar xs = [], ys = [], zs = [];\n\tvar xi = {}, yi = {}, zi = {};\n\tvar len = positions.length;\n\tfor (var i=0; i<len; i++) {\n\t\tvar p = positions[i];\n\t\tvar x = p[0], y = p[1], z = p[2];\n\n\t\t// Split the positions array into arrays of unique component values.\n\t\t//\n\t\t// Why go through the trouble of using a uniqueness hash table vs\n\t\t// sort and uniq:\n\t\t//\n\t\t// Suppose you've got a million positions in a 100x100x100 grid.\n\t\t//\n\t\t// Using a uniqueness hash table, you're doing 1M array reads,\n\t\t// 3M hash table lookups from 100-element hashes, 300 hash table inserts, then\n\t\t// sorting three 100-element arrays and iterating over them.\n\t\t// Roughly, 1M + 3M * ln(100) + 300 * ln(100/2) + 3 * 100 * ln(100) + 3 * 100 =\n\t\t//          1M + 13.8M + 0.0012M +  0.0014M + 0.0003M\n\t\t//          =~ 15M\n\t\t//\n\t\t// Sort and uniq solution would do 1M array reads, 3M array inserts,\n\t\t// sort three 1M-element arrays and iterate over them.\n\t\t// Roughly, 1M + 3M + 3 * 1M * ln(1M) + 3 * 1M =\n\t\t//          1M + 3M + 41.4M + 3M\n\t\t//          =~ 48.4M\n\t\t//\n\t\t// Guessing that a hard-coded sort & uniq would be faster due to not having\n\t\t// to run a hashing function on everything. More memory usage though\n\t\t// (bunch of small hash tables vs. duplicating the input array.)\n\t\t//\n\t\t// In JS-land, who knows. Maybe xi[x] casts x to string and destroys perf,\n\t\t// maybe numeric keys get special-cased, maybe the object lookups run at near O(1)-speeds.\n\t\t// Maybe the sorting comparison function is expensive to call, maybe it gets inlined or special-cased.\n\t\t//\n\t\t// ... You're probably not going to call this with more than 10k positions anyhow, so this is very academic.\n\t\t//\n\t\tif (!xi[x]) {\n\t\t\txs.push(x);\n\t\t\txi[x] = true;\n\t\t}\n\t\tif (!yi[y]) {\n\t\t\tys.push(y);\n\t\t\tyi[y] = true;\n\t\t}\n\t\tif (!zi[z]) {\n\t\t\tzs.push(z);\n\t\t\tzi[z] = true;\n\t\t}\n\t}\n\tvar xSep = findMinSeparation(xs);\n\tvar ySep = findMinSeparation(ys);\n\tvar zSep = findMinSeparation(zs);\n\tvar minSeparation = Math.min(xSep, ySep, zSep);\n\n\treturn isFinite(minSeparation) ? minSeparation : 1;\n};\n\nmodule.exports = function(vectorField, bounds) {\n\tvar positions = vectorField.startingPositions;\n\tvar maxLength = vectorField.maxLength || 1000;\n\tvar tubeSize = vectorField.tubeSize || 1;\n\tvar absoluteTubeSize = vectorField.absoluteTubeSize;\n\tvar gridFill = vectorField.gridFill || '+x+y+z';\n\n\tvar gridInfo = {};\n\tif(gridFill.indexOf('-x') !== -1) { gridInfo.reversedX = true; }\n\tif(gridFill.indexOf('-y') !== -1) { gridInfo.reversedY = true; }\n\tif(gridFill.indexOf('-z') !== -1) { gridInfo.reversedZ = true; }\n\tgridInfo.filled = GRID_TYPES.indexOf(gridFill.replace(/-/g, '').replace(/\\+/g, ''));\n\n\tvar getVelocity = vectorField.getVelocity || function(p) {\n\t\treturn sampleMeshgrid(p, vectorField, gridInfo);\n\t};\n\n\tvar getDivergence = vectorField.getDivergence || function(p, v0) {\n\t\tvar dp = vec3.create();\n\t\tvar e = 0.0001;\n\n\t\tvec3.add(dp, p, [e, 0, 0]);\n\t\tvar vx = getVelocity(dp);\n\t\tvec3.subtract(vx, vx, v0);\n\t\tvec3.scale(vx, vx, 1/e);\n\n\t\tvec3.add(dp, p, [0, e, 0]);\n\t\tvar vy = getVelocity(dp);\n\t\tvec3.subtract(vy, vy, v0);\n\t\tvec3.scale(vy, vy, 1/e);\n\n\t\tvec3.add(dp, p, [0, 0, e]);\n\t\tvar vz = getVelocity(dp);\n\t\tvec3.subtract(vz, vz, v0);\n\t\tvec3.scale(vz, vz, 1/e);\n\n\t\tvec3.add(dp, vx, vy);\n\t\tvec3.add(dp, dp, vz);\n\t\treturn dp;\n\t};\n\n\tvar streams = [];\n\n\tvar minX = bounds[0][0], minY = bounds[0][1], minZ = bounds[0][2];\n\tvar maxX = bounds[1][0], maxY = bounds[1][1], maxZ = bounds[1][2];\n\n\tvar inBounds = function(p) {\n\t\tvar x = p[0];\n\t\tvar y = p[1];\n\t\tvar z = p[2];\n\t\treturn !(\n\t\t\tx < minX || x > maxX ||\n\t\t\ty < minY || y > maxY ||\n\t\t\tz < minZ || z > maxZ\n\t\t);\n\t};\n\n\tvar boundsSize = vec3.distance(bounds[0], bounds[1]);\n\tvar maxStepSize = 10 * boundsSize / maxLength;\n\tvar maxStepSizeSq = maxStepSize * maxStepSize;\n\n\tvar minDistance = 1;\n\tvar maxDivergence = 0; // For component-wise divergence vec3.create();\n\n\t// In case we need to do component-wise divergence visualization\n\t// var tmp = vec3.create();\n\n\tvar len = positions.length;\n\tif (len > 1) {\n\t\tminDistance = calculateMinPositionDistance(positions);\n\t}\n\n\tfor (var i = 0; i < len; i++) {\n\t\tvar p = vec3.create();\n\t\tvec3.copy(p, positions[i]);\n\n\t\tvar stream = [p];\n\t\tvar velocities = [];\n\t\tvar v = getVelocity(p);\n\t\tvar op = p;\n\t\tvelocities.push(v);\n\n\t\tvar divergences = [];\n\n\t\tvar dv = getDivergence(p, v);\n\t\tvar dvLength = vec3.length(dv);\n\t\tif (isFinite(dvLength) && dvLength > maxDivergence) {\n\t\t\tmaxDivergence = dvLength;\n\t\t}\n\t\t// In case we need to do component-wise divergence visualization\n\t\t// vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\t\tdivergences.push(dvLength);\n\n\t\tstreams.push({points: stream, velocities: velocities, divergences: divergences});\n\n\t\tvar j = 0;\n\n\t\twhile (j < maxLength * 100 && stream.length < maxLength && inBounds(p)) {\n\t\t\tj++;\n\t\t\tvar np = vec3.clone(v);\n\t\t\tvar sqLen = vec3.squaredLength(np);\n\t\t\tif (sqLen === 0) {\n\t\t\t\tbreak;\n\t\t\t} else if (sqLen > maxStepSizeSq) {\n\t\t\t\tvec3.scale(np, np, maxStepSize / Math.sqrt(sqLen));\n\t\t\t}\n\t\t\tvec3.add(np, np, p);\n\n\t\t\tv = getVelocity(np);\n\n\t\t\tif (vec3.squaredDistance(op, np) - maxStepSizeSq > -0.0001 * maxStepSizeSq) {\n\t\t\t\tstream.push(np);\n\t\t\t\top = np;\n\t\t\t\tvelocities.push(v);\n\t\t\t\tvar dv = getDivergence(np, v);\n\t\t\t\tvar dvLength = vec3.length(dv);\n\t\t\t\tif (isFinite(dvLength) && dvLength > maxDivergence) {\n\t\t\t\t\tmaxDivergence = dvLength;\n\t\t\t\t}\n\t\t\t\t// In case we need to do component-wise divergence visualization\n\t\t\t\t//vec3.max(maxDivergence, maxDivergence, vabs(tmp, dv));\n\t\t\t\tdivergences.push(dvLength);\n\t\t\t}\n\n\t\t\tp = np;\n\t\t}\n\t}\n\n\tvar tubes = createTubes(streams, vectorField.colormap, maxDivergence, minDistance);\n\n\tif (absoluteTubeSize) {\n\t\ttubes.tubeScale = absoluteTubeSize;\n\t} else {\n\t\t// Avoid division by zero.\n\t\tif (maxDivergence === 0) {\n\t\t\tmaxDivergence = 1;\n\t\t}\n\t\ttubes.tubeScale = tubeSize * 0.5 * minDistance / maxDivergence;\n\t}\n\n\treturn tubes;\n};\n\nvar shaders = require('./lib/shaders');\nvar createMesh = require('gl-cone3d').createMesh;\nmodule.exports.createTubeMesh = function(gl, params) {\n\treturn createMesh(gl, params, {\n\t\tshaders: shaders,\n\t\ttraceType: 'streamtube'\n\t});\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}