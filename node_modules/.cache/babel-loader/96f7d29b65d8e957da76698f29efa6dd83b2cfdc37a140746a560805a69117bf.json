{"ast":null,"code":"'use strict';\n\nmodule.exports = boxIntersectIter;\nvar pool = require('typedarray-pool');\nvar bits = require('bit-twiddle');\nvar bruteForce = require('./brute');\nvar bruteForcePartial = bruteForce.partial;\nvar bruteForceFull = bruteForce.full;\nvar sweep = require('./sweep');\nvar findMedian = require('./median');\nvar genPartition = require('./partition');\n\n//Twiddle parameters\nvar BRUTE_FORCE_CUTOFF = 128; //Cut off for brute force search\nvar SCAN_CUTOFF = 1 << 22; //Cut off for two way scan\nvar SCAN_COMPLETE_CUTOFF = 1 << 22;\n\n//Partition functions\nvar partitionInteriorContainsInterval = genPartition('!(lo>=p0)&&!(p1>=hi)', ['p0', 'p1']);\nvar partitionStartEqual = genPartition('lo===p0', ['p0']);\nvar partitionStartLessThan = genPartition('lo<p0', ['p0']);\nvar partitionEndLessThanEqual = genPartition('hi<=p0', ['p0']);\nvar partitionContainsPoint = genPartition('lo<=p0&&p0<=hi', ['p0']);\nvar partitionContainsPointProper = genPartition('lo<p0&&p0<=hi', ['p0']);\n\n//Frame size for iterative loop\nvar IFRAME_SIZE = 6;\nvar DFRAME_SIZE = 2;\n\n//Data for box statck\nvar INIT_CAPACITY = 1024;\nvar BOX_ISTACK = pool.mallocInt32(INIT_CAPACITY);\nvar BOX_DSTACK = pool.mallocDouble(INIT_CAPACITY);\n\n//Initialize iterative loop queue\nfunction iterInit(d, count) {\n  var levels = 8 * bits.log2(count + 1) * (d + 1) | 0;\n  var maxInts = bits.nextPow2(IFRAME_SIZE * levels);\n  if (BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK);\n    BOX_ISTACK = pool.mallocInt32(maxInts);\n  }\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE * levels);\n  if (BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK);\n    BOX_DSTACK = pool.mallocDouble(maxDoubles);\n  }\n}\n\n//Append item to queue\nfunction iterPush(ptr, axis, redStart, redEnd, blueStart, blueEnd, state, lo, hi) {\n  var iptr = IFRAME_SIZE * ptr;\n  BOX_ISTACK[iptr] = axis;\n  BOX_ISTACK[iptr + 1] = redStart;\n  BOX_ISTACK[iptr + 2] = redEnd;\n  BOX_ISTACK[iptr + 3] = blueStart;\n  BOX_ISTACK[iptr + 4] = blueEnd;\n  BOX_ISTACK[iptr + 5] = state;\n  var dptr = DFRAME_SIZE * ptr;\n  BOX_DSTACK[dptr] = lo;\n  BOX_DSTACK[dptr + 1] = hi;\n}\n\n//Special case:  Intersect single point with list of intervals\nfunction onePointPartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n    if (flip && blueX === r0) {\n      continue;\n    }\n    var redId = redIndex[i];\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n    var retval;\n    if (flip) {\n      retval = visit(blueId, redId);\n    } else {\n      retval = visit(redId, blueId);\n    }\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n}\n\n//Special case:  Intersect one point with list of intervals\nfunction onePointFull(d, axis, visit, redStart, redEnd, red, redIndex, blueOffset, blue, blueId) {\n  var elemSize = 2 * d;\n  var bluePtr = blueOffset * elemSize;\n  var blueX = blue[bluePtr + axis];\n  red_loop: for (var i = redStart, redPtr = redStart * elemSize; i < redEnd; ++i, redPtr += elemSize) {\n    var redId = redIndex[i];\n    if (redId === blueId) {\n      continue;\n    }\n    var r0 = red[redPtr + axis];\n    var r1 = red[redPtr + axis + d];\n    if (blueX < r0 || r1 < blueX) {\n      continue;\n    }\n    for (var j = axis + 1; j < d; ++j) {\n      var r0 = red[redPtr + j];\n      var r1 = red[redPtr + j + d];\n      var b0 = blue[bluePtr + j];\n      var b1 = blue[bluePtr + j + d];\n      if (r1 < b0 || b1 < r0) {\n        continue red_loop;\n      }\n    }\n    var retval = visit(redId, blueId);\n    if (retval !== void 0) {\n      return retval;\n    }\n  }\n}\n\n//The main box intersection routine\nfunction boxIntersectIter(d, visit, initFull, xSize, xBoxes, xIndex, ySize, yBoxes, yIndex) {\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize);\n  var top = 0;\n  var elemSize = 2 * d;\n  var retval;\n  iterPush(top++, 0, 0, xSize, 0, ySize, initFull ? 16 : 0, -Infinity, Infinity);\n  if (!initFull) {\n    iterPush(top++, 0, 0, ySize, 0, xSize, 1, -Infinity, Infinity);\n  }\n  while (top > 0) {\n    top -= 1;\n    var iptr = top * IFRAME_SIZE;\n    var axis = BOX_ISTACK[iptr];\n    var redStart = BOX_ISTACK[iptr + 1];\n    var redEnd = BOX_ISTACK[iptr + 2];\n    var blueStart = BOX_ISTACK[iptr + 3];\n    var blueEnd = BOX_ISTACK[iptr + 4];\n    var state = BOX_ISTACK[iptr + 5];\n    var dptr = top * DFRAME_SIZE;\n    var lo = BOX_DSTACK[dptr];\n    var hi = BOX_DSTACK[dptr + 1];\n\n    //Unpack state info\n    var flip = state & 1;\n    var full = !!(state & 16);\n\n    //Unpack indices\n    var red = xBoxes;\n    var redIndex = xIndex;\n    var blue = yBoxes;\n    var blueIndex = yIndex;\n    if (flip) {\n      red = yBoxes;\n      redIndex = yIndex;\n      blue = xBoxes;\n      blueIndex = xIndex;\n    }\n    if (state & 2) {\n      redEnd = partitionStartLessThan(d, axis, redStart, redEnd, red, redIndex, hi);\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n    if (state & 4) {\n      redStart = partitionEndLessThanEqual(d, axis, redStart, redEnd, red, redIndex, lo);\n      if (redStart >= redEnd) {\n        continue;\n      }\n    }\n    var redCount = redEnd - redStart;\n    var blueCount = blueEnd - blueStart;\n    if (full) {\n      if (d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(d, axis, visit, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        if (retval !== void 0) {\n          return retval;\n        }\n        continue;\n      }\n    } else {\n      if (d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        if (retval !== void 0) {\n          return retval;\n        }\n        continue;\n      } else if (d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(d, axis, visit, flip, redStart, redEnd, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        if (retval !== void 0) {\n          return retval;\n        }\n        continue;\n      }\n    }\n\n    //First, find all red intervals whose interior contains (lo,hi)\n    var red0 = partitionInteriorContainsInterval(d, axis, redStart, redEnd, red, redIndex, lo, hi);\n\n    //Lower dimensional case\n    if (redStart < red0) {\n      if (d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(d, axis + 1, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (axis === d - 2) {\n        if (flip) {\n          retval = sweep.sweepBipartite(d, visit, blueStart, blueEnd, blue, blueIndex, redStart, red0, red, redIndex);\n        } else {\n          retval = sweep.sweepBipartite(d, visit, redStart, red0, red, redIndex, blueStart, blueEnd, blue, blueIndex);\n        }\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else {\n        iterPush(top++, axis + 1, redStart, red0, blueStart, blueEnd, flip, -Infinity, Infinity);\n        iterPush(top++, axis + 1, blueStart, blueEnd, redStart, red0, flip ^ 1, -Infinity, Infinity);\n      }\n    }\n\n    //Divide and conquer phase\n    if (red0 < redEnd) {\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(d, axis, blueStart, blueEnd, blue, blueIndex);\n      var mid = blue[elemSize * blue0 + axis];\n      var blue1 = partitionStartEqual(d, axis, blue0, blueEnd, blue, blueIndex, mid);\n\n      //Right case\n      if (blue1 < blueEnd) {\n        iterPush(top++, axis, red0, redEnd, blue1, blueEnd, (flip | 4) + (full ? 16 : 0), mid, hi);\n      }\n\n      //Left case\n      if (blueStart < blue0) {\n        iterPush(top++, axis, red0, redEnd, blueStart, blue0, (flip | 2) + (full ? 16 : 0), lo, mid);\n      }\n\n      //Center case (the hard part)\n      if (blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if (full) {\n          retval = onePointFull(d, axis, visit, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        } else {\n          retval = onePointPartial(d, axis, visit, flip, red0, redEnd, red, redIndex, blue0, blue, blueIndex[blue0]);\n        }\n        if (retval !== void 0) {\n          return retval;\n        }\n      } else if (blue0 < blue1) {\n        var red1;\n        if (full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n          if (red0 < red1) {\n            var redX = partitionStartEqual(d, axis, red0, red1, red, redIndex, mid);\n            if (axis === d - 2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if (red0 < redX) {\n                retval = sweep.sweepComplete(d, visit, red0, redX, red, redIndex, blue0, blue1, blue, blueIndex);\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n\n              //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n              if (redX < red1) {\n                retval = sweep.sweepBipartite(d, visit, redX, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n                if (retval !== void 0) {\n                  return retval;\n                }\n              }\n            } else {\n              if (red0 < redX) {\n                iterPush(top++, axis + 1, red0, redX, blue0, blue1, 16, -Infinity, Infinity);\n              }\n              if (redX < red1) {\n                iterPush(top++, axis + 1, redX, red1, blue0, blue1, 0, -Infinity, Infinity);\n                iterPush(top++, axis + 1, blue0, blue1, redX, red1, 1, -Infinity, Infinity);\n              }\n            }\n          }\n        } else {\n          if (flip) {\n            red1 = partitionContainsPointProper(d, axis, red0, redEnd, red, redIndex, mid);\n          } else {\n            red1 = partitionContainsPoint(d, axis, red0, redEnd, red, redIndex, mid);\n          }\n          if (red0 < red1) {\n            if (axis === d - 2) {\n              if (flip) {\n                retval = sweep.sweepBipartite(d, visit, blue0, blue1, blue, blueIndex, red0, red1, red, redIndex);\n              } else {\n                retval = sweep.sweepBipartite(d, visit, red0, red1, red, redIndex, blue0, blue1, blue, blueIndex);\n              }\n            } else {\n              iterPush(top++, axis + 1, red0, red1, blue0, blue1, flip, -Infinity, Infinity);\n              iterPush(top++, axis + 1, blue0, blue1, red0, red1, flip ^ 1, -Infinity, Infinity);\n            }\n          }\n        }\n      }\n    }\n  }\n}","map":{"version":3,"names":["module","exports","boxIntersectIter","pool","require","bits","bruteForce","bruteForcePartial","partial","bruteForceFull","full","sweep","findMedian","genPartition","BRUTE_FORCE_CUTOFF","SCAN_CUTOFF","SCAN_COMPLETE_CUTOFF","partitionInteriorContainsInterval","partitionStartEqual","partitionStartLessThan","partitionEndLessThanEqual","partitionContainsPoint","partitionContainsPointProper","IFRAME_SIZE","DFRAME_SIZE","INIT_CAPACITY","BOX_ISTACK","mallocInt32","BOX_DSTACK","mallocDouble","iterInit","d","count","levels","log2","maxInts","nextPow2","length","free","maxDoubles","iterPush","ptr","axis","redStart","redEnd","blueStart","blueEnd","state","lo","hi","iptr","dptr","onePointPartial","visit","flip","red","redIndex","blueOffset","blue","blueId","elemSize","bluePtr","blueX","red_loop","i","redPtr","r0","r1","redId","j","b0","b1","retval","onePointFull","initFull","xSize","xBoxes","xIndex","ySize","yBoxes","yIndex","top","Infinity","blueIndex","redCount","blueCount","scanComplete","Math","min","scanBipartite","red0","sweepBipartite","blue0","mid","blue1","red1","redX","sweepComplete"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/box-intersect/lib/intersect.js"],"sourcesContent":["'use strict'\n\nmodule.exports = boxIntersectIter\n\nvar pool = require('typedarray-pool')\nvar bits = require('bit-twiddle')\nvar bruteForce = require('./brute')\nvar bruteForcePartial = bruteForce.partial\nvar bruteForceFull = bruteForce.full\nvar sweep = require('./sweep')\nvar findMedian = require('./median')\nvar genPartition = require('./partition')\n\n//Twiddle parameters\nvar BRUTE_FORCE_CUTOFF    = 128       //Cut off for brute force search\nvar SCAN_CUTOFF           = (1<<22)   //Cut off for two way scan\nvar SCAN_COMPLETE_CUTOFF  = (1<<22)  \n\n//Partition functions\nvar partitionInteriorContainsInterval = genPartition(\n  '!(lo>=p0)&&!(p1>=hi)', \n  ['p0', 'p1'])\n\nvar partitionStartEqual = genPartition(\n  'lo===p0',\n  ['p0'])\n\nvar partitionStartLessThan = genPartition(\n  'lo<p0',\n  ['p0'])\n\nvar partitionEndLessThanEqual = genPartition(\n  'hi<=p0',\n  ['p0'])\n\nvar partitionContainsPoint = genPartition(\n  'lo<=p0&&p0<=hi',\n  ['p0'])\n\nvar partitionContainsPointProper = genPartition(\n  'lo<p0&&p0<=hi',\n  ['p0'])\n\n//Frame size for iterative loop\nvar IFRAME_SIZE = 6\nvar DFRAME_SIZE = 2\n\n//Data for box statck\nvar INIT_CAPACITY = 1024\nvar BOX_ISTACK  = pool.mallocInt32(INIT_CAPACITY)\nvar BOX_DSTACK  = pool.mallocDouble(INIT_CAPACITY)\n\n//Initialize iterative loop queue\nfunction iterInit(d, count) {\n  var levels = (8 * bits.log2(count+1) * (d+1))|0\n  var maxInts = bits.nextPow2(IFRAME_SIZE*levels)\n  if(BOX_ISTACK.length < maxInts) {\n    pool.free(BOX_ISTACK)\n    BOX_ISTACK = pool.mallocInt32(maxInts)\n  }\n  var maxDoubles = bits.nextPow2(DFRAME_SIZE*levels)\n  if(BOX_DSTACK.length < maxDoubles) {\n    pool.free(BOX_DSTACK)\n    BOX_DSTACK = pool.mallocDouble(maxDoubles)\n  }\n}\n\n//Append item to queue\nfunction iterPush(ptr,\n  axis, \n  redStart, redEnd, \n  blueStart, blueEnd, \n  state, \n  lo, hi) {\n\n  var iptr = IFRAME_SIZE * ptr\n  BOX_ISTACK[iptr]   = axis\n  BOX_ISTACK[iptr+1] = redStart\n  BOX_ISTACK[iptr+2] = redEnd\n  BOX_ISTACK[iptr+3] = blueStart\n  BOX_ISTACK[iptr+4] = blueEnd\n  BOX_ISTACK[iptr+5] = state\n\n  var dptr = DFRAME_SIZE * ptr\n  BOX_DSTACK[dptr]   = lo\n  BOX_DSTACK[dptr+1] = hi\n}\n\n//Special case:  Intersect single point with list of intervals\nfunction onePointPartial(\n  d, axis, visit, flip,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    if(flip && blueX === r0) {\n      continue\n    }\n    var redId = redIndex[i]\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval\n    if(flip) {\n      retval = visit(blueId, redId)\n    } else {\n      retval = visit(redId, blueId)\n    }\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//Special case:  Intersect one point with list of intervals\nfunction onePointFull(\n  d, axis, visit,\n  redStart, redEnd, red, redIndex,\n  blueOffset, blue, blueId) {\n\n  var elemSize = 2 * d\n  var bluePtr  = blueOffset * elemSize\n  var blueX    = blue[bluePtr + axis]\n\nred_loop:\n  for(var i=redStart, redPtr=redStart*elemSize; i<redEnd; ++i, redPtr+=elemSize) {\n    var redId = redIndex[i]\n    if(redId === blueId) {\n      continue\n    }\n    var r0 = red[redPtr+axis]\n    var r1 = red[redPtr+axis+d]\n    if(blueX < r0 || r1 < blueX) {\n      continue\n    }\n    for(var j=axis+1; j<d; ++j) {\n      var r0 = red[redPtr+j]\n      var r1 = red[redPtr+j+d]\n      var b0 = blue[bluePtr+j]\n      var b1 = blue[bluePtr+j+d]\n      if(r1 < b0 || b1 < r0) {\n        continue red_loop\n      }\n    }\n    var retval = visit(redId, blueId)\n    if(retval !== void 0) {\n      return retval\n    }\n  }\n}\n\n//The main box intersection routine\nfunction boxIntersectIter(\n  d, visit, initFull,\n  xSize, xBoxes, xIndex,\n  ySize, yBoxes, yIndex) {\n\n  //Reserve memory for stack\n  iterInit(d, xSize + ySize)\n\n  var top  = 0\n  var elemSize = 2 * d\n  var retval\n\n  iterPush(top++,\n      0,\n      0, xSize,\n      0, ySize,\n      initFull ? 16 : 0, \n      -Infinity, Infinity)\n  if(!initFull) {\n    iterPush(top++,\n      0,\n      0, ySize,\n      0, xSize,\n      1, \n      -Infinity, Infinity)\n  }\n\n  while(top > 0) {\n    top  -= 1\n\n    var iptr = top * IFRAME_SIZE\n    var axis      = BOX_ISTACK[iptr]\n    var redStart  = BOX_ISTACK[iptr+1]\n    var redEnd    = BOX_ISTACK[iptr+2]\n    var blueStart = BOX_ISTACK[iptr+3]\n    var blueEnd   = BOX_ISTACK[iptr+4]\n    var state     = BOX_ISTACK[iptr+5]\n\n    var dptr = top * DFRAME_SIZE\n    var lo        = BOX_DSTACK[dptr]\n    var hi        = BOX_DSTACK[dptr+1]\n\n    //Unpack state info\n    var flip      = (state & 1)\n    var full      = !!(state & 16)\n\n    //Unpack indices\n    var red       = xBoxes\n    var redIndex  = xIndex\n    var blue      = yBoxes\n    var blueIndex = yIndex\n    if(flip) {\n      red         = yBoxes\n      redIndex    = yIndex\n      blue        = xBoxes\n      blueIndex   = xIndex\n    }\n\n    if(state & 2) {\n      redEnd = partitionStartLessThan(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        hi)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    if(state & 4) {\n      redStart = partitionEndLessThanEqual(\n        d, axis,\n        redStart, redEnd, red, redIndex,\n        lo)\n      if(redStart >= redEnd) {\n        continue\n      }\n    }\n    \n    var redCount  = redEnd  - redStart\n    var blueCount = blueEnd - blueStart\n\n    if(full) {\n      if(d * redCount * (redCount + blueCount) < SCAN_COMPLETE_CUTOFF) {\n        retval = sweep.scanComplete(\n          d, axis, visit, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    } else {\n      if(d * Math.min(redCount, blueCount) < BRUTE_FORCE_CUTOFF) {\n        //If input small, then use brute force\n        retval = bruteForcePartial(\n            d, axis, visit, flip,\n            redStart,  redEnd,  red,  redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      } else if(d * redCount * blueCount < SCAN_CUTOFF) {\n        //If input medium sized, then use sweep and prune\n        retval = sweep.scanBipartite(\n          d, axis, visit, flip, \n          redStart, redEnd, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n        continue\n      }\n    }\n    \n    //First, find all red intervals whose interior contains (lo,hi)\n    var red0 = partitionInteriorContainsInterval(\n      d, axis, \n      redStart, redEnd, red, redIndex,\n      lo, hi)\n\n    //Lower dimensional case\n    if(redStart < red0) {\n\n      if(d * (red0 - redStart) < BRUTE_FORCE_CUTOFF) {\n        //Special case for small inputs: use brute force\n        retval = bruteForceFull(\n          d, axis+1, visit,\n          redStart, red0, red, redIndex,\n          blueStart, blueEnd, blue, blueIndex)\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(axis === d-2) {\n        if(flip) {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            blueStart, blueEnd, blue, blueIndex,\n            redStart, red0, red, redIndex)\n        } else {\n          retval = sweep.sweepBipartite(\n            d, visit,\n            redStart, red0, red, redIndex,\n            blueStart, blueEnd, blue, blueIndex)\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else {\n        iterPush(top++,\n          axis+1,\n          redStart, red0,\n          blueStart, blueEnd,\n          flip,\n          -Infinity, Infinity)\n        iterPush(top++,\n          axis+1,\n          blueStart, blueEnd,\n          redStart, red0,\n          flip^1,\n          -Infinity, Infinity)\n      }\n    }\n\n    //Divide and conquer phase\n    if(red0 < redEnd) {\n\n      //Cut blue into 3 parts:\n      //\n      //  Points < mid point\n      //  Points = mid point\n      //  Points > mid point\n      //\n      var blue0 = findMedian(\n        d, axis, \n        blueStart, blueEnd, blue, blueIndex)\n      var mid = blue[elemSize * blue0 + axis]\n      var blue1 = partitionStartEqual(\n        d, axis,\n        blue0, blueEnd, blue, blueIndex,\n        mid)\n\n      //Right case\n      if(blue1 < blueEnd) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blue1, blueEnd,\n          (flip|4) + (full ? 16 : 0),\n          mid, hi)\n      }\n\n      //Left case\n      if(blueStart < blue0) {\n        iterPush(top++,\n          axis,\n          red0, redEnd,\n          blueStart, blue0,\n          (flip|2) + (full ? 16 : 0),\n          lo, mid)\n      }\n\n      //Center case (the hard part)\n      if(blue0 + 1 === blue1) {\n        //Optimization: Range with exactly 1 point, use a brute force scan\n        if(full) {\n          retval = onePointFull(\n            d, axis, visit,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        } else {\n          retval = onePointPartial(\n            d, axis, visit, flip,\n            red0, redEnd, red, redIndex,\n            blue0, blue, blueIndex[blue0])\n        }\n        if(retval !== void 0) {\n          return retval\n        }\n      } else if(blue0 < blue1) {\n        var red1\n        if(full) {\n          //If full intersection, need to handle special case\n          red1 = partitionContainsPoint(\n            d, axis,\n            red0, redEnd, red, redIndex,\n            mid)\n          if(red0 < red1) {\n            var redX = partitionStartEqual(\n              d, axis,\n              red0, red1, red, redIndex,\n              mid)\n            if(axis === d-2) {\n              //Degenerate sweep intersection:\n              //  [red0, redX] with [blue0, blue1]\n              if(red0 < redX) {\n                retval = sweep.sweepComplete(\n                  d, visit,\n                  red0, redX, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n\n              //Normal sweep intersection:\n              //  [redX, red1] with [blue0, blue1]\n              if(redX < red1) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  redX, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n                if(retval !== void 0) {\n                  return retval\n                }\n              }\n            } else {\n              if(red0 < redX) {\n                iterPush(top++,\n                  axis+1,\n                  red0, redX,\n                  blue0, blue1,\n                  16,\n                  -Infinity, Infinity)\n              }\n              if(redX < red1) {\n                iterPush(top++,\n                  axis+1,\n                  redX, red1,\n                  blue0, blue1,\n                  0,\n                  -Infinity, Infinity)\n                iterPush(top++,\n                  axis+1,\n                  blue0, blue1,\n                  redX, red1,\n                  1,\n                  -Infinity, Infinity)\n              }\n            }\n          }\n        } else {\n          if(flip) {\n            red1 = partitionContainsPointProper(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          } else {\n            red1 = partitionContainsPoint(\n              d, axis,\n              red0, redEnd, red, redIndex,\n              mid)\n          }\n          if(red0 < red1) {\n            if(axis === d-2) {\n              if(flip) {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  blue0, blue1, blue, blueIndex,\n                  red0, red1, red, redIndex)\n              } else {\n                retval = sweep.sweepBipartite(\n                  d, visit,\n                  red0, red1, red, redIndex,\n                  blue0, blue1, blue, blueIndex)\n              }\n            } else {\n              iterPush(top++,\n                axis+1,\n                red0, red1,\n                blue0, blue1,\n                flip,\n                -Infinity, Infinity)\n              iterPush(top++,\n                axis+1,\n                blue0, blue1,\n                red0, red1,\n                flip^1,\n                -Infinity, Infinity)\n            }\n          }\n        }\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}