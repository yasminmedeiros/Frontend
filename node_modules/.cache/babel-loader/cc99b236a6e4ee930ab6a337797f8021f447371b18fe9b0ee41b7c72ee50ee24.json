{"ast":null,"code":"/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n\n'use strict';\n\nvar _slicedToArray = require(\"/home/yasmin/\\xC1rea de Trabalho/Frontend/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _toConsumableArray = require(\"/home/yasmin/\\xC1rea de Trabalho/Frontend/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar search = require('binary-search-bounds');\nvar clamp = require('clamp');\nvar rect = require('parse-rect');\nvar getBounds = require('array-bounds');\nvar pick = require('pick-by-alias');\nvar defined = require('defined');\nvar flatten = require('flatten-vertex-data');\nvar isObj = require('is-obj');\nvar dtype = require('dtype');\nvar log2 = require('math-log2');\nvar MAX_GROUP_ID = 1073741824;\nmodule.exports = function cluster(srcPoints, options) {\n  if (!options) options = {};\n  srcPoints = flatten(srcPoints, 'float64');\n  options = pick(options, {\n    bounds: 'range bounds dataBox databox',\n    maxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n    dtype: 'type dtype format out dst output destination'\n    // sort: 'sortBy sortby sort',\n    // pick: 'pick levelPoint',\n    // nodeSize: 'node nodeSize minNodeSize minSize size'\n  });\n\n  // let nodeSize = defined(options.nodeSize, 1)\n  var maxDepth = defined(options.maxDepth, 255);\n  var bounds = defined(options.bounds, getBounds(srcPoints, 2));\n  if (bounds[0] === bounds[2]) bounds[2]++;\n  if (bounds[1] === bounds[3]) bounds[3]++;\n  var points = normalize(srcPoints, bounds);\n\n  // init variables\n  var n = srcPoints.length >>> 1;\n  var ids;\n  if (!options.dtype) options.dtype = 'array';\n  if (typeof options.dtype === 'string') {\n    ids = new (dtype(options.dtype))(n);\n  } else if (options.dtype) {\n    ids = options.dtype;\n    if (Array.isArray(ids)) ids.length = n;\n  }\n  for (var i = 0; i < n; ++i) {\n    ids[i] = i;\n  }\n\n  // representative point indexes for levels\n  var levels = [];\n\n  // starting indexes of subranges in sub levels, levels.length * 4\n  var sublevels = [];\n\n  // unique group ids, sorted in z-curve fashion within levels by shifting bits\n  var groups = [];\n\n  // level offsets in `ids`\n  var offsets = [];\n\n  // sort points\n  sort(0, 0, 1, ids, 0, 1);\n\n  // return reordered ids with provided methods\n  // save level offsets in output buffer\n  var offset = 0;\n  for (var level = 0; level < levels.length; level++) {\n    var levelItems = levels[level];\n    if (ids.set) ids.set(levelItems, offset);else {\n      for (var _i = 0, l = levelItems.length; _i < l; _i++) {\n        ids[_i + offset] = levelItems[_i];\n      }\n    }\n    var nextOffset = offset + levels[level].length;\n    offsets[level] = [offset, nextOffset];\n    offset = nextOffset;\n  }\n  ids.range = range;\n  return ids;\n\n  // FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n  function sort(x, y, diam, ids, level, group) {\n    if (!ids.length) return null;\n\n    // save first point as level representative\n    var levelItems = levels[level] || (levels[level] = []);\n    var levelGroups = groups[level] || (groups[level] = []);\n    var sublevel = sublevels[level] || (sublevels[level] = []);\n    var offset = levelItems.length;\n    level++;\n\n    // max depth reached - put all items into a first group\n    // alternatively - if group id overflow - avoid proceeding\n    if (level > maxDepth || group > MAX_GROUP_ID) {\n      for (var _i2 = 0; _i2 < ids.length; _i2++) {\n        levelItems.push(ids[_i2]);\n        levelGroups.push(group);\n        sublevel.push(null, null, null, null);\n      }\n      return offset;\n    }\n    levelItems.push(ids[0]);\n    levelGroups.push(group);\n    if (ids.length <= 1) {\n      sublevel.push(null, null, null, null);\n      return offset;\n    }\n    var d2 = diam * .5;\n    var cx = x + d2,\n      cy = y + d2;\n\n    // distribute points by 4 buckets\n    var lolo = [],\n      lohi = [],\n      hilo = [],\n      hihi = [];\n    for (var _i3 = 1, _l = ids.length; _i3 < _l; _i3++) {\n      var idx = ids[_i3],\n        _x = points[idx * 2],\n        _y = points[idx * 2 + 1];\n      _x < cx ? _y < cy ? lolo.push(idx) : lohi.push(idx) : _y < cy ? hilo.push(idx) : hihi.push(idx);\n    }\n    group <<= 2;\n    sublevel.push(sort(x, y, d2, lolo, level, group), sort(x, cy, d2, lohi, level, group + 1), sort(cx, y, d2, hilo, level, group + 2), sort(cx, cy, d2, hihi, level, group + 3));\n    return offset;\n  }\n\n  // get all points within the passed range\n  function range() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var options;\n    if (isObj(args[args.length - 1])) {\n      var arg = args.pop();\n\n      // detect if that was a rect object\n      if (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n        args = [arg];\n        options = {};\n      }\n      options = pick(arg, {\n        level: 'level maxLevel',\n        d: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n        lod: 'lod details ranges offsets'\n      });\n    } else {\n      options = {};\n    }\n    if (!args.length) args = bounds;\n    var box = rect.apply(void 0, _toConsumableArray(args));\n    var _ref = [Math.min(box.x, box.x + box.width), Math.min(box.y, box.y + box.height), Math.max(box.x, box.x + box.width), Math.max(box.y, box.y + box.height)],\n      minX = _ref[0],\n      minY = _ref[1],\n      maxX = _ref[2],\n      maxY = _ref[3];\n    var _normalize = normalize([minX, minY, maxX, maxY], bounds),\n      _normalize2 = _slicedToArray(_normalize, 4),\n      nminX = _normalize2[0],\n      nminY = _normalize2[1],\n      nmaxX = _normalize2[2],\n      nmaxY = _normalize2[3];\n    var maxLevel = defined(options.level, levels.length);\n\n    // limit maxLevel by px size\n    if (options.d != null) {\n      var d;\n      if (typeof options.d === 'number') d = [options.d, options.d];else if (options.d.length) d = options.d;\n      maxLevel = Math.min(Math.max(Math.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))), Math.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))), maxLevel);\n    }\n    maxLevel = Math.min(maxLevel, levels.length);\n\n    // return levels of details\n    if (options.lod) {\n      return lod(nminX, nminY, nmaxX, nmaxY, maxLevel);\n    }\n\n    // do selection ids\n    var selection = [];\n\n    // FIXME: probably we can do LOD here beforehead\n    select(0, 0, 1, 0, 0, 1);\n    function select(lox, loy, d, level, from, to) {\n      if (from === null || to === null) return;\n      var hix = lox + d;\n      var hiy = loy + d;\n\n      // if box does not intersect level - ignore\n      if (nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy) return;\n      if (level >= maxLevel) return;\n      if (from === to) return;\n\n      // if points fall into box range - take it\n      var levelItems = levels[level];\n      if (to === undefined) to = levelItems.length;\n      for (var _i4 = from; _i4 < to; _i4++) {\n        var id = levelItems[_i4];\n        var px = srcPoints[id * 2];\n        var py = srcPoints[id * 2 + 1];\n        if (px >= minX && px <= maxX && py >= minY && py <= maxY) {\n          selection.push(id);\n        }\n      }\n\n      // for every subsection do select\n      var offsets = sublevels[level];\n      var off0 = offsets[from * 4 + 0];\n      var off1 = offsets[from * 4 + 1];\n      var off2 = offsets[from * 4 + 2];\n      var off3 = offsets[from * 4 + 3];\n      var end = nextOffset(offsets, from + 1);\n      var d2 = d * .5;\n      var nextLevel = level + 1;\n      select(lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end);\n      select(lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end);\n      select(lox + d2, loy, d2, nextLevel, off2, off3 || end);\n      select(lox + d2, loy + d2, d2, nextLevel, off3, end);\n    }\n    function nextOffset(offsets, from) {\n      var offset = null,\n        i = 0;\n      while (offset === null) {\n        offset = offsets[from * 4 + i];\n        i++;\n        if (i > offsets.length) return null;\n      }\n      return offset;\n    }\n    return selection;\n  }\n\n  // get range offsets within levels to render lods appropriate for zoom level\n  // TODO: it is possible to store minSize of a point to optimize neede level calc\n  function lod(lox, loy, hix, hiy, maxLevel) {\n    var ranges = [];\n    for (var _level = 0; _level < maxLevel; _level++) {\n      var levelGroups = groups[_level];\n      var from = offsets[_level][0];\n      var levelGroupStart = group(lox, loy, _level);\n      var levelGroupEnd = group(hix, hiy, _level);\n\n      // FIXME: utilize sublevels to speed up search range here\n      var startOffset = search.ge(levelGroups, levelGroupStart);\n      var endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1);\n      ranges[_level] = [startOffset + from, endOffset + from];\n    }\n    return ranges;\n  }\n\n  // get group id closest to the x,y coordinate, corresponding to a level\n  function group(x, y, level) {\n    var group = 1;\n    var cx = .5,\n      cy = .5;\n    var diam = .5;\n    for (var _i5 = 0; _i5 < level; _i5++) {\n      group <<= 2;\n      group += x < cx ? y < cy ? 0 : 1 : y < cy ? 2 : 3;\n      diam *= .5;\n      cx += x < cx ? -diam : diam;\n      cy += y < cy ? -diam : diam;\n    }\n    return group;\n  }\n};\n\n// normalize points by bounds\nfunction normalize(pts, bounds) {\n  var _bounds = _slicedToArray(bounds, 4),\n    lox = _bounds[0],\n    loy = _bounds[1],\n    hix = _bounds[2],\n    hiy = _bounds[3];\n  var scaleX = 1.0 / (hix - lox);\n  var scaleY = 1.0 / (hiy - loy);\n  var result = new Array(pts.length);\n  for (var i = 0, n = pts.length / 2; i < n; i++) {\n    result[2 * i] = clamp((pts[2 * i] - lox) * scaleX, 0, 1);\n    result[2 * i + 1] = clamp((pts[2 * i + 1] - loy) * scaleY, 0, 1);\n  }\n  return result;\n}","map":{"version":3,"names":["search","require","clamp","rect","getBounds","pick","defined","flatten","isObj","dtype","log2","MAX_GROUP_ID","module","exports","cluster","srcPoints","options","bounds","maxDepth","points","normalize","n","length","ids","Array","isArray","i","levels","sublevels","groups","offsets","sort","offset","level","levelItems","set","l","nextOffset","range","x","y","diam","group","levelGroups","sublevel","push","d2","cx","cy","lolo","lohi","hilo","hihi","idx","args","arg","pop","left","d","lod","box","Math","min","width","height","max","minX","minY","maxX","maxY","nminX","nminY","nmaxX","nmaxY","maxLevel","ceil","abs","selection","select","lox","loy","from","to","hix","hiy","undefined","id","px","py","off0","off1","off2","off3","end","nextLevel","ranges","levelGroupStart","levelGroupEnd","startOffset","ge","endOffset","gt","pts","scaleX","scaleY","result"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/@plotly/point-cluster/quad.js"],"sourcesContent":["/**\n * @module  point-cluster/quad\n *\n * Bucket based quad tree clustering\n */\n\n'use strict'\n\nconst search = require('binary-search-bounds')\nconst clamp = require('clamp')\nconst rect = require('parse-rect')\nconst getBounds = require('array-bounds')\nconst pick = require('pick-by-alias')\nconst defined = require('defined')\nconst flatten = require('flatten-vertex-data')\nconst isObj = require('is-obj')\nconst dtype = require('dtype')\nconst log2 = require('math-log2')\n\nconst MAX_GROUP_ID = 1073741824\n\nmodule.exports = function cluster (srcPoints, options) {\n\tif (!options) options = {}\n\n\tsrcPoints = flatten(srcPoints, 'float64')\n\n\toptions = pick(options, {\n\t\tbounds: 'range bounds dataBox databox',\n\t\tmaxDepth: 'depth maxDepth maxdepth level maxLevel maxlevel levels',\n\t\tdtype: 'type dtype format out dst output destination'\n\t\t// sort: 'sortBy sortby sort',\n\t\t// pick: 'pick levelPoint',\n\t\t// nodeSize: 'node nodeSize minNodeSize minSize size'\n\t})\n\n\t// let nodeSize = defined(options.nodeSize, 1)\n\tlet maxDepth = defined(options.maxDepth, 255)\n\tlet bounds = defined(options.bounds, getBounds(srcPoints, 2))\n\tif (bounds[0] === bounds[2]) bounds[2]++\n\tif (bounds[1] === bounds[3]) bounds[3]++\n\n\tlet points = normalize(srcPoints, bounds)\n\n\t// init variables\n\tlet n = srcPoints.length >>> 1\n\tlet ids\n\tif (!options.dtype) options.dtype = 'array'\n\n\tif (typeof options.dtype === 'string') {\n\t\tids = new (dtype(options.dtype))(n)\n\t}\n\telse if (options.dtype) {\n\t\tids = options.dtype\n\t\tif (Array.isArray(ids)) ids.length = n\n\t}\n\tfor (let i = 0; i < n; ++i) {\n\t\tids[i] = i\n\t}\n\n\t// representative point indexes for levels\n\tlet levels = []\n\n\t// starting indexes of subranges in sub levels, levels.length * 4\n\tlet sublevels = []\n\n\t// unique group ids, sorted in z-curve fashion within levels by shifting bits\n\tlet groups = []\n\n\t// level offsets in `ids`\n\tlet offsets = []\n\n\n\t// sort points\n\tsort(0, 0, 1, ids, 0, 1)\n\n\n\t// return reordered ids with provided methods\n\t// save level offsets in output buffer\n\tlet offset = 0\n\tfor (let level = 0; level < levels.length; level++) {\n\t\tlet levelItems = levels[level]\n\t\tif (ids.set) ids.set(levelItems, offset)\n\t\telse {\n\t\t\tfor (let i = 0, l = levelItems.length; i < l; i++) {\n\t\t\t\tids[i + offset] = levelItems[i]\n\t\t\t}\n\t\t}\n\t\tlet nextOffset = offset + levels[level].length\n\t\toffsets[level] = [offset, nextOffset]\n\t\toffset = nextOffset\n\t}\n\n\tids.range = range\n\n\treturn ids\n\n\n\n\t// FIXME: it is possible to create one typed array heap and reuse that to avoid memory blow\n\tfunction sort (x, y, diam, ids, level, group) {\n\t\tif (!ids.length) return null\n\n\t\t// save first point as level representative\n\t\tlet levelItems = levels[level] || (levels[level] = [])\n\t\tlet levelGroups = groups[level] || (groups[level] = [])\n\t\tlet sublevel = sublevels[level] || (sublevels[level] = [])\n\t\tlet offset = levelItems.length\n\n\t\tlevel++\n\n\t\t// max depth reached - put all items into a first group\n\t\t// alternatively - if group id overflow - avoid proceeding\n\t\tif (level > maxDepth || group > MAX_GROUP_ID) {\n\t\t\tfor (let i = 0; i < ids.length; i++) {\n\t\t\t\tlevelItems.push(ids[i])\n\t\t\t\tlevelGroups.push(group)\n\t\t\t\tsublevel.push(null, null, null, null)\n\t\t\t}\n\n\t\t\treturn offset\n\t\t}\n\n\t\tlevelItems.push(ids[0])\n\t\tlevelGroups.push(group)\n\n\t\tif (ids.length <= 1) {\n\t\t\tsublevel.push(null, null, null, null)\n\t\t\treturn offset\n\t\t}\n\n\n\t\tlet d2 = diam * .5\n\t\tlet cx = x + d2, cy = y + d2\n\n\t\t// distribute points by 4 buckets\n\t\tlet lolo = [], lohi = [], hilo = [], hihi = []\n\n\t\tfor (let i = 1, l = ids.length; i < l; i++) {\n\t\t\tlet idx = ids[i],\n\t\t\t\tx = points[idx * 2],\n\t\t\t\ty = points[idx * 2 + 1]\n\t\t\tx < cx ? (y < cy ? lolo.push(idx) : lohi.push(idx)) : (y < cy ? hilo.push(idx) : hihi.push(idx))\n\t\t}\n\n\t\tgroup <<= 2\n\n\t\tsublevel.push(\n\t\t\tsort(x, y, d2, lolo, level, group),\n\t\t\tsort(x, cy, d2, lohi, level, group + 1),\n\t\t\tsort(cx, y, d2, hilo, level, group + 2),\n\t\t\tsort(cx, cy, d2, hihi, level, group + 3)\n\t\t)\n\n\t\treturn offset\n\t}\n\n\t// get all points within the passed range\n\tfunction range ( ...args ) {\n\t\tlet options\n\n\t\tif (isObj(args[args.length - 1])) {\n\t\t\tlet arg = args.pop()\n\n\t\t\t// detect if that was a rect object\n\t\t\tif (!args.length && (arg.x != null || arg.l != null || arg.left != null)) {\n\t\t\t\targs = [arg]\n\t\t\t\toptions = {}\n\t\t\t}\n\n\t\t\toptions = pick(arg, {\n\t\t\t\tlevel: 'level maxLevel',\n\t\t\t\td: 'd diam diameter r radius px pxSize pixel pixelSize maxD size minSize',\n\t\t\t\tlod: 'lod details ranges offsets'\n\t\t\t})\n\t\t}\n\t\telse {\n\t\t\toptions = {}\n\t\t}\n\n\t\tif (!args.length) args = bounds\n\n\t\tlet box = rect( ...args )\n\n\t\tlet [minX, minY, maxX, maxY] = [\n\t\t\tMath.min(box.x, box.x + box.width),\n\t\t\tMath.min(box.y, box.y + box.height),\n\t\t\tMath.max(box.x, box.x + box.width),\n\t\t\tMath.max(box.y, box.y + box.height)\n\t\t]\n\n\t\tlet [nminX, nminY, nmaxX, nmaxY] = normalize([minX, minY, maxX, maxY], bounds )\n\n\t\tlet maxLevel = defined(options.level, levels.length)\n\n\t\t// limit maxLevel by px size\n\t\tif (options.d != null) {\n\t\t\tlet d\n\t\t\tif (typeof options.d === 'number') d = [options.d, options.d]\n\t\t\telse if (options.d.length) d = options.d\n\n\t\t\tmaxLevel = Math.min(\n\t\t\t\tMath.max(\n\t\t\t\t\tMath.ceil(-log2(Math.abs(d[0]) / (bounds[2] - bounds[0]))),\n\t\t\t\t\tMath.ceil(-log2(Math.abs(d[1]) / (bounds[3] - bounds[1])))\n\t\t\t\t),\n\t\t\t\tmaxLevel\n\t\t\t)\n\t\t}\n\t\tmaxLevel = Math.min(maxLevel, levels.length)\n\n\t\t// return levels of details\n\t\tif (options.lod) {\n\t\t\treturn lod(nminX, nminY, nmaxX, nmaxY, maxLevel)\n\t\t}\n\n\n\n\t\t// do selection ids\n\t\tlet selection = []\n\n\t\t// FIXME: probably we can do LOD here beforehead\n\t\tselect( 0, 0, 1, 0, 0, 1)\n\n\t\tfunction select ( lox, loy, d, level, from, to ) {\n\t\t\tif (from === null || to === null) return\n\n\t\t\tlet hix = lox + d\n\t\t\tlet hiy = loy + d\n\n\t\t\t// if box does not intersect level - ignore\n\t\t\tif ( nminX > hix || nminY > hiy || nmaxX < lox || nmaxY < loy ) return\n\t\t\tif ( level >= maxLevel ) return\n\t\t\tif ( from === to ) return\n\n\t\t\t// if points fall into box range - take it\n\t\t\tlet levelItems = levels[level]\n\n\t\t\tif (to === undefined) to = levelItems.length\n\n\t\t\tfor (let i = from; i < to; i++) {\n\t\t\t\tlet id = levelItems[i]\n\n\t\t\t\tlet px = srcPoints[ id * 2 ]\n\t\t\t\tlet py = srcPoints[ id * 2 + 1 ]\n\n\t\t\t\tif ( px >= minX && px <= maxX && py >= minY && py <= maxY ) {selection.push(id)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// for every subsection do select\n\t\t\tlet offsets = sublevels[ level ]\n\t\t\tlet off0 = offsets[ from * 4 + 0 ]\n\t\t\tlet off1 = offsets[ from * 4 + 1 ]\n\t\t\tlet off2 = offsets[ from * 4 + 2 ]\n\t\t\tlet off3 = offsets[ from * 4 + 3 ]\n\t\t\tlet end = nextOffset(offsets, from + 1)\n\n\t\t\tlet d2 = d * .5\n\t\t\tlet nextLevel = level + 1\n\t\t\tselect( lox, loy, d2, nextLevel, off0, off1 || off2 || off3 || end)\n\t\t\tselect( lox, loy + d2, d2, nextLevel, off1, off2 || off3 || end)\n\t\t\tselect( lox + d2, loy, d2, nextLevel, off2, off3 || end)\n\t\t\tselect( lox + d2, loy + d2, d2, nextLevel, off3, end)\n\t\t}\n\n\t\tfunction nextOffset(offsets, from) {\n\t\t\tlet offset = null, i = 0\n\t\t\twhile(offset === null) {\n\t\t\t\toffset = offsets[ from * 4 + i ]\n\t\t\t\ti++\n\t\t\t\tif (i > offsets.length) return null\n\t\t\t}\n\t\t\treturn offset\n\t\t}\n\n\t\treturn selection\n\t}\n\n\t// get range offsets within levels to render lods appropriate for zoom level\n\t// TODO: it is possible to store minSize of a point to optimize neede level calc\n\tfunction lod (lox, loy, hix, hiy, maxLevel) {\n\t\tlet ranges = []\n\n\t\tfor (let level = 0; level < maxLevel; level++) {\n\t\t\tlet levelGroups = groups[level]\n\t\t\tlet from = offsets[level][0]\n\n\t\t\tlet levelGroupStart = group(lox, loy, level)\n\t\t\tlet levelGroupEnd = group(hix, hiy, level)\n\n\t\t\t// FIXME: utilize sublevels to speed up search range here\n\t\t\tlet startOffset = search.ge(levelGroups, levelGroupStart)\n\t\t\tlet endOffset = search.gt(levelGroups, levelGroupEnd, startOffset, levelGroups.length - 1)\n\n\t\t\tranges[level] = [startOffset + from, endOffset + from]\n\t\t}\n\n\t\treturn ranges\n\t}\n\n\t// get group id closest to the x,y coordinate, corresponding to a level\n\tfunction group (x, y, level) {\n\t\tlet group = 1\n\n\t\tlet cx = .5, cy = .5\n\t\tlet diam = .5\n\n\t\tfor (let i = 0; i < level; i++) {\n\t\t\tgroup <<= 2\n\n\t\t\tgroup += x < cx ? (y < cy ? 0 : 1) : (y < cy ? 2 : 3)\n\n\t\t\tdiam *= .5\n\n\t\t\tcx += x < cx ? -diam : diam\n\t\t\tcy += y < cy ? -diam : diam\n\t\t}\n\n\t\treturn group\n\t}\n}\n\n\n// normalize points by bounds\nfunction normalize (pts, bounds) {\n\tlet [lox, loy, hix, hiy] = bounds\n\tlet scaleX = 1.0 / (hix - lox)\n\tlet scaleY = 1.0 / (hiy - loy)\n\tlet result = new Array(pts.length)\n\n\tfor (let i = 0, n = pts.length / 2; i < n; i++) {\n\t\tresult[2*i] = clamp((pts[2*i] - lox) * scaleX, 0, 1)\n\t\tresult[2*i+1] = clamp((pts[2*i+1] - loy) * scaleY, 0, 1)\n\t}\n\n\treturn result\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}