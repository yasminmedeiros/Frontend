{"ast":null,"code":"\"use strict\";\n\nmodule.exports = stronglyConnectedComponents;\nfunction stronglyConnectedComponents(adjList) {\n  var numVertices = adjList.length;\n  var index = new Array(numVertices);\n  var lowValue = new Array(numVertices);\n  var active = new Array(numVertices);\n  var child = new Array(numVertices);\n  var scc = new Array(numVertices);\n  var sccLinks = new Array(numVertices);\n\n  //Initialize tables\n  for (var i = 0; i < numVertices; ++i) {\n    index[i] = -1;\n    lowValue[i] = 0;\n    active[i] = false;\n    child[i] = 0;\n    scc[i] = -1;\n    sccLinks[i] = [];\n  }\n\n  // The strongConnect function\n  var count = 0;\n  var components = [];\n  var sccAdjList = [];\n  function strongConnect(v) {\n    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\n    var S = [v],\n      T = [v];\n    index[v] = lowValue[v] = count;\n    active[v] = true;\n    count += 1;\n    while (T.length > 0) {\n      v = T[T.length - 1];\n      var e = adjList[v];\n      if (child[v] < e.length) {\n        // If we're not done iterating over the children, first try finishing that.\n        for (var i = child[v]; i < e.length; ++i) {\n          // Start where we left off.\n          var u = e[i];\n          if (index[u] < 0) {\n            index[u] = lowValue[u] = count;\n            active[u] = true;\n            count += 1;\n            S.push(u);\n            T.push(u);\n            break; // First recurse, then continue here (with the same child!).\n            // There is a slight change to Tarjan's algorithm here.\n            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\n            // Here, we only do so if the child we recursed on is still active.\n            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\n          } else if (active[u]) {\n            lowValue[v] = Math.min(lowValue[v], lowValue[u]) | 0;\n          }\n          if (scc[u] >= 0) {\n            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\n            sccLinks[v].push(scc[u]);\n          }\n        }\n        child[v] = i; // Remember where we left off.\n      } else {\n        // If we're done iterating over the children, check whether we have an scc.\n        if (lowValue[v] === index[v]) {\n          // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\n          var component = [];\n          var links = [],\n            linkCount = 0;\n          for (var i = S.length - 1; i >= 0; --i) {\n            var w = S[i];\n            active[w] = false;\n            component.push(w);\n            links.push(sccLinks[w]);\n            linkCount += sccLinks[w].length;\n            scc[w] = components.length;\n            if (w === v) {\n              S.length = i;\n              break;\n            }\n          }\n          components.push(component);\n          var allLinks = new Array(linkCount);\n          for (var i = 0; i < links.length; i++) {\n            for (var j = 0; j < links[i].length; j++) {\n              allLinks[--linkCount] = links[i][j];\n            }\n          }\n          sccAdjList.push(allLinks);\n        }\n        T.pop(); // Now we're finished exploring this particular node (normally corresponds to the return statement)\n      }\n    }\n  }\n\n  //Run strong connect starting from each vertex\n  for (var i = 0; i < numVertices; ++i) {\n    if (index[i] < 0) {\n      strongConnect(i);\n    }\n  }\n\n  // Compact sccAdjList\n  var newE;\n  for (var i = 0; i < sccAdjList.length; i++) {\n    var e = sccAdjList[i];\n    if (e.length === 0) continue;\n    e.sort(function (a, b) {\n      return a - b;\n    });\n    newE = [e[0]];\n    for (var j = 1; j < e.length; j++) {\n      if (e[j] !== e[j - 1]) {\n        newE.push(e[j]);\n      }\n    }\n    sccAdjList[i] = newE;\n  }\n  return {\n    components: components,\n    adjacencyList: sccAdjList\n  };\n}","map":{"version":3,"names":["module","exports","stronglyConnectedComponents","adjList","numVertices","length","index","Array","lowValue","active","child","scc","sccLinks","i","count","components","sccAdjList","strongConnect","v","S","T","e","u","push","Math","min","component","links","linkCount","w","allLinks","j","pop","newE","sort","a","b","adjacencyList"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/strongly-connected-components/scc.js"],"sourcesContent":["\"use strict\"\n\nmodule.exports = stronglyConnectedComponents\n\nfunction stronglyConnectedComponents(adjList) {\n  var numVertices = adjList.length;\n  var index = new Array(numVertices)\n  var lowValue = new Array(numVertices)\n  var active = new Array(numVertices)\n  var child = new Array(numVertices)\n  var scc = new Array(numVertices)\n  var sccLinks = new Array(numVertices)\n  \n  //Initialize tables\n  for(var i=0; i<numVertices; ++i) {\n    index[i] = -1\n    lowValue[i] = 0\n    active[i] = false\n    child[i] = 0\n    scc[i] = -1\n    sccLinks[i] = []\n  }\n\n  // The strongConnect function\n  var count = 0\n  var components = []\n  var sccAdjList = []\n\n  function strongConnect(v) {\n    // To avoid running out of stack space, this emulates the recursive behaviour of the normal algorithm, effectively using T as the call stack.\n    var S = [v], T = [v]\n    index[v] = lowValue[v] = count\n    active[v] = true\n    count += 1\n    while(T.length > 0) {\n      v = T[T.length-1]\n      var e = adjList[v]\n      if (child[v] < e.length) { // If we're not done iterating over the children, first try finishing that.\n        for(var i=child[v]; i<e.length; ++i) { // Start where we left off.\n          var u = e[i]\n          if(index[u] < 0) {\n            index[u] = lowValue[u] = count\n            active[u] = true\n            count += 1\n            S.push(u)\n            T.push(u)\n            break // First recurse, then continue here (with the same child!).\n            // There is a slight change to Tarjan's algorithm here.\n            // Normally, after having recursed, we set lowValue like we do for an active child (although some variants of the algorithm do it slightly differently).\n            // Here, we only do so if the child we recursed on is still active.\n            // The reasoning is that if it is no longer active, it must have had a lowValue equal to its own index, which means that it is necessarily higher than our lowValue.\n          } else if (active[u]) {\n            lowValue[v] = Math.min(lowValue[v], lowValue[u])|0\n          }\n          if (scc[u] >= 0) {\n            // Node v is not yet assigned an scc, but once it is that scc can apparently reach scc[u].\n            sccLinks[v].push(scc[u])\n          }\n        }\n        child[v] = i // Remember where we left off.\n      } else { // If we're done iterating over the children, check whether we have an scc.\n        if(lowValue[v] === index[v]) { // TODO: It /might/ be true that T is always a prefix of S (at this point!!!), and if so, this could be used here.\n          var component = []\n          var links = [], linkCount = 0\n          for(var i=S.length-1; i>=0; --i) {\n            var w = S[i]\n            active[w] = false\n            component.push(w)\n            links.push(sccLinks[w])\n            linkCount += sccLinks[w].length\n            scc[w] = components.length\n            if(w === v) {\n              S.length = i\n              break\n            }\n          }\n          components.push(component)\n          var allLinks = new Array(linkCount)\n          for(var i=0; i<links.length; i++) {\n            for(var j=0; j<links[i].length; j++) {\n              allLinks[--linkCount] = links[i][j]\n            }\n          }\n          sccAdjList.push(allLinks)\n        }\n        T.pop() // Now we're finished exploring this particular node (normally corresponds to the return statement)\n      }\n    }\n  }\n\n  //Run strong connect starting from each vertex\n  for(var i=0; i<numVertices; ++i) {\n    if(index[i] < 0) {\n      strongConnect(i)\n    }\n  }\n  \n  // Compact sccAdjList\n  var newE\n  for(var i=0; i<sccAdjList.length; i++) {\n    var e = sccAdjList[i]\n    if (e.length === 0) continue\n    e.sort(function (a,b) { return a-b; })\n    newE = [e[0]]\n    for(var j=1; j<e.length; j++) {\n      if (e[j] !== e[j-1]) {\n        newE.push(e[j])\n      }\n    }\n    sccAdjList[i] = newE\n  }  \n\n  return {components: components, adjacencyList: sccAdjList}\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}