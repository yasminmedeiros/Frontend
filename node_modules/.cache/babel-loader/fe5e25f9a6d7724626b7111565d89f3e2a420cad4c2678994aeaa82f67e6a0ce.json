{"ast":null,"code":"/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowErrorTolerant: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n  'use strict';\n\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PropertyKind, Messages, Regex, SyntaxTreeDelegate, source, strict, index, lineNumber, lineStart, length, delegate, lookahead, state, extra;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n\n  // A function following one of those tokens is an expression.\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',\n  // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',\n  // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    ArrayExpression: 'ArrayExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    Program: 'Program',\n    Property: 'Property',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SwitchStatement: 'SwitchStatement',\n    SwitchCase: 'SwitchCase',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  PropertyKind = {\n    Data: 1,\n    Get: 2,\n    Set: 4\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictDuplicateProperty: 'Duplicate data property in object literal not allowed in strict mode',\n    AccessorDataProperty: 'Object literal may not have data and accessor property with the same name',\n    AccessorGetSet: 'Object literal may not have multiple get/set accessors with the same name',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp(\"[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]\"),\n    NonAsciiIdentifierPart: new RegExp(\"[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]\")\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 48 && ch <= 57; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n  }\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch >= 0x30 && ch <= 0x39 ||\n    // 0..9\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'class':\n      case 'enum':\n      case 'export':\n      case 'extends':\n      case 'import':\n      case 'super':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n    if (strict && isStrictModeReservedWord(id)) {\n      return true;\n    }\n\n    // 'const' is specialized as Keyword in V8.\n    // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n    // Some others are from future reserved words.\n\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n      case 10:\n        return id === 'instanceof';\n      default:\n        return false;\n    }\n  }\n\n  // 7.4 Comments\n\n  function addComment(type, value, start, end, loc) {\n    var comment, attacher;\n    assert(typeof start === 'number', 'Comment must have valid position');\n\n    // Because the way the actual token is scanned, often the comments\n    // (if any) are skipped twice during the lexical analysis.\n    // Thus, we need to skip adding a comment if the comment array already\n    // handled it.\n    if (state.lastCommentStart >= start) {\n      return;\n    }\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n    extra.comments.push(comment);\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n  }\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n      if (isLineTerminator(ch)) {\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n        if (index >= length) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n          return;\n        }\n        ++index;\n      } else {\n        ++index;\n      }\n    }\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n  function skipComment() {\n    var ch, start;\n    start = index === 0;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        ++index;\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n          ++index; // `!`\n          ++index; // `-`\n          ++index; // `-`\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  function scanHexEscape(prefix) {\n    var i,\n      len,\n      ch,\n      code = 0;\n    len = prefix === 'u' ? 4 : 2;\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  function getEscapedIdentifier() {\n    var ch, id;\n    ch = source.charCodeAt(index++);\n    id = String.fromCharCode(ch);\n\n    // '\\u' (U+005C, U+0075) denotes an escaped character.\n    if (ch === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n      ++index;\n      ch = scanHexEscape('u');\n      if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n      id = ch;\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n      ++index;\n      id += String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n        id = id.substr(0, id.length - 1);\n        if (source.charCodeAt(index) !== 0x75) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        ++index;\n        ch = scanHexEscape('u');\n        if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n        id += ch;\n      }\n    }\n    return id;\n  }\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getEscapedIdentifier();\n      }\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n    return source.slice(start, index);\n  }\n  function scanIdentifier() {\n    var start, id, type;\n    start = index;\n\n    // Backslash (U+005C) starts an escaped character.\n    id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();\n\n    // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n    var start = index,\n      code = source.charCodeAt(index),\n      code2,\n      ch1 = source[index],\n      ch2,\n      ch3,\n      ch4;\n    switch (code) {\n      // Check for most common single-character punctuators.\n      case 0x2E: // . dot\n      case 0x28: // ( open bracket\n      case 0x29: // ) close bracket\n      case 0x3B: // ; semicolon\n      case 0x2C: // , comma\n      case 0x7B: // { open curly brace\n      case 0x7D: // } close curly brace\n      case 0x5B: // [\n      case 0x5D: // ]\n      case 0x3A: // :\n      case 0x3F: // ?\n      case 0x7E:\n        // ~\n        ++index;\n        if (extra.tokenize) {\n          if (code === 0x28) {\n            extra.openParenToken = extra.tokens.length;\n          } else if (code === 0x7B) {\n            extra.openCurlyToken = extra.tokens.length;\n          }\n        }\n        return {\n          type: Token.Punctuator,\n          value: String.fromCharCode(code),\n          lineNumber: lineNumber,\n          lineStart: lineStart,\n          start: start,\n          end: index\n        };\n      default:\n        code2 = source.charCodeAt(index + 1);\n\n        // '=' (U+003D) marks an assignment or comparison operator.\n        if (code2 === 0x3D) {\n          switch (code) {\n            case 0x2B: // +\n            case 0x2D: // -\n            case 0x2F: // /\n            case 0x3C: // <\n            case 0x3E: // >\n            case 0x5E: // ^\n            case 0x7C: // |\n            case 0x25: // %\n            case 0x26: // &\n            case 0x2A:\n              // *\n              index += 2;\n              return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code) + String.fromCharCode(code2),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n              };\n            case 0x21: // !\n            case 0x3D:\n              // =\n              index += 2;\n\n              // !== and ===\n              if (source.charCodeAt(index) === 0x3D) {\n                ++index;\n              }\n              return {\n                type: Token.Punctuator,\n                value: source.slice(start, index),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n              };\n          }\n        }\n    }\n\n    // 4-character punctuator: >>>=\n\n    ch4 = source.substr(index, 4);\n    if (ch4 === '>>>=') {\n      index += 4;\n      return {\n        type: Token.Punctuator,\n        value: ch4,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    // 3-character punctuators: === !== >>> <<= >>=\n\n    ch3 = ch4.substr(0, 3);\n    if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n      index += 3;\n      return {\n        type: Token.Punctuator,\n        value: ch3,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    // Other 2-character punctuators: ++ -- << >> && ||\n    ch2 = ch3.substr(0, 2);\n    if (ch1 === ch2[1] && '+-<>&|'.indexOf(ch1) >= 0 || ch2 === '=>') {\n      index += 2;\n      return {\n        type: Token.Punctuator,\n        value: ch2,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n\n    // 1-character punctuators: < > = ! + - * % & | ^ /\n    if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n      ++index;\n      return {\n        type: Token.Punctuator,\n        value: ch1,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n    var number = '';\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanOctalLiteral(start) {\n    var number = '0' + source[index++];\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: true,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function isImplicitOctalLiteral() {\n    var i, ch;\n\n    // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n    return true;\n  }\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index];\n\n      // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(start);\n          }\n        }\n      }\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === '.') {\n      number += source[index++];\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n      }\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n    var str = '',\n      quote,\n      start,\n      ch,\n      code,\n      unescaped,\n      restore,\n      octal = false,\n      startLineNumber,\n      startLineStart;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              restore = index;\n              unescaped = scanHexEscape(ch);\n              if (unescaped) {\n                str += unescaped;\n              } else {\n                index = restore;\n                str += ch;\n              }\n              break;\n            case 'n':\n              str += '\\n';\n              break;\n            case 'r':\n              str += '\\r';\n              break;\n            case 't':\n              str += '\\t';\n              break;\n            case 'b':\n              str += '\\b';\n              break;\n            case 'f':\n              str += '\\f';\n              break;\n            case 'v':\n              str += '\\x0B';\n              break;\n            default:\n              if (isOctalDigit(ch)) {\n                code = '01234567'.indexOf(ch);\n\n                // \\0 is not octal escape sequence\n                if (code !== 0) {\n                  octal = true;\n                }\n                if (index < length && isOctalDigit(source[index])) {\n                  octal = true;\n                  code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                  // 3 digits are only allowed when string starts\n                  // with 0, 1, 2, 3\n                  if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                  }\n                }\n                str += String.fromCharCode(code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== '') {\n      throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      startLineNumber: startLineNumber,\n      startLineStart: startLineStart,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function testRegExp(pattern, flags) {\n    var value;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      throwError({}, Messages.InvalidRegExp);\n    }\n    return value;\n  }\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n      if (ch === '\\\\') {\n        ch = source[index++];\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwError({}, Messages.UnterminatedRegExp);\n        }\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwError({}, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n    if (!terminated) {\n      throwError({}, Messages.UnterminatedRegExp);\n    }\n\n    // Exclude leading and trailing slash.\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n    while (index < length) {\n      ch = source[index];\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      ++index;\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n          if (ch) {\n            flags += ch;\n            for (str += \"\\\\u\"; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += \"\\\\u\";\n          }\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        } else {\n          str += '\\\\';\n          throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n  function scanRegExp() {\n    var start, body, flags, pattern, value;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      start: start,\n      end: index\n    };\n  }\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    /* istanbul ignore next */\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n    return regex;\n  }\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n  function advanceSlash() {\n    var prevToken, checkToken;\n    // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n    prevToken = extra.tokens[extra.tokens.length - 1];\n    if (!prevToken) {\n      // Nothing before that: it cannot be a division.\n      return collectRegex();\n    }\n    if (prevToken.type === 'Punctuator') {\n      if (prevToken.value === ']') {\n        return scanPunctuator();\n      }\n      if (prevToken.value === ')') {\n        checkToken = extra.tokens[extra.openParenToken - 1];\n        if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {\n          return collectRegex();\n        }\n        return scanPunctuator();\n      }\n      if (prevToken.value === '}') {\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n          // Anonymous function.\n          checkToken = extra.tokens[extra.openCurlyToken - 4];\n          if (!checkToken) {\n            return scanPunctuator();\n          }\n        } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n          // Named function.\n          checkToken = extra.tokens[extra.openCurlyToken - 5];\n          if (!checkToken) {\n            return collectRegex();\n          }\n        } else {\n          return scanPunctuator();\n        }\n        // checkToken determines whether the function is\n        // a declaration or an expression.\n        if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n          // It is an expression.\n          return scanPunctuator();\n        }\n        // It is a declaration.\n        return collectRegex();\n      }\n      return collectRegex();\n    }\n    if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n      return collectRegex();\n    }\n    return scanPunctuator();\n  }\n  function advance() {\n    var ch;\n    skipComment();\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n    ch = source.charCodeAt(index);\n    if (isIdentifierStart(ch)) {\n      return scanIdentifier();\n    }\n\n    // Very common: ( and ) and ;\n    if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n      return scanPunctuator();\n    }\n\n    // String literal starts with single quote (U+0027) or double quote (U+0022).\n    if (ch === 0x27 || ch === 0x22) {\n      return scanStringLiteral();\n    }\n\n    // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n    if (ch === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n      return scanPunctuator();\n    }\n    if (isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    }\n\n    // Slash (/) U+002F can also start a regex.\n    if (extra.tokenize && ch === 0x2F) {\n      return advanceSlash();\n    }\n    return scanPunctuator();\n  }\n  function collectToken() {\n    var loc, token, range, value;\n    skipComment();\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      extra.tokens.push({\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      });\n    }\n    return token;\n  }\n  function lex() {\n    var token;\n    token = lookahead;\n    index = token.end;\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    index = token.end;\n    lineNumber = token.lineNumber;\n    lineStart = token.lineStart;\n    return token;\n  }\n  function peek() {\n    var pos, line, start;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n  }\n  function Position(line, column) {\n    this.line = line;\n    this.column = column;\n  }\n  function SourceLocation(startLine, startColumn, line, column) {\n    this.start = new Position(startLine, startColumn);\n    this.end = new Position(line, column);\n  }\n  SyntaxTreeDelegate = {\n    name: 'SyntaxTree',\n    processComment: function processComment(node) {\n      var lastChild, trailingComments;\n      if (node.type === Syntax.Program) {\n        if (node.body.length > 0) {\n          return;\n        }\n      }\n      if (extra.trailingComments.length > 0) {\n        if (extra.trailingComments[0].range[0] >= node.range[1]) {\n          trailingComments = extra.trailingComments;\n          extra.trailingComments = [];\n        } else {\n          extra.trailingComments.length = 0;\n        }\n      } else {\n        if (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments && extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {\n          trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n          delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n        }\n      }\n\n      // Eating the stack.\n      while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {\n        lastChild = extra.bottomRightStack.pop();\n      }\n      if (lastChild) {\n        if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n          node.leadingComments = lastChild.leadingComments;\n          delete lastChild.leadingComments;\n        }\n      } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n        node.leadingComments = extra.leadingComments;\n        extra.leadingComments = [];\n      }\n      if (trailingComments) {\n        node.trailingComments = trailingComments;\n      }\n      extra.bottomRightStack.push(node);\n    },\n    markEnd: function markEnd(node, startToken) {\n      if (extra.range) {\n        node.range = [startToken.start, index];\n      }\n      if (extra.loc) {\n        node.loc = new SourceLocation(startToken.startLineNumber === undefined ? startToken.lineNumber : startToken.startLineNumber, startToken.start - (startToken.startLineStart === undefined ? startToken.lineStart : startToken.startLineStart), lineNumber, index - lineStart);\n        this.postProcess(node);\n      }\n      if (extra.attachComment) {\n        this.processComment(node);\n      }\n      return node;\n    },\n    postProcess: function postProcess(node) {\n      if (extra.source) {\n        node.loc.source = extra.source;\n      }\n      return node;\n    },\n    createArrayExpression: function createArrayExpression(elements) {\n      return {\n        type: Syntax.ArrayExpression,\n        elements: elements\n      };\n    },\n    createAssignmentExpression: function createAssignmentExpression(operator, left, right) {\n      return {\n        type: Syntax.AssignmentExpression,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBinaryExpression: function createBinaryExpression(operator, left, right) {\n      var type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      return {\n        type: type,\n        operator: operator,\n        left: left,\n        right: right\n      };\n    },\n    createBlockStatement: function createBlockStatement(body) {\n      return {\n        type: Syntax.BlockStatement,\n        body: body\n      };\n    },\n    createBreakStatement: function createBreakStatement(label) {\n      return {\n        type: Syntax.BreakStatement,\n        label: label\n      };\n    },\n    createCallExpression: function createCallExpression(callee, args) {\n      return {\n        type: Syntax.CallExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createCatchClause: function createCatchClause(param, body) {\n      return {\n        type: Syntax.CatchClause,\n        param: param,\n        body: body\n      };\n    },\n    createConditionalExpression: function createConditionalExpression(test, consequent, alternate) {\n      return {\n        type: Syntax.ConditionalExpression,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createContinueStatement: function createContinueStatement(label) {\n      return {\n        type: Syntax.ContinueStatement,\n        label: label\n      };\n    },\n    createDebuggerStatement: function createDebuggerStatement() {\n      return {\n        type: Syntax.DebuggerStatement\n      };\n    },\n    createDoWhileStatement: function createDoWhileStatement(body, test) {\n      return {\n        type: Syntax.DoWhileStatement,\n        body: body,\n        test: test\n      };\n    },\n    createEmptyStatement: function createEmptyStatement() {\n      return {\n        type: Syntax.EmptyStatement\n      };\n    },\n    createExpressionStatement: function createExpressionStatement(expression) {\n      return {\n        type: Syntax.ExpressionStatement,\n        expression: expression\n      };\n    },\n    createForStatement: function createForStatement(init, test, update, body) {\n      return {\n        type: Syntax.ForStatement,\n        init: init,\n        test: test,\n        update: update,\n        body: body\n      };\n    },\n    createForInStatement: function createForInStatement(left, right, body) {\n      return {\n        type: Syntax.ForInStatement,\n        left: left,\n        right: right,\n        body: body,\n        each: false\n      };\n    },\n    createFunctionDeclaration: function createFunctionDeclaration(id, params, defaults, body) {\n      return {\n        type: Syntax.FunctionDeclaration,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: null,\n        generator: false,\n        expression: false\n      };\n    },\n    createFunctionExpression: function createFunctionExpression(id, params, defaults, body) {\n      return {\n        type: Syntax.FunctionExpression,\n        id: id,\n        params: params,\n        defaults: defaults,\n        body: body,\n        rest: null,\n        generator: false,\n        expression: false\n      };\n    },\n    createIdentifier: function createIdentifier(name) {\n      return {\n        type: Syntax.Identifier,\n        name: name\n      };\n    },\n    createIfStatement: function createIfStatement(test, consequent, alternate) {\n      return {\n        type: Syntax.IfStatement,\n        test: test,\n        consequent: consequent,\n        alternate: alternate\n      };\n    },\n    createLabeledStatement: function createLabeledStatement(label, body) {\n      return {\n        type: Syntax.LabeledStatement,\n        label: label,\n        body: body\n      };\n    },\n    createLiteral: function createLiteral(token) {\n      return {\n        type: Syntax.Literal,\n        value: token.value,\n        raw: source.slice(token.start, token.end)\n      };\n    },\n    createMemberExpression: function createMemberExpression(accessor, object, property) {\n      return {\n        type: Syntax.MemberExpression,\n        computed: accessor === '[',\n        object: object,\n        property: property\n      };\n    },\n    createNewExpression: function createNewExpression(callee, args) {\n      return {\n        type: Syntax.NewExpression,\n        callee: callee,\n        'arguments': args\n      };\n    },\n    createObjectExpression: function createObjectExpression(properties) {\n      return {\n        type: Syntax.ObjectExpression,\n        properties: properties\n      };\n    },\n    createPostfixExpression: function createPostfixExpression(operator, argument) {\n      return {\n        type: Syntax.UpdateExpression,\n        operator: operator,\n        argument: argument,\n        prefix: false\n      };\n    },\n    createProgram: function createProgram(body) {\n      return {\n        type: Syntax.Program,\n        body: body\n      };\n    },\n    createProperty: function createProperty(kind, key, value) {\n      return {\n        type: Syntax.Property,\n        key: key,\n        value: value,\n        kind: kind\n      };\n    },\n    createReturnStatement: function createReturnStatement(argument) {\n      return {\n        type: Syntax.ReturnStatement,\n        argument: argument\n      };\n    },\n    createSequenceExpression: function createSequenceExpression(expressions) {\n      return {\n        type: Syntax.SequenceExpression,\n        expressions: expressions\n      };\n    },\n    createSwitchCase: function createSwitchCase(test, consequent) {\n      return {\n        type: Syntax.SwitchCase,\n        test: test,\n        consequent: consequent\n      };\n    },\n    createSwitchStatement: function createSwitchStatement(discriminant, cases) {\n      return {\n        type: Syntax.SwitchStatement,\n        discriminant: discriminant,\n        cases: cases\n      };\n    },\n    createThisExpression: function createThisExpression() {\n      return {\n        type: Syntax.ThisExpression\n      };\n    },\n    createThrowStatement: function createThrowStatement(argument) {\n      return {\n        type: Syntax.ThrowStatement,\n        argument: argument\n      };\n    },\n    createTryStatement: function createTryStatement(block, guardedHandlers, handlers, finalizer) {\n      return {\n        type: Syntax.TryStatement,\n        block: block,\n        guardedHandlers: guardedHandlers,\n        handlers: handlers,\n        finalizer: finalizer\n      };\n    },\n    createUnaryExpression: function createUnaryExpression(operator, argument) {\n      if (operator === '++' || operator === '--') {\n        return {\n          type: Syntax.UpdateExpression,\n          operator: operator,\n          argument: argument,\n          prefix: true\n        };\n      }\n      return {\n        type: Syntax.UnaryExpression,\n        operator: operator,\n        argument: argument,\n        prefix: true\n      };\n    },\n    createVariableDeclaration: function createVariableDeclaration(declarations, kind) {\n      return {\n        type: Syntax.VariableDeclaration,\n        declarations: declarations,\n        kind: kind\n      };\n    },\n    createVariableDeclarator: function createVariableDeclarator(id, init) {\n      return {\n        type: Syntax.VariableDeclarator,\n        id: id,\n        init: init\n      };\n    },\n    createWhileStatement: function createWhileStatement(test, body) {\n      return {\n        type: Syntax.WhileStatement,\n        test: test,\n        body: body\n      };\n    },\n    createWithStatement: function createWithStatement(object, body) {\n      return {\n        type: Syntax.WithStatement,\n        object: object,\n        body: body\n      };\n    }\n  };\n\n  // Return true if there is a line terminator before the next token.\n\n  function peekLineTerminator() {\n    var pos, line, start, found;\n    pos = index;\n    line = lineNumber;\n    start = lineStart;\n    skipComment();\n    found = lineNumber !== line;\n    index = pos;\n    lineNumber = line;\n    lineStart = start;\n    return found;\n  }\n\n  // Throw an exception\n\n  function throwError(token, messageFormat) {\n    var error,\n      args = Array.prototype.slice.call(arguments, 2),\n      msg = messageFormat.replace(/%(\\d)/g, function (whole, index) {\n        assert(index < args.length, 'Message reference must be in range');\n        return args[index];\n      });\n    if (typeof token.lineNumber === 'number') {\n      error = new Error('Line ' + token.lineNumber + ': ' + msg);\n      error.index = token.start;\n      error.lineNumber = token.lineNumber;\n      error.column = token.start - lineStart + 1;\n    } else {\n      error = new Error('Line ' + lineNumber + ': ' + msg);\n      error.index = index;\n      error.lineNumber = lineNumber;\n      error.column = index - lineStart + 1;\n    }\n    error.description = msg;\n    throw error;\n  }\n  function throwErrorTolerant() {\n    try {\n      throwError.apply(null, arguments);\n    } catch (e) {\n      if (extra.errors) {\n        extra.errors.push(e);\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  // Throw an exception because of the token.\n\n  function throwUnexpected(token) {\n    if (token.type === Token.EOF) {\n      throwError(token, Messages.UnexpectedEOS);\n    }\n    if (token.type === Token.NumericLiteral) {\n      throwError(token, Messages.UnexpectedNumber);\n    }\n    if (token.type === Token.StringLiteral) {\n      throwError(token, Messages.UnexpectedString);\n    }\n    if (token.type === Token.Identifier) {\n      throwError(token, Messages.UnexpectedIdentifier);\n    }\n    if (token.type === Token.Keyword) {\n      if (isFutureReservedWord(token.value)) {\n        throwError(token, Messages.UnexpectedReserved);\n      } else if (strict && isStrictModeReservedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictReservedWord);\n        return;\n      }\n      throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // BooleanLiteral, NullLiteral, or Punctuator.\n    throwError(token, Messages.UnexpectedToken, token.value);\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n    var token = lex();\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpected(token);\n    }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n    var token = lex();\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpected(token);\n    }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  // Return true if the next token is an assignment operator\n\n  function matchAssign() {\n    var op;\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n  function consumeSemicolon() {\n    var line,\n      oldIndex = index,\n      oldLineNumber = lineNumber,\n      oldLineStart = lineStart,\n      oldLookahead = lookahead;\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(index) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n    line = lineNumber;\n    skipComment();\n    if (lineNumber !== line) {\n      index = oldIndex;\n      lineNumber = oldLineNumber;\n      lineStart = oldLineStart;\n      lookahead = oldLookahead;\n      return;\n    }\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpected(lookahead);\n    }\n  }\n\n  // Return true if provided expression is LeftHandSideExpression\n\n  function isLeftHandSide(expr) {\n    return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n    var elements = [],\n      startToken;\n    startToken = lookahead;\n    expect('[');\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        elements.push(parseAssignmentExpression());\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n    lex();\n    return delegate.markEnd(delegate.createArrayExpression(elements), startToken);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parsePropertyFunction(param, first) {\n    var previousStrict, body, startToken;\n    previousStrict = strict;\n    startToken = lookahead;\n    body = parseFunctionSourceElements();\n    if (first && strict && isRestrictedWord(param[0].name)) {\n      throwErrorTolerant(first, Messages.StrictParamName);\n    }\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);\n  }\n  function parseObjectPropertyKey() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex();\n\n    // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n      if (strict && token.octal) {\n        throwErrorTolerant(token, Messages.StrictOctalLiteral);\n      }\n      return delegate.markEnd(delegate.createLiteral(token), startToken);\n    }\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n  function parseObjectProperty() {\n    var token, key, id, value, param, startToken;\n    token = lookahead;\n    startToken = lookahead;\n    if (token.type === Token.Identifier) {\n      id = parseObjectPropertyKey();\n\n      // Property Assignment: Getter and Setter.\n\n      if (token.value === 'get' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        expect(')');\n        value = parsePropertyFunction([]);\n        return delegate.markEnd(delegate.createProperty('get', key, value), startToken);\n      }\n      if (token.value === 'set' && !match(':')) {\n        key = parseObjectPropertyKey();\n        expect('(');\n        token = lookahead;\n        if (token.type !== Token.Identifier) {\n          expect(')');\n          throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n          value = parsePropertyFunction([]);\n        } else {\n          param = [parseVariableIdentifier()];\n          expect(')');\n          value = parsePropertyFunction(param, token);\n        }\n        return delegate.markEnd(delegate.createProperty('set', key, value), startToken);\n      }\n      expect(':');\n      value = parseAssignmentExpression();\n      return delegate.markEnd(delegate.createProperty('init', id, value), startToken);\n    }\n    if (token.type === Token.EOF || token.type === Token.Punctuator) {\n      throwUnexpected(token);\n    } else {\n      key = parseObjectPropertyKey();\n      expect(':');\n      value = parseAssignmentExpression();\n      return delegate.markEnd(delegate.createProperty('init', key, value), startToken);\n    }\n  }\n  function parseObjectInitialiser() {\n    var properties = [],\n      property,\n      name,\n      key,\n      kind,\n      map = {},\n      toString = String,\n      startToken;\n    startToken = lookahead;\n    expect('{');\n    while (!match('}')) {\n      property = parseObjectProperty();\n      if (property.key.type === Syntax.Identifier) {\n        name = property.key.name;\n      } else {\n        name = toString(property.key.value);\n      }\n      kind = property.kind === 'init' ? PropertyKind.Data : property.kind === 'get' ? PropertyKind.Get : PropertyKind.Set;\n      key = '$' + name;\n      if (Object.prototype.hasOwnProperty.call(map, key)) {\n        if (map[key] === PropertyKind.Data) {\n          if (strict && kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n          } else if (kind !== PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          }\n        } else {\n          if (kind === PropertyKind.Data) {\n            throwErrorTolerant({}, Messages.AccessorDataProperty);\n          } else if (map[key] & kind) {\n            throwErrorTolerant({}, Messages.AccessorGetSet);\n          }\n        }\n        map[key] |= kind;\n      } else {\n        map[key] = kind;\n      }\n      properties.push(property);\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n    expect('}');\n    return delegate.markEnd(delegate.createObjectExpression(properties), startToken);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n    var expr;\n    expect('(');\n    expr = parseExpression();\n    expect(')');\n    return expr;\n  }\n\n  // 11.1 Primary Expressions\n\n  function parsePrimaryExpression() {\n    var type, token, expr, startToken;\n    if (match('(')) {\n      return parseGroupExpression();\n    }\n    if (match('[')) {\n      return parseArrayInitialiser();\n    }\n    if (match('{')) {\n      return parseObjectInitialiser();\n    }\n    type = lookahead.type;\n    startToken = lookahead;\n    if (type === Token.Identifier) {\n      expr = delegate.createIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      if (strict && lookahead.octal) {\n        throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n      }\n      expr = delegate.createLiteral(lex());\n    } else if (type === Token.Keyword) {\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n      if (matchKeyword('this')) {\n        lex();\n        expr = delegate.createThisExpression();\n      } else {\n        throwUnexpected(lex());\n      }\n    } else if (type === Token.BooleanLiteral) {\n      token = lex();\n      token.value = token.value === 'true';\n      expr = delegate.createLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      token = lex();\n      token.value = null;\n      expr = delegate.createLiteral(token);\n    } else if (match('/') || match('/=')) {\n      if (typeof extra.tokens !== 'undefined') {\n        expr = delegate.createLiteral(collectRegex());\n      } else {\n        expr = delegate.createLiteral(scanRegExp());\n      }\n      peek();\n    } else {\n      throwUnexpected(lex());\n    }\n    return delegate.markEnd(expr, startToken);\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n    var args = [];\n    expect('(');\n    if (!match(')')) {\n      while (index < length) {\n        args.push(parseAssignmentExpression());\n        if (match(')')) {\n          break;\n        }\n        expect(',');\n      }\n    }\n    expect(')');\n    return args;\n  }\n  function parseNonComputedProperty() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex();\n    if (!isIdentifierName(token)) {\n      throwUnexpected(token);\n    }\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = parseExpression();\n    expect(']');\n    return expr;\n  }\n  function parseNewExpression() {\n    var callee, args, startToken;\n    startToken = lookahead;\n    expectKeyword('new');\n    callee = parseLeftHandSideExpression();\n    args = match('(') ? parseArguments() : [];\n    return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);\n  }\n  function parseLeftHandSideExpressionAllowCall() {\n    var expr,\n      args,\n      property,\n      startToken,\n      previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n    for (;;) {\n      if (match('.')) {\n        property = parseNonComputedMember();\n        expr = delegate.createMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        args = parseArguments();\n        expr = delegate.createCallExpression(expr, args);\n      } else if (match('[')) {\n        property = parseComputedMember();\n        expr = delegate.createMemberExpression('[', expr, property);\n      } else {\n        break;\n      }\n      delegate.markEnd(expr, startToken);\n    }\n    state.allowIn = previousAllowIn;\n    return expr;\n  }\n  function parseLeftHandSideExpression() {\n    var expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n    expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n    while (match('.') || match('[')) {\n      if (match('[')) {\n        property = parseComputedMember();\n        expr = delegate.createMemberExpression('[', expr, property);\n      } else {\n        property = parseNonComputedMember();\n        expr = delegate.createMemberExpression('.', expr, property);\n      }\n      delegate.markEnd(expr, startToken);\n    }\n    return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n    var expr,\n      token,\n      startToken = lookahead;\n    expr = parseLeftHandSideExpressionAllowCall();\n    if (lookahead.type === Token.Punctuator) {\n      if ((match('++') || match('--')) && !peekLineTerminator()) {\n        // 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          throwErrorTolerant({}, Messages.StrictLHSPostfix);\n        }\n        if (!isLeftHandSide(expr)) {\n          throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n        }\n        token = lex();\n        expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);\n      }\n    }\n    return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression();\n      // 11.4.4, 11.4.5\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        throwErrorTolerant({}, Messages.StrictLHSPrefix);\n      }\n      if (!isLeftHandSide(expr)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression();\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = parseUnaryExpression();\n      expr = delegate.createUnaryExpression(token.value, expr);\n      expr = delegate.markEnd(expr, startToken);\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        throwErrorTolerant({}, Messages.StrictDelete);\n      }\n    } else {\n      expr = parsePostfixExpression();\n    }\n    return expr;\n  }\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n      case '&&':\n        prec = 2;\n        break;\n      case '|':\n        prec = 3;\n        break;\n      case '^':\n        prec = 4;\n        break;\n      case '&':\n        prec = 5;\n        break;\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n      default:\n        break;\n    }\n    return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = parseUnaryExpression();\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n    if (prec === 0) {\n      return left;\n    }\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = parseUnaryExpression();\n    stack = [left, token, right];\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        expr = delegate.createBinaryExpression(operator, left, right);\n        markers.pop();\n        marker = markers[markers.length - 1];\n        delegate.markEnd(expr, marker);\n        stack.push(expr);\n      }\n\n      // Shift.\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = parseUnaryExpression();\n      stack.push(expr);\n    }\n\n    // Final reduce to clean-up the stack.\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n    while (i > 1) {\n      expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n      marker = markers.pop();\n      delegate.markEnd(expr, marker);\n    }\n    return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = parseBinaryExpression();\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = parseAssignmentExpression();\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = parseAssignmentExpression();\n      expr = delegate.createConditionalExpression(expr, consequent, alternate);\n      delegate.markEnd(expr, startToken);\n    }\n    return expr;\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n    var token, left, right, node, startToken;\n    token = lookahead;\n    startToken = lookahead;\n    node = left = parseConditionalExpression();\n    if (matchAssign()) {\n      // LeftHandSideExpression\n      if (!isLeftHandSide(left)) {\n        throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n      }\n\n      // 11.13.1\n      if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n        throwErrorTolerant(token, Messages.StrictLHSAssignment);\n      }\n      token = lex();\n      right = parseAssignmentExpression();\n      node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);\n    }\n    return node;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n    var expr,\n      startToken = lookahead;\n    expr = parseAssignmentExpression();\n    if (match(',')) {\n      expr = delegate.createSequenceExpression([expr]);\n      while (index < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        expr.expressions.push(parseAssignmentExpression());\n      }\n      delegate.markEnd(expr, startToken);\n    }\n    return expr;\n  }\n\n  // 12.1 Block\n\n  function parseStatementList() {\n    var list = [],\n      statement;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      statement = parseSourceElement();\n      if (typeof statement === 'undefined') {\n        break;\n      }\n      list.push(statement);\n    }\n    return list;\n  }\n  function parseBlock() {\n    var block, startToken;\n    startToken = lookahead;\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return delegate.markEnd(delegate.createBlockStatement(block), startToken);\n  }\n\n  // 12.2 Variable Statement\n\n  function parseVariableIdentifier() {\n    var token, startToken;\n    startToken = lookahead;\n    token = lex();\n    if (token.type !== Token.Identifier) {\n      throwUnexpected(token);\n    }\n    return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n  }\n  function parseVariableDeclaration(kind) {\n    var init = null,\n      id,\n      startToken;\n    startToken = lookahead;\n    id = parseVariableIdentifier();\n\n    // 12.2.1\n    if (strict && isRestrictedWord(id.name)) {\n      throwErrorTolerant({}, Messages.StrictVarName);\n    }\n    if (kind === 'const') {\n      expect('=');\n      init = parseAssignmentExpression();\n    } else if (match('=')) {\n      lex();\n      init = parseAssignmentExpression();\n    }\n    return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);\n  }\n  function parseVariableDeclarationList(kind) {\n    var list = [];\n    do {\n      list.push(parseVariableDeclaration(kind));\n      if (!match(',')) {\n        break;\n      }\n      lex();\n    } while (index < length);\n    return list;\n  }\n  function parseVariableStatement() {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return delegate.createVariableDeclaration(declarations, 'var');\n  }\n\n  // kind may be `const` or `let`\n  // Both are experimental and not in the specification yet.\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n  // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n  function parseConstLetDeclaration(kind) {\n    var declarations, startToken;\n    startToken = lookahead;\n    expectKeyword(kind);\n    declarations = parseVariableDeclarationList(kind);\n    consumeSemicolon();\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);\n  }\n\n  // 12.3 Empty Statement\n\n  function parseEmptyStatement() {\n    expect(';');\n    return delegate.createEmptyStatement();\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement() {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return delegate.createExpressionStatement(expr);\n  }\n\n  // 12.5 If statement\n\n  function parseIfStatement() {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n    return delegate.createIfStatement(test, consequent, alternate);\n  }\n\n  // 12.6 Iteration Statements\n\n  function parseDoWhileStatement() {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    if (match(';')) {\n      lex();\n    }\n    return delegate.createDoWhileStatement(body, test);\n  }\n  function parseWhileStatement() {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return delegate.createWhileStatement(test, body);\n  }\n  function parseForVariableDeclaration() {\n    var token, declarations, startToken;\n    startToken = lookahead;\n    token = lex();\n    declarations = parseVariableDeclarationList();\n    return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);\n  }\n  function parseForStatement() {\n    var init,\n      test,\n      update,\n      left,\n      right,\n      body,\n      oldInIteration,\n      previousAllowIn = state.allowIn;\n    init = test = update = null;\n    expectKeyword('for');\n    expect('(');\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var') || matchKeyword('let')) {\n        state.allowIn = false;\n        init = parseForVariableDeclaration();\n        state.allowIn = previousAllowIn;\n        if (init.declarations.length === 1 && matchKeyword('in')) {\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      } else {\n        state.allowIn = false;\n        init = parseExpression();\n        state.allowIn = previousAllowIn;\n        if (matchKeyword('in')) {\n          // LeftHandSideExpression\n          if (!isLeftHandSide(init)) {\n            throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n          }\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        }\n      }\n      if (typeof left === 'undefined') {\n        expect(';');\n      }\n    }\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n      expect(';');\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? delegate.createForStatement(init, test, update, body) : delegate.createForInStatement(left, right, body);\n  }\n\n  // 12.7 The continue statement\n\n  function parseContinueStatement() {\n    var label = null,\n      key;\n    expectKeyword('continue');\n\n    // Optimize the most common form: 'continue;'.\n    if (source.charCodeAt(index) === 0x3B) {\n      lex();\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n      return delegate.createContinueStatement(null);\n    }\n    if (peekLineTerminator()) {\n      if (!state.inIteration) {\n        throwError({}, Messages.IllegalContinue);\n      }\n      return delegate.createContinueStatement(null);\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !state.inIteration) {\n      throwError({}, Messages.IllegalContinue);\n    }\n    return delegate.createContinueStatement(label);\n  }\n\n  // 12.8 The break statement\n\n  function parseBreakStatement() {\n    var label = null,\n      key;\n    expectKeyword('break');\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(index) === 0x3B) {\n      lex();\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n      return delegate.createBreakStatement(null);\n    }\n    if (peekLineTerminator()) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError({}, Messages.IllegalBreak);\n      }\n      return delegate.createBreakStatement(null);\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError({}, Messages.IllegalBreak);\n    }\n    return delegate.createBreakStatement(label);\n  }\n\n  // 12.9 The return statement\n\n  function parseReturnStatement() {\n    var argument = null;\n    expectKeyword('return');\n    if (!state.inFunctionBody) {\n      throwErrorTolerant({}, Messages.IllegalReturn);\n    }\n\n    // 'return' followed by a space and an identifier is very common.\n    if (source.charCodeAt(index) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(index + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return delegate.createReturnStatement(argument);\n      }\n    }\n    if (peekLineTerminator()) {\n      return delegate.createReturnStatement(null);\n    }\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n    consumeSemicolon();\n    return delegate.createReturnStatement(argument);\n  }\n\n  // 12.10 The with statement\n\n  function parseWithStatement() {\n    var object, body;\n    if (strict) {\n      // TODO(ikarienator): Should we update the test cases instead?\n      skipComment();\n      throwErrorTolerant({}, Messages.StrictModeWith);\n    }\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return delegate.createWithStatement(object, body);\n  }\n\n  // 12.10 The swith statement\n\n  function parseSwitchCase() {\n    var test,\n      consequent = [],\n      statement,\n      startToken;\n    startToken = lookahead;\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n    expect(':');\n    while (index < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n      statement = parseStatement();\n      consequent.push(statement);\n    }\n    return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);\n  }\n  function parseSwitchStatement() {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n    if (match('}')) {\n      lex();\n      return delegate.createSwitchStatement(discriminant, cases);\n    }\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      clause = parseSwitchCase();\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError({}, Messages.MultipleDefaultsInSwitch);\n        }\n        defaultFound = true;\n      }\n      cases.push(clause);\n    }\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return delegate.createSwitchStatement(discriminant, cases);\n  }\n\n  // 12.13 The throw statement\n\n  function parseThrowStatement() {\n    var argument;\n    expectKeyword('throw');\n    if (peekLineTerminator()) {\n      throwError({}, Messages.NewlineAfterThrow);\n    }\n    argument = parseExpression();\n    consumeSemicolon();\n    return delegate.createThrowStatement(argument);\n  }\n\n  // 12.14 The try statement\n\n  function parseCatchClause() {\n    var param, body, startToken;\n    startToken = lookahead;\n    expectKeyword('catch');\n    expect('(');\n    if (match(')')) {\n      throwUnexpected(lookahead);\n    }\n    param = parseVariableIdentifier();\n    // 12.14.1\n    if (strict && isRestrictedWord(param.name)) {\n      throwErrorTolerant({}, Messages.StrictCatchVariable);\n    }\n    expect(')');\n    body = parseBlock();\n    return delegate.markEnd(delegate.createCatchClause(param, body), startToken);\n  }\n  function parseTryStatement() {\n    var block,\n      handlers = [],\n      finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n    if (matchKeyword('catch')) {\n      handlers.push(parseCatchClause());\n    }\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n    if (handlers.length === 0 && !finalizer) {\n      throwError({}, Messages.NoCatchOrFinally);\n    }\n    return delegate.createTryStatement(block, [], handlers, finalizer);\n  }\n\n  // 12.15 The debugger statement\n\n  function parseDebuggerStatement() {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return delegate.createDebuggerStatement();\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n    var type = lookahead.type,\n      expr,\n      labeledBody,\n      key,\n      startToken;\n    if (type === Token.EOF) {\n      throwUnexpected(lookahead);\n    }\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n    startToken = lookahead;\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return delegate.markEnd(parseEmptyStatement(), startToken);\n        case '(':\n          return delegate.markEnd(parseExpressionStatement(), startToken);\n        default:\n          break;\n      }\n    }\n    if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return delegate.markEnd(parseBreakStatement(), startToken);\n        case 'continue':\n          return delegate.markEnd(parseContinueStatement(), startToken);\n        case 'debugger':\n          return delegate.markEnd(parseDebuggerStatement(), startToken);\n        case 'do':\n          return delegate.markEnd(parseDoWhileStatement(), startToken);\n        case 'for':\n          return delegate.markEnd(parseForStatement(), startToken);\n        case 'function':\n          return delegate.markEnd(parseFunctionDeclaration(), startToken);\n        case 'if':\n          return delegate.markEnd(parseIfStatement(), startToken);\n        case 'return':\n          return delegate.markEnd(parseReturnStatement(), startToken);\n        case 'switch':\n          return delegate.markEnd(parseSwitchStatement(), startToken);\n        case 'throw':\n          return delegate.markEnd(parseThrowStatement(), startToken);\n        case 'try':\n          return delegate.markEnd(parseTryStatement(), startToken);\n        case 'var':\n          return delegate.markEnd(parseVariableStatement(), startToken);\n        case 'while':\n          return delegate.markEnd(parseWhileStatement(), startToken);\n        case 'with':\n          return delegate.markEnd(parseWithStatement(), startToken);\n        default:\n          break;\n      }\n    }\n    expr = parseExpression();\n\n    // 12.12 Labelled Statements\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError({}, Messages.Redeclaration, 'Label', expr.name);\n      }\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);\n    }\n    consumeSemicolon();\n    return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);\n  }\n\n  // 13 Function Definition\n\n  function parseFunctionSourceElements() {\n    var sourceElement,\n      sourceElements = [],\n      token,\n      directive,\n      firstRestricted,\n      oldLabelSet,\n      oldInIteration,\n      oldInSwitch,\n      oldInFunctionBody,\n      startToken;\n    startToken = lookahead;\n    expect('{');\n    while (index < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n      token = lookahead;\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n    while (index < length) {\n      if (match('}')) {\n        break;\n      }\n      sourceElement = parseSourceElement();\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n      sourceElements.push(sourceElement);\n    }\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);\n  }\n  function parseParams(firstRestricted) {\n    var param,\n      params = [],\n      token,\n      stricted,\n      paramSet,\n      key,\n      message;\n    expect('(');\n    if (!match(')')) {\n      paramSet = {};\n      while (index < length) {\n        token = lookahead;\n        param = parseVariableIdentifier();\n        key = '$' + token.value;\n        if (strict) {\n          if (isRestrictedWord(token.value)) {\n            stricted = token;\n            message = Messages.StrictParamName;\n          }\n          if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n            stricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        } else if (!firstRestricted) {\n          if (isRestrictedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictParamName;\n          } else if (isStrictModeReservedWord(token.value)) {\n            firstRestricted = token;\n            message = Messages.StrictReservedWord;\n          } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n            firstRestricted = token;\n            message = Messages.StrictParamDupe;\n          }\n        }\n        params.push(param);\n        paramSet[key] = true;\n        if (match(')')) {\n          break;\n        }\n        expect(',');\n      }\n    }\n    expect(')');\n    return {\n      params: params,\n      stricted: stricted,\n      firstRestricted: firstRestricted,\n      message: message\n    };\n  }\n  function parseFunctionDeclaration() {\n    var id,\n      params = [],\n      body,\n      token,\n      stricted,\n      tmp,\n      firstRestricted,\n      message,\n      previousStrict,\n      startToken;\n    startToken = lookahead;\n    expectKeyword('function');\n    token = lookahead;\n    id = parseVariableIdentifier();\n    if (strict) {\n      if (isRestrictedWord(token.value)) {\n        throwErrorTolerant(token, Messages.StrictFunctionName);\n      }\n    } else {\n      if (isRestrictedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictFunctionName;\n      } else if (isStrictModeReservedWord(token.value)) {\n        firstRestricted = token;\n        message = Messages.StrictReservedWord;\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);\n  }\n  function parseFunctionExpression() {\n    var token,\n      id = null,\n      stricted,\n      firstRestricted,\n      message,\n      tmp,\n      params = [],\n      body,\n      previousStrict,\n      startToken;\n    startToken = lookahead;\n    expectKeyword('function');\n    if (!match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          throwErrorTolerant(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwError(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      throwErrorTolerant(stricted, message);\n    }\n    strict = previousStrict;\n    return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);\n  }\n\n  // 14 Program\n\n  function parseSourceElement() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'const':\n        case 'let':\n          return parseConstLetDeclaration(lookahead.value);\n        case 'function':\n          return parseFunctionDeclaration();\n        default:\n          return parseStatement();\n      }\n    }\n    if (lookahead.type !== Token.EOF) {\n      return parseStatement();\n    }\n  }\n  function parseSourceElements() {\n    var sourceElement,\n      sourceElements = [],\n      token,\n      directive,\n      firstRestricted;\n    while (index < length) {\n      token = lookahead;\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n      sourceElement = parseSourceElement();\n      sourceElements.push(sourceElement);\n      if (sourceElement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    while (index < length) {\n      sourceElement = parseSourceElement();\n      /* istanbul ignore if */\n      if (typeof sourceElement === 'undefined') {\n        break;\n      }\n      sourceElements.push(sourceElement);\n    }\n    return sourceElements;\n  }\n  function parseProgram() {\n    var body, startToken;\n    skipComment();\n    peek();\n    startToken = lookahead;\n    strict = false;\n    body = parseSourceElements();\n    return delegate.markEnd(delegate.createProgram(body), startToken);\n  }\n  function filterTokenLocation() {\n    var i,\n      entry,\n      token,\n      tokens = [];\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n      if (extra.range) {\n        token.range = entry.range;\n      }\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n      tokens.push(token);\n    }\n    extra.tokens = tokens;\n  }\n  function tokenize(code, options) {\n    var toString, token, tokens;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1\n    };\n    extra = {};\n\n    // Options matching.\n    options = options || {};\n\n    // Of course we collect tokens here.\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenize = true;\n    // The following two fields are necessary to compute the Regex tokens.\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n    try {\n      peek();\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n      token = lex();\n      while (lookahead.type !== Token.EOF) {\n        try {\n          token = lex();\n        } catch (lexError) {\n          token = lookahead;\n          if (extra.errors) {\n            extra.errors.push(lexError);\n            // We have to break on the first error\n            // to avoid infinite loops.\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n      filterTokenLocation();\n      tokens = extra.tokens;\n      if (typeof extra.comments !== 'undefined') {\n        tokens.comments = extra.comments;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return tokens;\n  }\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    delegate = SyntaxTreeDelegate;\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1\n    };\n    extra = {};\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n    }\n    try {\n      program = parseProgram();\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return program;\n  }\n\n  // Sync with *.json manifests.\n  exports.version = '1.2.5';\n  exports.tokenize = tokenize;\n  exports.parse = parse;\n\n  // Deep copy.\n  /* istanbul ignore next */\n  exports.Syntax = function () {\n    var name,\n      types = {};\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["root","factory","define","amd","exports","esprima","Token","TokenName","FnExprTokens","Syntax","PropertyKind","Messages","Regex","SyntaxTreeDelegate","source","strict","index","lineNumber","lineStart","length","delegate","lookahead","state","extra","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","RegularExpression","AssignmentExpression","ArrayExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","Literal","LabeledStatement","LogicalExpression","MemberExpression","NewExpression","ObjectExpression","Program","Property","ReturnStatement","SequenceExpression","SwitchStatement","SwitchCase","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","Data","Get","Set","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictDuplicateProperty","AccessorDataProperty","AccessorGetSet","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","isWhiteSpace","isLineTerminator","isIdentifierStart","test","String","fromCharCode","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","addComment","type","value","start","end","loc","comment","attacher","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","skipSingleLineComment","offset","line","column","charCodeAt","slice","skipMultiLineComment","throwError","skipComment","scanHexEscape","prefix","i","len","code","toLowerCase","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","scanPunctuator","code2","ch1","ch2","ch3","ch4","tokenize","openParenToken","tokens","openCurlyToken","scanHexLiteral","number","parseInt","scanOctalLiteral","octal","isImplicitOctalLiteral","scanNumericLiteral","parseFloat","scanStringLiteral","str","quote","unescaped","restore","startLineNumber","startLineStart","testRegExp","pattern","flags","e","scanRegExpBody","classMarker","terminated","body","literal","scanRegExpFlags","throwErrorTolerant","scanRegExp","collectRegex","pos","regex","token","pop","isIdentifierName","advanceSlash","prevToken","checkToken","advance","collectToken","lex","peek","Position","SourceLocation","startLine","startColumn","name","processComment","node","lastChild","bottomRightStack","markEnd","startToken","undefined","postProcess","createArrayExpression","elements","createAssignmentExpression","operator","left","right","createBinaryExpression","createBlockStatement","createBreakStatement","label","createCallExpression","callee","args","createCatchClause","param","createConditionalExpression","consequent","alternate","createContinueStatement","createDebuggerStatement","createDoWhileStatement","createEmptyStatement","createExpressionStatement","expression","createForStatement","init","update","createForInStatement","each","createFunctionDeclaration","params","defaults","rest","generator","createFunctionExpression","createIdentifier","createIfStatement","createLabeledStatement","createLiteral","raw","createMemberExpression","accessor","object","property","computed","createNewExpression","createObjectExpression","properties","createPostfixExpression","argument","createProgram","createProperty","kind","key","createReturnStatement","createSequenceExpression","expressions","createSwitchCase","createSwitchStatement","discriminant","cases","createThisExpression","createThrowStatement","createTryStatement","block","guardedHandlers","handlers","finalizer","createUnaryExpression","createVariableDeclaration","declarations","createVariableDeclarator","createWhileStatement","createWithStatement","peekLineTerminator","found","messageFormat","error","Array","prototype","call","arguments","msg","replace","whole","description","apply","errors","throwUnexpected","expect","expectKeyword","keyword","match","matchKeyword","matchAssign","op","consumeSemicolon","oldIndex","oldLineNumber","oldLineStart","oldLookahead","isLeftHandSide","expr","parseArrayInitialiser","parseAssignmentExpression","parsePropertyFunction","first","previousStrict","parseFunctionSourceElements","parseObjectPropertyKey","parseObjectProperty","parseVariableIdentifier","parseObjectInitialiser","map","toString","Object","hasOwnProperty","parseGroupExpression","parseExpression","parsePrimaryExpression","parseFunctionExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","parsePostfixExpression","parseUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","parseConditionalExpression","parseStatementList","list","statement","parseSourceElement","parseBlock","parseVariableDeclaration","parseVariableDeclarationList","parseVariableStatement","parseConstLetDeclaration","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForVariableDeclaration","parseForStatement","parseContinueStatement","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","inFunctionBody","parseWithStatement","parseSwitchCase","parseSwitchStatement","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","parseDebuggerStatement","labeledBody","parseFunctionDeclaration","sourceElement","sourceElements","directive","firstRestricted","oldLabelSet","oldInFunctionBody","parseParams","stricted","paramSet","tmp","parseSourceElements","parseProgram","filterTokenLocation","entry","options","tolerant","lexError","parse","program","version","types","create","freeze"],"sources":["/home/yasmin/rea de Trabalho/Frontend/node_modules/cwise-parser/node_modules/esprima/esprima.js"],"sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/*jslint bitwise:true plusplus:true */\n/*global esprima:true, define:true, exports:true, window: true,\nthrowErrorTolerant: true,\nthrowError: true, generateStatement: true, peek: true,\nparseAssignmentExpression: true, parseBlock: true, parseExpression: true,\nparseFunctionDeclaration: true, parseFunctionExpression: true,\nparseFunctionSourceElements: true, parseVariableIdentifier: true,\nparseLeftHandSideExpression: true,\nparseUnaryExpression: true,\nparseStatement: true, parseSourceElement: true */\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PropertyKind,\n        Messages,\n        Regex,\n        SyntaxTreeDelegate,\n        source,\n        strict,\n        index,\n        lineNumber,\n        lineStart,\n        length,\n        delegate,\n        lookahead,\n        state,\n        extra;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        ArrayExpression: 'ArrayExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        Program: 'Program',\n        Property: 'Property',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SwitchStatement: 'SwitchStatement',\n        SwitchCase: 'SwitchCase',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PropertyKind = {\n        Data: 1,\n        Get: 2,\n        Set: 4\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken:  'Unexpected token %0',\n        UnexpectedNumber:  'Unexpected number',\n        UnexpectedString:  'Unexpected string',\n        UnexpectedIdentifier:  'Unexpected identifier',\n        UnexpectedReserved:  'Unexpected reserved word',\n        UnexpectedEOS:  'Unexpected end of input',\n        NewlineAfterThrow:  'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp:  'Invalid regular expression: missing /',\n        InvalidLHSInAssignment:  'Invalid left-hand side in assignment',\n        InvalidLHSInForIn:  'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally:  'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith:  'Strict mode code may not include a with statement',\n        StrictCatchVariable:  'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName:  'Variable name may not be eval or arguments in strict mode',\n        StrictParamName:  'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName:  'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral:  'Octal literals are not allowed in strict mode.',\n        StrictDelete:  'Delete of an unqualified identifier in strict mode.',\n        StrictDuplicateProperty:  'Duplicate data property in object literal not allowed in strict mode',\n        AccessorDataProperty:  'Object literal may not have data and accessor property with the same name',\n        AccessorGetSet:  'Object literal may not have multiple get/set accessors with the same name',\n        StrictLHSAssignment:  'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix:  'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix:  'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord:  'Use of future reserved word in strict mode'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0\\u08A2-\\u08AC\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097F\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA697\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA80-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0\\u08A2-\\u08AC\\u08E4-\\u08FE\\u0900-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F0\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191C\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1D00-\\u1DE6\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA697\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7F8-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A\\uAA7B\\uAA80-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE26\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 48 && ch <= 57);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'class':\n        case 'enum':\n        case 'export':\n        case 'extends':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n        if (strict && isStrictModeReservedWord(id)) {\n            return true;\n        }\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatiblity with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment, attacher;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        // Because the way the actual token is scanned, often the comments\n        // (if any) are skipped twice during the lexical analysis.\n        // Thus, we need to skip adding a comment if the comment array already\n        // handled it.\n        if (state.lastCommentStart >= start) {\n            return;\n        }\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n                if (index >= length) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    function skipComment() {\n        var ch, start;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var start = index,\n            code = source.charCodeAt(index),\n            code2,\n            ch1 = source[index],\n            ch2,\n            ch3,\n            ch4;\n\n        switch (code) {\n\n        // Check for most common single-character punctuators.\n        case 0x2E:  // . dot\n        case 0x28:  // ( open bracket\n        case 0x29:  // ) close bracket\n        case 0x3B:  // ; semicolon\n        case 0x2C:  // , comma\n        case 0x7B:  // { open curly brace\n        case 0x7D:  // } close curly brace\n        case 0x5B:  // [\n        case 0x5D:  // ]\n        case 0x3A:  // :\n        case 0x3F:  // ?\n        case 0x7E:  // ~\n            ++index;\n            if (extra.tokenize) {\n                if (code === 0x28) {\n                    extra.openParenToken = extra.tokens.length;\n                } else if (code === 0x7B) {\n                    extra.openCurlyToken = extra.tokens.length;\n                }\n            }\n            return {\n                type: Token.Punctuator,\n                value: String.fromCharCode(code),\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n\n        default:\n            code2 = source.charCodeAt(index + 1);\n\n            // '=' (U+003D) marks an assignment or comparison operator.\n            if (code2 === 0x3D) {\n                switch (code) {\n                case 0x2B:  // +\n                case 0x2D:  // -\n                case 0x2F:  // /\n                case 0x3C:  // <\n                case 0x3E:  // >\n                case 0x5E:  // ^\n                case 0x7C:  // |\n                case 0x25:  // %\n                case 0x26:  // &\n                case 0x2A:  // *\n                    index += 2;\n                    return {\n                        type: Token.Punctuator,\n                        value: String.fromCharCode(code) + String.fromCharCode(code2),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n\n                case 0x21: // !\n                case 0x3D: // =\n                    index += 2;\n\n                    // !== and ===\n                    if (source.charCodeAt(index) === 0x3D) {\n                        ++index;\n                    }\n                    return {\n                        type: Token.Punctuator,\n                        value: source.slice(start, index),\n                        lineNumber: lineNumber,\n                        lineStart: lineStart,\n                        start: start,\n                        end: index\n                    };\n                }\n            }\n        }\n\n        // 4-character punctuator: >>>=\n\n        ch4 = source.substr(index, 4);\n\n        if (ch4 === '>>>=') {\n            index += 4;\n            return {\n                type: Token.Punctuator,\n                value: ch4,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 3-character punctuators: === !== >>> <<= >>=\n\n        ch3 = ch4.substr(0, 3);\n\n        if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {\n            index += 3;\n            return {\n                type: Token.Punctuator,\n                value: ch3,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // Other 2-character punctuators: ++ -- << >> && ||\n        ch2 = ch3.substr(0, 2);\n\n        if ((ch1 === ch2[1] && ('+-<>&|'.indexOf(ch1) >= 0)) || ch2 === '=>') {\n            index += 2;\n            return {\n                type: Token.Punctuator,\n                value: ch2,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        // 1-character punctuators: < > = ! + - * % & | ^ /\n        if ('<>=!+-*%&|^/'.indexOf(ch1) >= 0) {\n            ++index;\n            return {\n                type: Token.Punctuator,\n                value: ch1,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(start) {\n        var number = '0' + source[index++];\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: true,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, code, unescaped, restore, octal = false, startLineNumber, startLineStart;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        restore = index;\n                        unescaped = scanHexEscape(ch);\n                        if (unescaped) {\n                            str += unescaped;\n                        } else {\n                            index = restore;\n                            str += ch;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            code = '01234567'.indexOf(ch);\n\n                            // \\0 is not octal escape sequence\n                            if (code !== 0) {\n                                octal = true;\n                            }\n\n                            if (index < length && isOctalDigit(source[index])) {\n                                octal = true;\n                                code = code * 8 + '01234567'.indexOf(source[index++]);\n\n                                // 3 digits are only allowed when string starts\n                                // with 0, 1, 2, 3\n                                if ('0123'.indexOf(ch) >= 0 &&\n                                        index < length &&\n                                        isOctalDigit(source[index])) {\n                                    code = code * 8 + '01234567'.indexOf(source[index++]);\n                                }\n                            }\n                            str += String.fromCharCode(code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch ===  '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwError({}, Messages.UnexpectedToken, 'ILLEGAL');\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            startLineNumber: startLineNumber,\n            startLineStart: startLineStart,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var value;\n        try {\n            value = new RegExp(pattern, flags);\n        } catch (e) {\n            throwError({}, Messages.InvalidRegExp);\n        }\n        return value;\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwError({}, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwError({}, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwError({}, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                } else {\n                    str += '\\\\';\n                    throwErrorTolerant({}, Messages.UnexpectedToken, 'ILLEGAL');\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        var start, body, flags, pattern, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch;\n\n        skipComment();\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            return scanIdentifier();\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, range, value;\n\n        skipComment();\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            extra.tokens.push({\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            });\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n\n        token = lookahead;\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n\n        index = token.end;\n        lineNumber = token.lineNumber;\n        lineStart = token.lineStart;\n\n        return token;\n    }\n\n    function peek() {\n        var pos, line, start;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n    }\n\n    function Position(line, column) {\n        this.line = line;\n        this.column = column;\n    }\n\n    function SourceLocation(startLine, startColumn, line, column) {\n        this.start = new Position(startLine, startColumn);\n        this.end = new Position(line, column);\n    }\n\n    SyntaxTreeDelegate = {\n\n        name: 'SyntaxTree',\n\n        processComment: function (node) {\n            var lastChild, trailingComments;\n\n            if (node.type === Syntax.Program) {\n                if (node.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                if (extra.trailingComments[0].range[0] >= node.range[1]) {\n                    trailingComments = extra.trailingComments;\n                    extra.trailingComments = [];\n                } else {\n                    extra.trailingComments.length = 0;\n                }\n            } else {\n                if (extra.bottomRightStack.length > 0 &&\n                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments &&\n                        extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments[0].range[0] >= node.range[1]) {\n                    trailingComments = extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n                    delete extra.bottomRightStack[extra.bottomRightStack.length - 1].trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            while (extra.bottomRightStack.length > 0 && extra.bottomRightStack[extra.bottomRightStack.length - 1].range[0] >= node.range[0]) {\n                lastChild = extra.bottomRightStack.pop();\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= node.range[0]) {\n                    node.leadingComments = lastChild.leadingComments;\n                    delete lastChild.leadingComments;\n                }\n            } else if (extra.leadingComments.length > 0 && extra.leadingComments[extra.leadingComments.length - 1].range[1] <= node.range[0]) {\n                node.leadingComments = extra.leadingComments;\n                extra.leadingComments = [];\n            }\n\n\n            if (trailingComments) {\n                node.trailingComments = trailingComments;\n            }\n\n            extra.bottomRightStack.push(node);\n        },\n\n        markEnd: function (node, startToken) {\n            if (extra.range) {\n                node.range = [startToken.start, index];\n            }\n            if (extra.loc) {\n                node.loc = new SourceLocation(\n                    startToken.startLineNumber === undefined ?  startToken.lineNumber : startToken.startLineNumber,\n                    startToken.start - (startToken.startLineStart === undefined ?  startToken.lineStart : startToken.startLineStart),\n                    lineNumber,\n                    index - lineStart\n                );\n                this.postProcess(node);\n            }\n\n            if (extra.attachComment) {\n                this.processComment(node);\n            }\n            return node;\n        },\n\n        postProcess: function (node) {\n            if (extra.source) {\n                node.loc.source = extra.source;\n            }\n            return node;\n        },\n\n        createArrayExpression: function (elements) {\n            return {\n                type: Syntax.ArrayExpression,\n                elements: elements\n            };\n        },\n\n        createAssignmentExpression: function (operator, left, right) {\n            return {\n                type: Syntax.AssignmentExpression,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBinaryExpression: function (operator, left, right) {\n            var type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression :\n                        Syntax.BinaryExpression;\n            return {\n                type: type,\n                operator: operator,\n                left: left,\n                right: right\n            };\n        },\n\n        createBlockStatement: function (body) {\n            return {\n                type: Syntax.BlockStatement,\n                body: body\n            };\n        },\n\n        createBreakStatement: function (label) {\n            return {\n                type: Syntax.BreakStatement,\n                label: label\n            };\n        },\n\n        createCallExpression: function (callee, args) {\n            return {\n                type: Syntax.CallExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createCatchClause: function (param, body) {\n            return {\n                type: Syntax.CatchClause,\n                param: param,\n                body: body\n            };\n        },\n\n        createConditionalExpression: function (test, consequent, alternate) {\n            return {\n                type: Syntax.ConditionalExpression,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createContinueStatement: function (label) {\n            return {\n                type: Syntax.ContinueStatement,\n                label: label\n            };\n        },\n\n        createDebuggerStatement: function () {\n            return {\n                type: Syntax.DebuggerStatement\n            };\n        },\n\n        createDoWhileStatement: function (body, test) {\n            return {\n                type: Syntax.DoWhileStatement,\n                body: body,\n                test: test\n            };\n        },\n\n        createEmptyStatement: function () {\n            return {\n                type: Syntax.EmptyStatement\n            };\n        },\n\n        createExpressionStatement: function (expression) {\n            return {\n                type: Syntax.ExpressionStatement,\n                expression: expression\n            };\n        },\n\n        createForStatement: function (init, test, update, body) {\n            return {\n                type: Syntax.ForStatement,\n                init: init,\n                test: test,\n                update: update,\n                body: body\n            };\n        },\n\n        createForInStatement: function (left, right, body) {\n            return {\n                type: Syntax.ForInStatement,\n                left: left,\n                right: right,\n                body: body,\n                each: false\n            };\n        },\n\n        createFunctionDeclaration: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionDeclaration,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createFunctionExpression: function (id, params, defaults, body) {\n            return {\n                type: Syntax.FunctionExpression,\n                id: id,\n                params: params,\n                defaults: defaults,\n                body: body,\n                rest: null,\n                generator: false,\n                expression: false\n            };\n        },\n\n        createIdentifier: function (name) {\n            return {\n                type: Syntax.Identifier,\n                name: name\n            };\n        },\n\n        createIfStatement: function (test, consequent, alternate) {\n            return {\n                type: Syntax.IfStatement,\n                test: test,\n                consequent: consequent,\n                alternate: alternate\n            };\n        },\n\n        createLabeledStatement: function (label, body) {\n            return {\n                type: Syntax.LabeledStatement,\n                label: label,\n                body: body\n            };\n        },\n\n        createLiteral: function (token) {\n            return {\n                type: Syntax.Literal,\n                value: token.value,\n                raw: source.slice(token.start, token.end)\n            };\n        },\n\n        createMemberExpression: function (accessor, object, property) {\n            return {\n                type: Syntax.MemberExpression,\n                computed: accessor === '[',\n                object: object,\n                property: property\n            };\n        },\n\n        createNewExpression: function (callee, args) {\n            return {\n                type: Syntax.NewExpression,\n                callee: callee,\n                'arguments': args\n            };\n        },\n\n        createObjectExpression: function (properties) {\n            return {\n                type: Syntax.ObjectExpression,\n                properties: properties\n            };\n        },\n\n        createPostfixExpression: function (operator, argument) {\n            return {\n                type: Syntax.UpdateExpression,\n                operator: operator,\n                argument: argument,\n                prefix: false\n            };\n        },\n\n        createProgram: function (body) {\n            return {\n                type: Syntax.Program,\n                body: body\n            };\n        },\n\n        createProperty: function (kind, key, value) {\n            return {\n                type: Syntax.Property,\n                key: key,\n                value: value,\n                kind: kind\n            };\n        },\n\n        createReturnStatement: function (argument) {\n            return {\n                type: Syntax.ReturnStatement,\n                argument: argument\n            };\n        },\n\n        createSequenceExpression: function (expressions) {\n            return {\n                type: Syntax.SequenceExpression,\n                expressions: expressions\n            };\n        },\n\n        createSwitchCase: function (test, consequent) {\n            return {\n                type: Syntax.SwitchCase,\n                test: test,\n                consequent: consequent\n            };\n        },\n\n        createSwitchStatement: function (discriminant, cases) {\n            return {\n                type: Syntax.SwitchStatement,\n                discriminant: discriminant,\n                cases: cases\n            };\n        },\n\n        createThisExpression: function () {\n            return {\n                type: Syntax.ThisExpression\n            };\n        },\n\n        createThrowStatement: function (argument) {\n            return {\n                type: Syntax.ThrowStatement,\n                argument: argument\n            };\n        },\n\n        createTryStatement: function (block, guardedHandlers, handlers, finalizer) {\n            return {\n                type: Syntax.TryStatement,\n                block: block,\n                guardedHandlers: guardedHandlers,\n                handlers: handlers,\n                finalizer: finalizer\n            };\n        },\n\n        createUnaryExpression: function (operator, argument) {\n            if (operator === '++' || operator === '--') {\n                return {\n                    type: Syntax.UpdateExpression,\n                    operator: operator,\n                    argument: argument,\n                    prefix: true\n                };\n            }\n            return {\n                type: Syntax.UnaryExpression,\n                operator: operator,\n                argument: argument,\n                prefix: true\n            };\n        },\n\n        createVariableDeclaration: function (declarations, kind) {\n            return {\n                type: Syntax.VariableDeclaration,\n                declarations: declarations,\n                kind: kind\n            };\n        },\n\n        createVariableDeclarator: function (id, init) {\n            return {\n                type: Syntax.VariableDeclarator,\n                id: id,\n                init: init\n            };\n        },\n\n        createWhileStatement: function (test, body) {\n            return {\n                type: Syntax.WhileStatement,\n                test: test,\n                body: body\n            };\n        },\n\n        createWithStatement: function (object, body) {\n            return {\n                type: Syntax.WithStatement,\n                object: object,\n                body: body\n            };\n        }\n    };\n\n    // Return true if there is a line terminator before the next token.\n\n    function peekLineTerminator() {\n        var pos, line, start, found;\n\n        pos = index;\n        line = lineNumber;\n        start = lineStart;\n        skipComment();\n        found = lineNumber !== line;\n        index = pos;\n        lineNumber = line;\n        lineStart = start;\n\n        return found;\n    }\n\n    // Throw an exception\n\n    function throwError(token, messageFormat) {\n        var error,\n            args = Array.prototype.slice.call(arguments, 2),\n            msg = messageFormat.replace(\n                /%(\\d)/g,\n                function (whole, index) {\n                    assert(index < args.length, 'Message reference must be in range');\n                    return args[index];\n                }\n            );\n\n        if (typeof token.lineNumber === 'number') {\n            error = new Error('Line ' + token.lineNumber + ': ' + msg);\n            error.index = token.start;\n            error.lineNumber = token.lineNumber;\n            error.column = token.start - lineStart + 1;\n        } else {\n            error = new Error('Line ' + lineNumber + ': ' + msg);\n            error.index = index;\n            error.lineNumber = lineNumber;\n            error.column = index - lineStart + 1;\n        }\n\n        error.description = msg;\n        throw error;\n    }\n\n    function throwErrorTolerant() {\n        try {\n            throwError.apply(null, arguments);\n        } catch (e) {\n            if (extra.errors) {\n                extra.errors.push(e);\n            } else {\n                throw e;\n            }\n        }\n    }\n\n\n    // Throw an exception because of the token.\n\n    function throwUnexpected(token) {\n        if (token.type === Token.EOF) {\n            throwError(token, Messages.UnexpectedEOS);\n        }\n\n        if (token.type === Token.NumericLiteral) {\n            throwError(token, Messages.UnexpectedNumber);\n        }\n\n        if (token.type === Token.StringLiteral) {\n            throwError(token, Messages.UnexpectedString);\n        }\n\n        if (token.type === Token.Identifier) {\n            throwError(token, Messages.UnexpectedIdentifier);\n        }\n\n        if (token.type === Token.Keyword) {\n            if (isFutureReservedWord(token.value)) {\n                throwError(token, Messages.UnexpectedReserved);\n            } else if (strict && isStrictModeReservedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictReservedWord);\n                return;\n            }\n            throwError(token, Messages.UnexpectedToken, token.value);\n        }\n\n        // BooleanLiteral, NullLiteral, or Punctuator.\n        throwError(token, Messages.UnexpectedToken, token.value);\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpected(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        var line, oldIndex = index, oldLineNumber = lineNumber,\n            oldLineStart = lineStart, oldLookahead = lookahead;\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        line = lineNumber;\n        skipComment();\n        if (lineNumber !== line) {\n            index = oldIndex;\n            lineNumber = oldLineNumber;\n            lineStart = oldLineStart;\n            lookahead = oldLookahead;\n            return;\n        }\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpected(lookahead);\n        }\n    }\n\n    // Return true if provided expression is LeftHandSideExpression\n\n    function isLeftHandSide(expr) {\n        return expr.type === Syntax.Identifier || expr.type === Syntax.MemberExpression;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], startToken;\n\n        startToken = lookahead;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                elements.push(parseAssignmentExpression());\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return delegate.markEnd(delegate.createArrayExpression(elements), startToken);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(param, first) {\n        var previousStrict, body, startToken;\n\n        previousStrict = strict;\n        startToken = lookahead;\n        body = parseFunctionSourceElements();\n        if (first && strict && isRestrictedWord(param[0].name)) {\n            throwErrorTolerant(first, Messages.StrictParamName);\n        }\n        strict = previousStrict;\n        return delegate.markEnd(delegate.createFunctionExpression(null, param, [], body), startToken);\n    }\n\n    function parseObjectPropertyKey() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        if (token.type === Token.StringLiteral || token.type === Token.NumericLiteral) {\n            if (strict && token.octal) {\n                throwErrorTolerant(token, Messages.StrictOctalLiteral);\n            }\n            return delegate.markEnd(delegate.createLiteral(token), startToken);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseObjectProperty() {\n        var token, key, id, value, param, startToken;\n\n        token = lookahead;\n        startToken = lookahead;\n\n        if (token.type === Token.Identifier) {\n\n            id = parseObjectPropertyKey();\n\n            // Property Assignment: Getter and Setter.\n\n            if (token.value === 'get' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction([]);\n                return delegate.markEnd(delegate.createProperty('get', key, value), startToken);\n            }\n            if (token.value === 'set' && !match(':')) {\n                key = parseObjectPropertyKey();\n                expect('(');\n                token = lookahead;\n                if (token.type !== Token.Identifier) {\n                    expect(')');\n                    throwErrorTolerant(token, Messages.UnexpectedToken, token.value);\n                    value = parsePropertyFunction([]);\n                } else {\n                    param = [ parseVariableIdentifier() ];\n                    expect(')');\n                    value = parsePropertyFunction(param, token);\n                }\n                return delegate.markEnd(delegate.createProperty('set', key, value), startToken);\n            }\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', id, value), startToken);\n        }\n        if (token.type === Token.EOF || token.type === Token.Punctuator) {\n            throwUnexpected(token);\n        } else {\n            key = parseObjectPropertyKey();\n            expect(':');\n            value = parseAssignmentExpression();\n            return delegate.markEnd(delegate.createProperty('init', key, value), startToken);\n        }\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], property, name, key, kind, map = {}, toString = String, startToken;\n\n        startToken = lookahead;\n\n        expect('{');\n\n        while (!match('}')) {\n            property = parseObjectProperty();\n\n            if (property.key.type === Syntax.Identifier) {\n                name = property.key.name;\n            } else {\n                name = toString(property.key.value);\n            }\n            kind = (property.kind === 'init') ? PropertyKind.Data : (property.kind === 'get') ? PropertyKind.Get : PropertyKind.Set;\n\n            key = '$' + name;\n            if (Object.prototype.hasOwnProperty.call(map, key)) {\n                if (map[key] === PropertyKind.Data) {\n                    if (strict && kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.StrictDuplicateProperty);\n                    } else if (kind !== PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    }\n                } else {\n                    if (kind === PropertyKind.Data) {\n                        throwErrorTolerant({}, Messages.AccessorDataProperty);\n                    } else if (map[key] & kind) {\n                        throwErrorTolerant({}, Messages.AccessorGetSet);\n                    }\n                }\n                map[key] |= kind;\n            } else {\n                map[key] = kind;\n            }\n\n            properties.push(property);\n\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createObjectExpression(properties), startToken);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr;\n\n        expect('(');\n\n        expr = parseExpression();\n\n        expect(')');\n\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, startToken;\n\n        if (match('(')) {\n            return parseGroupExpression();\n        }\n\n        if (match('[')) {\n            return parseArrayInitialiser();\n        }\n\n        if (match('{')) {\n            return parseObjectInitialiser();\n        }\n\n        type = lookahead.type;\n        startToken = lookahead;\n\n        if (type === Token.Identifier) {\n            expr =  delegate.createIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            if (strict && lookahead.octal) {\n                throwErrorTolerant(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = delegate.createLiteral(lex());\n        } else if (type === Token.Keyword) {\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                expr = delegate.createThisExpression();\n            } else {\n                throwUnexpected(lex());\n            }\n        } else if (type === Token.BooleanLiteral) {\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = delegate.createLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            token = lex();\n            token.value = null;\n            expr = delegate.createLiteral(token);\n        } else if (match('/') || match('/=')) {\n            if (typeof extra.tokens !== 'undefined') {\n                expr = delegate.createLiteral(collectRegex());\n            } else {\n                expr = delegate.createLiteral(scanRegExp());\n            }\n            peek();\n        } else {\n            throwUnexpected(lex());\n        }\n\n        return delegate.markEnd(expr, startToken);\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (index < length) {\n                args.push(parseAssignmentExpression());\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = parseExpression();\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, startToken;\n\n        startToken = lookahead;\n        expectKeyword('new');\n        callee = parseLeftHandSideExpression();\n        args = match('(') ? parseArguments() : [];\n\n        return delegate.markEnd(delegate.createNewExpression(callee, args), startToken);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        for (;;) {\n            if (match('.')) {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                args = parseArguments();\n                expr = delegate.createCallExpression(expr, args);\n            } else if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                break;\n            }\n            delegate.markEnd(expr, startToken);\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        expr = matchKeyword('new') ? parseNewExpression() : parsePrimaryExpression();\n\n        while (match('.') || match('[')) {\n            if (match('[')) {\n                property = parseComputedMember();\n                expr = delegate.createMemberExpression('[', expr, property);\n            } else {\n                property = parseNonComputedMember();\n                expr = delegate.createMemberExpression('.', expr, property);\n            }\n            delegate.markEnd(expr, startToken);\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = parseLeftHandSideExpressionAllowCall();\n\n        if (lookahead.type === Token.Punctuator) {\n            if ((match('++') || match('--')) && !peekLineTerminator()) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    throwErrorTolerant({}, Messages.StrictLHSPostfix);\n                }\n\n                if (!isLeftHandSide(expr)) {\n                    throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n                }\n\n                token = lex();\n                expr = delegate.markEnd(delegate.createPostfixExpression(token.value, expr), startToken);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                throwErrorTolerant({}, Messages.StrictLHSPrefix);\n            }\n\n            if (!isLeftHandSide(expr)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = parseUnaryExpression();\n            expr = delegate.createUnaryExpression(token.value, expr);\n            expr = delegate.markEnd(expr, startToken);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                throwErrorTolerant({}, Messages.StrictDelete);\n            }\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = parseUnaryExpression();\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = parseUnaryExpression();\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                expr = delegate.createBinaryExpression(operator, left, right);\n                markers.pop();\n                marker = markers[markers.length - 1];\n                delegate.markEnd(expr, marker);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = parseUnaryExpression();\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = delegate.createBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n            marker = markers.pop();\n            delegate.markEnd(expr, marker);\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = parseBinaryExpression();\n\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = parseAssignmentExpression();\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = parseAssignmentExpression();\n\n            expr = delegate.createConditionalExpression(expr, consequent, alternate);\n            delegate.markEnd(expr, startToken);\n        }\n\n        return expr;\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, left, right, node, startToken;\n\n        token = lookahead;\n        startToken = lookahead;\n\n        node = left = parseConditionalExpression();\n\n        if (matchAssign()) {\n            // LeftHandSideExpression\n            if (!isLeftHandSide(left)) {\n                throwErrorTolerant({}, Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && left.type === Syntax.Identifier && isRestrictedWord(left.name)) {\n                throwErrorTolerant(token, Messages.StrictLHSAssignment);\n            }\n\n            token = lex();\n            right = parseAssignmentExpression();\n            node = delegate.markEnd(delegate.createAssignmentExpression(token.value, left, right), startToken);\n        }\n\n        return node;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead;\n\n        expr = parseAssignmentExpression();\n\n        if (match(',')) {\n            expr = delegate.createSequenceExpression([ expr ]);\n\n            while (index < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expr.expressions.push(parseAssignmentExpression());\n            }\n\n            delegate.markEnd(expr, startToken);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementList() {\n        var list = [],\n            statement;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            statement = parseSourceElement();\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            list.push(statement);\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, startToken;\n\n        startToken = lookahead;\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return delegate.markEnd(delegate.createBlockStatement(block), startToken);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, startToken;\n\n        startToken = lookahead;\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            throwUnexpected(token);\n        }\n\n        return delegate.markEnd(delegate.createIdentifier(token.value), startToken);\n    }\n\n    function parseVariableDeclaration(kind) {\n        var init = null, id, startToken;\n\n        startToken = lookahead;\n        id = parseVariableIdentifier();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            throwErrorTolerant({}, Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            expect('=');\n            init = parseAssignmentExpression();\n        } else if (match('=')) {\n            lex();\n            init = parseAssignmentExpression();\n        }\n\n        return delegate.markEnd(delegate.createVariableDeclarator(id, init), startToken);\n    }\n\n    function parseVariableDeclarationList(kind) {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration(kind));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (index < length);\n\n        return list;\n    }\n\n    function parseVariableStatement() {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return delegate.createVariableDeclaration(declarations, 'var');\n    }\n\n    // kind may be `const` or `let`\n    // Both are experimental and not in the specification yet.\n    // see http://wiki.ecmascript.org/doku.php?id=harmony:const\n    // and http://wiki.ecmascript.org/doku.php?id=harmony:let\n    function parseConstLetDeclaration(kind) {\n        var declarations, startToken;\n\n        startToken = lookahead;\n\n        expectKeyword(kind);\n\n        declarations = parseVariableDeclarationList(kind);\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, kind), startToken);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement() {\n        expect(';');\n        return delegate.createEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement() {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return delegate.createExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement() {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return delegate.createIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement() {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return delegate.createDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement() {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return delegate.createWhileStatement(test, body);\n    }\n\n    function parseForVariableDeclaration() {\n        var token, declarations, startToken;\n\n        startToken = lookahead;\n        token = lex();\n        declarations = parseVariableDeclarationList();\n\n        return delegate.markEnd(delegate.createVariableDeclaration(declarations, token.value), startToken);\n    }\n\n    function parseForStatement() {\n        var init, test, update, left, right, body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var') || matchKeyword('let')) {\n                state.allowIn = false;\n                init = parseForVariableDeclaration();\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            } else {\n                state.allowIn = false;\n                init = parseExpression();\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    // LeftHandSideExpression\n                    if (!isLeftHandSide(init)) {\n                        throwErrorTolerant({}, Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                }\n            }\n\n            if (typeof left === 'undefined') {\n                expect(';');\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                delegate.createForStatement(init, test, update, body) :\n                delegate.createForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement() {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!state.inIteration) {\n                throwError({}, Messages.IllegalContinue);\n            }\n\n            return delegate.createContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError({}, Messages.IllegalContinue);\n        }\n\n        return delegate.createContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement() {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(index) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (peekLineTerminator()) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError({}, Messages.IllegalBreak);\n            }\n\n            return delegate.createBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError({}, Messages.IllegalBreak);\n        }\n\n        return delegate.createBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement() {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            throwErrorTolerant({}, Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(index) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(index + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return delegate.createReturnStatement(argument);\n            }\n        }\n\n        if (peekLineTerminator()) {\n            return delegate.createReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return delegate.createReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement() {\n        var object, body;\n\n        if (strict) {\n            // TODO(ikarienator): Should we update the test cases instead?\n            skipComment();\n            throwErrorTolerant({}, Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return delegate.createWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, startToken;\n\n        startToken = lookahead;\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (index < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatement();\n            consequent.push(statement);\n        }\n\n        return delegate.markEnd(delegate.createSwitchCase(test, consequent), startToken);\n    }\n\n    function parseSwitchStatement() {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return delegate.createSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError({}, Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return delegate.createSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement() {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (peekLineTerminator()) {\n            throwError({}, Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return delegate.createThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, startToken;\n\n        startToken = lookahead;\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpected(lookahead);\n        }\n\n        param = parseVariableIdentifier();\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            throwErrorTolerant({}, Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return delegate.markEnd(delegate.createCatchClause(param, body), startToken);\n    }\n\n    function parseTryStatement() {\n        var block, handlers = [], finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handlers.push(parseCatchClause());\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (handlers.length === 0 && !finalizer) {\n            throwError({}, Messages.NoCatchOrFinally);\n        }\n\n        return delegate.createTryStatement(block, [], handlers, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement() {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return delegate.createDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            startToken;\n\n        if (type === Token.EOF) {\n            throwUnexpected(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n\n        startToken = lookahead;\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return delegate.markEnd(parseEmptyStatement(), startToken);\n            case '(':\n                return delegate.markEnd(parseExpressionStatement(), startToken);\n            default:\n                break;\n            }\n        }\n\n        if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return delegate.markEnd(parseBreakStatement(), startToken);\n            case 'continue':\n                return delegate.markEnd(parseContinueStatement(), startToken);\n            case 'debugger':\n                return delegate.markEnd(parseDebuggerStatement(), startToken);\n            case 'do':\n                return delegate.markEnd(parseDoWhileStatement(), startToken);\n            case 'for':\n                return delegate.markEnd(parseForStatement(), startToken);\n            case 'function':\n                return delegate.markEnd(parseFunctionDeclaration(), startToken);\n            case 'if':\n                return delegate.markEnd(parseIfStatement(), startToken);\n            case 'return':\n                return delegate.markEnd(parseReturnStatement(), startToken);\n            case 'switch':\n                return delegate.markEnd(parseSwitchStatement(), startToken);\n            case 'throw':\n                return delegate.markEnd(parseThrowStatement(), startToken);\n            case 'try':\n                return delegate.markEnd(parseTryStatement(), startToken);\n            case 'var':\n                return delegate.markEnd(parseVariableStatement(), startToken);\n            case 'while':\n                return delegate.markEnd(parseWhileStatement(), startToken);\n            case 'with':\n                return delegate.markEnd(parseWithStatement(), startToken);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError({}, Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return delegate.markEnd(delegate.createLabeledStatement(expr, labeledBody), startToken);\n        }\n\n        consumeSemicolon();\n\n        return delegate.markEnd(delegate.createExpressionStatement(expr), startToken);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, startToken;\n\n        startToken = lookahead;\n        expect('{');\n\n        while (index < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n\n        while (index < length) {\n            if (match('}')) {\n                break;\n            }\n            sourceElement = parseSourceElement();\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n\n        return delegate.markEnd(delegate.createBlockStatement(sourceElements), startToken);\n    }\n\n    function parseParams(firstRestricted) {\n        var param, params = [], token, stricted, paramSet, key, message;\n        expect('(');\n\n        if (!match(')')) {\n            paramSet = {};\n            while (index < length) {\n                token = lookahead;\n                param = parseVariableIdentifier();\n                key = '$' + token.value;\n                if (strict) {\n                    if (isRestrictedWord(token.value)) {\n                        stricted = token;\n                        message = Messages.StrictParamName;\n                    }\n                    if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        stricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                } else if (!firstRestricted) {\n                    if (isRestrictedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamName;\n                    } else if (isStrictModeReservedWord(token.value)) {\n                        firstRestricted = token;\n                        message = Messages.StrictReservedWord;\n                    } else if (Object.prototype.hasOwnProperty.call(paramSet, key)) {\n                        firstRestricted = token;\n                        message = Messages.StrictParamDupe;\n                    }\n                }\n                params.push(param);\n                paramSet[key] = true;\n                if (match(')')) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        return {\n            params: params,\n            stricted: stricted,\n            firstRestricted: firstRestricted,\n            message: message\n        };\n    }\n\n    function parseFunctionDeclaration() {\n        var id, params = [], body, token, stricted, tmp, firstRestricted, message, previousStrict, startToken;\n\n        startToken = lookahead;\n\n        expectKeyword('function');\n        token = lookahead;\n        id = parseVariableIdentifier();\n        if (strict) {\n            if (isRestrictedWord(token.value)) {\n                throwErrorTolerant(token, Messages.StrictFunctionName);\n            }\n        } else {\n            if (isRestrictedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictFunctionName;\n            } else if (isStrictModeReservedWord(token.value)) {\n                firstRestricted = token;\n                message = Messages.StrictReservedWord;\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionDeclaration(id, params, [], body), startToken);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp, params = [], body, previousStrict, startToken;\n\n        startToken = lookahead;\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    throwErrorTolerant(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwError(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            throwErrorTolerant(stricted, message);\n        }\n        strict = previousStrict;\n\n        return delegate.markEnd(delegate.createFunctionExpression(id, params, [], body), startToken);\n    }\n\n    // 14 Program\n\n    function parseSourceElement() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'const':\n            case 'let':\n                return parseConstLetDeclaration(lookahead.value);\n            case 'function':\n                return parseFunctionDeclaration();\n            default:\n                return parseStatement();\n            }\n        }\n\n        if (lookahead.type !== Token.EOF) {\n            return parseStatement();\n        }\n    }\n\n    function parseSourceElements() {\n        var sourceElement, sourceElements = [], token, directive, firstRestricted;\n\n        while (index < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            sourceElement = parseSourceElement();\n            sourceElements.push(sourceElement);\n            if (sourceElement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    throwErrorTolerant(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (index < length) {\n            sourceElement = parseSourceElement();\n            /* istanbul ignore if */\n            if (typeof sourceElement === 'undefined') {\n                break;\n            }\n            sourceElements.push(sourceElement);\n        }\n        return sourceElements;\n    }\n\n    function parseProgram() {\n        var body, startToken;\n\n        skipComment();\n        peek();\n        startToken = lookahead;\n        strict = false;\n\n        body = parseSourceElements();\n        return delegate.markEnd(delegate.createProgram(body), startToken);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            token,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            token = lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    token = lex();\n                } catch (lexError) {\n                    token = lookahead;\n                    if (extra.errors) {\n                        extra.errors.push(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        delegate = SyntaxTreeDelegate;\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1\n        };\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '1.2.5';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n   /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}