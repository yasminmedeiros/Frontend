{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar setConvertCartesian = require('../cartesian/set_convert');\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\n/**\n * setConvert for polar axes!\n *\n * @param {object} ax\n *   axis in question (works for both radial and angular axes)\n * @param {object} polarLayout\n *   full polar layout of the subplot associated with 'ax'\n * @param {object} fullLayout\n *   full layout\n *\n * Here, reuse some of the Cartesian setConvert logic,\n * but we must extend some of it, as both radial and angular axes\n * don't have domains and angular axes don't have _true_ ranges.\n *\n * Moreover, we introduce two new coordinate systems:\n * - 'g' for geometric coordinates and\n * - 't' for angular ticks\n *\n * Radial axis coordinate systems:\n * - d, c and l: same as for cartesian axes\n * - g: like calcdata but translated about `radialaxis.range[0]` & `polar.hole`\n *\n * Angular axis coordinate systems:\n * - d: data, in whatever form it's provided\n * - c: calcdata, turned into radians (for linear axes)\n *      or category indices (category axes)\n * - t: tick calcdata, just like 'c' but in degrees for linear axes\n * - g: geometric calcdata, radians coordinates that take into account\n *      axis rotation and direction\n *\n * Then, 'g'eometric data is ready to be converted to (x,y).\n */\nmodule.exports = function setConvert(ax, polarLayout, fullLayout) {\n  setConvertCartesian(ax, fullLayout);\n  switch (ax._id) {\n    case 'x':\n    case 'radialaxis':\n      setConvertRadial(ax, polarLayout);\n      break;\n    case 'angularaxis':\n      setConvertAngular(ax, polarLayout);\n      break;\n  }\n};\nfunction setConvertRadial(ax, polarLayout) {\n  var subplot = polarLayout._subplot;\n  ax.setGeometry = function () {\n    var rl0 = ax._rl[0];\n    var rl1 = ax._rl[1];\n    var b = subplot.innerRadius;\n    var m = (subplot.radius - b) / (rl1 - rl0);\n    var b2 = b / m;\n    var rFilter = rl0 > rl1 ? function (v) {\n      return v <= 0;\n    } : function (v) {\n      return v >= 0;\n    };\n    ax.c2g = function (v) {\n      var r = ax.c2l(v) - rl0;\n      return (rFilter(r) ? r : 0) + b2;\n    };\n    ax.g2c = function (v) {\n      return ax.l2c(v + rl0 - b2);\n    };\n    ax.g2p = function (v) {\n      return v * m;\n    };\n    ax.c2p = function (v) {\n      return ax.g2p(ax.c2g(v));\n    };\n  };\n}\nfunction toRadians(v, unit) {\n  return unit === 'degrees' ? deg2rad(v) : v;\n}\nfunction fromRadians(v, unit) {\n  return unit === 'degrees' ? rad2deg(v) : v;\n}\nfunction setConvertAngular(ax, polarLayout) {\n  var axType = ax.type;\n  if (axType === 'linear') {\n    var _d2c = ax.d2c;\n    var _c2d = ax.c2d;\n    ax.d2c = function (v, unit) {\n      return toRadians(_d2c(v), unit);\n    };\n    ax.c2d = function (v, unit) {\n      return _c2d(fromRadians(v, unit));\n    };\n  }\n\n  // override makeCalcdata to handle thetaunit and special theta0/dtheta logic\n  ax.makeCalcdata = function (trace, coord) {\n    var arrayIn = trace[coord];\n    var len = trace._length;\n    var arrayOut, i;\n    var _d2c = function _d2c(v) {\n      return ax.d2c(v, trace.thetaunit);\n    };\n    if (arrayIn) {\n      if (Lib.isTypedArray(arrayIn) && axType === 'linear') {\n        if (len === arrayIn.length) {\n          return arrayIn;\n        } else if (arrayIn.subarray) {\n          return arrayIn.subarray(0, len);\n        }\n      }\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = _d2c(arrayIn[i]);\n      }\n    } else {\n      var coord0 = coord + '0';\n      var dcoord = 'd' + coord;\n      var v0 = coord0 in trace ? _d2c(trace[coord0]) : 0;\n      var dv = trace[dcoord] ? _d2c(trace[dcoord]) : (ax.period || 2 * Math.PI) / len;\n      arrayOut = new Array(len);\n      for (i = 0; i < len; i++) {\n        arrayOut[i] = v0 + i * dv;\n      }\n    }\n    return arrayOut;\n  };\n\n  // N.B. we mock the axis 'range' here\n  ax.setGeometry = function () {\n    var sector = polarLayout.sector;\n    var sectorInRad = sector.map(deg2rad);\n    var dir = {\n      clockwise: -1,\n      counterclockwise: 1\n    }[ax.direction];\n    var rot = deg2rad(ax.rotation);\n    var rad2g = function rad2g(v) {\n      return dir * v + rot;\n    };\n    var g2rad = function g2rad(v) {\n      return (v - rot) / dir;\n    };\n    var rad2c, c2rad;\n    var rad2t, t2rad;\n    switch (axType) {\n      case 'linear':\n        c2rad = rad2c = Lib.identity;\n        t2rad = deg2rad;\n        rad2t = rad2deg;\n\n        // Set the angular range in degrees to make auto-tick computation cleaner,\n        // changing rotation/direction should not affect the angular tick value.\n        ax.range = Lib.isFullCircle(sectorInRad) ? [sector[0], sector[0] + 360] : sectorInRad.map(g2rad).map(rad2deg);\n        break;\n      case 'category':\n        var catLen = ax._categories.length;\n        var _period = ax.period ? Math.max(ax.period, catLen) : catLen;\n        c2rad = t2rad = function t2rad(v) {\n          return v * 2 * Math.PI / _period;\n        };\n        rad2c = rad2t = function rad2t(v) {\n          return v * _period / Math.PI / 2;\n        };\n        ax.range = [0, _period];\n        break;\n    }\n    ax.c2g = function (v) {\n      return rad2g(c2rad(v));\n    };\n    ax.g2c = function (v) {\n      return rad2c(g2rad(v));\n    };\n    ax.t2g = function (v) {\n      return rad2g(t2rad(v));\n    };\n    ax.g2t = function (v) {\n      return rad2t(g2rad(v));\n    };\n  };\n}","map":{"version":3,"names":["Lib","require","setConvertCartesian","deg2rad","rad2deg","module","exports","setConvert","ax","polarLayout","fullLayout","_id","setConvertRadial","setConvertAngular","subplot","_subplot","setGeometry","rl0","_rl","rl1","b","innerRadius","m","radius","b2","rFilter","v","c2g","r","c2l","g2c","l2c","g2p","c2p","toRadians","unit","fromRadians","axType","type","_d2c","d2c","_c2d","c2d","makeCalcdata","trace","coord","arrayIn","len","_length","arrayOut","i","thetaunit","isTypedArray","length","subarray","Array","coord0","dcoord","v0","dv","period","Math","PI","sector","sectorInRad","map","dir","clockwise","counterclockwise","direction","rot","rotation","rad2g","g2rad","rad2c","c2rad","rad2t","t2rad","identity","range","isFullCircle","catLen","_categories","_period","max","t2g","g2t"],"sources":["/home/yasmin/Ãrea de Trabalho/Frontend/node_modules/plotly.js/src/plots/polar/set_convert.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar Lib = require('../../lib');\nvar setConvertCartesian = require('../cartesian/set_convert');\n\nvar deg2rad = Lib.deg2rad;\nvar rad2deg = Lib.rad2deg;\n\n/**\n * setConvert for polar axes!\n *\n * @param {object} ax\n *   axis in question (works for both radial and angular axes)\n * @param {object} polarLayout\n *   full polar layout of the subplot associated with 'ax'\n * @param {object} fullLayout\n *   full layout\n *\n * Here, reuse some of the Cartesian setConvert logic,\n * but we must extend some of it, as both radial and angular axes\n * don't have domains and angular axes don't have _true_ ranges.\n *\n * Moreover, we introduce two new coordinate systems:\n * - 'g' for geometric coordinates and\n * - 't' for angular ticks\n *\n * Radial axis coordinate systems:\n * - d, c and l: same as for cartesian axes\n * - g: like calcdata but translated about `radialaxis.range[0]` & `polar.hole`\n *\n * Angular axis coordinate systems:\n * - d: data, in whatever form it's provided\n * - c: calcdata, turned into radians (for linear axes)\n *      or category indices (category axes)\n * - t: tick calcdata, just like 'c' but in degrees for linear axes\n * - g: geometric calcdata, radians coordinates that take into account\n *      axis rotation and direction\n *\n * Then, 'g'eometric data is ready to be converted to (x,y).\n */\nmodule.exports = function setConvert(ax, polarLayout, fullLayout) {\n    setConvertCartesian(ax, fullLayout);\n\n    switch(ax._id) {\n        case 'x':\n        case 'radialaxis':\n            setConvertRadial(ax, polarLayout);\n            break;\n        case 'angularaxis':\n            setConvertAngular(ax, polarLayout);\n            break;\n    }\n};\n\nfunction setConvertRadial(ax, polarLayout) {\n    var subplot = polarLayout._subplot;\n\n    ax.setGeometry = function() {\n        var rl0 = ax._rl[0];\n        var rl1 = ax._rl[1];\n\n        var b = subplot.innerRadius;\n        var m = (subplot.radius - b) / (rl1 - rl0);\n        var b2 = b / m;\n\n        var rFilter = rl0 > rl1 ?\n            function(v) { return v <= 0; } :\n            function(v) { return v >= 0; };\n\n        ax.c2g = function(v) {\n            var r = ax.c2l(v) - rl0;\n            return (rFilter(r) ? r : 0) + b2;\n        };\n\n        ax.g2c = function(v) {\n            return ax.l2c(v + rl0 - b2);\n        };\n\n        ax.g2p = function(v) { return v * m; };\n        ax.c2p = function(v) { return ax.g2p(ax.c2g(v)); };\n    };\n}\n\nfunction toRadians(v, unit) {\n    return unit === 'degrees' ? deg2rad(v) : v;\n}\n\nfunction fromRadians(v, unit) {\n    return unit === 'degrees' ? rad2deg(v) : v;\n}\n\nfunction setConvertAngular(ax, polarLayout) {\n    var axType = ax.type;\n\n    if(axType === 'linear') {\n        var _d2c = ax.d2c;\n        var _c2d = ax.c2d;\n\n        ax.d2c = function(v, unit) { return toRadians(_d2c(v), unit); };\n        ax.c2d = function(v, unit) { return _c2d(fromRadians(v, unit)); };\n    }\n\n    // override makeCalcdata to handle thetaunit and special theta0/dtheta logic\n    ax.makeCalcdata = function(trace, coord) {\n        var arrayIn = trace[coord];\n        var len = trace._length;\n        var arrayOut, i;\n\n        var _d2c = function(v) { return ax.d2c(v, trace.thetaunit); };\n\n        if(arrayIn) {\n            if(Lib.isTypedArray(arrayIn) && axType === 'linear') {\n                if(len === arrayIn.length) {\n                    return arrayIn;\n                } else if(arrayIn.subarray) {\n                    return arrayIn.subarray(0, len);\n                }\n            }\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = _d2c(arrayIn[i]);\n            }\n        } else {\n            var coord0 = coord + '0';\n            var dcoord = 'd' + coord;\n            var v0 = (coord0 in trace) ? _d2c(trace[coord0]) : 0;\n            var dv = (trace[dcoord]) ? _d2c(trace[dcoord]) : (ax.period || 2 * Math.PI) / len;\n\n            arrayOut = new Array(len);\n            for(i = 0; i < len; i++) {\n                arrayOut[i] = v0 + i * dv;\n            }\n        }\n\n        return arrayOut;\n    };\n\n    // N.B. we mock the axis 'range' here\n    ax.setGeometry = function() {\n        var sector = polarLayout.sector;\n        var sectorInRad = sector.map(deg2rad);\n        var dir = {clockwise: -1, counterclockwise: 1}[ax.direction];\n        var rot = deg2rad(ax.rotation);\n\n        var rad2g = function(v) { return dir * v + rot; };\n        var g2rad = function(v) { return (v - rot) / dir; };\n\n        var rad2c, c2rad;\n        var rad2t, t2rad;\n\n        switch(axType) {\n            case 'linear':\n                c2rad = rad2c = Lib.identity;\n                t2rad = deg2rad;\n                rad2t = rad2deg;\n\n                // Set the angular range in degrees to make auto-tick computation cleaner,\n                // changing rotation/direction should not affect the angular tick value.\n                ax.range = Lib.isFullCircle(sectorInRad) ?\n                    [sector[0], sector[0] + 360] :\n                    sectorInRad.map(g2rad).map(rad2deg);\n                break;\n\n            case 'category':\n                var catLen = ax._categories.length;\n                var _period = ax.period ? Math.max(ax.period, catLen) : catLen;\n\n                c2rad = t2rad = function(v) { return v * 2 * Math.PI / _period; };\n                rad2c = rad2t = function(v) { return v * _period / Math.PI / 2; };\n\n                ax.range = [0, _period];\n                break;\n        }\n\n        ax.c2g = function(v) { return rad2g(c2rad(v)); };\n        ax.g2c = function(v) { return rad2c(g2rad(v)); };\n\n        ax.t2g = function(v) { return rad2g(t2rad(v)); };\n        ax.g2t = function(v) { return rad2t(g2rad(v)); };\n    };\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}