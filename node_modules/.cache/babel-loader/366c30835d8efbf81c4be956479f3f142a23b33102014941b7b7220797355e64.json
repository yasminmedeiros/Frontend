{"ast":null,"code":"/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n'use strict';\n\nvar id2name = require('./axis_ids').id2name;\nvar scaleZoom = require('./scale_zoom');\nvar makePadFn = require('./autorange').makePadFn;\nvar concatExtremes = require('./autorange').concatExtremes;\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\nexports.enforce = function enforceAxisConstraints(gd) {\n  var fullLayout = gd._fullLayout;\n  var constraintGroups = fullLayout._axisConstraintGroups || [];\n  var i, j, axisID, ax, normScale, mode, factor;\n  for (i = 0; i < constraintGroups.length; i++) {\n    var group = constraintGroups[i];\n    var axisIDs = Object.keys(group);\n    var minScale = Infinity;\n    var maxScale = 0;\n    // mostly matchScale will be the same as minScale\n    // ie we expand axis ranges to encompass *everything*\n    // that's currently in any of their ranges, but during\n    // autorange of a subset of axes we will ignore other\n    // axes for this purpose.\n    var matchScale = Infinity;\n    var normScales = {};\n    var axes = {};\n    var hasAnyDomainConstraint = false;\n\n    // find the (normalized) scale of each axis in the group\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      axes[axisID] = ax = fullLayout[id2name(axisID)];\n      if (ax._inputDomain) ax.domain = ax._inputDomain.slice();else ax._inputDomain = ax.domain.slice();\n      if (!ax._inputRange) ax._inputRange = ax.range.slice();\n\n      // set axis scale here so we can use _m rather than\n      // having to calculate it from length and range\n      ax.setScale();\n\n      // abs: inverted scales still satisfy the constraint\n      normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n      minScale = Math.min(minScale, normScale);\n      if (ax.constrain === 'domain' || !ax._constraintShrinkable) {\n        matchScale = Math.min(matchScale, normScale);\n      }\n\n      // this has served its purpose, so remove it\n      delete ax._constraintShrinkable;\n      maxScale = Math.max(maxScale, normScale);\n      if (ax.constrain === 'domain') hasAnyDomainConstraint = true;\n    }\n\n    // Do we have a constraint mismatch? Give a small buffer for rounding errors\n    if (minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n    // now increase any ranges we need to until all normalized scales are equal\n    for (j = 0; j < axisIDs.length; j++) {\n      axisID = axisIDs[j];\n      normScale = normScales[axisID];\n      ax = axes[axisID];\n      mode = ax.constrain;\n\n      // even if the scale didn't change, if we're shrinking domain\n      // we need to recalculate in case `constraintoward` changed\n      if (normScale !== matchScale || mode === 'domain') {\n        factor = normScale / matchScale;\n        if (mode === 'range') {\n          scaleZoom(ax, factor);\n        } else {\n          // mode === 'domain'\n\n          var inputDomain = ax._inputDomain;\n          var domainShrunk = (ax.domain[1] - ax.domain[0]) / (inputDomain[1] - inputDomain[0]);\n          var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) / (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n          factor /= domainShrunk;\n          if (factor * rangeShrunk < 1) {\n            // we've asked to magnify the axis more than we can just by\n            // enlarging the domain - so we need to constrict range\n            ax.domain = ax._input.domain = inputDomain.slice();\n            scaleZoom(ax, factor);\n            continue;\n          }\n          if (rangeShrunk < 1) {\n            // the range has previously been constricted by ^^, but we've\n            // switched to the domain-constricted regime, so reset range\n            ax.range = ax._input.range = ax._inputRange.slice();\n            factor *= rangeShrunk;\n          }\n          if (ax.autorange) {\n            /*\n             * range & factor may need to change because range was\n             * calculated for the larger scaling, so some pixel\n             * paddings may get cut off when we reduce the domain.\n             *\n             * This is easier than the regular autorange calculation\n             * because we already know the scaling `m`, but we still\n             * need to cut out impossible constraints (like\n             * annotations with super-long arrows). That's what\n             * outerMin/Max are for - if the expansion was going to\n             * go beyond the original domain, it must be impossible\n             */\n            var rl0 = ax.r2l(ax.range[0]);\n            var rl1 = ax.r2l(ax.range[1]);\n            var rangeCenter = (rl0 + rl1) / 2;\n            var rangeMin = rangeCenter;\n            var rangeMax = rangeCenter;\n            var halfRange = Math.abs(rl1 - rangeCenter);\n            // extra tiny bit for rounding errors, in case we actually\n            // *are* expanding to the full domain\n            var outerMin = rangeCenter - halfRange * factor * 1.0001;\n            var outerMax = rangeCenter + halfRange * factor * 1.0001;\n            var getPad = makePadFn(ax);\n            updateDomain(ax, factor);\n            var m = Math.abs(ax._m);\n            var extremes = concatExtremes(gd, ax);\n            var minArray = extremes.min;\n            var maxArray = extremes.max;\n            var newVal;\n            var k;\n            for (k = 0; k < minArray.length; k++) {\n              newVal = minArray[k].val - getPad(minArray[k]) / m;\n              if (newVal > outerMin && newVal < rangeMin) {\n                rangeMin = newVal;\n              }\n            }\n            for (k = 0; k < maxArray.length; k++) {\n              newVal = maxArray[k].val + getPad(maxArray[k]) / m;\n              if (newVal < outerMax && newVal > rangeMax) {\n                rangeMax = newVal;\n              }\n            }\n            var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n            factor /= domainExpand;\n            rangeMin = ax.l2r(rangeMin);\n            rangeMax = ax.l2r(rangeMax);\n            ax.range = ax._input.range = rl0 < rl1 ? [rangeMin, rangeMax] : [rangeMax, rangeMin];\n          }\n          updateDomain(ax, factor);\n        }\n      }\n    }\n  }\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function cleanConstraints(gd, ax) {\n  if (ax._inputDomain) {\n    var isConstrained = false;\n    var axId = ax._id;\n    var constraintGroups = gd._fullLayout._axisConstraintGroups;\n    for (var j = 0; j < constraintGroups.length; j++) {\n      if (constraintGroups[j][axId]) {\n        isConstrained = true;\n        break;\n      }\n    }\n    if (!isConstrained || ax.constrain !== 'domain') {\n      ax._input.domain = ax.domain = ax._inputDomain;\n      delete ax._inputDomain;\n    }\n  }\n};\nfunction updateDomain(ax, factor) {\n  var inputDomain = ax._inputDomain;\n  var centerFraction = FROM_BL[ax.constraintoward];\n  var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n  ax.domain = ax._input.domain = [center + (inputDomain[0] - center) / factor, center + (inputDomain[1] - center) / factor];\n  ax.setScale();\n}","map":{"version":3,"names":["id2name","require","scaleZoom","makePadFn","concatExtremes","ALMOST_EQUAL","FROM_BL","exports","enforce","enforceAxisConstraints","gd","fullLayout","_fullLayout","constraintGroups","_axisConstraintGroups","i","j","axisID","ax","normScale","mode","factor","length","group","axisIDs","Object","keys","minScale","Infinity","maxScale","matchScale","normScales","axes","hasAnyDomainConstraint","_inputDomain","domain","slice","_inputRange","range","setScale","Math","abs","_m","min","constrain","_constraintShrinkable","max","inputDomain","domainShrunk","rangeShrunk","r2l","_input","autorange","rl0","rl1","rangeCenter","rangeMin","rangeMax","halfRange","outerMin","outerMax","getPad","updateDomain","m","extremes","minArray","maxArray","newVal","k","val","domainExpand","l2r","clean","cleanConstraints","isConstrained","axId","_id","centerFraction","constraintoward","center"],"sources":["/home/yasmin/Área de Trabalho/Frontend/node_modules/plotly.js/src/plots/cartesian/constraints.js"],"sourcesContent":["/**\n* Copyright 2012-2019, Plotly, Inc.\n* All rights reserved.\n*\n* This source code is licensed under the MIT license found in the\n* LICENSE file in the root directory of this source tree.\n*/\n\n\n'use strict';\n\nvar id2name = require('./axis_ids').id2name;\nvar scaleZoom = require('./scale_zoom');\nvar makePadFn = require('./autorange').makePadFn;\nvar concatExtremes = require('./autorange').concatExtremes;\n\nvar ALMOST_EQUAL = require('../../constants/numerical').ALMOST_EQUAL;\n\nvar FROM_BL = require('../../constants/alignment').FROM_BL;\n\n\nexports.enforce = function enforceAxisConstraints(gd) {\n    var fullLayout = gd._fullLayout;\n    var constraintGroups = fullLayout._axisConstraintGroups || [];\n\n    var i, j, axisID, ax, normScale, mode, factor;\n\n    for(i = 0; i < constraintGroups.length; i++) {\n        var group = constraintGroups[i];\n        var axisIDs = Object.keys(group);\n\n        var minScale = Infinity;\n        var maxScale = 0;\n        // mostly matchScale will be the same as minScale\n        // ie we expand axis ranges to encompass *everything*\n        // that's currently in any of their ranges, but during\n        // autorange of a subset of axes we will ignore other\n        // axes for this purpose.\n        var matchScale = Infinity;\n        var normScales = {};\n        var axes = {};\n        var hasAnyDomainConstraint = false;\n\n        // find the (normalized) scale of each axis in the group\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            axes[axisID] = ax = fullLayout[id2name(axisID)];\n\n            if(ax._inputDomain) ax.domain = ax._inputDomain.slice();\n            else ax._inputDomain = ax.domain.slice();\n\n            if(!ax._inputRange) ax._inputRange = ax.range.slice();\n\n            // set axis scale here so we can use _m rather than\n            // having to calculate it from length and range\n            ax.setScale();\n\n            // abs: inverted scales still satisfy the constraint\n            normScales[axisID] = normScale = Math.abs(ax._m) / group[axisID];\n            minScale = Math.min(minScale, normScale);\n            if(ax.constrain === 'domain' || !ax._constraintShrinkable) {\n                matchScale = Math.min(matchScale, normScale);\n            }\n\n            // this has served its purpose, so remove it\n            delete ax._constraintShrinkable;\n            maxScale = Math.max(maxScale, normScale);\n\n            if(ax.constrain === 'domain') hasAnyDomainConstraint = true;\n        }\n\n        // Do we have a constraint mismatch? Give a small buffer for rounding errors\n        if(minScale > ALMOST_EQUAL * maxScale && !hasAnyDomainConstraint) continue;\n\n        // now increase any ranges we need to until all normalized scales are equal\n        for(j = 0; j < axisIDs.length; j++) {\n            axisID = axisIDs[j];\n            normScale = normScales[axisID];\n            ax = axes[axisID];\n            mode = ax.constrain;\n\n            // even if the scale didn't change, if we're shrinking domain\n            // we need to recalculate in case `constraintoward` changed\n            if(normScale !== matchScale || mode === 'domain') {\n                factor = normScale / matchScale;\n\n                if(mode === 'range') {\n                    scaleZoom(ax, factor);\n                }\n                else {\n                    // mode === 'domain'\n\n                    var inputDomain = ax._inputDomain;\n                    var domainShrunk = (ax.domain[1] - ax.domain[0]) /\n                        (inputDomain[1] - inputDomain[0]);\n                    var rangeShrunk = (ax.r2l(ax.range[1]) - ax.r2l(ax.range[0])) /\n                        (ax.r2l(ax._inputRange[1]) - ax.r2l(ax._inputRange[0]));\n\n                    factor /= domainShrunk;\n\n                    if(factor * rangeShrunk < 1) {\n                        // we've asked to magnify the axis more than we can just by\n                        // enlarging the domain - so we need to constrict range\n                        ax.domain = ax._input.domain = inputDomain.slice();\n                        scaleZoom(ax, factor);\n                        continue;\n                    }\n\n                    if(rangeShrunk < 1) {\n                        // the range has previously been constricted by ^^, but we've\n                        // switched to the domain-constricted regime, so reset range\n                        ax.range = ax._input.range = ax._inputRange.slice();\n                        factor *= rangeShrunk;\n                    }\n\n                    if(ax.autorange) {\n                        /*\n                         * range & factor may need to change because range was\n                         * calculated for the larger scaling, so some pixel\n                         * paddings may get cut off when we reduce the domain.\n                         *\n                         * This is easier than the regular autorange calculation\n                         * because we already know the scaling `m`, but we still\n                         * need to cut out impossible constraints (like\n                         * annotations with super-long arrows). That's what\n                         * outerMin/Max are for - if the expansion was going to\n                         * go beyond the original domain, it must be impossible\n                         */\n                        var rl0 = ax.r2l(ax.range[0]);\n                        var rl1 = ax.r2l(ax.range[1]);\n                        var rangeCenter = (rl0 + rl1) / 2;\n                        var rangeMin = rangeCenter;\n                        var rangeMax = rangeCenter;\n                        var halfRange = Math.abs(rl1 - rangeCenter);\n                        // extra tiny bit for rounding errors, in case we actually\n                        // *are* expanding to the full domain\n                        var outerMin = rangeCenter - halfRange * factor * 1.0001;\n                        var outerMax = rangeCenter + halfRange * factor * 1.0001;\n                        var getPad = makePadFn(ax);\n\n                        updateDomain(ax, factor);\n                        var m = Math.abs(ax._m);\n                        var extremes = concatExtremes(gd, ax);\n                        var minArray = extremes.min;\n                        var maxArray = extremes.max;\n                        var newVal;\n                        var k;\n\n                        for(k = 0; k < minArray.length; k++) {\n                            newVal = minArray[k].val - getPad(minArray[k]) / m;\n                            if(newVal > outerMin && newVal < rangeMin) {\n                                rangeMin = newVal;\n                            }\n                        }\n\n                        for(k = 0; k < maxArray.length; k++) {\n                            newVal = maxArray[k].val + getPad(maxArray[k]) / m;\n                            if(newVal < outerMax && newVal > rangeMax) {\n                                rangeMax = newVal;\n                            }\n                        }\n\n                        var domainExpand = (rangeMax - rangeMin) / (2 * halfRange);\n                        factor /= domainExpand;\n\n                        rangeMin = ax.l2r(rangeMin);\n                        rangeMax = ax.l2r(rangeMax);\n                        ax.range = ax._input.range = (rl0 < rl1) ?\n                            [rangeMin, rangeMax] : [rangeMax, rangeMin];\n                    }\n\n                    updateDomain(ax, factor);\n                }\n            }\n        }\n    }\n};\n\n// For use before autoranging, check if this axis was previously constrained\n// by domain but no longer is\nexports.clean = function cleanConstraints(gd, ax) {\n    if(ax._inputDomain) {\n        var isConstrained = false;\n        var axId = ax._id;\n        var constraintGroups = gd._fullLayout._axisConstraintGroups;\n        for(var j = 0; j < constraintGroups.length; j++) {\n            if(constraintGroups[j][axId]) {\n                isConstrained = true;\n                break;\n            }\n        }\n        if(!isConstrained || ax.constrain !== 'domain') {\n            ax._input.domain = ax.domain = ax._inputDomain;\n            delete ax._inputDomain;\n        }\n    }\n};\n\nfunction updateDomain(ax, factor) {\n    var inputDomain = ax._inputDomain;\n    var centerFraction = FROM_BL[ax.constraintoward];\n    var center = inputDomain[0] + (inputDomain[1] - inputDomain[0]) * centerFraction;\n\n    ax.domain = ax._input.domain = [\n        center + (inputDomain[0] - center) / factor,\n        center + (inputDomain[1] - center) / factor\n    ];\n    ax.setScale();\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}